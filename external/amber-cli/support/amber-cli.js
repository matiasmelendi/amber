#!/usr/bin/env node
(function(define, require){
define('__wrap__', function (requirejs) {
requirejs.resolve = require.resolve;
require = requirejs;
// This file is used to make additional changes
// when building an app to run in node.js.
// Free to edit. You can break tests (cli test runner uses
// this to build itself - it is a node executable).
define("amber/Platform", ["amber_core/Platform-Node"], {});
define("amber/compatibility", ["amber/node-compatibility"], {});
define("jquery", {});

define("config-node", function(){});

/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define('amber/es6-promise',[],function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


define('amber/es2015-polyfills',['amber/es6-promise'], function (promiseLib) {
    promiseLib.polyfill();
});

// This file is injected dependencies by amber-compat-xxx modules.
// Therefore it is important that it _does_not_have_ define call.
;
define("amber/node-compatibility", ["./es2015-polyfills"], function(){});

/* ====================================================================
 |
 |   Amber Smalltalk
 |   http://amber-lang.net
 |
 ======================================================================

 ======================================================================
 |
 | Copyright (c) 2010-2014
 | Nicolas Petton <petton.nicolas@gmail.com>
 |
 | Copyright (c) 2012-2014
 | The Amber team https://github.com/amber-smalltalk?tab=members
 | Amber contributors https://github.com/amber-smalltalk/amber/graphs/contributors
 |
 | Amber is released under the MIT license
 |
 | Permission is hereby granted, free of charge, to any person obtaining
 | a copy of this software and associated documentation files (the
 | 'Software'), to deal in the Software without restriction, including
 | without limitation the rights to use, copy, modify, merge, publish,
 | distribute, sublicense, and/or sell copies of the Software, and to
 | permit persons to whom the Software is furnished to do so, subject to
 | the following conditions:
 |
 | The above copyright notice and this permission notice shall be
 | included in all copies or substantial portions of the Software.
 |
 | THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 | EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 | MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 | IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 | CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 | TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 | SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 |
 ==================================================================== */

//jshint eqnull:true

define('amber/boot',['require', './compatibility'], function (require) {

    /* Reconfigurable micro composition system, https://github.com/amber-smalltalk/brikz */

    function Brikz(api, apiKey, initKey) {
        var brikz = this, backup = {};
        apiKey = apiKey || 'exports';
        initKey = initKey || '__init__';

        function mixin(src, target, what) {
            for (var keys = Object.keys(what || src), l = keys.length, i = 0; i < l; ++i) {
                if (src == null) {
                    target[keys[i]] = undefined;
                } else {
                    var value = src[keys[i]];
                    if (typeof value !== "undefined") {
                        target[keys[i]] = value;
                    }
                }
            }
            return target;
        }

        var d = {value: null, enumerable: false, configurable: true, writable: true};
        Object.defineProperties(this, {ensure: d, rebuild: d});
        var exclude = mixin(this, {});

        this.rebuild = function () {
            Object.keys(backup).forEach(function (key) {
                mixin(null, api, (backup[key] || 0)[apiKey] || {});
            });
            var oapi = mixin(api, {}), order = [], chk = {};
            brikz.ensure = function (key) {
                if (key in exclude) {
                    return null;
                }
                var b = brikz[key], bak = backup[key];
                mixin(null, api, api);
                while (typeof b === "function") {
                    b = new b(brikz, api, bak);
                }
                if (b && !chk[key]) {
                    chk[key] = true;
                    order.push(b);
                }
                if (b && !b[apiKey]) {
                    b[apiKey] = mixin(api, {});
                }
                brikz[key] = b;
                return b;
            };
            Object.keys(brikz).forEach(function (key) {
                brikz.ensure(key);
            });
            brikz.ensure = null;
            mixin(oapi, mixin(null, api, api));
            order.forEach(function (brik) {
                mixin(brik[apiKey] || {}, api);
            });
            order.forEach(function (brik) {
                if (brik[initKey]) brik[initKey]();
            });
            backup = mixin(brikz, {});
        };
    }

    /* Brikz end */

    function inherits(child, parent) {
        child.prototype = Object.create(parent.prototype, {
            constructor: {
                value: child,
                enumerable: false, configurable: true, writable: true
            }
        });
        return child;
    }

    var jsGlobals = new Function("return this")();
    var globals = Object.create(jsGlobals);
    globals.SmalltalkSettings = {};
    var api = {};
    var brikz = new Brikz(api);

    function RootBrik(brikz, st) {

        /* Smalltalk foundational objects */

        /* SmalltalkRoot is the hidden root of the Amber hierarchy.
         All objects including `Object` inherit from SmalltalkRoot */
        function SmalltalkRoot() {
        }

        function SmalltalkProtoObject() {
        }

        inherits(SmalltalkProtoObject, SmalltalkRoot);
        function SmalltalkObject() {
        }

        inherits(SmalltalkObject, SmalltalkProtoObject);
        function SmalltalkNil() {
        }

        inherits(SmalltalkNil, SmalltalkObject);

        this.Object = SmalltalkObject;
        this.nil = new SmalltalkNil();

        // Adds an `isNil` property to the `nil` object.  When sending
        // nil objects from one environment to another, doing
        // `anObject == nil` (in JavaScript) does not always answer
        // true as the referenced nil object might come from the other
        // environment.
        Object.defineProperty(this.nil, 'isNil', {
            value: true,
            enumerable: false, configurable: false, writable: false
        });

        // Hidden root class of the system.
        this.rootAsClass = {fn: SmalltalkRoot};

        this.__init__ = function () {
            st.addPackage("Kernel-Objects");
            st.wrapClassName("ProtoObject", "Kernel-Objects", SmalltalkProtoObject, undefined, false);
            st.wrapClassName("Object", "Kernel-Objects", SmalltalkObject, globals.ProtoObject, false);
            st.wrapClassName("UndefinedObject", "Kernel-Objects", SmalltalkNil, globals.Object, false);
        };
    }

    function OrganizeBrik(brikz, st) {

        brikz.ensure("augments");
        var SmalltalkObject = brikz.ensure("root").Object;

        function SmalltalkOrganizer() {
        }

        function SmalltalkPackageOrganizer() {
            this.elements = [];
        }

        function SmalltalkClassOrganizer() {
            this.elements = [];
        }

        inherits(SmalltalkOrganizer, SmalltalkObject);
        inherits(SmalltalkPackageOrganizer, SmalltalkOrganizer);
        inherits(SmalltalkClassOrganizer, SmalltalkOrganizer);

        this.__init__ = function () {
            st.addPackage("Kernel-Infrastructure");
            st.wrapClassName("Organizer", "Kernel-Infrastructure", SmalltalkOrganizer, globals.Object, false);
            st.wrapClassName("PackageOrganizer", "Kernel-Infrastructure", SmalltalkPackageOrganizer, globals.Organizer, false);
            st.wrapClassName("ClassOrganizer", "Kernel-Infrastructure", SmalltalkClassOrganizer, globals.Organizer, false);
        };

        this.setupClassOrganization = function (klass) {
            klass.organization = new SmalltalkClassOrganizer();
            klass.organization.theClass = klass;
        };

        this.setupPackageOrganization = function (pkg) {
            pkg.organization = new SmalltalkPackageOrganizer();
        };

        this.addOrganizationElement = function (owner, element) {
            owner.organization.elements.addElement(element);
        };

        this.removeOrganizationElement = function (owner, element) {
            owner.organization.elements.removeElement(element);
        };
    }

    function DNUBrik(brikz, st) {

        brikz.ensure("selectorConversion");
        brikz.ensure("messageSend");
        var manip = brikz.ensure("manipulation");
        var rootAsClass = brikz.ensure("root").rootAsClass;

        /* Method not implemented handlers */

        var methods = [], methodDict = Object.create(null);
        this.selectors = [];
        this.jsSelectors = [];

        this.make = function (stSelector, targetClasses) {
            var method = methodDict[stSelector];
            if (method) return;
            var jsSelector = st.st2js(stSelector);
            this.selectors.push(stSelector);
            this.jsSelectors.push(jsSelector);
            method = {jsSelector: jsSelector, fn: createHandler(stSelector)};
            methodDict[stSelector] = method;
            methods.push(method);
            manip.installMethod(method, rootAsClass);
            targetClasses.forEach(function (target) {
                manip.installMethod(method, target);
            });
            return method;
        };

        /* Dnu handler method */

        function createHandler(stSelector) {
            return function () {
                return brikz.messageSend.messageNotUnderstood(this, stSelector, arguments);
            };
        }
    }

    function ClassInitBrik(brikz, st) {

        var dnu = brikz.ensure("dnu");
        var manip = brikz.ensure("manipulation");

        /* Initialize a class in its class hierarchy. Handle both classes and
         metaclasses. */

        st.init = function (klass) {
            initClass(klass);
            if (klass.klass && !klass.meta) {
                initClass(klass.klass);
            }
        };

        function initClass(klass) {
            if (klass.wrapped) {
                copySuperclass(klass);
            }
        }

        this.initClass = initClass;

        function copySuperclass(klass) {
            var superclass = klass.superclass,
                localMethods = klass.methods,
                localMethodsByJsSelector = {};
            Object.keys(localMethods).forEach(function (each) {
                var localMethod = localMethods[each];
                localMethodsByJsSelector[localMethod.jsSelector] = localMethod;
            });
            var myproto = klass.fn.prototype,
                superproto = superclass.fn.prototype;
            dnu.jsSelectors.forEach(function (selector) {
                if (!localMethodsByJsSelector[selector]) {
                    manip.installMethod({
                        jsSelector: selector,
                        fn: superproto[selector]
                    }, klass);
                } else if (!myproto[selector]) {
                    manip.installMethod(localMethodsByJsSelector[selector], klass);
                }
            });
        }
    }

    function ManipulationBrik(brikz, st) {
        this.installMethod = function (method, klass) {
            Object.defineProperty(klass.fn.prototype, method.jsSelector, {
                value: method.fn,
                enumerable: false, configurable: true, writable: true
            });
        };
    }


    function PackagesBrik(brikz, st) {

        var org = brikz.ensure("organize");
        var root = brikz.ensure("root");
        var nil = root.nil;
        var SmalltalkObject = root.Object;

        function SmalltalkPackage() {
        }

        inherits(SmalltalkPackage, SmalltalkObject);

        this.__init__ = function () {
            st.addPackage("Kernel-Infrastructure");
            st.wrapClassName("Package", "Kernel-Infrastructure", SmalltalkPackage, globals.Object, false);
        };

        st.packages = {};

        /* Smalltalk package creation. To add a Package, use smalltalk.addPackage() */

        function pkg(spec) {
            var that = new SmalltalkPackage();
            that.pkgName = spec.pkgName;
            org.setupPackageOrganization(that);
            that.properties = spec.properties || {};
            return that;
        }

        /* Add a package to the smalltalk.packages object, creating a new one if needed.
         If pkgName is null or empty we return nil, which is an allowed package for a class.
         If package already exists we still update the properties of it. */

        st.addPackage = function (pkgName, properties) {
            if (!pkgName) {
                return nil;
            }
            if (!(st.packages[pkgName])) {
                st.packages[pkgName] = pkg({
                    pkgName: pkgName,
                    properties: properties
                });
            } else {
                if (properties) {
                    st.packages[pkgName].properties = properties;
                }
            }
            return st.packages[pkgName];
        };
    }

    function ClassesBrik(brikz, st) {

        var org = brikz.ensure("organize");
        var root = brikz.ensure("root");
        var classInit = brikz.ensure("classInit");
        var nil = root.nil;
        var rootAsClass = root.rootAsClass;
        var SmalltalkObject = root.Object;
        rootAsClass.klass = {fn: SmalltalkClass};

        function SmalltalkBehavior() {
        }

        function SmalltalkClass() {
        }

        function SmalltalkMetaclass() {
        }

        inherits(SmalltalkBehavior, SmalltalkObject);
        inherits(SmalltalkClass, SmalltalkBehavior);
        inherits(SmalltalkMetaclass, SmalltalkBehavior);

        SmalltalkMetaclass.prototype.meta = true;

        this.__init__ = function () {
            st.addPackage("Kernel-Classes");
            st.wrapClassName("Behavior", "Kernel-Classes", SmalltalkBehavior, globals.Object, false);
            st.wrapClassName("Metaclass", "Kernel-Classes", SmalltalkMetaclass, globals.Behavior, false);
            st.wrapClassName("Class", "Kernel-Classes", SmalltalkClass, globals.Behavior, false);

            // Manually bootstrap the metaclass hierarchy
            globals.ProtoObject.klass.superclass = rootAsClass.klass = globals.Class;
            addSubclass(globals.ProtoObject.klass);
        };

        /* Smalltalk classes */

        var classes = [];
        var wrappedClasses = [];

        /* Smalltalk class creation. A class is an instance of an automatically
         created metaclass object. Newly created classes (not their metaclass)
         should be added to the smalltalk object, see smalltalk.addClass().
         Superclass linking is *not* handled here, see smalltalk.init()  */

        function klass(spec) {
            spec = spec || {};
            var setSuperClass = spec.superclass;
            if (!spec.superclass) {
                spec.superclass = rootAsClass;
            }

            var meta = metaclass(spec);
            var that = meta.instanceClass;

            that.superclass = setSuperClass;

            that.fn = spec.fn || inherits(function () {
                }, spec.superclass.fn);
            that.subclasses = [];

            setupClass(that, spec);

            that.className = spec.className;
            that.wrapped = spec.wrapped || false;
            meta.className = spec.className + ' class';
            meta.superclass = spec.superclass.klass;
            return that;
        }

        function metaclass(spec) {
            spec = spec || {};
            var that = new SmalltalkMetaclass();
            that.fn = inherits(function () {
            }, spec.superclass.klass.fn);
            that.instanceClass = new that.fn();
            setupClass(that);
            return that;
        }

        SmalltalkBehavior.prototype.toString = function () {
            return 'Smalltalk ' + this.className;
        };

        function wireKlass(klass) {
            Object.defineProperty(klass.fn.prototype, "klass", {
                value: klass,
                enumerable: false, configurable: true, writable: true
            });
        }

        function setupClass(klass, spec) {
            spec = spec || {};
            klass.iVarNames = spec.iVarNames || [];
            klass.pkg = spec.pkg;

            org.setupClassOrganization(klass);
            Object.defineProperty(klass, "methods", {
                value: Object.create(null),
                enumerable: false, configurable: true, writable: true
            });
            wireKlass(klass);
        }

        /* Add a class to the smalltalk object, creating a new one if needed.
         A Package is lazily created if it does not exist with given name. */

        st.addClass = function (className, superclass, iVarNames, pkgName) {
            // While subclassing nil is allowed, it might be an error, so
            // warn about it.
            if (typeof superclass == 'undefined' || superclass == nil) {
                console.warn('Compiling ' + className + ' as a subclass of `nil`. A dependency might be missing.');
            }
            rawAddClass(pkgName, className, superclass, iVarNames, false, null);
        };

        function rawAddClass(pkgName, className, superclass, iVarNames, wrapped, fn) {
            var pkg = st.packages[pkgName];

            if (!pkg) {
                throw new Error("Missing package " + pkgName);
            }

            if (!superclass || superclass == nil) {
                superclass = null;
            }
            var theClass = globals.hasOwnProperty(className) && globals[className];
            if (theClass && theClass.superclass == superclass) {
                //            theClass.superclass = superclass;
                theClass.iVarNames = iVarNames || [];
                if (pkg) theClass.pkg = pkg;
                if (fn) {
                    fn.prototype = theClass.fn.prototype;
                    theClass.fn = fn;
                    fn.prototype.constructor = fn;
                }
            } else {
                if (theClass) {
                    st.removeClass(theClass);
                }
                theClass = globals[className] = klass({
                    className: className,
                    superclass: superclass,
                    pkg: pkg,
                    iVarNames: iVarNames,
                    fn: fn,
                    wrapped: wrapped
                });

                addSubclass(theClass);
            }

            classes.addElement(theClass);
            org.addOrganizationElement(pkg, theClass);
        }

        st.removeClass = function (klass) {
            org.removeOrganizationElement(klass.pkg, klass);
            classes.removeElement(klass);
            removeSubclass(klass);
            delete globals[klass.className];
        };

        function addSubclass(klass) {
            if (klass.superclass) {
                klass.superclass.subclasses.addElement(klass);
            }
        }

        function removeSubclass(klass) {
            if (klass.superclass) {
                klass.superclass.subclasses.removeElement(klass);
            }
        }

        /* Create a new class wrapping a JavaScript constructor, and add it to the
         global smalltalk object. Package is lazily created if it does not exist with given name. */

        st.wrapClassName = function (className, pkgName, fn, superclass, wrapped) {
            wrapped = wrapped !== false;
            rawAddClass(pkgName, className, superclass, globals[className] && globals[className].iVarNames, wrapped, fn);
            if (wrapped) {
                wrappedClasses.addElement(globals[className]);
            }
        };

        /* Manually set the constructor of an existing Smalltalk klass, making it a wrapped class. */

        st.setClassConstructor = function (klass, constructor) {
            wrappedClasses.addElement(klass);
            klass.wrapped = true;
            klass.fn = constructor;

            // The fn property changed. We need to add back the klass property to the prototype
            wireKlass(klass);

            classInit.initClass(klass);
        };

        /* Create an alias for an existing class */

        st.alias = function (klass, alias) {
            globals[alias] = klass;
        };

        /* Answer all registered Smalltalk classes */
        //TODO: remove the function and make smalltalk.classes an array

        st.classes = function () {
            return classes;
        };

        st.wrappedClasses = function () {
            return wrappedClasses;
        };

        // Still used, but could go away now that subclasses are stored
        // into classes directly.
        st.allSubclasses = function (klass) {
            return klass._allSubclasses();
        };

    }

    function MethodsBrik(brikz, st) {

        var manip = brikz.ensure("manipulation");
        var org = brikz.ensure("organize");
        var stInit = brikz.ensure("stInit");
        var dnu = brikz.ensure("dnu");
        var SmalltalkObject = brikz.ensure("root").Object;
        brikz.ensure("selectorConversion");
        brikz.ensure("classes");

        function SmalltalkMethod() {
        }

        inherits(SmalltalkMethod, SmalltalkObject);

        this.__init__ = function () {
            st.addPackage("Kernel-Methods");
            st.wrapClassName("CompiledMethod", "Kernel-Methods", SmalltalkMethod, globals.Object, false);
        };

        /* Smalltalk method object. To add a method to a class,
         use smalltalk.addMethod() */

        st.method = function (spec) {
            var that = new SmalltalkMethod();
            that.selector = spec.selector;
            that.jsSelector = spec.jsSelector;
            that.args = spec.args || {};
            that.protocol = spec.protocol;
            that.source = spec.source;
            that.messageSends = spec.messageSends || [];
            that.referencedClasses = spec.referencedClasses || [];
            that.fn = spec.fn;
            return that;
        };

        function ensureJsSelector(method) {
            if (!(method.jsSelector)) {
                method.jsSelector = st.st2js(method.selector);
            }
        }

        /* Add/remove a method to/from a class */

        st.addMethod = function (method, klass) {
            ensureJsSelector(method);
            manip.installMethod(method, klass);
            klass.methods[method.selector] = method;
            method.methodClass = klass;

            // During the bootstrap, #addCompiledMethod is not used.
            // Therefore we populate the organizer here too
            org.addOrganizationElement(klass, method.protocol);

            propagateMethodChange(klass, method);

            var usedSelectors = method.messageSends,
                targetClasses = stInit.initialized() ? st.wrappedClasses() : [];

            dnu.make(method.selector, targetClasses);

            for (var i = 0; i < usedSelectors.length; i++) {
                dnu.make(usedSelectors[i], targetClasses);
            }
        };

        function propagateMethodChange(klass, method) {
            // If already initialized (else it will be done later anyway),
            // re-initialize all subclasses to ensure the method change
            // propagation (for wrapped classes, not using the prototype
            // chain).

            if (stInit.initialized()) {
                st.allSubclasses(klass).forEach(function (subclass) {
                    initMethodInClass(subclass, method);
                });
            }
        }

        function initMethodInClass(klass, method) {
            if (klass.wrapped && !klass.methods[method.selector]) {
                var jsSelector = method.jsSelector;
                manip.installMethod({
                    jsSelector: jsSelector,
                    fn: klass.superclass.fn.prototype[jsSelector]
                }, klass);
            }
        }

        st.removeMethod = function (method, klass) {
            if (klass !== method.methodClass) {
                throw new Error(
                    "Refusing to remove method " +
                    method.methodClass.className + ">>" + method.selector +
                    " from different class " +
                    klass.className);
            }

            ensureJsSelector(method);
            delete klass.fn.prototype[method.jsSelector];
            delete klass.methods[method.selector];

            initMethodInClass(klass, method);
            propagateMethodChange(klass, method);

            // Do *not* delete protocols from here.
            // This is handled by #removeCompiledMethod
        };

        /* Answer all method selectors based on dnu handlers */

        st.allSelectors = function () {
            return dnu.selectors;
        };

    }

    function AugmentsBrik(brikz, st) {

        /* Array extensions */

        Array.prototype.addElement = function (el) {
            if (typeof el === 'undefined') {
                return;
            }
            if (this.indexOf(el) == -1) {
                this.push(el);
            }
        };

        Array.prototype.removeElement = function (el) {
            var i = this.indexOf(el);
            if (i !== -1) {
                this.splice(i, 1);
            }
        };
    }

    function SmalltalkInitBrik(brikz, st) {

        brikz.ensure("classInit");
        brikz.ensure("classes");

        var initialized = false;

        /* Smalltalk initialization. Called on page load */

        st.initialize = function () {
            if (initialized) {
                return;
            }

            st.classes().forEach(function (klass) {
                st.init(klass);
            });

            runnable();

            st.classes().forEach(function (klass) {
                klass._initialize();
            });

            initialized = true;
        };

        this.initialized = function () {
            return initialized;
        };

        this.__init__ = function () {
            st.addPackage("Kernel-Methods");
            st.wrapClassName("Number", "Kernel-Objects", Number, globals.Object);
            st.wrapClassName("BlockClosure", "Kernel-Methods", Function, globals.Object);
            st.wrapClassName("Boolean", "Kernel-Objects", Boolean, globals.Object);
            st.wrapClassName("Date", "Kernel-Objects", Date, globals.Object);

            st.addPackage("Kernel-Collections");
            st.addClass("Collection", globals.Object, null, "Kernel-Collections");
            st.addClass("IndexableCollection", globals.Collection, null, "Kernel-Collections");
            st.addClass("SequenceableCollection", globals.IndexableCollection, null, "Kernel-Collections");
            st.addClass("CharacterArray", globals.SequenceableCollection, null, "Kernel-Collections");
            st.wrapClassName("String", "Kernel-Collections", String, globals.CharacterArray);
            st.wrapClassName("Array", "Kernel-Collections", Array, globals.SequenceableCollection);
            st.wrapClassName("RegularExpression", "Kernel-Collections", RegExp, globals.Object);

            st.addPackage("Kernel-Exceptions");
            st.wrapClassName("Error", "Kernel-Exceptions", Error, globals.Object);

            /* Alias definitions */

            st.alias(globals.Array, "OrderedCollection");
            st.alias(globals.Date, "Time");

        };
    }

    function PrimitivesBrik(brikz, st) {

        /* Unique ID number generator */

        var oid = 0;
        st.nextId = function () {
            oid += 1;
            return oid;
        };

        /* Converts a JavaScript object to valid Smalltalk Object */
        st.readJSObject = function (js) {
            if (js == null)
                return null;
            var readObject = js.constructor === Object;
            var readArray = js.constructor === Array;
            var object = readObject ? globals.Dictionary._new() : readArray ? [] : js;

            for (var i in js) {
                if (readObject) {
                    object._at_put_(i, st.readJSObject(js[i]));
                }
                if (readArray) {
                    object[i] = st.readJSObject(js[i]);
                }
            }
            return object;
        };

        /* Boolean assertion */
        st.assert = function (shouldBeBoolean) {
            if (typeof shouldBeBoolean === "boolean") return shouldBeBoolean;
            else if (shouldBeBoolean != null && typeof shouldBeBoolean === "object") {
                shouldBeBoolean = shouldBeBoolean.valueOf();
                if (typeof shouldBeBoolean === "boolean") return shouldBeBoolean;
            }
            globals.NonBooleanReceiver._new()._object_(shouldBeBoolean)._signal();
        };

        /* List of all reserved words in JavaScript. They may not be used as variables
         in Smalltalk. */

        // list of reserved JavaScript keywords as of
        //   http://es5.github.com/#x7.6.1.1
        // and
        //   http://people.mozilla.org/~jorendorff/es6-draft.html#sec-7.6.1
        st.reservedWords = ['break', 'case', 'catch', 'continue', 'debugger',
            'default', 'delete', 'do', 'else', 'finally', 'for', 'function',
            'if', 'in', 'instanceof', 'new', 'return', 'switch', 'this', 'throw',
            'try', 'typeof', 'var', 'void', 'while', 'with',
            // Amber protected words: these should not be compiled as-is when in code
            'arguments',
            // ES5: future use: http://es5.github.com/#x7.6.1.2
            'class', 'const', 'enum', 'export', 'extends', 'import', 'super',
            // ES5: future use in strict mode
            'implements', 'interface', 'let', 'package', 'private', 'protected',
            'public', 'static', 'yield'];

        st.globalJsVariables = ['window', 'document', 'process', 'global'];

    }

    function RuntimeBrik(brikz, st) {

        brikz.ensure("selectorConversion");
        var root = brikz.ensure("root");
        var nil = root.nil;
        var SmalltalkObject = root.Object;

        function SmalltalkMethodContext(home, setup) {
            this.sendIdx = {};
            this.homeContext = home;
            this.setup = setup || function () {
                };

            this.supercall = false;
        }

        inherits(SmalltalkMethodContext, SmalltalkObject);

        this.__init__ = function () {
            st.addPackage("Kernel-Methods");
            st.wrapClassName("MethodContext", "Kernel-Methods", SmalltalkMethodContext, globals.Object, false);

            // Fallbacks
            SmalltalkMethodContext.prototype.locals = {};
            SmalltalkMethodContext.prototype.receiver = null;
            SmalltalkMethodContext.prototype.selector = null;
            SmalltalkMethodContext.prototype.lookupClass = null;

            SmalltalkMethodContext.prototype.fill = function (receiver, selector, locals, lookupClass) {
                this.receiver = receiver;
                this.selector = selector;
                this.locals = locals || {};
                this.lookupClass = lookupClass;
                if (this.homeContext) {
                    this.homeContext.evaluatedSelector = selector;
                }
            };

            SmalltalkMethodContext.prototype.fillBlock = function (locals, ctx, index) {
                this.locals = locals || {};
                this.outerContext = ctx;
                this.index = index || 0;
            };

            SmalltalkMethodContext.prototype.init = function () {
                var home = this.homeContext;
                if (home) {
                    home.init();
                }

                this.setup(this);
            };

            SmalltalkMethodContext.prototype.method = function () {
                var method;
                var lookup = this.lookupClass || this.receiver.klass;
                while (!method && lookup) {
                    method = lookup.methods[st.js2st(this.selector)];
                    lookup = lookup.superclass;
                }
                return method;
            };
        };

        /* This is the current call context object. While it is publicly available,
         Use smalltalk.getThisContext() instead which will answer a safe copy of
         the current context */

        var thisContext = null;

        st.withContext = function (worker, setup) {
            if (thisContext) {
                return inContext(worker, setup);
            } else {
                return inContextWithErrorHandling(worker, setup);
            }
        };

        function inContextWithErrorHandling(worker, setup) {
            try {
                return inContext(worker, setup);
            } catch (error) {
                handleError(error);
                thisContext = null;
                // Rethrow the error in any case.
                error.amberHandled = true;
                throw error;
            }
        }

        function inContext(worker, setup) {
            var oldContext = thisContext;
            thisContext = new SmalltalkMethodContext(thisContext, setup);
            var result = worker(thisContext);
            thisContext = oldContext;
            return result;
        }

        /* Wrap a JavaScript exception in a Smalltalk Exception.

         In case of a RangeError, stub the stack after 100 contexts to
         avoid another RangeError later when the stack is manipulated. */
        function wrappedError(error) {
            var errorWrapper = globals.JavaScriptException._on_(error);
            // Add the error to the context, so it is visible in the stack
            try {
                errorWrapper._signal();
            } catch (ex) {
            }
            var context = st.getThisContext();
            if (isRangeError(error)) {
                stubContextStack(context);
            }
            errorWrapper._context_(context);
            return errorWrapper;
        }

        /* Stub the context stack after 100 contexts */
        function stubContextStack(context) {
            var currentContext = context;
            var contexts = 0;
            while (contexts < 100) {
                if (currentContext) {
                    currentContext = currentContext.homeContext;
                }
                contexts++;
            }
            if (currentContext) {
                currentContext.homeContext = undefined;
            }
        }

        function isRangeError(error) {
            return error instanceof RangeError;
        }


        /* Handles Smalltalk errors. Triggers the registered ErrorHandler
         (See the Smalltalk class ErrorHandler and its subclasses */

        function handleError(error) {
            if (!error.smalltalkError) {
                error = wrappedError(error);
            }
            globals.ErrorHandler._handleError_(error);
        }

        /* Handle thisContext pseudo variable */

        st.getThisContext = function () {
            if (thisContext) {
                thisContext.init();
                return thisContext;
            } else {
                return nil;
            }
        };
    }

    function MessageSendBrik(brikz, st) {

        brikz.ensure("selectorConversion");
        var nil = brikz.ensure("root").nil;

        /* Handles unhandled errors during message sends */
        // simply send the message and handle #dnu:

        st.send = function (receiver, jsSelector, args, klass) {
            var method;
            if (receiver == null) {
                receiver = nil;
            }
            method = klass ? klass.fn.prototype[jsSelector] : receiver.klass && receiver[jsSelector];
            if (method) {
                return method.apply(receiver, args || []);
            } else {
                return messageNotUnderstood(receiver, st.js2st(jsSelector), args);
            }
        };

        function invokeDnuMethod(receiver, stSelector, args) {
            return receiver._doesNotUnderstand_(
                globals.Message._new()
                    ._selector_(stSelector)
                    ._arguments_([].slice.call(args))
            );
        }

        /* Handles #dnu: *and* JavaScript method calls.
         if the receiver has no klass, we consider it a JS object (outside of the
         Amber system). Else assume that the receiver understands #doesNotUnderstand: */
        function messageNotUnderstood(receiver, stSelector, args) {
            if (receiver.klass != null && !receiver.allowJavaScriptCalls) {
                return invokeDnuMethod(receiver, stSelector, args);
            }
            /* Call a method of a JS object, or answer a property if it exists.
             Else try wrapping a JSObjectProxy around the receiver. */
            var propertyName = st.st2prop(stSelector);
            if (!(propertyName in receiver)) {
                return invokeDnuMethod(globals.JSObjectProxy._on_(receiver), stSelector, args);
            }
            return accessJavaScript(receiver, propertyName, args);
        }

        /* If the object property is a function, then call it, except if it starts with
         an uppercase character (we probably want to answer the function itself in this
         case and send it #new from Amber).

         Converts keyword-based selectors by using the first
         keyword only, but keeping all message arguments.

         Example:
         "self do: aBlock with: anObject" -> "self.do(aBlock, anObject)" */
        function accessJavaScript(receiver, propertyName, args) {
            var propertyValue = receiver[propertyName];
            if (typeof propertyValue === "function" && !/^[A-Z]/.test(propertyName)) {
                return propertyValue.apply(receiver, args || []);
            } else if (args.length > 0) {
                receiver[propertyName] = args[0];
                return nil;
            } else {
                return propertyValue;
            }
        }

        st.accessJavaScript = accessJavaScript;
        this.messageNotUnderstood = messageNotUnderstood;
    }

    function SelectorConversionBrik(brikz, st) {

        /* Convert a Smalltalk selector into a JS selector */
        st.st2js = function (string) {
            var selector = '_' + string;
            selector = selector.replace(/:/g, '_');
            selector = selector.replace(/[\&]/g, '_and');
            selector = selector.replace(/[\|]/g, '_or');
            selector = selector.replace(/[+]/g, '_plus');
            selector = selector.replace(/-/g, '_minus');
            selector = selector.replace(/[*]/g, '_star');
            selector = selector.replace(/[\/]/g, '_slash');
            selector = selector.replace(/[\\]/g, '_backslash');
            selector = selector.replace(/[\~]/g, '_tild');
            selector = selector.replace(/>/g, '_gt');
            selector = selector.replace(/</g, '_lt');
            selector = selector.replace(/=/g, '_eq');
            selector = selector.replace(/,/g, '_comma');
            selector = selector.replace(/[@]/g, '_at');
            return selector;
        };

        /* Convert a string to a valid smalltalk selector.
         if you modify the following functions, also change st2js
         accordingly */
        st.js2st = function (selector) {
            if (selector.match(/^__/)) {
                return binaryJsToSt(selector);
            } else {
                return keywordJsToSt(selector);
            }
        };

        function keywordJsToSt(selector) {
            return selector.replace(/^_/, '').replace(/_/g, ':');
        }

        function binaryJsToSt(selector) {
            return selector
                .replace(/^_/, '')
                .replace(/_and/g, '&')
                .replace(/_or/g, '|')
                .replace(/_plus/g, '+')
                .replace(/_minus/g, '-')
                .replace(/_star/g, '*')
                .replace(/_slash/g, '/')
                .replace(/_backslash/g, '\\')
                .replace(/_tild/g, '~')
                .replace(/_gt/g, '>')
                .replace(/_lt/g, '<')
                .replace(/_eq/g, '=')
                .replace(/_comma/g, ',')
                .replace(/_at/g, '@');
        }

        st.st2prop = function (stSelector) {
            var colonPosition = stSelector.indexOf(':');
            return colonPosition === -1 ? stSelector : stSelector.slice(0, colonPosition);
        };
    }

    /* Adds AMD and requirejs related methods to the smalltalk object */
    function AMDBrik(brikz, st) {
        this.__init__ = function () {
            st.amdRequire = require;
            st.defaultTransportType = st.defaultTransportType || "amd";
            st.defaultAmdNamespace = st.defaultAmdNamespace || "amber_core";
        };
    }

    /* Defines asReceiver to be present at load time */
    /* (logically it belongs more to PrimitiveBrik) */
    function AsReceiverBrik(brikz, st) {

        var nil = brikz.ensure("root").nil;

        /**
         * This function is used all over the compiled amber code.
         * It takes any value (JavaScript or Smalltalk)
         * and returns a proper Amber Smalltalk receiver.
         *
         * null or undefined -> nil,
         * plain JS object -> wrapped JS object,
         * otherwise unchanged
         */
        this.asReceiver = function (o) {
            if (o == null) return nil;
            if (typeof o === "object" || typeof o === "function") {
                return o.klass != null ? o : globals.JSObjectProxy._on_(o);
            }
            // IMPORTANT: This optimization (return o if typeof !== "object")
            // assumes all primitive types are wrapped by some Smalltalk class
            // so they can be returned as-is, without boxing and looking for .klass.
            // KEEP THE primitives-are-wrapped INVARIANT!
            return o;
        };
    }


    /* Making smalltalk that can load */

    brikz.root = RootBrik;
    brikz.dnu = DNUBrik;
    brikz.organize = OrganizeBrik;
    brikz.selectorConversion = SelectorConversionBrik;
    brikz.classInit = ClassInitBrik;
    brikz.manipulation = ManipulationBrik;
    brikz.packages = PackagesBrik;
    brikz.classes = ClassesBrik;
    brikz.methods = MethodsBrik;
    brikz.stInit = SmalltalkInitBrik;
    brikz.augments = AugmentsBrik;
    brikz.asReceiver = AsReceiverBrik;
    brikz.amd = AMDBrik;

    brikz.rebuild();

    /* Making smalltalk that can run */

    function runnable() {
        brikz.messageSend = MessageSendBrik;
        brikz.runtime = RuntimeBrik;
        brikz.primitives = PrimitivesBrik;

        brikz.rebuild();
    }

    return {
        api: api,
        nil: brikz.root.nil,
        dnu: brikz.root.rootAsClass,
        globals: globals,
        asReceiver: brikz.asReceiver.asReceiver
    };
});

define('amber/helpers',["amber/boot", "require"], function (boot, require) {
    var globals = boot.globals,
        exports = {},
        api = boot.api,
        nil = boot.nil;

    // API

    exports.popupHelios = function () {
        require(['helios/index'], function (helios) {
            helios.popup();
        }, function (err) {
            window.alert("Error loading helios.\nIf not present, you can install it with 'bower install helios --save-dev'.\nThe error follows:\n" + err);
        });
    };
    Object.defineProperty(exports, "api", {
        value: api,
        enumerable: true, configurable: true, writable: false
    });
    Object.defineProperty(exports, "globals", {
        value: globals,
        enumerable: true, configurable: true, writable: false
    });
    Object.defineProperty(exports, "nil", {
        value: nil,
        enumerable: true, configurable: true, writable: false
    });

    function mixinToSettings(source) {
        var settings = globals.SmalltalkSettings;
        Object.keys(source).forEach(function (key) {
            settings[key] = source[key];
        });
    }

    function settingsInLocalStorage() {
        //jshint evil:true
        var global = new Function('return this')(),
            storage = 'localStorage' in global && global.localStorage;

        if (storage) {
            var fromStorage;
            try {
                fromStorage = JSON.parse(storage.getItem('amber.SmalltalkSettings'));
            } catch (ex) {
                // pass
            }
            mixinToSettings(fromStorage || {});
            if (typeof window !== "undefined") {
                requirejs(['jquery'], function ($) {
                    $(window).on('beforeunload', function () {
                        storage.setItem('amber.SmalltalkSettings', JSON.stringify(globals.SmalltalkSettings));
                    });
                });
            }
        }
    }

    exports.initialize = function (options) {
        return Promise.resolve()
            .then(function () {
                globals.SmalltalkSettings['transport.defaultAmdNamespace'] = api.defaultAmdNamespace;
            })
            .then(settingsInLocalStorage)
            .then(function () {
                return options || {};
            })
            .then(mixinToSettings)
            .then(function () {
                return api.initialize();
            })
    };

    // Exports

    return exports;
});

define("amber_core/Kernel-Objects", ["amber/boot"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Kernel-Objects');
$core.packages["Kernel-Objects"].innerEval = function (expr) { return eval(expr); };
$core.packages["Kernel-Objects"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('ProtoObject', null, [], 'Kernel-Objects');
$globals.ProtoObject.comment="I implement the basic behavior required for any object in Amber.\x0a\x0aIn most cases, subclassing `ProtoObject` is wrong and `Object` should be used instead. However subclassing `ProtoObject` can be useful in some special cases like proxy implementations.";
$core.addMethod(
$core.method({
selector: "=",
protocol: 'comparing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self.__eq_eq(anObject);
}, function($ctx1) {$ctx1.fill(self,"=",{anObject:anObject},$globals.ProtoObject)});
},
args: ["anObject"],
source: "= anObject\x0a\x09^ self == anObject",
referencedClasses: [],
messageSends: ["=="]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "==",
protocol: 'comparing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self._class() === $recv(anObject)._class() && self._isSameInstanceAs_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"==",{anObject:anObject},$globals.ProtoObject)});
},
args: ["anObject"],
source: "== anObject\x0a<return self._class() === $recv(anObject)._class() && self._isSameInstanceAs_(anObject)>",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "asString",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._printString();
}, function($ctx1) {$ctx1.fill(self,"asString",{},$globals.ProtoObject)});
},
args: [],
source: "asString\x0a\x09^ self printString",
referencedClasses: [],
messageSends: ["printString"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "class",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.klass;
return self;
}, function($ctx1) {$ctx1.fill(self,"class",{},$globals.ProtoObject)});
},
args: [],
source: "class\x0a\x09<return self.klass>",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "doesNotUnderstand:",
protocol: 'error handling',
fn: function (aMessage){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.MessageNotUnderstood)._new();
$recv($1)._receiver_(self);
$recv($1)._message_(aMessage);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"doesNotUnderstand:",{aMessage:aMessage},$globals.ProtoObject)});
},
args: ["aMessage"],
source: "doesNotUnderstand: aMessage\x0a\x09MessageNotUnderstood new\x0a\x09\x09receiver: self;\x0a\x09\x09message: aMessage;\x0a\x09\x09signal",
referencedClasses: ["MessageNotUnderstood"],
messageSends: ["receiver:", "new", "message:", "signal"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "evaluate:on:",
protocol: 'evaluating',
fn: function (aString,anEvaluator){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(anEvaluator)._evaluate_receiver_(aString,self);
}, function($ctx1) {$ctx1.fill(self,"evaluate:on:",{aString:aString,anEvaluator:anEvaluator},$globals.ProtoObject)});
},
args: ["aString", "anEvaluator"],
source: "evaluate: aString on: anEvaluator\x0a\x09^ anEvaluator evaluate: aString receiver: self",
referencedClasses: [],
messageSends: ["evaluate:receiver:"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "identityHash",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		var hash=self.identityHash;
		if (hash) return hash;
		hash=$core.nextId();
		Object.defineProperty(self, 'identityHash', {value:hash});
		return hash;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"identityHash",{},$globals.ProtoObject)});
},
args: [],
source: "identityHash\x0a\x09<\x0a\x09\x09var hash=self.identityHash;\x0a\x09\x09if (hash) return hash;\x0a\x09\x09hash=$core.nextId();\x0a\x09\x09Object.defineProperty(self, 'identityHash', {value:hash});\x0a\x09\x09return hash;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "ifNil:",
protocol: 'testing',
fn: function (aBlock){
var self=this;
return self;

},
args: ["aBlock"],
source: "ifNil: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "ifNil:ifNotNil:",
protocol: 'testing',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(anotherBlock)._value_(self);
}, function($ctx1) {$ctx1.fill(self,"ifNil:ifNotNil:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.ProtoObject)});
},
args: ["aBlock", "anotherBlock"],
source: "ifNil: aBlock ifNotNil: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ anotherBlock value: self",
referencedClasses: [],
messageSends: ["value:"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "ifNotNil:",
protocol: 'testing',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aBlock)._value_(self);
}, function($ctx1) {$ctx1.fill(self,"ifNotNil:",{aBlock:aBlock},$globals.ProtoObject)});
},
args: ["aBlock"],
source: "ifNotNil: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ aBlock value: self",
referencedClasses: [],
messageSends: ["value:"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "ifNotNil:ifNil:",
protocol: 'testing',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aBlock)._value_(self);
}, function($ctx1) {$ctx1.fill(self,"ifNotNil:ifNil:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.ProtoObject)});
},
args: ["aBlock", "anotherBlock"],
source: "ifNotNil: aBlock ifNil: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ aBlock value: self",
referencedClasses: [],
messageSends: ["value:"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return self;

},
args: [],
source: "initialize",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "inspect",
protocol: 'inspecting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Inspector)._inspect_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspect",{},$globals.ProtoObject)});
},
args: [],
source: "inspect\x0a\x09Inspector inspect: self",
referencedClasses: ["Inspector"],
messageSends: ["inspect:"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: 'inspecting',
fn: function (anInspector){
var self=this;
return self;

},
args: ["anInspector"],
source: "inspectOn: anInspector",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "instVarAt:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
 return self['@'+aString] ;
return self;
}, function($ctx1) {$ctx1.fill(self,"instVarAt:",{aString:aString},$globals.ProtoObject)});
},
args: ["aString"],
source: "instVarAt: aString\x0a\x09< return self['@'+aString] >",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "instVarAt:put:",
protocol: 'accessing',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {
 self['@' + aString] = anObject ;
return self;
}, function($ctx1) {$ctx1.fill(self,"instVarAt:put:",{aString:aString,anObject:anObject},$globals.ProtoObject)});
},
args: ["aString", "anObject"],
source: "instVarAt: aString put: anObject\x0a\x09< self['@' + aString] = anObject >",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "isKindOf:",
protocol: 'testing',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._isMemberOf_(aClass);
if($core.assert($1)){
return true;
} else {
return $recv(self._class())._inheritsFrom_(aClass);
};
}, function($ctx1) {$ctx1.fill(self,"isKindOf:",{aClass:aClass},$globals.ProtoObject)});
},
args: ["aClass"],
source: "isKindOf: aClass\x0a\x09^ (self isMemberOf: aClass)\x0a\x09\x09ifTrue: [ true ]\x0a\x09\x09ifFalse: [ self class inheritsFrom: aClass ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "isMemberOf:", "inheritsFrom:", "class"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "isNil",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isNil\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "isSameInstanceAs:",
protocol: 'comparing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._identityHash();
$ctx1.sendIdx["identityHash"]=1;
return $recv($1).__eq($recv(anObject)._identityHash());
}, function($ctx1) {$ctx1.fill(self,"isSameInstanceAs:",{anObject:anObject},$globals.ProtoObject)});
},
args: ["anObject"],
source: "isSameInstanceAs: anObject\x0a\x09^ self identityHash = anObject identityHash",
referencedClasses: [],
messageSends: ["=", "identityHash"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "notNil",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._isNil())._not();
}, function($ctx1) {$ctx1.fill(self,"notNil",{},$globals.ProtoObject)});
},
args: [],
source: "notNil\x0a\x09^ self isNil not",
referencedClasses: [],
messageSends: ["not", "isNil"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "perform:",
protocol: 'message handling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self._perform_withArguments_(aString,[]);
}, function($ctx1) {$ctx1.fill(self,"perform:",{aString:aString},$globals.ProtoObject)});
},
args: ["aString"],
source: "perform: aString\x0a\x09^ self perform: aString withArguments: #()",
referencedClasses: [],
messageSends: ["perform:withArguments:"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "perform:withArguments:",
protocol: 'message handling',
fn: function (aString,aCollection){
var self=this;
return $core.withContext(function($ctx1) {
return $core.send(self, aString._asJavaScriptMethodName(), aCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"perform:withArguments:",{aString:aString,aCollection:aCollection},$globals.ProtoObject)});
},
args: ["aString", "aCollection"],
source: "perform: aString withArguments: aCollection\x0a\x09<return $core.send(self, aString._asJavaScriptMethodName(), aCollection)>",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $5,$4,$3,$2,$1;
$5=self._class();
$ctx1.sendIdx["class"]=1;
$4=$recv($5)._name();
$ctx1.sendIdx["name"]=1;
$3=$recv($4)._first();
$2=$recv($3)._isVowel();
if($core.assert($2)){
$1="an ";
} else {
$1="a ";
};
$recv(aStream)._nextPutAll_($1);
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_($recv(self._class())._name());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.ProtoObject)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: (self class name first isVowel\x0a\x09\x09ifTrue: [ 'an ' ]\x0a\x09\x09ifFalse: [ 'a ' ]).\x0a\x09aStream nextPutAll: self class name",
referencedClasses: [],
messageSends: ["nextPutAll:", "ifTrue:ifFalse:", "isVowel", "first", "name", "class"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "printString",
protocol: 'printing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
return self._printOn_(str);
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"printString",{},$globals.ProtoObject)});
},
args: [],
source: "printString\x0a\x09^ String streamContents: [ :str | \x0a\x09\x09self printOn: str ]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "printOn:"]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "yourself",
protocol: 'accessing',
fn: function (){
var self=this;
return self;

},
args: [],
source: "yourself\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "~=",
protocol: 'comparing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self.__eq(anObject)).__eq(false);
$ctx1.sendIdx["="]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"~=",{anObject:anObject},$globals.ProtoObject)});
},
args: ["anObject"],
source: "~= anObject\x0a\x09^ (self = anObject) = false",
referencedClasses: [],
messageSends: ["="]
}),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "~~",
protocol: 'comparing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self.__eq_eq(anObject)).__eq(false);
}, function($ctx1) {$ctx1.fill(self,"~~",{anObject:anObject},$globals.ProtoObject)});
},
args: ["anObject"],
source: "~~ anObject\x0a\x09^ (self == anObject) = false",
referencedClasses: [],
messageSends: ["=", "=="]
}),
$globals.ProtoObject);


$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return self;

},
args: [],
source: "initialize",
referencedClasses: [],
messageSends: []
}),
$globals.ProtoObject.klass);


$core.addClass('Object', $globals.ProtoObject, [], 'Kernel-Objects');
$globals.Object.comment="**I am the root of the Smalltalk class system**. With the exception of unual subclasses of `ProtoObject`, all other classes in the system are subclasses of me.\x0a\x0aI provide default behavior common to all normal objects (some of it inherited from `ProtoObject`), such as:\x0a\x0a- accessing\x0a- copying\x0a- comparison\x0a- error handling\x0a- message sending\x0a- reflection\x0a\x0aAlso utility messages that all objects should respond to are defined here.\x0a\x0aI have no instance variable.\x0a\x0a##Access\x0a\x0aInstance variables can be accessed with `#instVarAt:` and `#instVarAt:put:`. `#instanceVariableNames` answers a collection of all instance variable names.\x0aAccessing JavaScript properties of an object is done through `#basicAt:`, `#basicAt:put:` and `basicDelete:`.\x0a\x0a##Copying\x0a\x0aCopying an object is handled by `#copy` and `#deepCopy`. The first one performs a shallow copy of the receiver, while the second one performs a deep copy.\x0aThe hook method `#postCopy` can be overriden in subclasses to copy fields as necessary to complete the full copy. It will be sent by the copy of the receiver.\x0a\x0a##Comparison\x0a\x0aI understand equality `#=` and identity `#==` comparison.\x0a\x0a##Error handling\x0a\x0a- `#halt` is the typical message to use for inserting breakpoints during debugging.\x0a- `#error:` throws a generic error exception\x0a- `#doesNotUnderstand:` handles the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message.\x0a\x09Overriding this message can be useful to implement proxies for example.";
$core.addMethod(
$core.method({
selector: "->",
protocol: 'converting',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Association)._key_value_(self,anObject);
}, function($ctx1) {$ctx1.fill(self,"->",{anObject:anObject},$globals.Object)});
},
args: ["anObject"],
source: "-> anObject\x0a\x09^ Association key: self value: anObject",
referencedClasses: ["Association"],
messageSends: ["key:value:"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "asJSON",
protocol: 'converting',
fn: function (){
var self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.HashedCollection)._new();
$recv($recv(self._class())._allInstanceVariableNames())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(variables)._at_put_(each,$recv(self._instVarAt_(each))._asJSON());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return variables;
}, function($ctx1) {$ctx1.fill(self,"asJSON",{variables:variables},$globals.Object)});
},
args: [],
source: "asJSON\x0a\x09| variables |\x0a\x09variables := HashedCollection new.\x0a\x09self class allInstanceVariableNames do: [ :each |\x0a\x09\x09variables at: each put: (self instVarAt: each) asJSON ].\x0a\x09^ variables",
referencedClasses: ["HashedCollection"],
messageSends: ["new", "do:", "allInstanceVariableNames", "class", "at:put:", "asJSON", "instVarAt:"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "asJSONString",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.JSON)._stringify_(self._asJSON());
}, function($ctx1) {$ctx1.fill(self,"asJSONString",{},$globals.Object)});
},
args: [],
source: "asJSONString\x0a\x09^ JSON stringify: self asJSON",
referencedClasses: ["JSON"],
messageSends: ["stringify:", "asJSON"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "asJavascript",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._asString();
}, function($ctx1) {$ctx1.fill(self,"asJavascript",{},$globals.Object)});
},
args: [],
source: "asJavascript\x0a\x09^ self asString",
referencedClasses: [],
messageSends: ["asString"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "basicAt:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self[aString];
return self;
}, function($ctx1) {$ctx1.fill(self,"basicAt:",{aString:aString},$globals.Object)});
},
args: ["aString"],
source: "basicAt: aString\x0a\x09<return self[aString]>",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "basicAt:put:",
protocol: 'accessing',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self[aString] = anObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicAt:put:",{aString:aString,anObject:anObject},$globals.Object)});
},
args: ["aString", "anObject"],
source: "basicAt: aString put: anObject\x0a\x09<return self[aString] = anObject>",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "basicDelete:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
delete self[aString]; return aString;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicDelete:",{aString:aString},$globals.Object)});
},
args: ["aString"],
source: "basicDelete: aString\x0a\x09<delete self[aString]; return aString>",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "basicPerform:",
protocol: 'message handling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self._basicPerform_withArguments_(aString,[]);
}, function($ctx1) {$ctx1.fill(self,"basicPerform:",{aString:aString},$globals.Object)});
},
args: ["aString"],
source: "basicPerform: aString\x0a\x09^ self basicPerform: aString withArguments: #()",
referencedClasses: [],
messageSends: ["basicPerform:withArguments:"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "basicPerform:withArguments:",
protocol: 'message handling',
fn: function (aString,aCollection){
var self=this;
return $core.withContext(function($ctx1) {
return self[aString].apply(self, aCollection);;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicPerform:withArguments:",{aString:aString,aCollection:aCollection},$globals.Object)});
},
args: ["aString", "aCollection"],
source: "basicPerform: aString withArguments: aCollection\x0a\x09<return self[aString].apply(self, aCollection);>",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "browse",
protocol: 'browsing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Finder)._findClass_(self._class());
return self;
}, function($ctx1) {$ctx1.fill(self,"browse",{},$globals.Object)});
},
args: [],
source: "browse\x0a\x09Finder findClass: self class",
referencedClasses: ["Finder"],
messageSends: ["findClass:", "class"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "copy",
protocol: 'copying',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._shallowCopy())._postCopy();
}, function($ctx1) {$ctx1.fill(self,"copy",{},$globals.Object)});
},
args: [],
source: "copy\x0a\x09^ self shallowCopy postCopy",
referencedClasses: [],
messageSends: ["postCopy", "shallowCopy"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: 'copying',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		var copy = self.klass._new();
		Object.keys(self).forEach(function (i) {
		if(/^@.+/.test(i)) {
			copy[i] = self[i]._deepCopy();
		}
		});
		return copy;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"deepCopy",{},$globals.Object)});
},
args: [],
source: "deepCopy\x0a\x09<\x0a\x09\x09var copy = self.klass._new();\x0a\x09\x09Object.keys(self).forEach(function (i) {\x0a\x09\x09if(/^@.+/.test(i)) {\x0a\x09\x09\x09copy[i] = self[i]._deepCopy();\x0a\x09\x09}\x0a\x09\x09});\x0a\x09\x09return copy;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "deprecatedAPI",
protocol: 'error handling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$6,$5,$4,$8,$7,$3,$2;
$1=console;
$6=$core.getThisContext()._home();
$ctx1.sendIdx["home"]=1;
$5=$recv($6)._asString();
$ctx1.sendIdx["asString"]=1;
$4=$recv($5).__comma(" is deprecated! (in ");
$8=$recv($core.getThisContext()._home())._home();
$ctx1.sendIdx["home"]=2;
$7=$recv($8)._asString();
$3=$recv($4).__comma($7);
$ctx1.sendIdx[","]=2;
$2=$recv($3).__comma(")");
$ctx1.sendIdx[","]=1;
$recv($1)._warn_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"deprecatedAPI",{},$globals.Object)});
},
args: [],
source: "deprecatedAPI\x0a\x09\x22Just a simple way to deprecate methods.\x0a\x09#deprecatedAPI is in the 'error handling' protocol even if it doesn't throw an error,\x0a\x09but it could in the future.\x22\x0a\x09console warn: thisContext home asString, ' is deprecated! (in ', thisContext home home asString, ')'.",
referencedClasses: [],
messageSends: ["warn:", ",", "asString", "home"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "deprecatedAPI:",
protocol: 'error handling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$6,$5,$4,$8,$7,$3,$2;
$1=console;
$6=$core.getThisContext()._home();
$ctx1.sendIdx["home"]=1;
$5=$recv($6)._asString();
$ctx1.sendIdx["asString"]=1;
$4=$recv($5).__comma(" is deprecated! (in ");
$8=$recv($core.getThisContext()._home())._home();
$ctx1.sendIdx["home"]=2;
$7=$recv($8)._asString();
$3=$recv($4).__comma($7);
$ctx1.sendIdx[","]=2;
$2=$recv($3).__comma(")");
$ctx1.sendIdx[","]=1;
$recv($1)._warn_($2);
$ctx1.sendIdx["warn:"]=1;
$recv(console)._warn_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"deprecatedAPI:",{aString:aString},$globals.Object)});
},
args: ["aString"],
source: "deprecatedAPI: aString\x0a\x09\x22Just a simple way to deprecate methods.\x0a\x09#deprecatedAPI is in the 'error handling' protocol even if it doesn't throw an error,\x0a\x09but it could in the future.\x22\x0a\x09console warn: thisContext home asString, ' is deprecated! (in ', thisContext home home asString, ')'.\x0a\x09console warn: aString",
referencedClasses: [],
messageSends: ["warn:", ",", "asString", "home"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "error:",
protocol: 'error handling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Error)._signal_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"error:",{aString:aString},$globals.Object)});
},
args: ["aString"],
source: "error: aString\x0a\x09Error signal: aString",
referencedClasses: ["Error"],
messageSends: ["signal:"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "halt",
protocol: 'error handling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Halt)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"halt",{},$globals.Object)});
},
args: [],
source: "halt\x0a\x09Halt signal",
referencedClasses: ["Halt"],
messageSends: ["signal"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "in:",
protocol: 'evaluating',
fn: function (aValuable){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aValuable)._value_(self);
}, function($ctx1) {$ctx1.fill(self,"in:",{aValuable:aValuable},$globals.Object)});
},
args: ["aValuable"],
source: "in: aValuable\x0a\x09^ aValuable value: self",
referencedClasses: [],
messageSends: ["value:"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isBehavior",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isBehavior\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isBoolean",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isBoolean\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isClass",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isClass\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isCompiledMethod",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isCompiledMethod\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isImmutable\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isMemberOf:",
protocol: 'testing',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._class()).__eq(aClass);
}, function($ctx1) {$ctx1.fill(self,"isMemberOf:",{aClass:aClass},$globals.Object)});
},
args: ["aClass"],
source: "isMemberOf: aClass\x0a\x09^ self class = aClass",
referencedClasses: [],
messageSends: ["=", "class"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isMetaclass",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isMetaclass\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isNumber",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isNumber\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isPackage",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isPackage\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isParseFailure",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isParseFailure\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isString",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isString\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isSymbol",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isSymbol\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "postCopy",
protocol: 'copying',
fn: function (){
var self=this;
return self;

},
args: [],
source: "postCopy",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "putOn:",
protocol: 'streaming',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPut_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"putOn:",{aStream:aStream},$globals.Object)});
},
args: ["aStream"],
source: "putOn: aStream\x0a\x09aStream nextPut: self",
referencedClasses: [],
messageSends: ["nextPut:"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "respondsTo:",
protocol: 'testing',
fn: function (aSelector){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._class())._canUnderstand_(aSelector);
}, function($ctx1) {$ctx1.fill(self,"respondsTo:",{aSelector:aSelector},$globals.Object)});
},
args: ["aSelector"],
source: "respondsTo: aSelector\x0a\x09^ self class canUnderstand: aSelector",
referencedClasses: [],
messageSends: ["canUnderstand:", "class"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: 'copying',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		var copy = self.klass._new();
		Object.keys(self).forEach(function(i) {
		if(/^@.+/.test(i)) {
			copy[i] = self[i];
		}
		});
		return copy;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"shallowCopy",{},$globals.Object)});
},
args: [],
source: "shallowCopy\x0a\x09<\x0a\x09\x09var copy = self.klass._new();\x0a\x09\x09Object.keys(self).forEach(function(i) {\x0a\x09\x09if(/^@.+/.test(i)) {\x0a\x09\x09\x09copy[i] = self[i];\x0a\x09\x09}\x0a\x09\x09});\x0a\x09\x09return copy;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "shouldNotImplement",
protocol: 'error handling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._error_("This method should not be implemented in ".__comma($recv(self._class())._name()));
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldNotImplement",{},$globals.Object)});
},
args: [],
source: "shouldNotImplement\x0a\x09self error: 'This method should not be implemented in ', self class name",
referencedClasses: [],
messageSends: ["error:", ",", "name", "class"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "size",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._error_("Object not indexable");
return self;
}, function($ctx1) {$ctx1.fill(self,"size",{},$globals.Object)});
},
args: [],
source: "size\x0a\x09self error: 'Object not indexable'",
referencedClasses: [],
messageSends: ["error:"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "subclassResponsibility",
protocol: 'error handling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._error_("This method is a responsibility of a subclass");
return self;
}, function($ctx1) {$ctx1.fill(self,"subclassResponsibility",{},$globals.Object)});
},
args: [],
source: "subclassResponsibility\x0a\x09self error: 'This method is a responsibility of a subclass'",
referencedClasses: [],
messageSends: ["error:"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "throw:",
protocol: 'error handling',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
 throw anObject ;
return self;
}, function($ctx1) {$ctx1.fill(self,"throw:",{anObject:anObject},$globals.Object)});
},
args: ["anObject"],
source: "throw: anObject\x0a\x09< throw anObject >",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "value",
protocol: 'evaluating',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.valueOf();
return self;
}, function($ctx1) {$ctx1.fill(self,"value",{},$globals.Object)});
},
args: [],
source: "value\x0a\x09<return self.valueOf()>",
referencedClasses: [],
messageSends: []
}),
$globals.Object);


$core.addMethod(
$core.method({
selector: "accessorProtocolWith:",
protocol: 'helios',
fn: function (aGenerator){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aGenerator)._accessorProtocolForObject();
return self;
}, function($ctx1) {$ctx1.fill(self,"accessorProtocolWith:",{aGenerator:aGenerator},$globals.Object.klass)});
},
args: ["aGenerator"],
source: "accessorProtocolWith: aGenerator\x0a\x09aGenerator accessorProtocolForObject",
referencedClasses: [],
messageSends: ["accessorProtocolForObject"]
}),
$globals.Object.klass);

$core.addMethod(
$core.method({
selector: "accessorsSourceCodesWith:",
protocol: 'helios',
fn: function (aGenerator){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aGenerator)._accessorsForObject();
return self;
}, function($ctx1) {$ctx1.fill(self,"accessorsSourceCodesWith:",{aGenerator:aGenerator},$globals.Object.klass)});
},
args: ["aGenerator"],
source: "accessorsSourceCodesWith: aGenerator\x0a\x09aGenerator accessorsForObject",
referencedClasses: [],
messageSends: ["accessorsForObject"]
}),
$globals.Object.klass);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return self;

},
args: [],
source: "initialize\x0a\x09\x22no op\x22",
referencedClasses: [],
messageSends: []
}),
$globals.Object.klass);

$core.addMethod(
$core.method({
selector: "initializeProtocolWith:",
protocol: 'helios',
fn: function (aGenerator){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aGenerator)._initializeProtocolForObject();
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeProtocolWith:",{aGenerator:aGenerator},$globals.Object.klass)});
},
args: ["aGenerator"],
source: "initializeProtocolWith: aGenerator\x0a\x09aGenerator initializeProtocolForObject",
referencedClasses: [],
messageSends: ["initializeProtocolForObject"]
}),
$globals.Object.klass);

$core.addMethod(
$core.method({
selector: "initializeSourceCodesWith:",
protocol: 'helios',
fn: function (aGenerator){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aGenerator)._initializeForObject();
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeSourceCodesWith:",{aGenerator:aGenerator},$globals.Object.klass)});
},
args: ["aGenerator"],
source: "initializeSourceCodesWith: aGenerator\x0a\x09aGenerator initializeForObject",
referencedClasses: [],
messageSends: ["initializeForObject"]
}),
$globals.Object.klass);


$core.addClass('Boolean', $globals.Object, [], 'Kernel-Objects');
$globals.Boolean.comment="I define the protocol for logic testing operations and conditional control structures for the logical values (see the `controlling` protocol).\x0a\x0aI have two instances, `true` and `false`.\x0a\x0aI am directly mapped to JavaScript Boolean. The `true` and `false` objects are the JavaScript boolean objects.\x0a\x0a## Usage Example:\x0a\x0a    aBoolean not ifTrue: [ ... ] ifFalse: [ ... ]";
$core.addMethod(
$core.method({
selector: "&",
protocol: 'controlling',
fn: function (aBoolean){
var self=this;
return $core.withContext(function($ctx1) {

		if(self == true) {
		return aBoolean;
		} else {
		return false;
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"&",{aBoolean:aBoolean},$globals.Boolean)});
},
args: ["aBoolean"],
source: "& aBoolean\x0a\x09<\x0a\x09\x09if(self == true) {\x0a\x09\x09return aBoolean;\x0a\x09\x09} else {\x0a\x09\x09return false;\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "==",
protocol: 'comparing',
fn: function (aBoolean){
var self=this;
return $core.withContext(function($ctx1) {

	if (typeof aBoolean === "boolean") return self.valueOf() === aBoolean;
	else if (aBoolean != null && typeof aBoolean === "object") return self.valueOf() === aBoolean.valueOf();
	else return false;;
return self;
}, function($ctx1) {$ctx1.fill(self,"==",{aBoolean:aBoolean},$globals.Boolean)});
},
args: ["aBoolean"],
source: "== aBoolean\x0a<\x0a\x09if (typeof aBoolean === \x22boolean\x22) return self.valueOf() === aBoolean;\x0a\x09else if (aBoolean != null && typeof aBoolean === \x22object\x22) return self.valueOf() === aBoolean.valueOf();\x0a\x09else return false;\x0a>",
referencedClasses: [],
messageSends: []
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "and:",
protocol: 'controlling',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self.__eq(true);
return $recv($1)._ifTrue_ifFalse_(aBlock,(function(){
return false;

}));
}, function($ctx1) {$ctx1.fill(self,"and:",{aBlock:aBlock},$globals.Boolean)});
},
args: ["aBlock"],
source: "and: aBlock\x0a\x09^ self = true\x0a\x09\x09ifTrue: aBlock\x0a\x09\x09ifFalse: [ false ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "="]
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "asBit",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
if($core.assert(self)){
return (1);
} else {
return (0);
};
}, function($ctx1) {$ctx1.fill(self,"asBit",{},$globals.Boolean)});
},
args: [],
source: "asBit\x0a\x09^ self ifTrue: [ 1 ] ifFalse: [ 0 ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:"]
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "asJSON",
protocol: 'converting',
fn: function (){
var self=this;
return self;

},
args: [],
source: "asJSON\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "asString",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
 return self.toString() ;
return self;
}, function($ctx1) {$ctx1.fill(self,"asString",{},$globals.Boolean)});
},
args: [],
source: "asString\x0a\x09< return self.toString() >",
referencedClasses: [],
messageSends: []
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: 'copying',
fn: function (){
var self=this;
return self;

},
args: [],
source: "deepCopy\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "ifFalse:",
protocol: 'controlling',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._ifTrue_ifFalse_((function(){

}),aBlock);
}, function($ctx1) {$ctx1.fill(self,"ifFalse:",{aBlock:aBlock},$globals.Boolean)});
},
args: ["aBlock"],
source: "ifFalse: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self ifTrue: [] ifFalse: aBlock",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:"]
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "ifFalse:ifTrue:",
protocol: 'controlling',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._ifTrue_ifFalse_(anotherBlock,aBlock);
}, function($ctx1) {$ctx1.fill(self,"ifFalse:ifTrue:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.Boolean)});
},
args: ["aBlock", "anotherBlock"],
source: "ifFalse: aBlock ifTrue: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self ifTrue: anotherBlock ifFalse: aBlock",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:"]
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "ifTrue:",
protocol: 'controlling',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._ifTrue_ifFalse_(aBlock,(function(){

}));
}, function($ctx1) {$ctx1.fill(self,"ifTrue:",{aBlock:aBlock},$globals.Boolean)});
},
args: ["aBlock"],
source: "ifTrue: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self ifTrue: aBlock ifFalse: []",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:"]
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "ifTrue:ifFalse:",
protocol: 'controlling',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {

		if(self == true) {
		return aBlock._value();
		} else {
		return anotherBlock._value();
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"ifTrue:ifFalse:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.Boolean)});
},
args: ["aBlock", "anotherBlock"],
source: "ifTrue: aBlock ifFalse: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09<\x0a\x09\x09if(self == true) {\x0a\x09\x09return aBlock._value();\x0a\x09\x09} else {\x0a\x09\x09return anotherBlock._value();\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "isBoolean",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isBoolean\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "not",
protocol: 'controlling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.__eq(false);
}, function($ctx1) {$ctx1.fill(self,"not",{},$globals.Boolean)});
},
args: [],
source: "not\x0a\x09^ self = false",
referencedClasses: [],
messageSends: ["="]
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "or:",
protocol: 'controlling',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self.__eq(true);
return $recv($1)._ifTrue_ifFalse_((function(){
return true;

}),aBlock);
}, function($ctx1) {$ctx1.fill(self,"or:",{aBlock:aBlock},$globals.Boolean)});
},
args: ["aBlock"],
source: "or: aBlock\x0a\x09^ self = true\x0a\x09\x09ifTrue: [ true ]\x0a\x09\x09ifFalse: aBlock",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "="]
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_(self._asString());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Boolean)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: self asString",
referencedClasses: [],
messageSends: ["nextPutAll:", "asString"]
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: 'copying',
fn: function (){
var self=this;
return self;

},
args: [],
source: "shallowCopy\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "|",
protocol: 'controlling',
fn: function (aBoolean){
var self=this;
return $core.withContext(function($ctx1) {

		if(self == true) {
		return true;
		} else {
		return aBoolean;
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"|",{aBoolean:aBoolean},$globals.Boolean)});
},
args: ["aBoolean"],
source: "| aBoolean\x0a\x09<\x0a\x09\x09if(self == true) {\x0a\x09\x09return true;\x0a\x09\x09} else {\x0a\x09\x09return aBoolean;\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Boolean);



$core.addClass('Date', $globals.Object, [], 'Kernel-Objects');
$globals.Date.comment="I am used to work with both dates and times. Therefore `Date today` and `Date now` are both valid in\x0aAmber and answer the same date object.\x0a\x0aDate directly maps to the `Date()` JavaScript constructor, and Amber date objects are JavaScript date objects.\x0a\x0a## API\x0a\x0aThe class-side `instance creation` protocol contains some convenience methods for creating date/time objects such as `#fromSeconds:`.\x0a\x0aArithmetic and comparison is supported (see the `comparing` and `arithmetic` protocols).\x0a\x0aThe `converting` protocol provides convenience methods for various convertions (to numbers, strings, etc.).";
$core.addMethod(
$core.method({
selector: "+",
protocol: 'arithmetic',
fn: function (aDate){
var self=this;
return $core.withContext(function($ctx1) {
return self + aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,"+",{aDate:aDate},$globals.Date)});
},
args: ["aDate"],
source: "+ aDate\x0a\x09<return self + aDate>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "-",
protocol: 'arithmetic',
fn: function (aDate){
var self=this;
return $core.withContext(function($ctx1) {
return self - aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,"-",{aDate:aDate},$globals.Date)});
},
args: ["aDate"],
source: "- aDate\x0a\x09<return self - aDate>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "<",
protocol: 'comparing',
fn: function (aDate){
var self=this;
return $core.withContext(function($ctx1) {
return self < aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,"<",{aDate:aDate},$globals.Date)});
},
args: ["aDate"],
source: "< aDate\x0a\x09<return self < aDate>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "<=",
protocol: 'comparing',
fn: function (aDate){
var self=this;
return $core.withContext(function($ctx1) {
return self <= aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,"<=",{aDate:aDate},$globals.Date)});
},
args: ["aDate"],
source: "<= aDate\x0a\x09<return self <= aDate>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "=",
protocol: 'comparing',
fn: function (aDate){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3;
$2=$recv(aDate)._class();
$ctx1.sendIdx["class"]=1;
$1=$recv($2).__eq_eq(self._class());
$ctx1.sendIdx["=="]=1;
return $recv($1)._and_((function(){
return $core.withContext(function($ctx2) {
$3=self._asMilliseconds();
$ctx2.sendIdx["asMilliseconds"]=1;
return $recv($3).__eq_eq($recv(aDate)._asMilliseconds());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"=",{aDate:aDate},$globals.Date)});
},
args: ["aDate"],
source: "= aDate\x0a\x09^ (aDate class == self class) and: [ self asMilliseconds == aDate asMilliseconds ]",
referencedClasses: [],
messageSends: ["and:", "==", "class", "asMilliseconds"]
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: ">",
protocol: 'comparing',
fn: function (aDate){
var self=this;
return $core.withContext(function($ctx1) {
return self > aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,">",{aDate:aDate},$globals.Date)});
},
args: ["aDate"],
source: "> aDate\x0a\x09<return self >> aDate>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: ">=",
protocol: 'comparing',
fn: function (aDate){
var self=this;
return $core.withContext(function($ctx1) {
return self >= aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,">=",{aDate:aDate},$globals.Date)});
},
args: ["aDate"],
source: ">= aDate\x0a\x09<return self >>= aDate>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asDateString",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.toDateString();
return self;
}, function($ctx1) {$ctx1.fill(self,"asDateString",{},$globals.Date)});
},
args: [],
source: "asDateString\x0a\x09<return self.toDateString()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asLocaleString",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.toLocaleString();
return self;
}, function($ctx1) {$ctx1.fill(self,"asLocaleString",{},$globals.Date)});
},
args: [],
source: "asLocaleString\x0a\x09<return self.toLocaleString()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asMilliseconds",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._time();
}, function($ctx1) {$ctx1.fill(self,"asMilliseconds",{},$globals.Date)});
},
args: [],
source: "asMilliseconds\x0a\x09^ self time",
referencedClasses: [],
messageSends: ["time"]
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asNumber",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._asMilliseconds();
}, function($ctx1) {$ctx1.fill(self,"asNumber",{},$globals.Date)});
},
args: [],
source: "asNumber\x0a\x09^ self asMilliseconds",
referencedClasses: [],
messageSends: ["asMilliseconds"]
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asString",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.toString();
return self;
}, function($ctx1) {$ctx1.fill(self,"asString",{},$globals.Date)});
},
args: [],
source: "asString\x0a\x09<return self.toString()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asTimeString",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.toTimeString();
return self;
}, function($ctx1) {$ctx1.fill(self,"asTimeString",{},$globals.Date)});
},
args: [],
source: "asTimeString\x0a\x09<return self.toTimeString()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "day",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._dayOfWeek();
}, function($ctx1) {$ctx1.fill(self,"day",{},$globals.Date)});
},
args: [],
source: "day\x0a\x09^ self dayOfWeek",
referencedClasses: [],
messageSends: ["dayOfWeek"]
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "day:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
self._dayOfWeek_(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"day:",{aNumber:aNumber},$globals.Date)});
},
args: ["aNumber"],
source: "day: aNumber\x0a\x09self dayOfWeek: aNumber",
referencedClasses: [],
messageSends: ["dayOfWeek:"]
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "dayOfMonth",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.getDate();
return self;
}, function($ctx1) {$ctx1.fill(self,"dayOfMonth",{},$globals.Date)});
},
args: [],
source: "dayOfMonth\x0a\x09<return self.getDate()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "dayOfMonth:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
self.setDate(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"dayOfMonth:",{aNumber:aNumber},$globals.Date)});
},
args: ["aNumber"],
source: "dayOfMonth: aNumber\x0a\x09<self.setDate(aNumber)>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "dayOfWeek",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.getDay() + 1;
return self;
}, function($ctx1) {$ctx1.fill(self,"dayOfWeek",{},$globals.Date)});
},
args: [],
source: "dayOfWeek\x0a\x09<return self.getDay() + 1>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "dayOfWeek:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self.setDay(aNumber - 1);
return self;
}, function($ctx1) {$ctx1.fill(self,"dayOfWeek:",{aNumber:aNumber},$globals.Date)});
},
args: ["aNumber"],
source: "dayOfWeek: aNumber\x0a\x09<return self.setDay(aNumber - 1)>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "hours",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.getHours();
return self;
}, function($ctx1) {$ctx1.fill(self,"hours",{},$globals.Date)});
},
args: [],
source: "hours\x0a\x09<return self.getHours()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "hours:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
self.setHours(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"hours:",{aNumber:aNumber},$globals.Date)});
},
args: ["aNumber"],
source: "hours: aNumber\x0a\x09<self.setHours(aNumber)>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "milliseconds",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.getMilliseconds();
return self;
}, function($ctx1) {$ctx1.fill(self,"milliseconds",{},$globals.Date)});
},
args: [],
source: "milliseconds\x0a\x09<return self.getMilliseconds()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "milliseconds:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
self.setMilliseconds(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"milliseconds:",{aNumber:aNumber},$globals.Date)});
},
args: ["aNumber"],
source: "milliseconds: aNumber\x0a\x09<self.setMilliseconds(aNumber)>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "minutes",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.getMinutes();
return self;
}, function($ctx1) {$ctx1.fill(self,"minutes",{},$globals.Date)});
},
args: [],
source: "minutes\x0a\x09<return self.getMinutes()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "minutes:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
self.setMinutes(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"minutes:",{aNumber:aNumber},$globals.Date)});
},
args: ["aNumber"],
source: "minutes: aNumber\x0a\x09<self.setMinutes(aNumber)>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "month",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.getMonth() + 1;
return self;
}, function($ctx1) {$ctx1.fill(self,"month",{},$globals.Date)});
},
args: [],
source: "month\x0a\x09<return self.getMonth() + 1>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "month:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
self.setMonth(aNumber - 1);
return self;
}, function($ctx1) {$ctx1.fill(self,"month:",{aNumber:aNumber},$globals.Date)});
},
args: ["aNumber"],
source: "month: aNumber\x0a\x09<self.setMonth(aNumber - 1)>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_(self._asString());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Date)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: self asString",
referencedClasses: [],
messageSends: ["nextPutAll:", "asString"]
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "seconds",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.getSeconds();
return self;
}, function($ctx1) {$ctx1.fill(self,"seconds",{},$globals.Date)});
},
args: [],
source: "seconds\x0a\x09<return self.getSeconds()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "seconds:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
self.setSeconds(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"seconds:",{aNumber:aNumber},$globals.Date)});
},
args: ["aNumber"],
source: "seconds: aNumber\x0a\x09<self.setSeconds(aNumber)>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "time",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.getTime();
return self;
}, function($ctx1) {$ctx1.fill(self,"time",{},$globals.Date)});
},
args: [],
source: "time\x0a\x09<return self.getTime()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "time:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
self.setTime(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"time:",{aNumber:aNumber},$globals.Date)});
},
args: ["aNumber"],
source: "time: aNumber\x0a\x09<self.setTime(aNumber)>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "year",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.getFullYear();
return self;
}, function($ctx1) {$ctx1.fill(self,"year",{},$globals.Date)});
},
args: [],
source: "year\x0a\x09<return self.getFullYear()>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "year:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
self.setFullYear(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"year:",{aNumber:aNumber},$globals.Date)});
},
args: ["aNumber"],
source: "year: aNumber\x0a\x09<self.setFullYear(aNumber)>",
referencedClasses: [],
messageSends: []
}),
$globals.Date);


$core.addMethod(
$core.method({
selector: "classTag",
protocol: 'accessing',
fn: function (){
var self=this;
return "magnitude";

},
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'magnitude'",
referencedClasses: [],
messageSends: []
}),
$globals.Date.klass);

$core.addMethod(
$core.method({
selector: "fromMilliseconds:",
protocol: 'instance creation',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self._new_(aNumber);
}, function($ctx1) {$ctx1.fill(self,"fromMilliseconds:",{aNumber:aNumber},$globals.Date.klass)});
},
args: ["aNumber"],
source: "fromMilliseconds: aNumber\x0a\x09^ self new: aNumber",
referencedClasses: [],
messageSends: ["new:"]
}),
$globals.Date.klass);

$core.addMethod(
$core.method({
selector: "fromSeconds:",
protocol: 'instance creation',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self._fromMilliseconds_($recv(aNumber).__star((1000)));
}, function($ctx1) {$ctx1.fill(self,"fromSeconds:",{aNumber:aNumber},$globals.Date.klass)});
},
args: ["aNumber"],
source: "fromSeconds: aNumber\x0a\x09^ self fromMilliseconds: aNumber * 1000",
referencedClasses: [],
messageSends: ["fromMilliseconds:", "*"]
}),
$globals.Date.klass);

$core.addMethod(
$core.method({
selector: "fromString:",
protocol: 'instance creation',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self._new_(aString);
}, function($ctx1) {$ctx1.fill(self,"fromString:",{aString:aString},$globals.Date.klass)});
},
args: ["aString"],
source: "fromString: aString\x0a\x09\x22Example: Date fromString('2011/04/15 00:00:00')\x22\x0a\x09^ self new: aString",
referencedClasses: [],
messageSends: ["new:"]
}),
$globals.Date.klass);

$core.addMethod(
$core.method({
selector: "millisecondsToRun:",
protocol: 'instance creation',
fn: function (aBlock){
var self=this;
var t;
return $core.withContext(function($ctx1) {
t=$recv($globals.Date)._now();
$ctx1.sendIdx["now"]=1;
$recv(aBlock)._value();
return $recv($recv($globals.Date)._now()).__minus(t);
}, function($ctx1) {$ctx1.fill(self,"millisecondsToRun:",{aBlock:aBlock,t:t},$globals.Date.klass)});
},
args: ["aBlock"],
source: "millisecondsToRun: aBlock\x0a\x09| t |\x0a\x09t := Date now.\x0a\x09aBlock value.\x0a\x09^ Date now - t",
referencedClasses: ["Date"],
messageSends: ["now", "value", "-"]
}),
$globals.Date.klass);

$core.addMethod(
$core.method({
selector: "new:",
protocol: 'instance creation',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return new Date(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"new:",{anObject:anObject},$globals.Date.klass)});
},
args: ["anObject"],
source: "new: anObject\x0a\x09<return new Date(anObject)>",
referencedClasses: [],
messageSends: []
}),
$globals.Date.klass);

$core.addMethod(
$core.method({
selector: "now",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._today();
}, function($ctx1) {$ctx1.fill(self,"now",{},$globals.Date.klass)});
},
args: [],
source: "now\x0a\x09^ self today",
referencedClasses: [],
messageSends: ["today"]
}),
$globals.Date.klass);

$core.addMethod(
$core.method({
selector: "today",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._new();
}, function($ctx1) {$ctx1.fill(self,"today",{},$globals.Date.klass)});
},
args: [],
source: "today\x0a\x09^ self new",
referencedClasses: [],
messageSends: ["new"]
}),
$globals.Date.klass);


$core.addClass('Number', $globals.Object, [], 'Kernel-Objects');
$globals.Number.comment="I am the Amber representation for all numbers.\x0aI am directly mapped to JavaScript Number.\x0a\x0a## API\x0a\x0aI provide all necessary methods for arithmetic operations, comparison, conversion and so on with numbers.\x0a\x0aMy instances can also be used to evaluate a block a fixed number of times:\x0a\x0a\x095 timesRepeat: [ Transcript show: 'This will be printed 5 times'; cr ].\x0a\x09\x0a\x091 to: 5 do: [ :aNumber| Transcript show: aNumber asString; cr ].\x0a\x09\x0a\x091 to: 10 by: 2 do: [ :aNumber| Transcript show: aNumber asString; cr ].";
$core.addMethod(
$core.method({
selector: "&",
protocol: 'converting',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self & aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,"&",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "& aNumber\x0a\x09<return self & aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "*",
protocol: 'arithmetic',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self * aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,"*",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "* aNumber\x0a\x09\x22Inlined in the Compiler\x22\x0a\x09<return self * aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "**",
protocol: 'mathematical functions',
fn: function (exponent){
var self=this;
return $core.withContext(function($ctx1) {
return self._raisedTo_(exponent);
}, function($ctx1) {$ctx1.fill(self,"**",{exponent:exponent},$globals.Number)});
},
args: ["exponent"],
source: "** exponent\x0a\x09^ self raisedTo: exponent",
referencedClasses: [],
messageSends: ["raisedTo:"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "+",
protocol: 'arithmetic',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self + aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,"+",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "+ aNumber\x0a\x09\x22Inlined in the Compiler\x22\x0a\x09<return self + aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "-",
protocol: 'arithmetic',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self - aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,"-",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "- aNumber\x0a\x09\x22Inlined in the Compiler\x22\x0a\x09<return self - aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "/",
protocol: 'arithmetic',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self / aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,"/",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "/ aNumber\x0a\x09\x22Inlined in the Compiler\x22\x0a\x09<return self / aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "//",
protocol: 'arithmetic',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self.__slash(aNumber))._floor();
}, function($ctx1) {$ctx1.fill(self,"//",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "// aNumber\x0a\x09^ (self / aNumber) floor",
referencedClasses: [],
messageSends: ["floor", "/"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "<",
protocol: 'comparing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self < aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,"<",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "< aNumber\x0a\x09\x22Inlined in the Compiler\x22\x0a\x09<return self < aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "<=",
protocol: 'comparing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self <= aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,"<=",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "<= aNumber\x0a\x09\x22Inlined in the Compiler\x22\x0a\x09<return self <= aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "==",
protocol: 'comparing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {

	if (typeof aNumber === "number") return Number(self) === aNumber;
	else if (aNumber != null && typeof aNumber === "object") return Number(self) === aNumber.valueOf();
	else return false;;
return self;
}, function($ctx1) {$ctx1.fill(self,"==",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "== aNumber\x0a<\x0a\x09if (typeof aNumber === \x22number\x22) return Number(self) === aNumber;\x0a\x09else if (aNumber != null && typeof aNumber === \x22object\x22) return Number(self) === aNumber.valueOf();\x0a\x09else return false;\x0a>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: ">",
protocol: 'comparing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self > aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,">",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "> aNumber\x0a\x09\x22Inlined in the Compiler\x22\x0a\x09<return self >> aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: ">=",
protocol: 'comparing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self >= aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,">=",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: ">= aNumber\x0a\x09\x22Inlined in the Compiler\x22\x0a\x09<return self >>= aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "@",
protocol: 'converting',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Point)._x_y_(self,aNumber);
}, function($ctx1) {$ctx1.fill(self,"@",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "@ aNumber\x0a\x09^ Point x: self y: aNumber",
referencedClasses: ["Point"],
messageSends: ["x:y:"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "\x5c\x5c",
protocol: 'arithmetic',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self % aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,"\x5c\x5c",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "\x5c\x5c aNumber\x0a\x09<return self % aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "abs",
protocol: 'arithmetic',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.abs(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"abs",{},$globals.Number)});
},
args: [],
source: "abs\x0a\x09<return Math.abs(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "arcCos",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.acos(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"arcCos",{},$globals.Number)});
},
args: [],
source: "arcCos\x0a\x09<return Math.acos(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "arcSin",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.asin(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"arcSin",{},$globals.Number)});
},
args: [],
source: "arcSin\x0a\x09<return Math.asin(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "arcTan",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.atan(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"arcTan",{},$globals.Number)});
},
args: [],
source: "arcTan\x0a\x09<return Math.atan(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "asJSON",
protocol: 'converting',
fn: function (){
var self=this;
return self;

},
args: [],
source: "asJSON\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "asJavascript",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv("(".__comma(self._printString())).__comma(")");
$ctx1.sendIdx[","]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"asJavascript",{},$globals.Number)});
},
args: [],
source: "asJavascript\x0a\x09^ '(', self printString, ')'",
referencedClasses: [],
messageSends: [",", "printString"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "asNumber",
protocol: 'converting',
fn: function (){
var self=this;
return self;

},
args: [],
source: "asNumber\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "asPoint",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Point)._x_y_(self,self);
}, function($ctx1) {$ctx1.fill(self,"asPoint",{},$globals.Number)});
},
args: [],
source: "asPoint\x0a\x09^ Point x: self y: self",
referencedClasses: ["Point"],
messageSends: ["x:y:"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "asString",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
 return String(self) ;
return self;
}, function($ctx1) {$ctx1.fill(self,"asString",{},$globals.Number)});
},
args: [],
source: "asString\x0a\x09< return String(self) >",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "atRandom",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv($recv($recv($globals.Random)._new())._next()).__star(self))._truncated()).__plus((1));
}, function($ctx1) {$ctx1.fill(self,"atRandom",{},$globals.Number)});
},
args: [],
source: "atRandom\x0a\x09^ (Random new next * self) truncated + 1",
referencedClasses: ["Random"],
messageSends: ["+", "truncated", "*", "next", "new"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "ceiling",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.ceil(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"ceiling",{},$globals.Number)});
},
args: [],
source: "ceiling\x0a\x09<return Math.ceil(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "copy",
protocol: 'copying',
fn: function (){
var self=this;
return self;

},
args: [],
source: "copy\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "cos",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.cos(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"cos",{},$globals.Number)});
},
args: [],
source: "cos\x0a\x09<return Math.cos(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: 'copying',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._copy();
}, function($ctx1) {$ctx1.fill(self,"deepCopy",{},$globals.Number)});
},
args: [],
source: "deepCopy\x0a\x09^ self copy",
referencedClasses: [],
messageSends: ["copy"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "even",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return (0).__eq(self.__backslash_backslash((2)));
}, function($ctx1) {$ctx1.fill(self,"even",{},$globals.Number)});
},
args: [],
source: "even\x0a\x09^ 0 = (self \x5c\x5c 2)",
referencedClasses: [],
messageSends: ["=", "\x5c\x5c"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "floor",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.floor(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"floor",{},$globals.Number)});
},
args: [],
source: "floor\x0a\x09<return Math.floor(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isNumber",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isNumber\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isZero",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.__eq((0));
}, function($ctx1) {$ctx1.fill(self,"isZero",{},$globals.Number)});
},
args: [],
source: "isZero\x0a\x09^ self = 0",
referencedClasses: [],
messageSends: ["="]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "ln",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.log(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"ln",{},$globals.Number)});
},
args: [],
source: "ln\x0a\x09<return Math.log(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "log",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.log(self) / Math.LN10;;
return self;
}, function($ctx1) {$ctx1.fill(self,"log",{},$globals.Number)});
},
args: [],
source: "log\x0a\x09<return Math.log(self) / Math.LN10;>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "log:",
protocol: 'mathematical functions',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return Math.log(self) / Math.log(aNumber);;
return self;
}, function($ctx1) {$ctx1.fill(self,"log:",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "log: aNumber\x0a\x09<return Math.log(self) / Math.log(aNumber);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "max:",
protocol: 'arithmetic',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return Math.max(self, aNumber);;
return self;
}, function($ctx1) {$ctx1.fill(self,"max:",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "max: aNumber\x0a\x09<return Math.max(self, aNumber);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "min:",
protocol: 'arithmetic',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return Math.min(self, aNumber);;
return self;
}, function($ctx1) {$ctx1.fill(self,"min:",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "min: aNumber\x0a\x09<return Math.min(self, aNumber);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "negated",
protocol: 'arithmetic',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return (0).__minus(self);
}, function($ctx1) {$ctx1.fill(self,"negated",{},$globals.Number)});
},
args: [],
source: "negated\x0a\x09^ 0 - self",
referencedClasses: [],
messageSends: ["-"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "negative",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.__lt((0));
}, function($ctx1) {$ctx1.fill(self,"negative",{},$globals.Number)});
},
args: [],
source: "negative\x0a\x09\x22Answer whether the receiver is mathematically negative.\x22\x0a\x0a\x09^ self < 0",
referencedClasses: [],
messageSends: ["<"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "odd",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._even())._not();
}, function($ctx1) {$ctx1.fill(self,"odd",{},$globals.Number)});
},
args: [],
source: "odd\x0a\x09^ self even not",
referencedClasses: [],
messageSends: ["not", "even"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "positive",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.__gt_eq((0));
}, function($ctx1) {$ctx1.fill(self,"positive",{},$globals.Number)});
},
args: [],
source: "positive\x0a\x09\x22Answer whether the receiver is positive or equal to 0. (ST-80 protocol).\x22\x0a\x0a\x09^ self >= 0",
referencedClasses: [],
messageSends: [">="]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_(self._asString());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Number)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: self asString",
referencedClasses: [],
messageSends: ["nextPutAll:", "asString"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "printShowingDecimalPlaces:",
protocol: 'printing',
fn: function (placesDesired){
var self=this;
return $core.withContext(function($ctx1) {
return self.toFixed(placesDesired);
return self;
}, function($ctx1) {$ctx1.fill(self,"printShowingDecimalPlaces:",{placesDesired:placesDesired},$globals.Number)});
},
args: ["placesDesired"],
source: "printShowingDecimalPlaces: placesDesired\x0a\x09<return self.toFixed(placesDesired)>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "raisedTo:",
protocol: 'mathematical functions',
fn: function (exponent){
var self=this;
return $core.withContext(function($ctx1) {
return Math.pow(self, exponent);;
return self;
}, function($ctx1) {$ctx1.fill(self,"raisedTo:",{exponent:exponent},$globals.Number)});
},
args: ["exponent"],
source: "raisedTo: exponent\x0a\x09<return Math.pow(self, exponent);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "rounded",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.round(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"rounded",{},$globals.Number)});
},
args: [],
source: "rounded\x0a\x09<return Math.round(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "sign",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=self._isZero();
if($core.assert($1)){
return (0);
};
$2=self._positive();
if($core.assert($2)){
return (1);
} else {
return (-1);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"sign",{},$globals.Number)});
},
args: [],
source: "sign\x0a\x09self isZero \x0a\x09\x09ifTrue: [ ^ 0 ].\x0a\x09self positive\x0a\x09\x09ifTrue: [ ^ 1 ]\x0a\x09\x09ifFalse: [ ^ -1 ].",
referencedClasses: [],
messageSends: ["ifTrue:", "isZero", "ifTrue:ifFalse:", "positive"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "sin",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.sin(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"sin",{},$globals.Number)});
},
args: [],
source: "sin\x0a\x09<return Math.sin(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "sqrt",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.sqrt(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"sqrt",{},$globals.Number)});
},
args: [],
source: "sqrt\x0a\x09<return Math.sqrt(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "squared",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.__star(self);
}, function($ctx1) {$ctx1.fill(self,"squared",{},$globals.Number)});
},
args: [],
source: "squared\x0a\x09^ self * self",
referencedClasses: [],
messageSends: ["*"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "tan",
protocol: 'mathematical functions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.tan(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"tan",{},$globals.Number)});
},
args: [],
source: "tan\x0a\x09<return Math.tan(self);>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "timesRepeat:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
var count;
return $core.withContext(function($ctx1) {
count=(1);
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(count).__gt(self);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value();
count=$recv(count).__plus((1));
return count;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"timesRepeat:",{aBlock:aBlock,count:count},$globals.Number)});
},
args: ["aBlock"],
source: "timesRepeat: aBlock\x0a\x09| count |\x0a\x09count := 1.\x0a\x09[ count > self ] whileFalse: [\x0a\x09\x09aBlock value.\x0a\x09\x09count := count + 1 ]",
referencedClasses: [],
messageSends: ["whileFalse:", ">", "value", "+"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "to:",
protocol: 'converting',
fn: function (aNumber){
var self=this;
var array,first,last,count;
return $core.withContext(function($ctx1) {
first=self._truncated();
$ctx1.sendIdx["truncated"]=1;
last=$recv($recv(aNumber)._truncated()).__plus((1));
$ctx1.sendIdx["+"]=1;
count=(1);
array=$recv($globals.Array)._new();
$recv($recv(last).__minus(first))._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
$recv(array)._at_put_(count,first);
count=$recv(count).__plus((1));
$ctx2.sendIdx["+"]=2;
count;
first=$recv(first).__plus((1));
return first;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return array;
}, function($ctx1) {$ctx1.fill(self,"to:",{aNumber:aNumber,array:array,first:first,last:last,count:count},$globals.Number)});
},
args: ["aNumber"],
source: "to: aNumber\x0a\x09| array first last count |\x0a\x09first := self truncated.\x0a\x09last := aNumber truncated + 1.\x0a\x09count := 1.\x0a\x09array := Array new.\x0a\x09(last - first) timesRepeat: [\x0a\x09\x09array at: count put: first.\x0a\x09\x09count := count + 1.\x0a\x09\x09first := first + 1 ].\x0a\x09^ array",
referencedClasses: ["Array"],
messageSends: ["truncated", "+", "new", "timesRepeat:", "-", "at:put:"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "to:by:",
protocol: 'converting',
fn: function (stop,step){
var self=this;
var array,value,pos;
return $core.withContext(function($ctx1) {
var $1,$2;
value=self;
array=$recv($globals.Array)._new();
pos=(1);
$1=$recv(step).__eq((0));
if($core.assert($1)){
self._error_("step must be non-zero");
};
$2=$recv(step).__lt((0));
if($core.assert($2)){
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(value).__gt_eq(stop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
$recv(array)._at_put_(pos,value);
$ctx2.sendIdx["at:put:"]=1;
pos=$recv(pos).__plus((1));
$ctx2.sendIdx["+"]=1;
pos;
value=$recv(value).__plus(step);
$ctx2.sendIdx["+"]=2;
return value;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}));
$ctx1.sendIdx["whileTrue:"]=1;
} else {
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(value).__lt_eq(stop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,6)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
$recv(array)._at_put_(pos,value);
pos=$recv(pos).__plus((1));
$ctx2.sendIdx["+"]=3;
pos;
value=$recv(value).__plus(step);
return value;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,7)});
}));
};
return array;
}, function($ctx1) {$ctx1.fill(self,"to:by:",{stop:stop,step:step,array:array,value:value,pos:pos},$globals.Number)});
},
args: ["stop", "step"],
source: "to: stop by: step\x0a\x09| array value pos |\x0a\x09value := self.\x0a\x09array := Array new.\x0a\x09pos := 1.\x0a\x09step = 0 ifTrue: [ self error: 'step must be non-zero' ].\x0a\x09step < 0\x0a\x09\x09ifTrue: [ [ value >= stop ] whileTrue: [\x0a\x09\x09\x09\x09\x09array at: pos put: value.\x0a\x09\x09\x09\x09\x09pos := pos + 1.\x0a\x09\x09\x09\x09\x09value := value + step ]]\x0a\x09\x09ifFalse: [ [ value <= stop ] whileTrue: [\x0a\x09\x09\x09\x09\x09array at: pos put: value.\x0a\x09\x09\x09\x09pos := pos + 1.\x0a\x09\x09\x09\x09\x09value := value + step ]].\x0a\x09^ array",
referencedClasses: ["Array"],
messageSends: ["new", "ifTrue:", "=", "error:", "ifTrue:ifFalse:", "<", "whileTrue:", ">=", "at:put:", "+", "<="]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "to:by:do:",
protocol: 'enumerating',
fn: function (stop,step,aBlock){
var self=this;
var value;
return $core.withContext(function($ctx1) {
var $1,$2;
value=self;
$1=$recv(step).__eq((0));
if($core.assert($1)){
self._error_("step must be non-zero");
};
$2=$recv(step).__lt((0));
if($core.assert($2)){
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(value).__gt_eq(stop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value_(value);
$ctx2.sendIdx["value:"]=1;
value=$recv(value).__plus(step);
$ctx2.sendIdx["+"]=1;
return value;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}));
$ctx1.sendIdx["whileTrue:"]=1;
} else {
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(value).__lt_eq(stop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,6)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value_(value);
value=$recv(value).__plus(step);
return value;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,7)});
}));
};
return self;
}, function($ctx1) {$ctx1.fill(self,"to:by:do:",{stop:stop,step:step,aBlock:aBlock,value:value},$globals.Number)});
},
args: ["stop", "step", "aBlock"],
source: "to: stop by: step do: aBlock\x0a\x09| value |\x0a\x09value := self.\x0a\x09step = 0 ifTrue: [ self error: 'step must be non-zero' ].\x0a\x09step < 0\x0a\x09\x09ifTrue: [ [ value >= stop ] whileTrue: [\x0a\x09\x09\x09\x09\x09aBlock value: value.\x0a\x09\x09\x09\x09\x09value := value + step ]]\x0a\x09\x09ifFalse: [ [ value <= stop ] whileTrue: [\x0a\x09\x09\x09\x09\x09aBlock value: value.\x0a\x09\x09\x09\x09\x09value := value + step ]]",
referencedClasses: [],
messageSends: ["ifTrue:", "=", "error:", "ifTrue:ifFalse:", "<", "whileTrue:", ">=", "value:", "+", "<="]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "to:do:",
protocol: 'enumerating',
fn: function (stop,aBlock){
var self=this;
var nextValue;
return $core.withContext(function($ctx1) {
nextValue=self;
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(nextValue).__lt_eq(stop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value_(nextValue);
nextValue=$recv(nextValue).__plus((1));
return nextValue;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"to:do:",{stop:stop,aBlock:aBlock,nextValue:nextValue},$globals.Number)});
},
args: ["stop", "aBlock"],
source: "to: stop do: aBlock\x0a\x09\x22Evaluate aBlock for each number from self to aNumber.\x22\x0a\x09| nextValue |\x0a\x09nextValue := self.\x0a\x09[ nextValue <= stop ]\x0a\x09\x09whileTrue:\x0a\x09\x09\x09[ aBlock value: nextValue.\x0a\x09\x09\x09nextValue := nextValue + 1 ]",
referencedClasses: [],
messageSends: ["whileTrue:", "<=", "value:", "+"]
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "truncated",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		if(self >= 0) {
			return Math.floor(self);
		} else {
			return Math.floor(self * (-1)) * (-1);
		};
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"truncated",{},$globals.Number)});
},
args: [],
source: "truncated\x0a\x09<\x0a\x09\x09if(self >>= 0) {\x0a\x09\x09\x09return Math.floor(self);\x0a\x09\x09} else {\x0a\x09\x09\x09return Math.floor(self * (-1)) * (-1);\x0a\x09\x09};\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);

$core.addMethod(
$core.method({
selector: "|",
protocol: 'converting',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
return self | aNumber;
return self;
}, function($ctx1) {$ctx1.fill(self,"|",{aNumber:aNumber},$globals.Number)});
},
args: ["aNumber"],
source: "| aNumber\x0a\x09<return self | aNumber>",
referencedClasses: [],
messageSends: []
}),
$globals.Number);


$core.addMethod(
$core.method({
selector: "classTag",
protocol: 'accessing',
fn: function (){
var self=this;
return "magnitude";

},
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'magnitude'",
referencedClasses: [],
messageSends: []
}),
$globals.Number.klass);

$core.addMethod(
$core.method({
selector: "e",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.E;;
return self;
}, function($ctx1) {$ctx1.fill(self,"e",{},$globals.Number.klass)});
},
args: [],
source: "e\x0a\x09<return Math.E;>",
referencedClasses: [],
messageSends: []
}),
$globals.Number.klass);

$core.addMethod(
$core.method({
selector: "pi",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.PI;
return self;
}, function($ctx1) {$ctx1.fill(self,"pi",{},$globals.Number.klass)});
},
args: [],
source: "pi\x0a\x09<return Math.PI>",
referencedClasses: [],
messageSends: []
}),
$globals.Number.klass);


$core.addClass('Point', $globals.Object, ['x', 'y'], 'Kernel-Objects');
$globals.Point.comment="I represent an x-y pair of numbers usually designating a geometric coordinate.\x0a\x0a## API\x0a\x0aInstances are traditionally created using the binary `#@` message to a number:\x0a\x0a\x09100@120\x0a\x0aPoints can then be arithmetically manipulated:\x0a\x0a\x09100@100 + (10@10)\x0a\x0a...or for example:\x0a\x0a\x09(100@100) * 2\x0a\x0a**NOTE:** Creating a point with a negative y-value will need a space after `@` in order to avoid a parsing error:\x0a\x0a\x09100@ -100 \x22but 100@-100 would not parse\x22";
$core.addMethod(
$core.method({
selector: "*",
protocol: 'arithmetic',
fn: function (aPoint){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$4,$3,$1,$6,$5;
$2=self._x();
$ctx1.sendIdx["x"]=1;
$4=$recv(aPoint)._asPoint();
$ctx1.sendIdx["asPoint"]=1;
$3=$recv($4)._x();
$1=$recv($2).__star($3);
$ctx1.sendIdx["*"]=1;
$6=self._y();
$ctx1.sendIdx["y"]=1;
$5=$recv($6).__star($recv($recv(aPoint)._asPoint())._y());
return $recv($globals.Point)._x_y_($1,$5);
}, function($ctx1) {$ctx1.fill(self,"*",{aPoint:aPoint},$globals.Point)});
},
args: ["aPoint"],
source: "* aPoint\x0a\x09^ Point x: self x * aPoint asPoint x y: self y * aPoint asPoint y",
referencedClasses: ["Point"],
messageSends: ["x:y:", "*", "x", "asPoint", "y"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "+",
protocol: 'arithmetic',
fn: function (aPoint){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$4,$3,$1,$6,$5;
$2=self._x();
$ctx1.sendIdx["x"]=1;
$4=$recv(aPoint)._asPoint();
$ctx1.sendIdx["asPoint"]=1;
$3=$recv($4)._x();
$1=$recv($2).__plus($3);
$ctx1.sendIdx["+"]=1;
$6=self._y();
$ctx1.sendIdx["y"]=1;
$5=$recv($6).__plus($recv($recv(aPoint)._asPoint())._y());
return $recv($globals.Point)._x_y_($1,$5);
}, function($ctx1) {$ctx1.fill(self,"+",{aPoint:aPoint},$globals.Point)});
},
args: ["aPoint"],
source: "+ aPoint\x0a\x09^ Point x: self x + aPoint asPoint x y: self y + aPoint asPoint y",
referencedClasses: ["Point"],
messageSends: ["x:y:", "+", "x", "asPoint", "y"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "-",
protocol: 'arithmetic',
fn: function (aPoint){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$4,$3,$1,$6,$5;
$2=self._x();
$ctx1.sendIdx["x"]=1;
$4=$recv(aPoint)._asPoint();
$ctx1.sendIdx["asPoint"]=1;
$3=$recv($4)._x();
$1=$recv($2).__minus($3);
$ctx1.sendIdx["-"]=1;
$6=self._y();
$ctx1.sendIdx["y"]=1;
$5=$recv($6).__minus($recv($recv(aPoint)._asPoint())._y());
return $recv($globals.Point)._x_y_($1,$5);
}, function($ctx1) {$ctx1.fill(self,"-",{aPoint:aPoint},$globals.Point)});
},
args: ["aPoint"],
source: "- aPoint\x0a\x09^ Point x: self x - aPoint asPoint x y: self y - aPoint asPoint y",
referencedClasses: ["Point"],
messageSends: ["x:y:", "-", "x", "asPoint", "y"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "/",
protocol: 'arithmetic',
fn: function (aPoint){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$4,$3,$1,$6,$5;
$2=self._x();
$ctx1.sendIdx["x"]=1;
$4=$recv(aPoint)._asPoint();
$ctx1.sendIdx["asPoint"]=1;
$3=$recv($4)._x();
$1=$recv($2).__slash($3);
$ctx1.sendIdx["/"]=1;
$6=self._y();
$ctx1.sendIdx["y"]=1;
$5=$recv($6).__slash($recv($recv(aPoint)._asPoint())._y());
return $recv($globals.Point)._x_y_($1,$5);
}, function($ctx1) {$ctx1.fill(self,"/",{aPoint:aPoint},$globals.Point)});
},
args: ["aPoint"],
source: "/ aPoint\x0a\x09^ Point x: self x / aPoint asPoint x y: self y / aPoint asPoint y",
referencedClasses: ["Point"],
messageSends: ["x:y:", "/", "x", "asPoint", "y"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "<",
protocol: 'comparing',
fn: function (aPoint){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3;
$2=self._x();
$ctx1.sendIdx["x"]=1;
$1=$recv($2).__lt($recv(aPoint)._x());
$ctx1.sendIdx["<"]=1;
return $recv($1)._and_((function(){
return $core.withContext(function($ctx2) {
$3=self._y();
$ctx2.sendIdx["y"]=1;
return $recv($3).__lt($recv(aPoint)._y());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"<",{aPoint:aPoint},$globals.Point)});
},
args: ["aPoint"],
source: "< aPoint\x0a\x09^ self x < aPoint x and: [\x0a\x09\x09self y < aPoint y ]",
referencedClasses: [],
messageSends: ["and:", "<", "x", "y"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "<=",
protocol: 'comparing',
fn: function (aPoint){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3;
$2=self._x();
$ctx1.sendIdx["x"]=1;
$1=$recv($2).__lt_eq($recv(aPoint)._x());
$ctx1.sendIdx["<="]=1;
return $recv($1)._and_((function(){
return $core.withContext(function($ctx2) {
$3=self._y();
$ctx2.sendIdx["y"]=1;
return $recv($3).__lt_eq($recv(aPoint)._y());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"<=",{aPoint:aPoint},$globals.Point)});
},
args: ["aPoint"],
source: "<= aPoint\x0a\x09^ self x <= aPoint x and: [\x0a\x09\x09self y <= aPoint y ]",
referencedClasses: [],
messageSends: ["and:", "<=", "x", "y"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "=",
protocol: 'comparing',
fn: function (aPoint){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$6,$5;
$2=$recv(aPoint)._class();
$ctx1.sendIdx["class"]=1;
$1=$recv($2).__eq(self._class());
$ctx1.sendIdx["="]=1;
return $recv($1)._and_((function(){
return $core.withContext(function($ctx2) {
$4=$recv(aPoint)._x();
$ctx2.sendIdx["x"]=1;
$3=$recv($4).__eq(self._x());
$ctx2.sendIdx["="]=2;
$6=$recv(aPoint)._y();
$ctx2.sendIdx["y"]=1;
$5=$recv($6).__eq(self._y());
return $recv($3).__and($5);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"=",{aPoint:aPoint},$globals.Point)});
},
args: ["aPoint"],
source: "= aPoint\x0a\x09^ aPoint class = self class and: [\x0a\x09\x09(aPoint x = self x) & (aPoint y = self y) ]",
referencedClasses: [],
messageSends: ["and:", "=", "class", "&", "x", "y"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: ">",
protocol: 'comparing',
fn: function (aPoint){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3;
$2=self._x();
$ctx1.sendIdx["x"]=1;
$1=$recv($2).__gt($recv(aPoint)._x());
$ctx1.sendIdx[">"]=1;
return $recv($1)._and_((function(){
return $core.withContext(function($ctx2) {
$3=self._y();
$ctx2.sendIdx["y"]=1;
return $recv($3).__gt($recv(aPoint)._y());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,">",{aPoint:aPoint},$globals.Point)});
},
args: ["aPoint"],
source: "> aPoint\x0a\x09^ self x > aPoint x and: [\x0a\x09\x09self y > aPoint y ]",
referencedClasses: [],
messageSends: ["and:", ">", "x", "y"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: ">=",
protocol: 'comparing',
fn: function (aPoint){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3;
$2=self._x();
$ctx1.sendIdx["x"]=1;
$1=$recv($2).__gt_eq($recv(aPoint)._x());
$ctx1.sendIdx[">="]=1;
return $recv($1)._and_((function(){
return $core.withContext(function($ctx2) {
$3=self._y();
$ctx2.sendIdx["y"]=1;
return $recv($3).__gt_eq($recv(aPoint)._y());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,">=",{aPoint:aPoint},$globals.Point)});
},
args: ["aPoint"],
source: ">= aPoint\x0a\x09^ self x >= aPoint x and: [\x0a\x09\x09self y >= aPoint y ]",
referencedClasses: [],
messageSends: ["and:", ">=", "x", "y"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "asPoint",
protocol: 'converting',
fn: function (){
var self=this;
return self;

},
args: [],
source: "asPoint\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "dist:",
protocol: 'transforming',
fn: function (aPoint){
var self=this;
var dx,dy;
return $core.withContext(function($ctx1) {
var $2,$1;
dx=$recv($recv(aPoint)._x()).__minus(self["@x"]);
$ctx1.sendIdx["-"]=1;
dy=$recv($recv(aPoint)._y()).__minus(self["@y"]);
$2=$recv(dx).__star(dx);
$ctx1.sendIdx["*"]=1;
$1=$recv($2).__plus($recv(dy).__star(dy));
return $recv($1)._sqrt();
}, function($ctx1) {$ctx1.fill(self,"dist:",{aPoint:aPoint,dx:dx,dy:dy},$globals.Point)});
},
args: ["aPoint"],
source: "dist: aPoint \x0a\x09\x22Answer the distance between aPoint and the receiver.\x22\x0a\x09| dx dy |\x0a\x09dx := aPoint x - x.\x0a\x09dy := aPoint y - y.\x0a\x09^ (dx * dx + (dy * dy)) sqrt",
referencedClasses: [],
messageSends: ["-", "x", "y", "sqrt", "+", "*"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(self["@x"])._printOn_(aStream);
$ctx1.sendIdx["printOn:"]=1;
$recv(aStream)._nextPutAll_("@");
$1=$recv($recv(self["@y"])._notNil())._and_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@y"])._negative();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
if($core.assert($1)){
$recv(aStream)._space();
};
$recv(self["@y"])._printOn_(aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Point)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09\x22Print receiver in classic x@y notation.\x22\x0a\x0a\x09x printOn: aStream.\x0a\x09\x0a\x09aStream nextPutAll: '@'.\x0a\x09(y notNil and: [ y negative ]) ifTrue: [\x0a\x09\x09\x09\x22Avoid ambiguous @- construct\x22\x0a\x09\x09\x09aStream space ].\x0a\x09\x0a\x09y printOn: aStream",
referencedClasses: [],
messageSends: ["printOn:", "nextPutAll:", "ifTrue:", "and:", "notNil", "negative", "space"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "translateBy:",
protocol: 'transforming',
fn: function (delta){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv(delta)._x()).__plus(self["@x"]);
$ctx1.sendIdx["+"]=1;
return $recv($1).__at($recv($recv(delta)._y()).__plus(self["@y"]));
}, function($ctx1) {$ctx1.fill(self,"translateBy:",{delta:delta},$globals.Point)});
},
args: ["delta"],
source: "translateBy: delta\x0a\x09\x22Answer a Point translated by delta (an instance of Point).\x22\x0a\x09^ (delta x + x) @ (delta y + y)",
referencedClasses: [],
messageSends: ["@", "+", "x", "y"]
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "x",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@x"];

},
args: [],
source: "x\x0a\x09^ x",
referencedClasses: [],
messageSends: []
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "x:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
self["@x"]=aNumber;
return self;

},
args: ["aNumber"],
source: "x: aNumber\x0a\x09x := aNumber",
referencedClasses: [],
messageSends: []
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "y",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@y"];

},
args: [],
source: "y\x0a\x09^ y",
referencedClasses: [],
messageSends: []
}),
$globals.Point);

$core.addMethod(
$core.method({
selector: "y:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
self["@y"]=aNumber;
return self;

},
args: ["aNumber"],
source: "y: aNumber\x0a\x09y := aNumber",
referencedClasses: [],
messageSends: []
}),
$globals.Point);


$core.addMethod(
$core.method({
selector: "classTag",
protocol: 'accessing',
fn: function (){
var self=this;
return "magnitude";

},
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'magnitude'",
referencedClasses: [],
messageSends: []
}),
$globals.Point.klass);

$core.addMethod(
$core.method({
selector: "x:y:",
protocol: 'instance creation',
fn: function (aNumber,anotherNumber){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._x_(aNumber);
$recv($1)._y_(anotherNumber);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"x:y:",{aNumber:aNumber,anotherNumber:anotherNumber},$globals.Point.klass)});
},
args: ["aNumber", "anotherNumber"],
source: "x: aNumber y: anotherNumber\x0a\x09^ self new\x0a\x09\x09x: aNumber;\x0a\x09\x09y: anotherNumber;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["x:", "new", "y:", "yourself"]
}),
$globals.Point.klass);


$core.addClass('Random', $globals.Object, [], 'Kernel-Objects');
$globals.Random.comment="I an used to generate a random number and I am implemented as a trivial wrapper around javascript `Math.random()`.\x0a\x0a## API\x0a\x0aThe typical use case it to use the `#next` method like the following:\x0a\x0a\x09Random new next\x0a\x0aThis will return a float x where x < 1 and x > 0. If you want a random integer from 1 to 10 you can use `#atRandom`\x0a\x0a\x0910 atRandom\x0a\x0aA random number in a specific interval can be obtained with the following:\x0a\x0a\x09(3 to: 7) atRandom\x0a\x0aBe aware that `#to:` does not create an Interval as in other Smalltalk implementations but in fact an `Array` of numbers, so it's better to use:\x0a\x0a\x095 atRandom + 2\x0a\x0aSince `#atRandom` is implemented in `SequencableCollection` you can easy pick an element at random:\x0a\x0a\x09#('a' 'b' 'c') atRandom\x0a\x0aAs well as letter from a `String`:\x0a\x0a\x09'abc' atRandom\x0a\x0aSince Amber does not have Characters this will return a `String` of length 1 like for example `'b'`.";
$core.addMethod(
$core.method({
selector: "next",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Math.random();
return self;
}, function($ctx1) {$ctx1.fill(self,"next",{},$globals.Random)});
},
args: [],
source: "next\x0a\x09<return Math.random()>",
referencedClasses: [],
messageSends: []
}),
$globals.Random);

$core.addMethod(
$core.method({
selector: "next:",
protocol: 'accessing',
fn: function (anInteger){
var self=this;
return $core.withContext(function($ctx1) {
return $recv((1)._to_(anInteger))._collect_((function(each){
return $core.withContext(function($ctx2) {
return self._next();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"next:",{anInteger:anInteger},$globals.Random)});
},
args: ["anInteger"],
source: "next: anInteger\x0a\x09^ (1 to: anInteger) collect: [ :each | self next ]",
referencedClasses: [],
messageSends: ["collect:", "to:", "next"]
}),
$globals.Random);



$core.addClass('UndefinedObject', $globals.Object, [], 'Kernel-Objects');
$globals.UndefinedObject.comment="I describe the behavior of my sole instance, `nil`. `nil` represents a prior value for variables that have not been initialized, or for results which are meaningless.\x0a\x0a`nil` is the Smalltalk equivalent of the `undefined` JavaScript object.\x0a\x0a__note:__ When sending messages to the `undefined` JavaScript object, it will be replaced by `nil`.";
$core.addMethod(
$core.method({
selector: "asJSON",
protocol: 'converting',
fn: function (){
var self=this;
return null;

},
args: [],
source: "asJSON\x0a\x09^ null",
referencedClasses: [],
messageSends: []
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: 'copying',
fn: function (){
var self=this;
return self;

},
args: [],
source: "deepCopy\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "ifNil:",
protocol: 'testing',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._ifNil_ifNotNil_(aBlock,(function(){

}));
}, function($ctx1) {$ctx1.fill(self,"ifNil:",{aBlock:aBlock},$globals.UndefinedObject)});
},
args: ["aBlock"],
source: "ifNil: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self ifNil: aBlock ifNotNil: []",
referencedClasses: [],
messageSends: ["ifNil:ifNotNil:"]
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "ifNil:ifNotNil:",
protocol: 'testing',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aBlock)._value();
}, function($ctx1) {$ctx1.fill(self,"ifNil:ifNotNil:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.UndefinedObject)});
},
args: ["aBlock", "anotherBlock"],
source: "ifNil: aBlock ifNotNil: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ aBlock value",
referencedClasses: [],
messageSends: ["value"]
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "ifNotNil:",
protocol: 'testing',
fn: function (aBlock){
var self=this;
return self;

},
args: ["aBlock"],
source: "ifNotNil: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "ifNotNil:ifNil:",
protocol: 'testing',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(anotherBlock)._value();
}, function($ctx1) {$ctx1.fill(self,"ifNotNil:ifNil:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.UndefinedObject)});
},
args: ["aBlock", "anotherBlock"],
source: "ifNotNil: aBlock ifNil: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ anotherBlock value",
referencedClasses: [],
messageSends: ["value"]
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "isNil",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isNil\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "notNil",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "notNil\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_("nil");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.UndefinedObject)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: 'nil'",
referencedClasses: [],
messageSends: ["nextPutAll:"]
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: 'copying',
fn: function (){
var self=this;
return self;

},
args: [],
source: "shallowCopy\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:",
protocol: 'class creation',
fn: function (aString,anotherString){
var self=this;
return $core.withContext(function($ctx1) {
return self._subclass_instanceVariableNames_package_(aString,anotherString,nil);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:",{aString:aString,anotherString:anotherString},$globals.UndefinedObject)});
},
args: ["aString", "anotherString"],
source: "subclass: aString instanceVariableNames: anotherString\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString instanceVariableNames: anotherString package: nil",
referencedClasses: [],
messageSends: ["subclass:instanceVariableNames:package:"]
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:category:",
protocol: 'class creation',
fn: function (aString,aString2,aString3){
var self=this;
return $core.withContext(function($ctx1) {
return self._subclass_instanceVariableNames_package_(aString,aString2,aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:category:",{aString:aString,aString2:aString2,aString3:aString3},$globals.UndefinedObject)});
},
args: ["aString", "aString2", "aString3"],
source: "subclass: aString instanceVariableNames: aString2 category: aString3\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString instanceVariableNames: aString2 package: aString3",
referencedClasses: [],
messageSends: ["subclass:instanceVariableNames:package:"]
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
protocol: 'class creation',
fn: function (aString,aString2,classVars,pools,aString3){
var self=this;
return $core.withContext(function($ctx1) {
return self._subclass_instanceVariableNames_package_(aString,aString2,aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",{aString:aString,aString2:aString2,classVars:classVars,pools:pools,aString3:aString3},$globals.UndefinedObject)});
},
args: ["aString", "aString2", "classVars", "pools", "aString3"],
source: "subclass: aString instanceVariableNames: aString2 classVariableNames: classVars poolDictionaries: pools category: aString3\x0a\x09\x22Kept for file-in compatibility. ignores class variables and pools.\x22\x0a\x09^ self subclass: aString instanceVariableNames: aString2 package: aString3",
referencedClasses: [],
messageSends: ["subclass:instanceVariableNames:package:"]
}),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:package:",
protocol: 'class creation',
fn: function (aString,aString2,aString3){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.ClassBuilder)._new())._superclass_subclass_instanceVariableNames_package_(self,$recv(aString)._asString(),aString2,aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:package:",{aString:aString,aString2:aString2,aString3:aString3},$globals.UndefinedObject)});
},
args: ["aString", "aString2", "aString3"],
source: "subclass: aString instanceVariableNames: aString2 package: aString3\x0a\x09^ ClassBuilder new\x0a\x09\x09superclass: self subclass: aString asString instanceVariableNames: aString2 package: aString3",
referencedClasses: ["ClassBuilder"],
messageSends: ["superclass:subclass:instanceVariableNames:package:", "new", "asString"]
}),
$globals.UndefinedObject);


$core.addMethod(
$core.method({
selector: "new",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._error_("You cannot create new instances of UndefinedObject. Use nil");
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{},$globals.UndefinedObject.klass)});
},
args: [],
source: "new\x0a\x09\x09self error: 'You cannot create new instances of UndefinedObject. Use nil'",
referencedClasses: [],
messageSends: ["error:"]
}),
$globals.UndefinedObject.klass);

});

define("amber_core/Kernel-Classes", ["amber/boot", "amber_core/Kernel-Objects"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Kernel-Classes');
$core.packages["Kernel-Classes"].innerEval = function (expr) { return eval(expr); };
$core.packages["Kernel-Classes"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('Behavior', $globals.Object, [], 'Kernel-Classes');
$globals.Behavior.comment="I am the superclass of all class objects.\x0a\x0aI define the protocol for creating instances of a class with `#basicNew` and `#new` (see `boot.js` for class constructors details).\x0a\x0aMy instances know about the subclass/superclass relationships between classes, contain the description that instances are created from,\x0aand hold the method dictionary that's associated with each class.\x0a\x0aI also provides methods for compiling methods, examining the method dictionary, and iterating over the class hierarchy.";
$core.addMethod(
$core.method({
selector: ">>",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self._methodAt_(aString);
}, function($ctx1) {$ctx1.fill(self,">>",{aString:aString},$globals.Behavior)});
},
args: ["aString"],
source: ">> aString\x0a\x09^ self methodAt: aString",
referencedClasses: [],
messageSends: ["methodAt:"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "addCompiledMethod:",
protocol: 'compiling',
fn: function (aMethod){
var self=this;
var oldMethod,announcement;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$4,$5,$6,$7,$8,$9,$10,$receiver;
oldMethod=$recv(self._methodDictionary())._at_ifAbsent_($recv(aMethod)._selector(),(function(){
return nil;

}));
$2=self._protocols();
$3=$recv(aMethod)._protocol();
$ctx1.sendIdx["protocol"]=1;
$1=$recv($2)._includes_($3);
if(!$core.assert($1)){
$4=self._organization();
$5=$recv(aMethod)._protocol();
$ctx1.sendIdx["protocol"]=2;
$recv($4)._addElement_($5);
};
self._basicAddCompiledMethod_(aMethod);
$6=oldMethod;
if(($receiver = $6) == null || $receiver.isNil){
$6;
} else {
self._removeProtocolIfEmpty_($recv(oldMethod)._protocol());
};
$7=oldMethod;
if(($receiver = $7) == null || $receiver.isNil){
$8=$recv($globals.MethodAdded)._new();
$ctx1.sendIdx["new"]=1;
$recv($8)._method_(aMethod);
$ctx1.sendIdx["method:"]=1;
$9=$recv($8)._yourself();
$ctx1.sendIdx["yourself"]=1;
announcement=$9;
} else {
$10=$recv($globals.MethodModified)._new();
$recv($10)._oldMethod_(oldMethod);
$recv($10)._method_(aMethod);
announcement=$recv($10)._yourself();
};
$recv($recv($globals.SystemAnnouncer)._current())._announce_(announcement);
return self;
}, function($ctx1) {$ctx1.fill(self,"addCompiledMethod:",{aMethod:aMethod,oldMethod:oldMethod,announcement:announcement},$globals.Behavior)});
},
args: ["aMethod"],
source: "addCompiledMethod: aMethod\x0a\x09| oldMethod announcement |\x0a\x09\x0a\x09oldMethod := self methodDictionary\x0a\x09\x09at: aMethod selector\x0a\x09\x09ifAbsent: [ nil ].\x0a\x09\x0a\x09(self protocols includes: aMethod protocol)\x0a\x09\x09ifFalse: [ self organization addElement: aMethod protocol ].\x0a\x0a\x09self basicAddCompiledMethod: aMethod.\x0a\x09\x0a\x09oldMethod ifNotNil: [\x0a\x09\x09self removeProtocolIfEmpty: oldMethod protocol ].\x0a\x09\x0a\x09announcement := oldMethod\x0a\x09\x09ifNil: [\x0a\x09\x09\x09MethodAdded new\x0a\x09\x09\x09\x09\x09method: aMethod;\x0a\x09\x09\x09\x09\x09yourself ]\x0a\x09\x09ifNotNil: [\x0a\x09\x09\x09MethodModified new\x0a\x09\x09\x09\x09\x09oldMethod: oldMethod;\x0a\x09\x09\x09\x09\x09method: aMethod;\x0a\x09\x09\x09\x09\x09yourself ].\x0a\x09\x09\x09\x09\x09\x0a\x09\x09\x09\x09\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09\x09\x09announce: announcement",
referencedClasses: ["MethodAdded", "MethodModified", "SystemAnnouncer"],
messageSends: ["at:ifAbsent:", "methodDictionary", "selector", "ifFalse:", "includes:", "protocols", "protocol", "addElement:", "organization", "basicAddCompiledMethod:", "ifNotNil:", "removeProtocolIfEmpty:", "ifNil:ifNotNil:", "method:", "new", "yourself", "oldMethod:", "announce:", "current"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "allInstanceVariableNames",
protocol: 'accessing',
fn: function (){
var self=this;
var result;
return $core.withContext(function($ctx1) {
var $1,$receiver;
result=$recv(self._instanceVariableNames())._copy();
$1=self._superclass();
$ctx1.sendIdx["superclass"]=1;
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
$recv(result)._addAll_($recv(self._superclass())._allInstanceVariableNames());
};
return result;
}, function($ctx1) {$ctx1.fill(self,"allInstanceVariableNames",{result:result},$globals.Behavior)});
},
args: [],
source: "allInstanceVariableNames\x0a\x09| result |\x0a\x09result := self instanceVariableNames copy.\x0a\x09self superclass ifNotNil: [\x0a\x09\x09result addAll: self superclass allInstanceVariableNames ].\x0a\x09^ result",
referencedClasses: [],
messageSends: ["copy", "instanceVariableNames", "ifNotNil:", "superclass", "addAll:", "allInstanceVariableNames"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "allSelectors",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=self._allSuperclasses();
$2=self._selectors();
$ctx1.sendIdx["selectors"]=1;
return $recv($1)._inject_into_($2,(function(acc,each){
return $core.withContext(function($ctx2) {
$recv(acc)._addAll_($recv(each)._selectors());
return $recv(acc)._yourself();
}, function($ctx2) {$ctx2.fillBlock({acc:acc,each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"allSelectors",{},$globals.Behavior)});
},
args: [],
source: "allSelectors\x0a\x09^ self allSuperclasses\x0a\x09\x09inject: self selectors\x0a\x09\x09into: [ :acc :each | acc addAll: each selectors; yourself ]",
referencedClasses: [],
messageSends: ["inject:into:", "allSuperclasses", "selectors", "addAll:", "yourself"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "allSubclasses",
protocol: 'accessing',
fn: function (){
var self=this;
var subclasses,index;
return $core.withContext(function($ctx1) {
subclasses=self._subclasses();
$ctx1.sendIdx["subclasses"]=1;
index=(1);
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(index).__gt($recv(subclasses)._size());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
$recv(subclasses)._addAll_($recv($recv(subclasses)._at_(index))._subclasses());
index=$recv(index).__plus((1));
return index;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return subclasses;
}, function($ctx1) {$ctx1.fill(self,"allSubclasses",{subclasses:subclasses,index:index},$globals.Behavior)});
},
args: [],
source: "allSubclasses\x0a\x09\x22Answer an collection of the receiver's and the receiver's descendent's subclasses. \x22\x0a\x0a\x09| subclasses index |\x0a\x09\x0a\x09subclasses := self subclasses.\x0a\x09index := 1.\x0a\x09[ index > subclasses size ]\x0a\x09\x09whileFalse: [ subclasses addAll: (subclasses at: index) subclasses.\x0a\x09\x09\x09index := index + 1 ].\x0a\x0a\x09^ subclasses",
referencedClasses: [],
messageSends: ["subclasses", "whileFalse:", ">", "size", "addAll:", "at:", "+"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "allSubclassesDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._allSubclasses())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"allSubclassesDo:",{aBlock:aBlock},$globals.Behavior)});
},
args: ["aBlock"],
source: "allSubclassesDo: aBlock\x0a\x09\x22Evaluate the argument, aBlock, for each of the receiver's subclasses.\x22\x0a\x0a\x09self allSubclasses do: [ :each |\x0a    \x09aBlock value: each ]",
referencedClasses: [],
messageSends: ["do:", "allSubclasses", "value:"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "allSuperclasses",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$receiver;
$1=self._superclass();
$ctx1.sendIdx["superclass"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return [];
} else {
$1;
};
$3=self._superclass();
$ctx1.sendIdx["superclass"]=2;
$2=$recv($globals.OrderedCollection)._with_($3);
$recv($2)._addAll_($recv(self._superclass())._allSuperclasses());
return $recv($2)._yourself();
}, function($ctx1) {$ctx1.fill(self,"allSuperclasses",{},$globals.Behavior)});
},
args: [],
source: "allSuperclasses\x0a\x09\x0a\x09self superclass ifNil: [ ^ #() ].\x0a\x09\x0a\x09^ (OrderedCollection with: self superclass)\x0a\x09\x09addAll: self superclass allSuperclasses;\x0a\x09\x09yourself",
referencedClasses: ["OrderedCollection"],
messageSends: ["ifNil:", "superclass", "addAll:", "with:", "allSuperclasses", "yourself"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "basicAddCompiledMethod:",
protocol: 'private',
fn: function (aMethod){
var self=this;
return $core.withContext(function($ctx1) {
$core.addMethod(aMethod, self);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicAddCompiledMethod:",{aMethod:aMethod},$globals.Behavior)});
},
args: ["aMethod"],
source: "basicAddCompiledMethod: aMethod\x0a\x09<$core.addMethod(aMethod, self)>",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "basicNew",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return new self.fn();
return self;
}, function($ctx1) {$ctx1.fill(self,"basicNew",{},$globals.Behavior)});
},
args: [],
source: "basicNew\x0a\x09<return new self.fn()>",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "basicRemoveCompiledMethod:",
protocol: 'private',
fn: function (aMethod){
var self=this;
return $core.withContext(function($ctx1) {
$core.removeMethod(aMethod,self);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicRemoveCompiledMethod:",{aMethod:aMethod},$globals.Behavior)});
},
args: ["aMethod"],
source: "basicRemoveCompiledMethod: aMethod\x0a\x09<$core.removeMethod(aMethod,self)>",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "canUnderstand:",
protocol: 'testing',
fn: function (aSelector){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
return $recv(self._includesSelector_($recv(aSelector)._asString()))._or_((function(){
return $core.withContext(function($ctx2) {
$2=self._superclass();
$ctx2.sendIdx["superclass"]=1;
$1=$recv($2)._notNil();
return $recv($1)._and_((function(){
return $core.withContext(function($ctx3) {
return $recv(self._superclass())._canUnderstand_(aSelector);
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"canUnderstand:",{aSelector:aSelector},$globals.Behavior)});
},
args: ["aSelector"],
source: "canUnderstand: aSelector\x0a\x09^ (self includesSelector: aSelector asString) or: [\x0a\x09\x09self superclass notNil and: [ self superclass canUnderstand: aSelector ]]",
referencedClasses: [],
messageSends: ["or:", "includesSelector:", "asString", "and:", "notNil", "superclass", "canUnderstand:"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "comment",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._basicAt_("comment");
if(($receiver = $1) == null || $receiver.isNil){
return "";
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"comment",{},$globals.Behavior)});
},
args: [],
source: "comment\x0a\x09^ (self basicAt: 'comment') ifNil: [ '' ]",
referencedClasses: [],
messageSends: ["ifNil:", "basicAt:"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "comment:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
self._basicAt_put_("comment",aString);
$1=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.ClassCommentChanged)._new();
$recv($3)._theClass_(self);
$2=$recv($3)._yourself();
$recv($1)._announce_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"comment:",{aString:aString},$globals.Behavior)});
},
args: ["aString"],
source: "comment: aString\x0a\x09self basicAt: 'comment' put: aString.\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassCommentChanged new\x0a\x09\x09\x09theClass: self;\x0a\x09\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ClassCommentChanged"],
messageSends: ["basicAt:put:", "announce:", "current", "theClass:", "new", "yourself"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "compile:protocol:",
protocol: 'compiling',
fn: function (aString,anotherString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Compiler)._new())._install_forClass_protocol_(aString,self,anotherString);
}, function($ctx1) {$ctx1.fill(self,"compile:protocol:",{aString:aString,anotherString:anotherString},$globals.Behavior)});
},
args: ["aString", "anotherString"],
source: "compile: aString protocol: anotherString\x0a\x09^ Compiler new\x0a\x09\x09install: aString\x0a\x09\x09forClass: self\x0a\x09\x09protocol: anotherString",
referencedClasses: ["Compiler"],
messageSends: ["install:forClass:protocol:", "new"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "definition",
protocol: 'accessing',
fn: function (){
var self=this;
return "";

},
args: [],
source: "definition\x0a\x09^ ''",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "includesBehavior:",
protocol: 'testing',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self.__eq_eq(aClass))._or_((function(){
return $core.withContext(function($ctx2) {
return self._inheritsFrom_(aClass);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"includesBehavior:",{aClass:aClass},$globals.Behavior)});
},
args: ["aClass"],
source: "includesBehavior: aClass\x0a\x09^ self == aClass or: [\x0a\x09\x09\x09self inheritsFrom: aClass ]",
referencedClasses: [],
messageSends: ["or:", "==", "inheritsFrom:"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "includesSelector:",
protocol: 'testing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._methodDictionary())._includesKey_(aString);
}, function($ctx1) {$ctx1.fill(self,"includesSelector:",{aString:aString},$globals.Behavior)});
},
args: ["aString"],
source: "includesSelector: aString\x0a\x09^ self methodDictionary includesKey: aString",
referencedClasses: [],
messageSends: ["includesKey:", "methodDictionary"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "inheritsFrom:",
protocol: 'testing',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$receiver;
$1=self._superclass();
$ctx1.sendIdx["superclass"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return false;
} else {
$1;
};
$3=self._superclass();
$ctx1.sendIdx["superclass"]=2;
$2=$recv(aClass).__eq_eq($3);
return $recv($2)._or_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._superclass())._inheritsFrom_(aClass);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"inheritsFrom:",{aClass:aClass},$globals.Behavior)});
},
args: ["aClass"],
source: "inheritsFrom: aClass\x0a\x09self superclass ifNil: [ ^ false ].\x0a\x0a\x09^ aClass == self superclass or: [ \x0a\x09\x09self superclass inheritsFrom: aClass ]",
referencedClasses: [],
messageSends: ["ifNil:", "superclass", "or:", "==", "inheritsFrom:"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "instanceVariableNames",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.iVarNames;
return self;
}, function($ctx1) {$ctx1.fill(self,"instanceVariableNames",{},$globals.Behavior)});
},
args: [],
source: "instanceVariableNames\x0a\x09<return self.iVarNames>",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "isBehavior",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isBehavior\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "javascriptConstructor",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.fn;
return self;
}, function($ctx1) {$ctx1.fill(self,"javascriptConstructor",{},$globals.Behavior)});
},
args: [],
source: "javascriptConstructor\x0a\x09\x22Answer the JS constructor used to instantiate. See boot.js\x22\x0a\x09\x0a\x09<return self.fn>",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "javascriptConstructor:",
protocol: 'accessing',
fn: function (aJavaScriptFunction){
var self=this;
return $core.withContext(function($ctx1) {
$core.setClassConstructor(self, aJavaScriptFunction);;
return self;
}, function($ctx1) {$ctx1.fill(self,"javascriptConstructor:",{aJavaScriptFunction:aJavaScriptFunction},$globals.Behavior)});
},
args: ["aJavaScriptFunction"],
source: "javascriptConstructor: aJavaScriptFunction\x0a\x09\x22Set the JS constructor used to instantiate.\x0a\x09See the JS counter-part in boot.js `$core.setClassConstructor'\x22\x0a\x09\x0a\x09<$core.setClassConstructor(self, aJavaScriptFunction);>",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "lookupSelector:",
protocol: 'accessing',
fn: function (selector){
var self=this;
var lookupClass;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
lookupClass=self;
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(lookupClass).__eq(nil);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
$1=$recv(lookupClass)._includesSelector_(selector);
if($core.assert($1)){
throw $early=[$recv(lookupClass)._methodAt_(selector)];
};
lookupClass=$recv(lookupClass)._superclass();
return lookupClass;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return nil;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"lookupSelector:",{selector:selector,lookupClass:lookupClass},$globals.Behavior)});
},
args: ["selector"],
source: "lookupSelector: selector\x0a\x09\x22Look up the given selector in my methodDictionary.\x0a\x09Return the corresponding method if found.\x0a\x09Otherwise chase the superclass chain and try again.\x0a\x09Return nil if no method is found.\x22\x0a\x09\x0a\x09| lookupClass |\x0a\x09\x0a\x09lookupClass := self.\x0a\x09[ lookupClass = nil ] whileFalse: [\x0a\x09\x09(lookupClass includesSelector: selector)\x0a\x09\x09\x09\x09ifTrue: [ ^ lookupClass methodAt: selector ].\x0a\x09\x09\x09lookupClass := lookupClass superclass ].\x0a\x09^ nil",
referencedClasses: [],
messageSends: ["whileFalse:", "=", "ifTrue:", "includesSelector:", "methodAt:", "superclass"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "methodAt:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._methodDictionary())._at_(aString);
}, function($ctx1) {$ctx1.fill(self,"methodAt:",{aString:aString},$globals.Behavior)});
},
args: ["aString"],
source: "methodAt: aString\x0a\x09^ self methodDictionary at: aString",
referencedClasses: [],
messageSends: ["at:", "methodDictionary"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "methodDictionary",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var dict = $globals.HashedCollection._new();
	var methods = self.methods;
	Object.keys(methods).forEach(function(i) {
		if(methods[i].selector) {
			dict._at_put_(methods[i].selector, methods[i]);
		}
	});
	return dict;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodDictionary",{},$globals.Behavior)});
},
args: [],
source: "methodDictionary\x0a\x09<var dict = $globals.HashedCollection._new();\x0a\x09var methods = self.methods;\x0a\x09Object.keys(methods).forEach(function(i) {\x0a\x09\x09if(methods[i].selector) {\x0a\x09\x09\x09dict._at_put_(methods[i].selector, methods[i]);\x0a\x09\x09}\x0a\x09});\x0a\x09return dict>",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "methodTemplate",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$6,$7,$5,$8,$4;
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
$recv(stream)._nextPutAll_("messageSelectorAndArgumentNames");
$ctx2.sendIdx["nextPutAll:"]=1;
$2=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=1;
$3=$recv($globals.String)._tab();
$ctx2.sendIdx["tab"]=1;
$1=$recv($2).__comma($3);
$ctx2.sendIdx[","]=1;
$recv(stream)._nextPutAll_($1);
$ctx2.sendIdx["nextPutAll:"]=2;
$recv(stream)._nextPutAll_("\x22comment stating purpose of message\x22");
$ctx2.sendIdx["nextPutAll:"]=3;
$6=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=2;
$7=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=3;
$5=$recv($6).__comma($7);
$ctx2.sendIdx[","]=3;
$8=$recv($globals.String)._tab();
$ctx2.sendIdx["tab"]=2;
$4=$recv($5).__comma($8);
$ctx2.sendIdx[","]=2;
$recv(stream)._nextPutAll_($4);
$ctx2.sendIdx["nextPutAll:"]=4;
$recv(stream)._nextPutAll_("| temporary variable names |");
$ctx2.sendIdx["nextPutAll:"]=5;
$recv(stream)._nextPutAll_($recv($recv($globals.String)._lf()).__comma($recv($globals.String)._tab()));
$ctx2.sendIdx["nextPutAll:"]=6;
return $recv(stream)._nextPutAll_("statements");
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"methodTemplate",{},$globals.Behavior)});
},
args: [],
source: "methodTemplate\x0a\x09^ String streamContents: [ :stream |\x0a\x09\x09stream \x0a\x09\x09\x09nextPutAll: 'messageSelectorAndArgumentNames';\x0a\x09\x09\x09nextPutAll: String lf, String tab;\x0a\x09\x09\x09nextPutAll: '\x22comment stating purpose of message\x22';\x0a\x09\x09\x09nextPutAll: String lf, String lf, String tab;\x0a\x09\x09\x09nextPutAll: '| temporary variable names |';\x0a\x09\x09\x09nextPutAll: String lf, String tab;\x0a\x09\x09\x09nextPutAll: 'statements' ]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "nextPutAll:", ",", "lf", "tab"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "methods",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._methodDictionary())._values();
}, function($ctx1) {$ctx1.fill(self,"methods",{},$globals.Behavior)});
},
args: [],
source: "methods\x0a\x09^ self methodDictionary values",
referencedClasses: [],
messageSends: ["values", "methodDictionary"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "methodsInProtocol:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._methods())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._protocol()).__eq(aString);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"methodsInProtocol:",{aString:aString},$globals.Behavior)});
},
args: ["aString"],
source: "methodsInProtocol: aString\x0a\x09^ self methods select: [ :each | each protocol = aString ]",
referencedClasses: [],
messageSends: ["select:", "methods", "=", "protocol"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "name",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.className || nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"name",{},$globals.Behavior)});
},
args: [],
source: "name\x0a\x09<return self.className || nil>",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "new",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._basicNew())._initialize();
}, function($ctx1) {$ctx1.fill(self,"new",{},$globals.Behavior)});
},
args: [],
source: "new\x0a\x09^ self basicNew initialize",
referencedClasses: [],
messageSends: ["initialize", "basicNew"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "organization",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._basicAt_("organization");
}, function($ctx1) {$ctx1.fill(self,"organization",{},$globals.Behavior)});
},
args: [],
source: "organization\x0a\x09^ self basicAt: 'organization'",
referencedClasses: [],
messageSends: ["basicAt:"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "ownMethods",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv($recv(self._ownProtocols())._inject_into_($recv($globals.OrderedCollection)._new(),(function(acc,each){
return $core.withContext(function($ctx2) {
return $recv(acc).__comma(self._methodsInProtocol_(each));
}, function($ctx2) {$ctx2.fillBlock({acc:acc,each:each},$ctx1,1)});
})))._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
$1=$recv(a)._selector();
$ctx2.sendIdx["selector"]=1;
return $recv($1).__lt_eq($recv(b)._selector());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownMethods",{},$globals.Behavior)});
},
args: [],
source: "ownMethods\x0a\x09\x22Answer the methods of the receiver that are not package extensions\x22\x0a\x0a\x09^ (self ownProtocols \x0a\x09\x09inject: OrderedCollection new\x0a\x09\x09into: [ :acc :each | acc, (self methodsInProtocol: each) ])\x0a\x09\x09\x09sorted: [ :a :b | a selector <= b selector ]",
referencedClasses: ["OrderedCollection"],
messageSends: ["sorted:", "inject:into:", "ownProtocols", "new", ",", "methodsInProtocol:", "<=", "selector"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "ownProtocols",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._protocols())._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._match_("^\x5c*");
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownProtocols",{},$globals.Behavior)});
},
args: [],
source: "ownProtocols\x0a\x09\x22Answer the protocols of the receiver that are not package extensions\x22\x0a\x0a\x09^ self protocols reject: [ :each |\x0a\x09\x09each match: '^\x5c*' ]",
referencedClasses: [],
messageSends: ["reject:", "protocols", "match:"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "packageOfProtocol:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(aString)._beginsWith_("*");
if(!$core.assert($1)){
return self._package();
};
return $recv($globals.Package)._named_ifAbsent_($recv(aString)._allButFirst(),(function(){
return nil;

}));
}, function($ctx1) {$ctx1.fill(self,"packageOfProtocol:",{aString:aString},$globals.Behavior)});
},
args: ["aString"],
source: "packageOfProtocol: aString\x0a\x09\x22Answer the package the method of receiver belongs to:\x0a\x09- if it is an extension method, answer the corresponding package\x0a\x09- else answer the receiver's package\x22\x0a\x09\x0a\x09(aString beginsWith: '*') ifFalse: [\x0a\x09\x09^ self package ].\x0a\x09\x09\x0a\x09^ Package \x0a\x09\x09named: aString allButFirst\x0a\x09\x09ifAbsent: [ nil ]",
referencedClasses: ["Package"],
messageSends: ["ifFalse:", "beginsWith:", "package", "named:ifAbsent:", "allButFirst"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "protocols",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._organization())._elements())._sorted();
}, function($ctx1) {$ctx1.fill(self,"protocols",{},$globals.Behavior)});
},
args: [],
source: "protocols\x0a\x09^ self organization elements sorted",
referencedClasses: [],
messageSends: ["sorted", "elements", "organization"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "protocolsDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
var methodsByProtocol;
return $core.withContext(function($ctx1) {
methodsByProtocol=$recv($globals.HashedCollection)._new();
$ctx1.sendIdx["new"]=1;
$recv(self._methodDictionary())._valuesDo_((function(m){
return $core.withContext(function($ctx2) {
return $recv($recv(methodsByProtocol)._at_ifAbsentPut_($recv(m)._protocol(),(function(){
return $core.withContext(function($ctx3) {
return $recv($globals.Array)._new();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
})))._add_(m);
}, function($ctx2) {$ctx2.fillBlock({m:m},$ctx1,1)});
}));
$recv(self._protocols())._do_((function(protocol){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_value_(protocol,$recv(methodsByProtocol)._at_(protocol));
}, function($ctx2) {$ctx2.fillBlock({protocol:protocol},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"protocolsDo:",{aBlock:aBlock,methodsByProtocol:methodsByProtocol},$globals.Behavior)});
},
args: ["aBlock"],
source: "protocolsDo: aBlock\x0a\x09\x22Execute aBlock for each method protocol with\x0a\x09its collection of methods in the sort order of protocol name.\x22\x0a\x0a\x09| methodsByProtocol |\x0a\x09methodsByProtocol := HashedCollection new.\x0a\x09self methodDictionary valuesDo: [ :m |\x0a\x09\x09(methodsByProtocol at: m protocol ifAbsentPut: [ Array new ])\x0a\x09\x09\x09add: m ].\x0a\x09self protocols do: [ :protocol |\x0a\x09\x09aBlock value: protocol value: (methodsByProtocol at: protocol) ]",
referencedClasses: ["HashedCollection", "Array"],
messageSends: ["new", "valuesDo:", "methodDictionary", "add:", "at:ifAbsentPut:", "protocol", "do:", "protocols", "value:value:", "at:"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "prototype",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.fn.prototype;
return self;
}, function($ctx1) {$ctx1.fill(self,"prototype",{},$globals.Behavior)});
},
args: [],
source: "prototype\x0a\x09<return self.fn.prototype>",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "recompile",
protocol: 'compiling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Compiler)._new())._recompile_(self);
}, function($ctx1) {$ctx1.fill(self,"recompile",{},$globals.Behavior)});
},
args: [],
source: "recompile\x0a\x09^ Compiler new recompile: self",
referencedClasses: ["Compiler"],
messageSends: ["recompile:", "new"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "removeCompiledMethod:",
protocol: 'compiling',
fn: function (aMethod){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
self._basicRemoveCompiledMethod_(aMethod);
self._removeProtocolIfEmpty_($recv(aMethod)._protocol());
$1=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.MethodRemoved)._new();
$recv($3)._method_(aMethod);
$2=$recv($3)._yourself();
$recv($1)._announce_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeCompiledMethod:",{aMethod:aMethod},$globals.Behavior)});
},
args: ["aMethod"],
source: "removeCompiledMethod: aMethod\x0a\x09self basicRemoveCompiledMethod: aMethod.\x0a\x09\x0a\x09self removeProtocolIfEmpty: aMethod protocol.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (MethodRemoved new\x0a\x09\x09\x09method: aMethod;\x0a\x09\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "MethodRemoved"],
messageSends: ["basicRemoveCompiledMethod:", "removeProtocolIfEmpty:", "protocol", "announce:", "current", "method:", "new", "yourself"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "removeProtocolIfEmpty:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._methods())._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._protocol()).__eq(aString);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(self._organization())._removeElement_(aString);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"removeProtocolIfEmpty:",{aString:aString},$globals.Behavior)});
},
args: ["aString"],
source: "removeProtocolIfEmpty: aString\x0a\x09self methods\x0a\x09\x09detect: [ :each | each protocol = aString ]\x0a\x09\x09ifNone: [ self organization removeElement: aString ]",
referencedClasses: [],
messageSends: ["detect:ifNone:", "methods", "=", "protocol", "removeElement:", "organization"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "selectors",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._methodDictionary())._keys();
}, function($ctx1) {$ctx1.fill(self,"selectors",{},$globals.Behavior)});
},
args: [],
source: "selectors\x0a\x09^ self methodDictionary keys",
referencedClasses: [],
messageSends: ["keys", "methodDictionary"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "subclasses",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"subclasses",{},$globals.Behavior)});
},
args: [],
source: "subclasses\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "superclass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.superclass;
return self;
}, function($ctx1) {$ctx1.fill(self,"superclass",{},$globals.Behavior)});
},
args: [],
source: "superclass\x0a\x09<return self.superclass>",
referencedClasses: [],
messageSends: []
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "theMetaClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"theMetaClass",{},$globals.Behavior)});
},
args: [],
source: "theMetaClass\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "theNonMetaClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"theNonMetaClass",{},$globals.Behavior)});
},
args: [],
source: "theNonMetaClass\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "withAllSubclasses",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Array)._with_(self);
$recv($1)._addAll_(self._allSubclasses());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"withAllSubclasses",{},$globals.Behavior)});
},
args: [],
source: "withAllSubclasses\x0a\x09^ (Array with: self) addAll: self allSubclasses; yourself",
referencedClasses: ["Array"],
messageSends: ["addAll:", "with:", "allSubclasses", "yourself"]
}),
$globals.Behavior);



$core.addClass('Class', $globals.Behavior, [], 'Kernel-Classes');
$globals.Class.comment="I am __the__ class object.\x0a\x0aMy instances are the classes of the system.\x0aClass creation is done throught a `ClassBuilder` instance.";
$core.addMethod(
$core.method({
selector: "asJavascript",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return "$globals.".__comma(self._name());
}, function($ctx1) {$ctx1.fill(self,"asJavascript",{},$globals.Class)});
},
args: [],
source: "asJavascript\x0a\x09^ '$globals.', self name",
referencedClasses: [],
messageSends: [",", "name"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "browse",
protocol: 'browsing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Finder)._findClass_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"browse",{},$globals.Class)});
},
args: [],
source: "browse\x0a\x09Finder findClass: self",
referencedClasses: ["Finder"],
messageSends: ["findClass:"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "category",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._package();
$ctx1.sendIdx["package"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return "Unclassified";
} else {
return $recv(self._package())._name();
};
}, function($ctx1) {$ctx1.fill(self,"category",{},$globals.Class)});
},
args: [],
source: "category\x0a\x09^ self package ifNil: [ 'Unclassified' ] ifNotNil: [ self package name ]",
referencedClasses: [],
messageSends: ["ifNil:ifNotNil:", "package", "name"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "classTag",
protocol: 'accessing',
fn: function (){
var self=this;
return "class";

},
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'class'",
referencedClasses: [],
messageSends: []
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "definition",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$4,$5;
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
$recv(stream)._nextPutAll_($recv(self._superclass())._asString());
$ctx2.sendIdx["nextPutAll:"]=1;
$recv(stream)._nextPutAll_(" subclass: #");
$ctx2.sendIdx["nextPutAll:"]=2;
$recv(stream)._nextPutAll_(self._name());
$ctx2.sendIdx["nextPutAll:"]=3;
$2=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=1;
$3=$recv($globals.String)._tab();
$ctx2.sendIdx["tab"]=1;
$1=$recv($2).__comma($3);
$ctx2.sendIdx[","]=1;
$recv(stream)._nextPutAll_($1);
$ctx2.sendIdx["nextPutAll:"]=4;
$4=$recv(stream)._nextPutAll_("instanceVariableNames: '");
$ctx2.sendIdx["nextPutAll:"]=5;
$4;
$recv(self._instanceVariableNames())._do_separatedBy_((function(each){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPutAll_(each);
$ctx3.sendIdx["nextPutAll:"]=6;
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPutAll_(" ");
$ctx3.sendIdx["nextPutAll:"]=7;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
$5=$recv("'".__comma($recv($globals.String)._lf())).__comma($recv($globals.String)._tab());
$ctx2.sendIdx[","]=2;
$recv(stream)._nextPutAll_($5);
$ctx2.sendIdx["nextPutAll:"]=8;
$recv(stream)._nextPutAll_("package: '");
$ctx2.sendIdx["nextPutAll:"]=9;
$recv(stream)._nextPutAll_(self._category());
$ctx2.sendIdx["nextPutAll:"]=10;
return $recv(stream)._nextPutAll_("'");
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"definition",{},$globals.Class)});
},
args: [],
source: "definition\x0a\x09^ String streamContents: [ :stream |\x0a\x09\x09stream\x0a\x09\x09\x09nextPutAll: self superclass asString;\x0a\x09\x09\x09nextPutAll: ' subclass: #';\x0a\x09\x09\x09nextPutAll: self name;\x0a\x09\x09\x09nextPutAll: String lf, String tab;\x0a\x09\x09\x09nextPutAll: 'instanceVariableNames: '''.\x0a\x09\x09self instanceVariableNames\x0a\x09\x09\x09do: [ :each | stream nextPutAll: each ]\x0a\x09\x09\x09separatedBy: [ stream nextPutAll: ' ' ].\x0a\x09\x09stream\x0a\x09\x09\x09nextPutAll: '''', String lf, String tab;\x0a\x09\x09\x09nextPutAll: 'package: ''';\x0a\x09\x09\x09nextPutAll: self category;\x0a\x09\x09\x09nextPutAll: '''' ]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "nextPutAll:", "asString", "superclass", "name", ",", "lf", "tab", "do:separatedBy:", "instanceVariableNames", "category"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "isClass",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isClass\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "package",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._basicAt_("pkg");
}, function($ctx1) {$ctx1.fill(self,"package",{},$globals.Class)});
},
args: [],
source: "package\x0a\x09^ self basicAt: 'pkg'",
referencedClasses: [],
messageSends: ["basicAt:"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "package:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
var oldPackage;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$4,$6,$5;
$2=self._package();
$ctx1.sendIdx["package"]=1;
$1=$recv($2).__eq(aPackage);
if($core.assert($1)){
return self;
};
oldPackage=self._package();
self._basicAt_put_("pkg",aPackage);
$3=$recv(oldPackage)._organization();
$ctx1.sendIdx["organization"]=1;
$recv($3)._removeElement_(self);
$recv($recv(aPackage)._organization())._addElement_(self);
$4=$recv($globals.SystemAnnouncer)._current();
$6=$recv($globals.ClassMoved)._new();
$recv($6)._theClass_(self);
$recv($6)._oldPackage_(oldPackage);
$5=$recv($6)._yourself();
$recv($4)._announce_($5);
return self;
}, function($ctx1) {$ctx1.fill(self,"package:",{aPackage:aPackage,oldPackage:oldPackage},$globals.Class)});
},
args: ["aPackage"],
source: "package: aPackage\x0a\x09| oldPackage |\x0a\x09\x0a\x09self package = aPackage ifTrue: [ ^ self ].\x0a\x09\x0a\x09oldPackage := self package.\x0a\x09\x0a\x09self basicAt: 'pkg' put: aPackage.\x0a\x09oldPackage organization removeElement: self.\x0a\x09aPackage organization addElement: self.\x0a\x0a\x09SystemAnnouncer current announce: (ClassMoved new\x0a\x09\x09theClass: self;\x0a\x09\x09oldPackage: oldPackage;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ClassMoved"],
messageSends: ["ifTrue:", "=", "package", "basicAt:put:", "removeElement:", "organization", "addElement:", "announce:", "current", "theClass:", "new", "oldPackage:", "yourself"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_(self._name());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Class)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: self name",
referencedClasses: [],
messageSends: ["nextPutAll:", "name"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "rename:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.ClassBuilder)._new())._renameClass_to_(self,aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"rename:",{aString:aString},$globals.Class)});
},
args: ["aString"],
source: "rename: aString\x0a\x09ClassBuilder new renameClass: self to: aString",
referencedClasses: ["ClassBuilder"],
messageSends: ["renameClass:to:", "new"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:",
protocol: 'class creation',
fn: function (aString,anotherString){
var self=this;
return $core.withContext(function($ctx1) {
return self._subclass_instanceVariableNames_package_(aString,anotherString,nil);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:",{aString:aString,anotherString:anotherString},$globals.Class)});
},
args: ["aString", "anotherString"],
source: "subclass: aString instanceVariableNames: anotherString\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString instanceVariableNames: anotherString package: nil",
referencedClasses: [],
messageSends: ["subclass:instanceVariableNames:package:"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:category:",
protocol: 'class creation',
fn: function (aString,aString2,aString3){
var self=this;
return $core.withContext(function($ctx1) {
return self._subclass_instanceVariableNames_package_(aString,aString2,aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:category:",{aString:aString,aString2:aString2,aString3:aString3},$globals.Class)});
},
args: ["aString", "aString2", "aString3"],
source: "subclass: aString instanceVariableNames: aString2 category: aString3\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString instanceVariableNames: aString2 package: aString3",
referencedClasses: [],
messageSends: ["subclass:instanceVariableNames:package:"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
protocol: 'class creation',
fn: function (aString,aString2,classVars,pools,aString3){
var self=this;
return $core.withContext(function($ctx1) {
return self._subclass_instanceVariableNames_package_(aString,aString2,aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",{aString:aString,aString2:aString2,classVars:classVars,pools:pools,aString3:aString3},$globals.Class)});
},
args: ["aString", "aString2", "classVars", "pools", "aString3"],
source: "subclass: aString instanceVariableNames: aString2 classVariableNames: classVars poolDictionaries: pools category: aString3\x0a\x09\x22Kept for file-in compatibility. ignores class variables and pools.\x22\x0a\x09^ self subclass: aString instanceVariableNames: aString2 package: aString3",
referencedClasses: [],
messageSends: ["subclass:instanceVariableNames:package:"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:package:",
protocol: 'class creation',
fn: function (aString,aString2,aString3){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.ClassBuilder)._new())._superclass_subclass_instanceVariableNames_package_(self,$recv(aString)._asString(),aString2,aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:package:",{aString:aString,aString2:aString2,aString3:aString3},$globals.Class)});
},
args: ["aString", "aString2", "aString3"],
source: "subclass: aString instanceVariableNames: aString2 package: aString3\x0a\x09^ ClassBuilder new\x0a\x09\x09superclass: self subclass: aString asString instanceVariableNames: aString2 package: aString3",
referencedClasses: ["ClassBuilder"],
messageSends: ["superclass:subclass:instanceVariableNames:package:", "new", "asString"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "subclasses",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.subclasses._copy();
return self;
}, function($ctx1) {$ctx1.fill(self,"subclasses",{},$globals.Class)});
},
args: [],
source: "subclasses\x0a\x09<return self.subclasses._copy()>",
referencedClasses: [],
messageSends: []
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "theMetaClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._class();
}, function($ctx1) {$ctx1.fill(self,"theMetaClass",{},$globals.Class)});
},
args: [],
source: "theMetaClass\x0a\x09^ self class",
referencedClasses: [],
messageSends: ["class"]
}),
$globals.Class);

$core.addMethod(
$core.method({
selector: "theNonMetaClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self;

},
args: [],
source: "theNonMetaClass\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.Class);



$core.addClass('Metaclass', $globals.Behavior, [], 'Kernel-Classes');
$globals.Metaclass.comment="I am the root of the class hierarchy.\x0a\x0aMy instances are metaclasses, one for each real class, and have a single instance, which they hold onto: the class that they are the metaclass of.";
$core.addMethod(
$core.method({
selector: "asJavascript",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv("$globals.".__comma($recv(self._instanceClass())._name())).__comma(".klass");
$ctx1.sendIdx[","]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"asJavascript",{},$globals.Metaclass)});
},
args: [],
source: "asJavascript\x0a\x09^ '$globals.', self instanceClass name, '.klass'",
referencedClasses: [],
messageSends: [",", "name", "instanceClass"]
}),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "definition",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
$recv(stream)._nextPutAll_(self._asString());
$ctx2.sendIdx["nextPutAll:"]=1;
$1=$recv(stream)._nextPutAll_(" instanceVariableNames: '");
$ctx2.sendIdx["nextPutAll:"]=2;
$1;
$recv(self._instanceVariableNames())._do_separatedBy_((function(each){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPutAll_(each);
$ctx3.sendIdx["nextPutAll:"]=3;
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPutAll_(" ");
$ctx3.sendIdx["nextPutAll:"]=4;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
return $recv(stream)._nextPutAll_("'");
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"definition",{},$globals.Metaclass)});
},
args: [],
source: "definition\x0a\x09^ String streamContents: [ :stream |\x0a\x09\x09stream\x0a\x09\x09\x09nextPutAll: self asString;\x0a\x09\x09\x09nextPutAll: ' instanceVariableNames: '''.\x0a\x09\x09self instanceVariableNames\x0a\x09\x09\x09do: [ :each | stream nextPutAll: each ]\x0a\x09\x09\x09separatedBy: [ stream nextPutAll: ' ' ].\x0a\x09\x09stream nextPutAll: '''' ]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "nextPutAll:", "asString", "do:separatedBy:", "instanceVariableNames"]
}),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "instanceClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.instanceClass;
return self;
}, function($ctx1) {$ctx1.fill(self,"instanceClass",{},$globals.Metaclass)});
},
args: [],
source: "instanceClass\x0a\x09<return self.instanceClass>",
referencedClasses: [],
messageSends: []
}),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "instanceVariableNames:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.ClassBuilder)._new())._class_instanceVariableNames_(self,aCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"instanceVariableNames:",{aCollection:aCollection},$globals.Metaclass)});
},
args: ["aCollection"],
source: "instanceVariableNames: aCollection\x0a\x09ClassBuilder new\x0a\x09\x09class: self instanceVariableNames: aCollection",
referencedClasses: ["ClassBuilder"],
messageSends: ["class:instanceVariableNames:", "new"]
}),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "isMetaclass",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isMetaclass\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "package",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._instanceClass())._package();
}, function($ctx1) {$ctx1.fill(self,"package",{},$globals.Metaclass)});
},
args: [],
source: "package\x0a\x09^ self instanceClass package",
referencedClasses: [],
messageSends: ["package", "instanceClass"]
}),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_($recv(self._instanceClass())._name());
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_(" class");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Metaclass)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream\x0a\x09\x09nextPutAll: self instanceClass name;\x0a\x09\x09nextPutAll: ' class'",
referencedClasses: [],
messageSends: ["nextPutAll:", "name", "instanceClass"]
}),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "subclasses",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv(self._instanceClass())._subclasses())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._isMetaclass())._not();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._theMetaClass();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"subclasses",{},$globals.Metaclass)});
},
args: [],
source: "subclasses\x0a\x09^ (self instanceClass subclasses \x0a\x09\x09select: [ :each | each isMetaclass not ])\x0a\x09\x09collect: [ :each | each theMetaClass ]",
referencedClasses: [],
messageSends: ["collect:", "select:", "subclasses", "instanceClass", "not", "isMetaclass", "theMetaClass"]
}),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "theMetaClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self;

},
args: [],
source: "theMetaClass\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "theNonMetaClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._instanceClass();
}, function($ctx1) {$ctx1.fill(self,"theNonMetaClass",{},$globals.Metaclass)});
},
args: [],
source: "theNonMetaClass\x0a\x09^ self instanceClass",
referencedClasses: [],
messageSends: ["instanceClass"]
}),
$globals.Metaclass);



$core.addClass('ClassBuilder', $globals.Object, [], 'Kernel-Classes');
$globals.ClassBuilder.comment="I am responsible for compiling new classes or modifying existing classes in the system.\x0a\x0aRather than using me directly to compile a class, use `Class >> subclass:instanceVariableNames:package:`.";
$core.addMethod(
$core.method({
selector: "addSubclassOf:named:instanceVariableNames:package:",
protocol: 'class definition',
fn: function (aClass,className,aCollection,packageName){
var self=this;
var theClass,thePackage;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
theClass=$recv($recv($globals.Smalltalk)._globals())._at_(className);
thePackage=$recv($globals.Package)._named_(packageName);
$1=theClass;
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
$recv(theClass)._package_(thePackage);
$2=$recv($recv(theClass)._superclass()).__eq_eq(aClass);
if(!$core.assert($2)){
return self._migrateClassNamed_superclass_instanceVariableNames_package_(className,aClass,aCollection,packageName);
};
};
return self._basicAddSubclassOf_named_instanceVariableNames_package_(aClass,className,aCollection,packageName);
}, function($ctx1) {$ctx1.fill(self,"addSubclassOf:named:instanceVariableNames:package:",{aClass:aClass,className:className,aCollection:aCollection,packageName:packageName,theClass:theClass,thePackage:thePackage},$globals.ClassBuilder)});
},
args: ["aClass", "className", "aCollection", "packageName"],
source: "addSubclassOf: aClass named: className instanceVariableNames: aCollection package: packageName\x0a\x09| theClass thePackage |\x0a\x09\x0a\x09theClass := Smalltalk globals at: className.\x0a\x09thePackage := Package named: packageName.\x0a\x09\x0a\x09theClass ifNotNil: [\x0a\x09\x09theClass package: thePackage.\x0a\x09\x09theClass superclass == aClass ifFalse: [\x0a\x09\x09\x09^ self\x0a\x09\x09\x09\x09migrateClassNamed: className\x0a\x09\x09\x09\x09superclass: aClass\x0a\x09\x09\x09\x09instanceVariableNames: aCollection\x0a\x09\x09\x09\x09package: packageName ] ].\x0a\x09\x09\x0a\x09^ self\x0a\x09\x09basicAddSubclassOf: aClass\x0a\x09\x09named: className\x0a\x09\x09instanceVariableNames: aCollection\x0a\x09\x09package: packageName",
referencedClasses: ["Smalltalk", "Package"],
messageSends: ["at:", "globals", "named:", "ifNotNil:", "package:", "ifFalse:", "==", "superclass", "migrateClassNamed:superclass:instanceVariableNames:package:", "basicAddSubclassOf:named:instanceVariableNames:package:"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicAddSubclassOf:named:instanceVariableNames:package:",
protocol: 'private',
fn: function (aClass,aString,aCollection,packageName){
var self=this;
return $core.withContext(function($ctx1) {

		$core.addClass(aString, aClass, aCollection, packageName);
		return $globals[aString]
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicAddSubclassOf:named:instanceVariableNames:package:",{aClass:aClass,aString:aString,aCollection:aCollection,packageName:packageName},$globals.ClassBuilder)});
},
args: ["aClass", "aString", "aCollection", "packageName"],
source: "basicAddSubclassOf: aClass named: aString instanceVariableNames: aCollection package: packageName\x0a\x09<\x0a\x09\x09$core.addClass(aString, aClass, aCollection, packageName);\x0a\x09\x09return $globals[aString]\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicClass:instanceVariableNames:",
protocol: 'private',
fn: function (aClass,aString){
var self=this;
return $core.withContext(function($ctx1) {
self._basicClass_instanceVariables_(aClass,self._instanceVariableNamesFor_(aString));
return self;
}, function($ctx1) {$ctx1.fill(self,"basicClass:instanceVariableNames:",{aClass:aClass,aString:aString},$globals.ClassBuilder)});
},
args: ["aClass", "aString"],
source: "basicClass: aClass instanceVariableNames: aString\x0a\x09self basicClass: aClass instanceVariables: (self instanceVariableNamesFor: aString)",
referencedClasses: [],
messageSends: ["basicClass:instanceVariables:", "instanceVariableNamesFor:"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicClass:instanceVariables:",
protocol: 'private',
fn: function (aClass,aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(aClass)._isMetaclass();
if(!$core.assert($1)){
self._error_($recv($recv(aClass)._name()).__comma(" is not a metaclass"));
};
$recv(aClass)._basicAt_put_("iVarNames",aCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicClass:instanceVariables:",{aClass:aClass,aCollection:aCollection},$globals.ClassBuilder)});
},
args: ["aClass", "aCollection"],
source: "basicClass: aClass instanceVariables: aCollection\x0a\x0a\x09aClass isMetaclass ifFalse: [ self error: aClass name, ' is not a metaclass' ].\x0a\x09aClass basicAt: 'iVarNames' put: aCollection",
referencedClasses: [],
messageSends: ["ifFalse:", "isMetaclass", "error:", ",", "name", "basicAt:put:"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicRemoveClass:",
protocol: 'private',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
$core.removeClass(aClass);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicRemoveClass:",{aClass:aClass},$globals.ClassBuilder)});
},
args: ["aClass"],
source: "basicRemoveClass: aClass\x0a\x09<$core.removeClass(aClass)>",
referencedClasses: [],
messageSends: []
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicRenameClass:to:",
protocol: 'private',
fn: function (aClass,aString){
var self=this;
return $core.withContext(function($ctx1) {

		$globals[aString] = aClass;
		delete $globals[aClass.className];
		aClass.className = aString;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicRenameClass:to:",{aClass:aClass,aString:aString},$globals.ClassBuilder)});
},
args: ["aClass", "aString"],
source: "basicRenameClass: aClass to: aString\x0a\x09<\x0a\x09\x09$globals[aString] = aClass;\x0a\x09\x09delete $globals[aClass.className];\x0a\x09\x09aClass.className = aString;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicSwapClassNames:with:",
protocol: 'private',
fn: function (aClass,anotherClass){
var self=this;
return $core.withContext(function($ctx1) {

		var tmp = aClass.className;
		aClass.className = anotherClass.className;
		anotherClass.className = tmp;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicSwapClassNames:with:",{aClass:aClass,anotherClass:anotherClass},$globals.ClassBuilder)});
},
args: ["aClass", "anotherClass"],
source: "basicSwapClassNames: aClass with: anotherClass\x0a\x09<\x0a\x09\x09var tmp = aClass.className;\x0a\x09\x09aClass.className = anotherClass.className;\x0a\x09\x09anotherClass.className = tmp;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "class:instanceVariableNames:",
protocol: 'class definition',
fn: function (aClass,ivarNames){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
self._basicClass_instanceVariableNames_(aClass,ivarNames);
self._setupClass_(aClass);
$1=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.ClassDefinitionChanged)._new();
$recv($3)._theClass_(aClass);
$2=$recv($3)._yourself();
$recv($1)._announce_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"class:instanceVariableNames:",{aClass:aClass,ivarNames:ivarNames},$globals.ClassBuilder)});
},
args: ["aClass", "ivarNames"],
source: "class: aClass instanceVariableNames: ivarNames\x0a\x09self basicClass: aClass instanceVariableNames: ivarNames.\x0a\x09self setupClass: aClass.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassDefinitionChanged new\x0a\x09\x09\x09theClass: aClass;\x0a\x09\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ClassDefinitionChanged"],
messageSends: ["basicClass:instanceVariableNames:", "setupClass:", "announce:", "current", "theClass:", "new", "yourself"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "copyClass:named:",
protocol: 'copying',
fn: function (aClass,className){
var self=this;
var newClass;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
newClass=self._addSubclassOf_named_instanceVariableNames_package_($recv(aClass)._superclass(),className,$recv(aClass)._instanceVariableNames(),$recv($recv(aClass)._package())._name());
self._copyClass_to_(aClass,newClass);
$1=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.ClassAdded)._new();
$recv($3)._theClass_(newClass);
$2=$recv($3)._yourself();
$recv($1)._announce_($2);
return newClass;
}, function($ctx1) {$ctx1.fill(self,"copyClass:named:",{aClass:aClass,className:className,newClass:newClass},$globals.ClassBuilder)});
},
args: ["aClass", "className"],
source: "copyClass: aClass named: className\x0a\x09| newClass |\x0a\x0a\x09newClass := self\x0a\x09\x09addSubclassOf: aClass superclass\x0a\x09\x09named: className\x0a\x09\x09instanceVariableNames: aClass instanceVariableNames\x0a\x09\x09package: aClass package name.\x0a\x0a\x09self copyClass: aClass to: newClass.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassAdded new\x0a\x09\x09\x09theClass: newClass;\x0a\x09\x09\x09yourself).\x0a\x09\x0a\x09^ newClass",
referencedClasses: ["SystemAnnouncer", "ClassAdded"],
messageSends: ["addSubclassOf:named:instanceVariableNames:package:", "superclass", "instanceVariableNames", "name", "package", "copyClass:to:", "announce:", "current", "theClass:", "new", "yourself"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "copyClass:to:",
protocol: 'copying',
fn: function (aClass,anotherClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$7,$6,$9,$8;
$recv(anotherClass)._comment_($recv(aClass)._comment());
$1=$recv(aClass)._methodDictionary();
$ctx1.sendIdx["methodDictionary"]=1;
$recv($1)._valuesDo_((function(each){
return $core.withContext(function($ctx2) {
$2=$recv($globals.Compiler)._new();
$ctx2.sendIdx["new"]=1;
$3=$recv(each)._source();
$ctx2.sendIdx["source"]=1;
$4=$recv(each)._protocol();
$ctx2.sendIdx["protocol"]=1;
return $recv($2)._install_forClass_protocol_($3,anotherClass,$4);
$ctx2.sendIdx["install:forClass:protocol:"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["valuesDo:"]=1;
$5=$recv(anotherClass)._class();
$ctx1.sendIdx["class"]=1;
$7=$recv(aClass)._class();
$ctx1.sendIdx["class"]=2;
$6=$recv($7)._instanceVariableNames();
self._basicClass_instanceVariables_($5,$6);
$9=$recv(aClass)._class();
$ctx1.sendIdx["class"]=3;
$8=$recv($9)._methodDictionary();
$recv($8)._valuesDo_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.Compiler)._new())._install_forClass_protocol_($recv(each)._source(),$recv(anotherClass)._class(),$recv(each)._protocol());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
self._setupClass_(anotherClass);
return self;
}, function($ctx1) {$ctx1.fill(self,"copyClass:to:",{aClass:aClass,anotherClass:anotherClass},$globals.ClassBuilder)});
},
args: ["aClass", "anotherClass"],
source: "copyClass: aClass to: anotherClass\x0a\x0a\x09anotherClass comment: aClass comment.\x0a\x0a\x09aClass methodDictionary valuesDo: [ :each |\x0a\x09\x09Compiler new install: each source forClass: anotherClass protocol: each protocol ].\x0a\x0a\x09self basicClass: anotherClass class instanceVariables: aClass class instanceVariableNames.\x0a\x0a\x09aClass class methodDictionary valuesDo: [ :each |\x0a\x09\x09Compiler new install: each source forClass: anotherClass class protocol: each protocol ].\x0a\x0a\x09self setupClass: anotherClass",
referencedClasses: ["Compiler"],
messageSends: ["comment:", "comment", "valuesDo:", "methodDictionary", "install:forClass:protocol:", "new", "source", "protocol", "basicClass:instanceVariables:", "class", "instanceVariableNames", "setupClass:"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "installMethod:forClass:protocol:",
protocol: 'method definition',
fn: function (aCompiledMethod,aBehavior,aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aCompiledMethod)._protocol_(aString);
$recv(aBehavior)._addCompiledMethod_(aCompiledMethod);
return aCompiledMethod;
}, function($ctx1) {$ctx1.fill(self,"installMethod:forClass:protocol:",{aCompiledMethod:aCompiledMethod,aBehavior:aBehavior,aString:aString},$globals.ClassBuilder)});
},
args: ["aCompiledMethod", "aBehavior", "aString"],
source: "installMethod: aCompiledMethod forClass: aBehavior protocol: aString\x0a\x09aCompiledMethod protocol: aString.\x0a\x09aBehavior addCompiledMethod: aCompiledMethod.\x0a\x09^ aCompiledMethod",
referencedClasses: [],
messageSends: ["protocol:", "addCompiledMethod:"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "instanceVariableNamesFor:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aString)._tokenize_(" "))._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._isEmpty();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"instanceVariableNamesFor:",{aString:aString},$globals.ClassBuilder)});
},
args: ["aString"],
source: "instanceVariableNamesFor: aString\x0a\x09^ (aString tokenize: ' ') reject: [ :each | each isEmpty ]",
referencedClasses: [],
messageSends: ["reject:", "tokenize:", "isEmpty"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "migrateClass:superclass:",
protocol: 'class migration',
fn: function (aClass,anotherClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(aClass)._name();
$ctx1.sendIdx["name"]=1;
return self._migrateClassNamed_superclass_instanceVariableNames_package_($1,anotherClass,$recv(aClass)._instanceVariableNames(),$recv($recv(aClass)._package())._name());
}, function($ctx1) {$ctx1.fill(self,"migrateClass:superclass:",{aClass:aClass,anotherClass:anotherClass},$globals.ClassBuilder)});
},
args: ["aClass", "anotherClass"],
source: "migrateClass: aClass superclass: anotherClass\x0a\x09^ self\x0a\x09\x09migrateClassNamed: aClass name\x0a\x09\x09superclass: anotherClass\x0a\x09\x09instanceVariableNames: aClass instanceVariableNames\x0a\x09\x09package: aClass package name",
referencedClasses: [],
messageSends: ["migrateClassNamed:superclass:instanceVariableNames:package:", "name", "instanceVariableNames", "package"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "migrateClassNamed:superclass:instanceVariableNames:package:",
protocol: 'class migration',
fn: function (className,aClass,aCollection,packageName){
var self=this;
var oldClass,newClass,tmp;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3;
tmp="new*".__comma(className);
oldClass=$recv($recv($globals.Smalltalk)._globals())._at_(className);
newClass=self._addSubclassOf_named_instanceVariableNames_package_(aClass,tmp,aCollection,packageName);
self._basicSwapClassNames_with_(oldClass,newClass);
$ctx1.sendIdx["basicSwapClassNames:with:"]=1;
$recv((function(){
return $core.withContext(function($ctx2) {
return self._copyClass_to_(oldClass,newClass);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(exception){
return $core.withContext(function($ctx2) {
self._basicSwapClassNames_with_(oldClass,newClass);
$1=self._basicRemoveClass_(newClass);
$ctx2.sendIdx["basicRemoveClass:"]=1;
$1;
return $recv(exception)._resignal();
}, function($ctx2) {$ctx2.fillBlock({exception:exception},$ctx1,2)});
}));
self._rawRenameClass_to_(oldClass,tmp);
$ctx1.sendIdx["rawRenameClass:to:"]=1;
self._rawRenameClass_to_(newClass,className);
$recv($recv(oldClass)._subclasses())._do_((function(each){
return $core.withContext(function($ctx2) {
return self._migrateClass_superclass_(each,newClass);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
self._basicRemoveClass_(oldClass);
$2=$recv($globals.SystemAnnouncer)._current();
$4=$recv($globals.ClassMigrated)._new();
$recv($4)._theClass_(newClass);
$recv($4)._oldClass_(oldClass);
$3=$recv($4)._yourself();
$recv($2)._announce_($3);
return newClass;
}, function($ctx1) {$ctx1.fill(self,"migrateClassNamed:superclass:instanceVariableNames:package:",{className:className,aClass:aClass,aCollection:aCollection,packageName:packageName,oldClass:oldClass,newClass:newClass,tmp:tmp},$globals.ClassBuilder)});
},
args: ["className", "aClass", "aCollection", "packageName"],
source: "migrateClassNamed: className superclass: aClass instanceVariableNames: aCollection package: packageName\x0a\x09| oldClass newClass tmp |\x0a\x09\x0a\x09tmp := 'new*', className.\x0a\x09oldClass := Smalltalk globals at: className.\x0a\x09\x0a\x09newClass := self\x0a\x09\x09addSubclassOf: aClass\x0a\x09\x09named: tmp\x0a\x09\x09instanceVariableNames: aCollection\x0a\x09\x09package: packageName.\x0a\x0a\x09self basicSwapClassNames: oldClass with: newClass.\x0a\x0a\x09[ self copyClass: oldClass to: newClass ]\x0a\x09\x09on: Error\x0a\x09\x09do: [ :exception |\x0a\x09\x09\x09self\x0a\x09\x09\x09\x09basicSwapClassNames: oldClass with: newClass;\x0a\x09\x09\x09\x09basicRemoveClass: newClass.\x0a\x09\x09\x09\x09exception resignal ].\x0a\x0a\x09self\x0a\x09\x09rawRenameClass: oldClass to: tmp;\x0a\x09\x09rawRenameClass: newClass to: className.\x0a\x0a\x09oldClass subclasses \x0a\x09\x09do: [ :each | self migrateClass: each superclass: newClass ].\x0a\x0a\x09self basicRemoveClass: oldClass.\x0a\x09\x0a\x09SystemAnnouncer current announce: (ClassMigrated new\x0a\x09\x09theClass: newClass;\x0a\x09\x09oldClass: oldClass;\x0a\x09\x09yourself).\x0a\x09\x0a\x09^ newClass",
referencedClasses: ["Smalltalk", "Error", "SystemAnnouncer", "ClassMigrated"],
messageSends: [",", "at:", "globals", "addSubclassOf:named:instanceVariableNames:package:", "basicSwapClassNames:with:", "on:do:", "copyClass:to:", "basicRemoveClass:", "resignal", "rawRenameClass:to:", "do:", "subclasses", "migrateClass:superclass:", "announce:", "current", "theClass:", "new", "oldClass:", "yourself"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "rawRenameClass:to:",
protocol: 'private',
fn: function (aClass,aString){
var self=this;
return $core.withContext(function($ctx1) {

		$globals[aString] = aClass;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"rawRenameClass:to:",{aClass:aClass,aString:aString},$globals.ClassBuilder)});
},
args: ["aClass", "aString"],
source: "rawRenameClass: aClass to: aString\x0a\x09<\x0a\x09\x09$globals[aString] = aClass;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "renameClass:to:",
protocol: 'class migration',
fn: function (aClass,className){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
self._basicRenameClass_to_(aClass,className);
$recv(aClass)._recompile();
$1=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.ClassRenamed)._new();
$recv($3)._theClass_(aClass);
$2=$recv($3)._yourself();
$recv($1)._announce_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"renameClass:to:",{aClass:aClass,className:className},$globals.ClassBuilder)});
},
args: ["aClass", "className"],
source: "renameClass: aClass to: className\x0a\x09self basicRenameClass: aClass to: className.\x0a\x09\x0a\x09\x22Recompile the class to fix potential issues with super sends\x22\x0a\x09aClass recompile.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassRenamed new\x0a\x09\x09\x09theClass: aClass;\x0a\x09\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ClassRenamed"],
messageSends: ["basicRenameClass:to:", "recompile", "announce:", "current", "theClass:", "new", "yourself"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "setupClass:",
protocol: 'public',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
$core.init(aClass);;
return self;
}, function($ctx1) {$ctx1.fill(self,"setupClass:",{aClass:aClass},$globals.ClassBuilder)});
},
args: ["aClass"],
source: "setupClass: aClass\x0a\x09<$core.init(aClass);>",
referencedClasses: [],
messageSends: []
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "superclass:subclass:",
protocol: 'class definition',
fn: function (aClass,className){
var self=this;
return $core.withContext(function($ctx1) {
return self._superclass_subclass_instanceVariableNames_package_(aClass,className,"",nil);
}, function($ctx1) {$ctx1.fill(self,"superclass:subclass:",{aClass:aClass,className:className},$globals.ClassBuilder)});
},
args: ["aClass", "className"],
source: "superclass: aClass subclass: className\x0a\x09^ self superclass: aClass subclass: className instanceVariableNames: '' package: nil",
referencedClasses: [],
messageSends: ["superclass:subclass:instanceVariableNames:package:"]
}),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "superclass:subclass:instanceVariableNames:package:",
protocol: 'class definition',
fn: function (aClass,className,ivarNames,packageName){
var self=this;
var newClass;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$4,$receiver;
$1=self._instanceVariableNamesFor_(ivarNames);
if(($receiver = packageName) == null || $receiver.isNil){
$2="unclassified";
} else {
$2=packageName;
};
newClass=self._addSubclassOf_named_instanceVariableNames_package_(aClass,className,$1,$2);
self._setupClass_(newClass);
$3=$recv($globals.SystemAnnouncer)._current();
$5=$recv($globals.ClassAdded)._new();
$recv($5)._theClass_(newClass);
$4=$recv($5)._yourself();
$recv($3)._announce_($4);
return newClass;
}, function($ctx1) {$ctx1.fill(self,"superclass:subclass:instanceVariableNames:package:",{aClass:aClass,className:className,ivarNames:ivarNames,packageName:packageName,newClass:newClass},$globals.ClassBuilder)});
},
args: ["aClass", "className", "ivarNames", "packageName"],
source: "superclass: aClass subclass: className instanceVariableNames: ivarNames package: packageName\x0a\x09| newClass |\x0a\x09\x0a\x09newClass := self addSubclassOf: aClass\x0a\x09\x09named: className instanceVariableNames: (self instanceVariableNamesFor: ivarNames)\x0a\x09\x09package: (packageName ifNil: [ 'unclassified' ]).\x0a\x09self setupClass: newClass.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassAdded new\x0a\x09\x09\x09theClass: newClass;\x0a\x09\x09\x09yourself).\x0a\x09\x0a\x09^ newClass",
referencedClasses: ["SystemAnnouncer", "ClassAdded"],
messageSends: ["addSubclassOf:named:instanceVariableNames:package:", "instanceVariableNamesFor:", "ifNil:", "setupClass:", "announce:", "current", "theClass:", "new", "yourself"]
}),
$globals.ClassBuilder);



$core.addClass('ClassSorterNode', $globals.Object, ['theClass', 'level', 'nodes'], 'Kernel-Classes');
$globals.ClassSorterNode.comment="I provide an algorithm for sorting classes alphabetically.\x0a\x0aSee [Issue #143](https://github.com/amber-smalltalk/amber/issues/143) on GitHub.";
$core.addMethod(
$core.method({
selector: "getNodesFrom:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
var children,others;
return $core.withContext(function($ctx1) {
var $1;
children=[];
others=[];
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv($recv(each)._superclass()).__eq(self._theClass());
if($core.assert($1)){
return $recv(children)._add_(each);
$ctx2.sendIdx["add:"]=1;
} else {
return $recv(others)._add_(each);
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
self["@nodes"]=$recv(children)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($globals.ClassSorterNode)._on_classes_level_(each,others,$recv(self._level()).__plus((1)));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"getNodesFrom:",{aCollection:aCollection,children:children,others:others},$globals.ClassSorterNode)});
},
args: ["aCollection"],
source: "getNodesFrom: aCollection\x0a\x09| children others |\x0a\x09children := #().\x0a\x09others := #().\x0a\x09aCollection do: [ :each |\x0a\x09\x09(each superclass = self theClass)\x0a\x09\x09\x09ifTrue: [ children add: each ]\x0a\x09\x09\x09ifFalse: [ others add: each ]].\x0a\x09nodes:= children collect: [ :each |\x0a\x09\x09ClassSorterNode on: each classes: others level: self level + 1 ]",
referencedClasses: ["ClassSorterNode"],
messageSends: ["do:", "ifTrue:ifFalse:", "=", "superclass", "theClass", "add:", "collect:", "on:classes:level:", "+", "level"]
}),
$globals.ClassSorterNode);

$core.addMethod(
$core.method({
selector: "level",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@level"];

},
args: [],
source: "level\x0a\x09^ level",
referencedClasses: [],
messageSends: []
}),
$globals.ClassSorterNode);

$core.addMethod(
$core.method({
selector: "level:",
protocol: 'accessing',
fn: function (anInteger){
var self=this;
self["@level"]=anInteger;
return self;

},
args: ["anInteger"],
source: "level: anInteger\x0a\x09level := anInteger",
referencedClasses: [],
messageSends: []
}),
$globals.ClassSorterNode);

$core.addMethod(
$core.method({
selector: "nodes",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@nodes"];

},
args: [],
source: "nodes\x0a\x09^ nodes",
referencedClasses: [],
messageSends: []
}),
$globals.ClassSorterNode);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@theClass"];

},
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
messageSends: []
}),
$globals.ClassSorterNode);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@theClass"]=aClass;
return self;

},
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.ClassSorterNode);

$core.addMethod(
$core.method({
selector: "traverseClassesWith:",
protocol: 'visiting',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
$1=self._theClass();
$ctx1.sendIdx["theClass"]=1;
$recv(aCollection)._add_($1);
$recv($recv(self._nodes())._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
$3=$recv(a)._theClass();
$ctx2.sendIdx["theClass"]=2;
$2=$recv($3)._name();
$ctx2.sendIdx["name"]=1;
return $recv($2).__lt_eq($recv($recv(b)._theClass())._name());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
})))._do_((function(aNode){
return $core.withContext(function($ctx2) {
return $recv(aNode)._traverseClassesWith_(aCollection);
}, function($ctx2) {$ctx2.fillBlock({aNode:aNode},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"traverseClassesWith:",{aCollection:aCollection},$globals.ClassSorterNode)});
},
args: ["aCollection"],
source: "traverseClassesWith: aCollection\x0a\x09\x22sort classes alphabetically Issue #143\x22\x0a\x0a\x09aCollection add: self theClass.\x0a\x09(self nodes sorted: [ :a :b | a theClass name <= b theClass name ]) do: [ :aNode |\x0a\x09\x09aNode traverseClassesWith: aCollection ].",
referencedClasses: [],
messageSends: ["add:", "theClass", "do:", "sorted:", "nodes", "<=", "name", "traverseClassesWith:"]
}),
$globals.ClassSorterNode);


$core.addMethod(
$core.method({
selector: "on:classes:level:",
protocol: 'instance creation',
fn: function (aClass,aCollection,anInteger){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._theClass_(aClass);
$recv($1)._level_(anInteger);
$recv($1)._getNodesFrom_(aCollection);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:classes:level:",{aClass:aClass,aCollection:aCollection,anInteger:anInteger},$globals.ClassSorterNode.klass)});
},
args: ["aClass", "aCollection", "anInteger"],
source: "on: aClass classes: aCollection level: anInteger\x0a\x09^ self new\x0a\x09\x09theClass: aClass;\x0a\x09\x09level: anInteger;\x0a\x09\x09getNodesFrom: aCollection;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["theClass:", "new", "level:", "getNodesFrom:", "yourself"]
}),
$globals.ClassSorterNode.klass);

});

define("amber_core/Kernel-Methods", ["amber/boot", "amber_core/Kernel-Objects"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Kernel-Methods');
$core.packages["Kernel-Methods"].innerEval = function (expr) { return eval(expr); };
$core.packages["Kernel-Methods"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('BlockClosure', $globals.Object, [], 'Kernel-Methods');
$globals.BlockClosure.comment="I represent a lexical closure.\x0aI am is directly mapped to JavaScript Function.\x0a\x0a## API\x0a\x0a1. Evaluation\x0a\x0a    My instances get evaluated with the `#value*` methods in the 'evaluating' protocol.\x0a\x0a    Example: ` [ :x | x + 1 ] value: 3 \x22Answers 4\x22 `\x0a\x0a2. Control structures\x0a\x0a    Blocks are used (together with `Boolean`) for control structures (methods in the `controlling` protocol).\x0a\x0a    Example: `aBlock whileTrue: [ ... ]`\x0a\x0a3. Error handling\x0a\x0a    I provide the `#on:do:` method for handling exceptions.\x0a\x0a    Example: ` aBlock on: MessageNotUnderstood do: [ :ex | ... ] `";
$core.addMethod(
$core.method({
selector: "applyTo:arguments:",
protocol: 'evaluating',
fn: function (anObject,aCollection){
var self=this;
return $core.withContext(function($ctx1) {
return self.apply(anObject, aCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"applyTo:arguments:",{anObject:anObject,aCollection:aCollection},$globals.BlockClosure)});
},
args: ["anObject", "aCollection"],
source: "applyTo: anObject arguments: aCollection\x0a\x09<return self.apply(anObject, aCollection)>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "asCompiledMethod:",
protocol: 'converting',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $core.method({selector:aString, fn:self});;
return self;
}, function($ctx1) {$ctx1.fill(self,"asCompiledMethod:",{aString:aString},$globals.BlockClosure)});
},
args: ["aString"],
source: "asCompiledMethod: aString\x0a\x09<return $core.method({selector:aString, fn:self});>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "compiledSource",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.toString();
return self;
}, function($ctx1) {$ctx1.fill(self,"compiledSource",{},$globals.BlockClosure)});
},
args: [],
source: "compiledSource\x0a\x09<return self.toString()>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "currySelf",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		return function () {
			var args = [ this ];
			args.push.apply(args, arguments);
			return self.apply(null, args);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"currySelf",{},$globals.BlockClosure)});
},
args: [],
source: "currySelf\x0a\x09\x22Transforms [ :selfarg :x :y | stcode ] block\x0a\x09which represents JS function (selfarg, x, y, ...) {jscode}\x0a\x09into function (x, y, ...) {jscode} that takes selfarg from 'this'.\x0a\x09IOW, it is usable as JS method and first arg takes the receiver.\x22\x0a\x09\x0a\x09<\x0a\x09\x09return function () {\x0a\x09\x09\x09var args = [ this ];\x0a\x09\x09\x09args.push.apply(args, arguments);\x0a\x09\x09\x09return self.apply(null, args);\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "ensure:",
protocol: 'evaluating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
try{return self._value()}finally{aBlock._value()};
return self;
}, function($ctx1) {$ctx1.fill(self,"ensure:",{aBlock:aBlock},$globals.BlockClosure)});
},
args: ["aBlock"],
source: "ensure: aBlock\x0a\x09<try{return self._value()}finally{aBlock._value()}>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "fork",
protocol: 'timeout/interval',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.ForkPool)._default())._fork_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"fork",{},$globals.BlockClosure)});
},
args: [],
source: "fork\x0a\x09ForkPool default fork: self",
referencedClasses: ["ForkPool"],
messageSends: ["fork:", "default"]
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "new",
protocol: 'evaluating',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return new self();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{},$globals.BlockClosure)});
},
args: [],
source: "new\x0a\x09\x22Use the receiver as a JS constructor.\x0a\x09*Do not* use this method to instanciate Smalltalk objects!\x22\x0a\x09<return new self()>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "newValue:",
protocol: 'evaluating',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self._newWithValues_([anObject]);
}, function($ctx1) {$ctx1.fill(self,"newValue:",{anObject:anObject},$globals.BlockClosure)});
},
args: ["anObject"],
source: "newValue: anObject\x0a\x09^ self newWithValues: { anObject }",
referencedClasses: [],
messageSends: ["newWithValues:"]
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "newValue:value:",
protocol: 'evaluating',
fn: function (anObject,anObject2){
var self=this;
return $core.withContext(function($ctx1) {
return self._newWithValues_([anObject,anObject2]);
}, function($ctx1) {$ctx1.fill(self,"newValue:value:",{anObject:anObject,anObject2:anObject2},$globals.BlockClosure)});
},
args: ["anObject", "anObject2"],
source: "newValue: anObject value: anObject2\x0a\x09^ self newWithValues: { anObject. anObject2 }.",
referencedClasses: [],
messageSends: ["newWithValues:"]
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "newValue:value:value:",
protocol: 'evaluating',
fn: function (anObject,anObject2,anObject3){
var self=this;
return $core.withContext(function($ctx1) {
return self._newWithValues_([anObject,anObject2,anObject3]);
}, function($ctx1) {$ctx1.fill(self,"newValue:value:value:",{anObject:anObject,anObject2:anObject2,anObject3:anObject3},$globals.BlockClosure)});
},
args: ["anObject", "anObject2", "anObject3"],
source: "newValue: anObject value: anObject2 value: anObject3\x0a\x09^ self newWithValues: { anObject. anObject2. anObject3 }.",
referencedClasses: [],
messageSends: ["newWithValues:"]
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "newWithValues:",
protocol: 'evaluating',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {

		var object = Object.create(self.prototype);
		var result = self.apply(object, aCollection);
		return typeof result === "object" ? result : object;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"newWithValues:",{aCollection:aCollection},$globals.BlockClosure)});
},
args: ["aCollection"],
source: "newWithValues: aCollection\x0a\x09\x22Simulates JS new operator by combination of Object.create and .apply\x22\x0a\x09<\x0a\x09\x09var object = Object.create(self.prototype);\x0a\x09\x09var result = self.apply(object, aCollection);\x0a\x09\x09return typeof result === \x22object\x22 ? result : object;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "numArgs",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.length;
return self;
}, function($ctx1) {$ctx1.fill(self,"numArgs",{},$globals.BlockClosure)});
},
args: [],
source: "numArgs\x0a\x09<return self.length>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "on:do:",
protocol: 'error handling',
fn: function (anErrorClass,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return self._tryCatch_((function(error){
var smalltalkError;
return $core.withContext(function($ctx2) {
smalltalkError=$recv($globals.Smalltalk)._asSmalltalkException_(error);
smalltalkError;
$1=$recv(smalltalkError)._isKindOf_(anErrorClass);
if($core.assert($1)){
return $recv(aBlock)._value_(smalltalkError);
} else {
return $recv(smalltalkError)._resignal();
};
}, function($ctx2) {$ctx2.fillBlock({error:error,smalltalkError:smalltalkError},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"on:do:",{anErrorClass:anErrorClass,aBlock:aBlock},$globals.BlockClosure)});
},
args: ["anErrorClass", "aBlock"],
source: "on: anErrorClass do: aBlock\x0a\x09\x22All exceptions thrown in the Smalltalk stack are cought.\x0a\x09Convert all JS exceptions to JavaScriptException instances.\x22\x0a\x09\x0a\x09^ self tryCatch: [ :error | | smalltalkError |\x0a\x09\x09smalltalkError := Smalltalk asSmalltalkException: error.\x0a\x09\x09(smalltalkError isKindOf: anErrorClass)\x0a\x09\x09ifTrue: [ aBlock value: smalltalkError ]\x0a\x09\x09ifFalse: [ smalltalkError resignal ] ]",
referencedClasses: ["Smalltalk"],
messageSends: ["tryCatch:", "asSmalltalkException:", "ifTrue:ifFalse:", "isKindOf:", "value:", "resignal"]
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: 'accessing',
fn: function (){
var self=this;
return nil;

},
args: [],
source: "receiver\x0a\x09^ nil",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "timeToRun",
protocol: 'evaluating',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Date)._millisecondsToRun_(self);
}, function($ctx1) {$ctx1.fill(self,"timeToRun",{},$globals.BlockClosure)});
},
args: [],
source: "timeToRun\x0a\x09\x22Answer the number of milliseconds taken to execute this block.\x22\x0a\x0a\x09^ Date millisecondsToRun: self",
referencedClasses: ["Date"],
messageSends: ["millisecondsToRun:"]
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "tryCatch:",
protocol: 'error handling',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		try {
			return self._value();
		} catch(error) {
			// pass non-local returns undetected
			if (Array.isArray(error) && error.length === 1) throw error;
			return aBlock._value_(error);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"tryCatch:",{aBlock:aBlock},$globals.BlockClosure)});
},
args: ["aBlock"],
source: "tryCatch: aBlock\x0a\x09<\x0a\x09\x09try {\x0a\x09\x09\x09return self._value();\x0a\x09\x09} catch(error) {\x0a\x09\x09\x09// pass non-local returns undetected\x0a\x09\x09\x09if (Array.isArray(error) && error.length === 1) throw error;\x0a\x09\x09\x09return aBlock._value_(error);\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "value",
protocol: 'evaluating',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self();;
return self;
}, function($ctx1) {$ctx1.fill(self,"value",{},$globals.BlockClosure)});
},
args: [],
source: "value\x0a\x09<return self();>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "value:",
protocol: 'evaluating',
fn: function (anArg){
var self=this;
return $core.withContext(function($ctx1) {
return self(anArg);;
return self;
}, function($ctx1) {$ctx1.fill(self,"value:",{anArg:anArg},$globals.BlockClosure)});
},
args: ["anArg"],
source: "value: anArg\x0a\x09<return self(anArg);>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "value:value:",
protocol: 'evaluating',
fn: function (firstArg,secondArg){
var self=this;
return $core.withContext(function($ctx1) {
return self(firstArg, secondArg);;
return self;
}, function($ctx1) {$ctx1.fill(self,"value:value:",{firstArg:firstArg,secondArg:secondArg},$globals.BlockClosure)});
},
args: ["firstArg", "secondArg"],
source: "value: firstArg value: secondArg\x0a\x09<return self(firstArg, secondArg);>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "value:value:value:",
protocol: 'evaluating',
fn: function (firstArg,secondArg,thirdArg){
var self=this;
return $core.withContext(function($ctx1) {
return self(firstArg, secondArg, thirdArg);;
return self;
}, function($ctx1) {$ctx1.fill(self,"value:value:value:",{firstArg:firstArg,secondArg:secondArg,thirdArg:thirdArg},$globals.BlockClosure)});
},
args: ["firstArg", "secondArg", "thirdArg"],
source: "value: firstArg value: secondArg value: thirdArg\x0a\x09<return self(firstArg, secondArg, thirdArg);>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "valueWithInterval:",
protocol: 'timeout/interval',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {

		var interval = setInterval(self, aNumber);
		return $globals.Timeout._on_(interval);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"valueWithInterval:",{aNumber:aNumber},$globals.BlockClosure)});
},
args: ["aNumber"],
source: "valueWithInterval: aNumber\x0a\x09<\x0a\x09\x09var interval = setInterval(self, aNumber);\x0a\x09\x09return $globals.Timeout._on_(interval);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "valueWithPossibleArguments:",
protocol: 'evaluating',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
return self.apply(null, aCollection);;
return self;
}, function($ctx1) {$ctx1.fill(self,"valueWithPossibleArguments:",{aCollection:aCollection},$globals.BlockClosure)});
},
args: ["aCollection"],
source: "valueWithPossibleArguments: aCollection\x0a\x09<return self.apply(null, aCollection);>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "valueWithTimeout:",
protocol: 'timeout/interval',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {

		var timeout = setTimeout(self, aNumber);
		return $globals.Timeout._on_(timeout);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"valueWithTimeout:",{aNumber:aNumber},$globals.BlockClosure)});
},
args: ["aNumber"],
source: "valueWithTimeout: aNumber\x0a\x09<\x0a\x09\x09var timeout = setTimeout(self, aNumber);\x0a\x09\x09return $globals.Timeout._on_(timeout);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "whileFalse",
protocol: 'controlling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._whileFalse_((function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"whileFalse",{},$globals.BlockClosure)});
},
args: [],
source: "whileFalse\x0a\x09self whileFalse: []",
referencedClasses: [],
messageSends: ["whileFalse:"]
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "whileFalse:",
protocol: 'controlling',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
while(!$core.assert(self._value())) {aBlock._value()};
return self;
}, function($ctx1) {$ctx1.fill(self,"whileFalse:",{aBlock:aBlock},$globals.BlockClosure)});
},
args: ["aBlock"],
source: "whileFalse: aBlock\x0a\x09<while(!$core.assert(self._value())) {aBlock._value()}>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "whileTrue",
protocol: 'controlling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._whileTrue_((function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"whileTrue",{},$globals.BlockClosure)});
},
args: [],
source: "whileTrue\x0a\x09self whileTrue: []",
referencedClasses: [],
messageSends: ["whileTrue:"]
}),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "whileTrue:",
protocol: 'controlling',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
while($core.assert(self._value())) {aBlock._value()};
return self;
}, function($ctx1) {$ctx1.fill(self,"whileTrue:",{aBlock:aBlock},$globals.BlockClosure)});
},
args: ["aBlock"],
source: "whileTrue: aBlock\x0a\x09<while($core.assert(self._value())) {aBlock._value()}>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosure);



$core.addClass('CompiledMethod', $globals.Object, [], 'Kernel-Methods');
$globals.CompiledMethod.comment="I represent a class method of the system. I hold the source and compiled code of a class method.\x0a\x0a## API\x0aMy instances can be accessed using `Behavior >> #methodAt:`\x0a\x0a    Object methodAt: 'asString'\x0a\x0aSource code access:\x0a\x0a\x09(String methodAt: 'lines') source\x0a\x0aReferenced classes:\x0a\x0a\x09(String methodAt: 'lines') referencedClasses\x0a\x0aMessages sent from an instance:\x0a\x09\x0a\x09(String methodAt: 'lines') messageSends";
$core.addMethod(
$core.method({
selector: "arguments",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.args || [];
return self;
}, function($ctx1) {$ctx1.fill(self,"arguments",{},$globals.CompiledMethod)});
},
args: [],
source: "arguments\x0a\x09<return self.args || []>",
referencedClasses: [],
messageSends: []
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "browse",
protocol: 'browsing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Finder)._findMethod_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"browse",{},$globals.CompiledMethod)});
},
args: [],
source: "browse\x0a\x09Finder findMethod: self",
referencedClasses: ["Finder"],
messageSends: ["findMethod:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "category",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._protocol();
}, function($ctx1) {$ctx1.fill(self,"category",{},$globals.CompiledMethod)});
},
args: [],
source: "category\x0a\x09^ self protocol",
referencedClasses: [],
messageSends: ["protocol"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "defaultProtocol",
protocol: 'defaults',
fn: function (){
var self=this;
return "as yet unclassified";

},
args: [],
source: "defaultProtocol\x0a\x09^ 'as yet unclassified'",
referencedClasses: [],
messageSends: []
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "fn",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._basicAt_("fn");
}, function($ctx1) {$ctx1.fill(self,"fn",{},$globals.CompiledMethod)});
},
args: [],
source: "fn\x0a\x09^ self basicAt: 'fn'",
referencedClasses: [],
messageSends: ["basicAt:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "fn:",
protocol: 'accessing',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._basicAt_put_("fn",aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"fn:",{aBlock:aBlock},$globals.CompiledMethod)});
},
args: ["aBlock"],
source: "fn: aBlock\x0a\x09self basicAt: 'fn' put: aBlock",
referencedClasses: [],
messageSends: ["basicAt:put:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "isCompiledMethod",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isCompiledMethod\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "isOverridden",
protocol: 'testing',
fn: function (){
var self=this;
var selector;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
selector=self._selector();
$recv(self._methodClass())._allSubclassesDo_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(each)._includesSelector_(selector);
if($core.assert($1)){
throw $early=[true];
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return false;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"isOverridden",{selector:selector},$globals.CompiledMethod)});
},
args: [],
source: "isOverridden\x0a\x09| selector |\x0a    \x0a    selector := self selector.\x0a    self methodClass allSubclassesDo: [ :each |\x0a\x09    (each includesSelector: selector)\x0a        \x09ifTrue: [ ^ true ] ].\x0a\x09^ false",
referencedClasses: [],
messageSends: ["selector", "allSubclassesDo:", "methodClass", "ifTrue:", "includesSelector:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "isOverride",
protocol: 'testing',
fn: function (){
var self=this;
var superclass;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
$1=self._methodClass();
$ctx1.sendIdx["methodClass"]=1;
superclass=$recv($1)._superclass();
$ctx1.sendIdx["superclass"]=1;
$2=superclass;
if(($receiver = $2) == null || $receiver.isNil){
return false;
} else {
$2;
};
return $recv($recv($recv(self._methodClass())._superclass())._lookupSelector_(self._selector()))._notNil();
}, function($ctx1) {$ctx1.fill(self,"isOverride",{superclass:superclass},$globals.CompiledMethod)});
},
args: [],
source: "isOverride\x0a\x09| superclass |\x0a    \x0a    superclass := self methodClass superclass.\x0a\x09superclass ifNil: [ ^ false ].\x0a\x09\x0a    ^ (self methodClass superclass lookupSelector: self selector) notNil",
referencedClasses: [],
messageSends: ["superclass", "methodClass", "ifNil:", "notNil", "lookupSelector:", "selector"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "messageSends",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._basicAt_("messageSends");
}, function($ctx1) {$ctx1.fill(self,"messageSends",{},$globals.CompiledMethod)});
},
args: [],
source: "messageSends\x0a\x09^ self basicAt: 'messageSends'",
referencedClasses: [],
messageSends: ["basicAt:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "methodClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._basicAt_("methodClass");
}, function($ctx1) {$ctx1.fill(self,"methodClass",{},$globals.CompiledMethod)});
},
args: [],
source: "methodClass\x0a\x09^ self basicAt: 'methodClass'",
referencedClasses: [],
messageSends: ["basicAt:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "package",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._methodClass();
if(($receiver = $1) == null || $receiver.isNil){
return $1;
} else {
var class_;
class_=$receiver;
return $recv(class_)._packageOfProtocol_(self._protocol());
};
}, function($ctx1) {$ctx1.fill(self,"package",{},$globals.CompiledMethod)});
},
args: [],
source: "package\x0a\x09\x22Answer the package the receiver belongs to:\x0a\x09- if it is an extension method, answer the corresponding package\x0a\x09- else answer the `methodClass` package\x22\x0a\x09\x0a\x09^ self methodClass ifNotNil: [ :class | class packageOfProtocol: self protocol ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "methodClass", "packageOfProtocol:", "protocol"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "protocol",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._basicAt_("protocol");
if(($receiver = $1) == null || $receiver.isNil){
return self._defaultProtocol();
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"protocol",{},$globals.CompiledMethod)});
},
args: [],
source: "protocol\x0a\x09^ (self basicAt: 'protocol') ifNil: [ self defaultProtocol ]",
referencedClasses: [],
messageSends: ["ifNil:", "basicAt:", "defaultProtocol"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "protocol:",
protocol: 'accessing',
fn: function (aString){
var self=this;
var oldProtocol;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$4,$receiver;
oldProtocol=self._protocol();
self._basicAt_put_("protocol",aString);
$1=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.MethodMoved)._new();
$recv($3)._method_(self);
$recv($3)._oldProtocol_(oldProtocol);
$2=$recv($3)._yourself();
$recv($1)._announce_($2);
$4=self._methodClass();
if(($receiver = $4) == null || $receiver.isNil){
$4;
} else {
var methodClass;
methodClass=$receiver;
$recv($recv(methodClass)._organization())._addElement_(aString);
$recv(methodClass)._removeProtocolIfEmpty_(oldProtocol);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"protocol:",{aString:aString,oldProtocol:oldProtocol},$globals.CompiledMethod)});
},
args: ["aString"],
source: "protocol: aString\x0a\x09| oldProtocol |\x0a\x09oldProtocol := self protocol.\x0a\x09self basicAt: 'protocol' put: aString.\x0a\x0a\x09SystemAnnouncer current announce: (MethodMoved new\x0a\x09\x09method: self;\x0a\x09\x09oldProtocol: oldProtocol;\x0a\x09\x09yourself).\x0a\x0a\x09self methodClass ifNotNil: [ :methodClass |\x0a\x09\x09methodClass organization addElement: aString.\x0a\x09\x09methodClass removeProtocolIfEmpty: oldProtocol ]",
referencedClasses: ["SystemAnnouncer", "MethodMoved"],
messageSends: ["protocol", "basicAt:put:", "announce:", "current", "method:", "new", "oldProtocol:", "yourself", "ifNotNil:", "methodClass", "addElement:", "organization", "removeProtocolIfEmpty:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "referencedClasses",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._basicAt_("referencedClasses");
}, function($ctx1) {$ctx1.fill(self,"referencedClasses",{},$globals.CompiledMethod)});
},
args: [],
source: "referencedClasses\x0a\x09^ self basicAt: 'referencedClasses'",
referencedClasses: [],
messageSends: ["basicAt:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._basicAt_("selector");
}, function($ctx1) {$ctx1.fill(self,"selector",{},$globals.CompiledMethod)});
},
args: [],
source: "selector\x0a\x09^ self basicAt: 'selector'",
referencedClasses: [],
messageSends: ["basicAt:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._basicAt_put_("selector",aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"selector:",{aString:aString},$globals.CompiledMethod)});
},
args: ["aString"],
source: "selector: aString\x0a\x09self basicAt: 'selector' put: aString",
referencedClasses: [],
messageSends: ["basicAt:put:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "sendTo:arguments:",
protocol: 'evaluating',
fn: function (anObject,aCollection){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._fn())._applyTo_arguments_(anObject,aCollection);
}, function($ctx1) {$ctx1.fill(self,"sendTo:arguments:",{anObject:anObject,aCollection:aCollection},$globals.CompiledMethod)});
},
args: ["anObject", "aCollection"],
source: "sendTo: anObject arguments: aCollection\x0a\x09^ self fn applyTo: anObject arguments: aCollection",
referencedClasses: [],
messageSends: ["applyTo:arguments:", "fn"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "source",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._basicAt_("source");
if(($receiver = $1) == null || $receiver.isNil){
return "";
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"source",{},$globals.CompiledMethod)});
},
args: [],
source: "source\x0a\x09^ (self basicAt: 'source') ifNil: [ '' ]",
referencedClasses: [],
messageSends: ["ifNil:", "basicAt:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "source:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._basicAt_put_("source",aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"source:",{aString:aString},$globals.CompiledMethod)});
},
args: ["aString"],
source: "source: aString\x0a\x09self basicAt: 'source' put: aString",
referencedClasses: [],
messageSends: ["basicAt:put:"]
}),
$globals.CompiledMethod);



$core.addClass('ForkPool', $globals.Object, ['poolSize', 'maxPoolSize', 'queue', 'worker'], 'Kernel-Methods');
$globals.ForkPool.comment="I am responsible for handling forked blocks.\x0aThe pool size sets the maximum concurrent forked blocks.\x0a\x0a## API\x0a\x0aThe default instance is accessed with `#default`.\x0aThe maximum concurrent forked blocks can be set with `#maxPoolSize:`.\x0a\x0aForking is done via `BlockClosure >> #fork`";
$core.addMethod(
$core.method({
selector: "addWorker",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@worker"])._valueWithTimeout_((0));
self["@poolSize"]=$recv(self["@poolSize"]).__plus((1));
return self;
}, function($ctx1) {$ctx1.fill(self,"addWorker",{},$globals.ForkPool)});
},
args: [],
source: "addWorker\x0a\x09worker valueWithTimeout: 0.\x0a\x09poolSize := poolSize + 1",
referencedClasses: [],
messageSends: ["valueWithTimeout:", "+"]
}),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "defaultMaxPoolSize",
protocol: 'defaults',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._class())._defaultMaxPoolSize();
}, function($ctx1) {$ctx1.fill(self,"defaultMaxPoolSize",{},$globals.ForkPool)});
},
args: [],
source: "defaultMaxPoolSize\x0a\x09^ self class defaultMaxPoolSize",
referencedClasses: [],
messageSends: ["defaultMaxPoolSize", "class"]
}),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "fork:",
protocol: 'actions',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self["@poolSize"]).__lt(self._maxPoolSize());
if($core.assert($1)){
self._addWorker();
};
$recv(self["@queue"])._nextPut_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"fork:",{aBlock:aBlock},$globals.ForkPool)});
},
args: ["aBlock"],
source: "fork: aBlock\x0a\x09poolSize < self maxPoolSize ifTrue: [ self addWorker ].\x0a\x09queue nextPut: aBlock",
referencedClasses: [],
messageSends: ["ifTrue:", "<", "maxPoolSize", "addWorker", "nextPut:"]
}),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.ForkPool.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@poolSize"]=(0);
self["@queue"]=$recv($globals.Queue)._new();
self["@worker"]=self._makeWorker();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.ForkPool)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09\x0a\x09poolSize := 0.\x0a\x09queue := Queue new.\x0a\x09worker := self makeWorker",
referencedClasses: ["Queue"],
messageSends: ["initialize", "new", "makeWorker"]
}),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "makeWorker",
protocol: 'initialization',
fn: function (){
var self=this;
var sentinel;
return $core.withContext(function($ctx1) {
var $1;
sentinel=$recv($globals.Object)._new();
return (function(){
var block;
return $core.withContext(function($ctx2) {
self["@poolSize"]=$recv(self["@poolSize"]).__minus((1));
self["@poolSize"];
block=$recv(self["@queue"])._nextIfAbsent_((function(){
return sentinel;

}));
block;
$1=$recv(block).__eq_eq(sentinel);
if(!$core.assert($1)){
return $recv((function(){
return $core.withContext(function($ctx3) {
return $recv(block)._value();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,4)});
}))._ensure_((function(){
return $core.withContext(function($ctx3) {
return self._addWorker();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,5)});
}));
};
}, function($ctx2) {$ctx2.fillBlock({block:block},$ctx1,1)});
});
}, function($ctx1) {$ctx1.fill(self,"makeWorker",{sentinel:sentinel},$globals.ForkPool)});
},
args: [],
source: "makeWorker\x0a\x09| sentinel |\x0a\x09sentinel := Object new.\x0a\x09^ [ | block |\x0a\x09\x09poolSize := poolSize - 1.\x0a\x09\x09block := queue nextIfAbsent: [ sentinel ].\x0a\x09\x09block == sentinel ifFalse: [\x0a\x09\x09\x09[ block value ] ensure: [ self addWorker ] ]]",
referencedClasses: ["Object"],
messageSends: ["new", "-", "nextIfAbsent:", "ifFalse:", "==", "ensure:", "value", "addWorker"]
}),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "maxPoolSize",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@maxPoolSize"];
if(($receiver = $1) == null || $receiver.isNil){
return self._defaultMaxPoolSize();
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"maxPoolSize",{},$globals.ForkPool)});
},
args: [],
source: "maxPoolSize\x0a\x09^ maxPoolSize ifNil: [ self defaultMaxPoolSize ]",
referencedClasses: [],
messageSends: ["ifNil:", "defaultMaxPoolSize"]
}),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "maxPoolSize:",
protocol: 'accessing',
fn: function (anInteger){
var self=this;
self["@maxPoolSize"]=anInteger;
return self;

},
args: ["anInteger"],
source: "maxPoolSize: anInteger\x0a\x09maxPoolSize := anInteger",
referencedClasses: [],
messageSends: []
}),
$globals.ForkPool);


$globals.ForkPool.klass.iVarNames = ['default'];
$core.addMethod(
$core.method({
selector: "default",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@default"];
if(($receiver = $1) == null || $receiver.isNil){
self["@default"]=self._new();
return self["@default"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"default",{},$globals.ForkPool.klass)});
},
args: [],
source: "default\x0a\x09^ default ifNil: [ default := self new ]",
referencedClasses: [],
messageSends: ["ifNil:", "new"]
}),
$globals.ForkPool.klass);

$core.addMethod(
$core.method({
selector: "defaultMaxPoolSize",
protocol: 'accessing',
fn: function (){
var self=this;
return (100);

},
args: [],
source: "defaultMaxPoolSize\x0a\x09^ 100",
referencedClasses: [],
messageSends: []
}),
$globals.ForkPool.klass);

$core.addMethod(
$core.method({
selector: "resetDefault",
protocol: 'accessing',
fn: function (){
var self=this;
self["@default"]=nil;
return self;

},
args: [],
source: "resetDefault\x0a\x09default := nil",
referencedClasses: [],
messageSends: []
}),
$globals.ForkPool.klass);


$core.addClass('Message', $globals.Object, ['selector', 'arguments'], 'Kernel-Methods');
$globals.Message.comment="In general, the system does not use instances of me for efficiency reasons.\x0aHowever, when a message is not understood by its receiver, the interpreter will make up an instance of it in order to capture the information involved in an actual message transmission.\x0aThis instance is sent it as an argument with the message `#doesNotUnderstand:` to the receiver.\x0a\x0aSee boot.js, `messageNotUnderstood` and its counterpart `Object >> #doesNotUnderstand:`\x0a\x0a## API\x0a\x0aBesides accessing methods, `#sendTo:` provides a convenient way to send a message to an object.";
$core.addMethod(
$core.method({
selector: "arguments",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@arguments"];

},
args: [],
source: "arguments\x0a\x09^ arguments",
referencedClasses: [],
messageSends: []
}),
$globals.Message);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: 'accessing',
fn: function (anArray){
var self=this;
self["@arguments"]=anArray;
return self;

},
args: ["anArray"],
source: "arguments: anArray\x0a\x09arguments := anArray",
referencedClasses: [],
messageSends: []
}),
$globals.Message);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Message.superclass||$boot.dnu).fn.prototype._printOn_.apply($recv(self), [aStream]));
$ctx1.supercall = false;
$recv(aStream)._nextPutAll_("(");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_(self._selector());
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Message)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09aStream\x0a\x09\x09nextPutAll: '(';\x0a\x09\x09nextPutAll: self selector;\x0a\x09\x09nextPutAll: ')'",
referencedClasses: [],
messageSends: ["printOn:", "nextPutAll:", "selector"]
}),
$globals.Message);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@selector"];

},
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
messageSends: []
}),
$globals.Message);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@selector"]=aString;
return self;

},
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
messageSends: []
}),
$globals.Message);

$core.addMethod(
$core.method({
selector: "sendTo:",
protocol: 'actions',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(anObject)._perform_withArguments_(self._selector(),self._arguments());
}, function($ctx1) {$ctx1.fill(self,"sendTo:",{anObject:anObject},$globals.Message)});
},
args: ["anObject"],
source: "sendTo: anObject\x0a\x09^ anObject perform: self selector withArguments: self arguments",
referencedClasses: [],
messageSends: ["perform:withArguments:", "selector", "arguments"]
}),
$globals.Message);


$core.addMethod(
$core.method({
selector: "selector:arguments:",
protocol: 'instance creation',
fn: function (aString,anArray){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._selector_(aString);
$recv($1)._arguments_(anArray);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"selector:arguments:",{aString:aString,anArray:anArray},$globals.Message.klass)});
},
args: ["aString", "anArray"],
source: "selector: aString arguments: anArray\x0a\x09^ self new\x0a\x09\x09selector: aString;\x0a\x09\x09arguments: anArray;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["selector:", "new", "arguments:", "yourself"]
}),
$globals.Message.klass);


$core.addClass('MessageSend', $globals.Object, ['receiver', 'message'], 'Kernel-Methods');
$globals.MessageSend.comment="I encapsulate message sends to objects. Arguments can be either predefined or supplied when the message send is performed. \x0a\x0a## API\x0a\x0aUse `#value` to perform a message send with its predefined arguments and `#value:*` if additonal arguments have to supplied.";
$core.addMethod(
$core.method({
selector: "arguments",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@message"])._arguments();
}, function($ctx1) {$ctx1.fill(self,"arguments",{},$globals.MessageSend)});
},
args: [],
source: "arguments\x0a\x09^ message arguments",
referencedClasses: [],
messageSends: ["arguments"]
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@message"])._arguments_(aCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"arguments:",{aCollection:aCollection},$globals.MessageSend)});
},
args: ["aCollection"],
source: "arguments: aCollection\x0a\x09message arguments: aCollection",
referencedClasses: [],
messageSends: ["arguments:"]
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.MessageSend.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@message"]=$recv($globals.Message)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.MessageSend)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09message := Message new",
referencedClasses: ["Message"],
messageSends: ["initialize", "new"]
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.MessageSend.superclass||$boot.dnu).fn.prototype._printOn_.apply($recv(self), [aStream]));
$ctx1.supercall = false;
$recv(aStream)._nextPutAll_("(");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_(self._receiver());
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_(" >> ");
$ctx1.sendIdx["nextPutAll:"]=3;
$recv(aStream)._nextPutAll_(self._selector());
$ctx1.sendIdx["nextPutAll:"]=4;
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.MessageSend)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09aStream\x0a\x09\x09nextPutAll: '(';\x0a\x09\x09nextPutAll: self receiver;\x0a\x09\x09nextPutAll: ' >> ';\x0a\x09\x09nextPutAll: self selector;\x0a\x09\x09nextPutAll: ')'",
referencedClasses: [],
messageSends: ["printOn:", "nextPutAll:", "receiver", "selector"]
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@receiver"];

},
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
messageSends: []
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@receiver"]=anObject;
return self;

},
args: ["anObject"],
source: "receiver: anObject\x0a\x09receiver := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@message"])._selector();
}, function($ctx1) {$ctx1.fill(self,"selector",{},$globals.MessageSend)});
},
args: [],
source: "selector\x0a\x09^ message selector",
referencedClasses: [],
messageSends: ["selector"]
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@message"])._selector_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"selector:",{aString:aString},$globals.MessageSend)});
},
args: ["aString"],
source: "selector: aString\x0a\x09message selector: aString",
referencedClasses: [],
messageSends: ["selector:"]
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "value",
protocol: 'evaluating',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@message"])._sendTo_(self._receiver());
}, function($ctx1) {$ctx1.fill(self,"value",{},$globals.MessageSend)});
},
args: [],
source: "value\x0a\x09^ message sendTo: self receiver",
referencedClasses: [],
messageSends: ["sendTo:", "receiver"]
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "value:",
protocol: 'evaluating',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self["@message"];
$recv($1)._arguments_([anObject]);
return $recv($1)._sendTo_(self._receiver());
}, function($ctx1) {$ctx1.fill(self,"value:",{anObject:anObject},$globals.MessageSend)});
},
args: ["anObject"],
source: "value: anObject\x0a\x09^ message \x0a\x09\x09arguments: { anObject };\x0a\x09\x09sendTo: self receiver",
referencedClasses: [],
messageSends: ["arguments:", "sendTo:", "receiver"]
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "value:value:",
protocol: 'evaluating',
fn: function (firstArgument,secondArgument){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self["@message"];
$recv($1)._arguments_([firstArgument,secondArgument]);
return $recv($1)._sendTo_(self._receiver());
}, function($ctx1) {$ctx1.fill(self,"value:value:",{firstArgument:firstArgument,secondArgument:secondArgument},$globals.MessageSend)});
},
args: ["firstArgument", "secondArgument"],
source: "value: firstArgument value: secondArgument\x0a\x09^ message \x0a\x09\x09arguments: { firstArgument. secondArgument };\x0a\x09\x09sendTo: self receiver",
referencedClasses: [],
messageSends: ["arguments:", "sendTo:", "receiver"]
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "value:value:value:",
protocol: 'evaluating',
fn: function (firstArgument,secondArgument,thirdArgument){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self["@message"];
$recv($1)._arguments_([firstArgument,secondArgument,thirdArgument]);
return $recv($1)._sendTo_(self._receiver());
}, function($ctx1) {$ctx1.fill(self,"value:value:value:",{firstArgument:firstArgument,secondArgument:secondArgument,thirdArgument:thirdArgument},$globals.MessageSend)});
},
args: ["firstArgument", "secondArgument", "thirdArgument"],
source: "value: firstArgument value: secondArgument value: thirdArgument\x0a\x09^ message \x0a\x09\x09arguments: { firstArgument. secondArgument. thirdArgument };\x0a\x09\x09sendTo: self receiver",
referencedClasses: [],
messageSends: ["arguments:", "sendTo:", "receiver"]
}),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "valueWithPossibleArguments:",
protocol: 'evaluating',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
self._arguments_(aCollection);
return self._value();
}, function($ctx1) {$ctx1.fill(self,"valueWithPossibleArguments:",{aCollection:aCollection},$globals.MessageSend)});
},
args: ["aCollection"],
source: "valueWithPossibleArguments: aCollection\x0a\x09self arguments: aCollection.\x0a\x09^ self value",
referencedClasses: [],
messageSends: ["arguments:", "value"]
}),
$globals.MessageSend);



$core.addClass('MethodContext', $globals.Object, [], 'Kernel-Methods');
$globals.MethodContext.comment="I hold all the dynamic state associated with the execution of either a method activation resulting from a message send. I am used to build the call stack while debugging.\x0a\x0aMy instances are JavaScript `SmalltalkMethodContext` objects defined in `boot.js`.";
$core.addMethod(
$core.method({
selector: "asString",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$5,$7,$6,$4,$11,$10,$9,$8,$12,$16,$15,$14,$13,$1;
$2=self._isBlockContext();
if($core.assert($2)){
$3="a block (in ".__comma($recv(self._methodContext())._asString());
$ctx1.sendIdx[","]=2;
$1=$recv($3).__comma(")");
$ctx1.sendIdx[","]=1;
} else {
var methodClass;
methodClass=$recv(self._method())._methodClass();
methodClass;
$5=methodClass;
$7=self._receiver();
$ctx1.sendIdx["receiver"]=1;
$6=$recv($7)._class();
$ctx1.sendIdx["class"]=1;
$4=$recv($5).__eq($6);
if($core.assert($4)){
$11=self._receiver();
$ctx1.sendIdx["receiver"]=2;
$10=$recv($11)._class();
$ctx1.sendIdx["class"]=2;
$9=$recv($10)._name();
$ctx1.sendIdx["name"]=1;
$8=$recv($9).__comma(" >> ");
$ctx1.sendIdx[","]=4;
$12=self._selector();
$ctx1.sendIdx["selector"]=1;
$1=$recv($8).__comma($12);
$ctx1.sendIdx[","]=3;
} else {
$16=$recv($recv(self._receiver())._class())._name();
$ctx1.sendIdx["name"]=2;
$15=$recv($16).__comma("(");
$14=$recv($15).__comma($recv(methodClass)._name());
$ctx1.sendIdx[","]=7;
$13=$recv($14).__comma(") >> ");
$ctx1.sendIdx[","]=6;
$1=$recv($13).__comma(self._selector());
$ctx1.sendIdx[","]=5;
};
};
return $1;
}, function($ctx1) {$ctx1.fill(self,"asString",{},$globals.MethodContext)});
},
args: [],
source: "asString\x0a\x09^ self isBlockContext\x0a\x09\x09ifTrue: [ 'a block (in ', self methodContext asString, ')' ]\x0a\x09\x09ifFalse: [ \x0a\x09\x09\x09| methodClass |\x0a\x09\x09\x09methodClass := self method methodClass.\x0a\x09\x09\x09methodClass = self receiver class \x0a\x09\x09\x09\x09ifTrue: [ self receiver class name, ' >> ', self selector ]\x0a\x09\x09\x09\x09ifFalse: [ self receiver class name, '(', methodClass name, ') >> ', self selector ] ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "isBlockContext", ",", "asString", "methodContext", "methodClass", "method", "=", "class", "receiver", "name", "selector"]
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "basicReceiver",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.receiver;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicReceiver",{},$globals.MethodContext)});
},
args: [],
source: "basicReceiver\x0a\x09<return self.receiver>",
referencedClasses: [],
messageSends: []
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "evaluatedSelector",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.evaluatedSelector;
return self;
}, function($ctx1) {$ctx1.fill(self,"evaluatedSelector",{},$globals.MethodContext)});
},
args: [],
source: "evaluatedSelector\x0a\x09<return self.evaluatedSelector>",
referencedClasses: [],
messageSends: []
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "findContextSuchThat:",
protocol: 'accessing',
fn: function (testBlock){
var self=this;
var context;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
context=self;
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(context)._isNil();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
$1=$recv(testBlock)._value_(context);
if($core.assert($1)){
throw $early=[context];
};
context=$recv(context)._outerContext();
return context;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return nil;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"findContextSuchThat:",{testBlock:testBlock,context:context},$globals.MethodContext)});
},
args: ["testBlock"],
source: "findContextSuchThat: testBlock\x0a\x09\x22Search self and my sender chain for first one that satisfies `testBlock`.  \x0a\x09Answer `nil` if none satisfy\x22\x0a\x0a\x09| context |\x0a\x09\x0a\x09context := self.\x0a\x09[ context isNil] whileFalse: [\x0a\x09\x09(testBlock value: context) \x0a\x09\x09\x09ifTrue: [ ^ context ].\x0a\x09\x09context := context outerContext ].\x0a\x0a\x09^ nil",
referencedClasses: [],
messageSends: ["whileFalse:", "isNil", "ifTrue:", "value:", "outerContext"]
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "home",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.homeContext;
return self;
}, function($ctx1) {$ctx1.fill(self,"home",{},$globals.MethodContext)});
},
args: [],
source: "home\x0a\x09<return self.homeContext>",
referencedClasses: [],
messageSends: []
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "index",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.index || 0;
return self;
}, function($ctx1) {$ctx1.fill(self,"index",{},$globals.MethodContext)});
},
args: [],
source: "index\x0a\x09<return self.index || 0>",
referencedClasses: [],
messageSends: []
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "isBlockContext",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._selector())._isNil();
}, function($ctx1) {$ctx1.fill(self,"isBlockContext",{},$globals.MethodContext)});
},
args: [],
source: "isBlockContext\x0a\x09\x22Block context do not have selectors.\x22\x0a\x09\x0a\x09^ self selector isNil",
referencedClasses: [],
messageSends: ["isNil", "selector"]
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "locals",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.locals || {};
return self;
}, function($ctx1) {$ctx1.fill(self,"locals",{},$globals.MethodContext)});
},
args: [],
source: "locals\x0a\x09<return self.locals || {}>",
referencedClasses: [],
messageSends: []
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "method",
protocol: 'accessing',
fn: function (){
var self=this;
var method,lookupClass,receiverClass,supercall;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$4,$6,$5,$7,$8,$receiver;
$1=self._methodContext();
$ctx1.sendIdx["methodContext"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return nil;
} else {
$1;
};
$3=self._methodContext();
$ctx1.sendIdx["methodContext"]=2;
$2=$recv($3)._receiver();
receiverClass=$recv($2)._class();
$4=receiverClass;
$6=self._methodContext();
$ctx1.sendIdx["methodContext"]=3;
$5=$recv($6)._selector();
$ctx1.sendIdx["selector"]=1;
method=$recv($4)._lookupSelector_($5);
$ctx1.sendIdx["lookupSelector:"]=1;
$7=self._outerContext();
if(($receiver = $7) == null || $receiver.isNil){
supercall=false;
} else {
var outer;
outer=$receiver;
supercall=$recv(outer)._supercall();
};
$8=supercall;
if($core.assert($8)){
return $recv($recv($recv(method)._methodClass())._superclass())._lookupSelector_($recv(self._methodContext())._selector());
} else {
return method;
};
}, function($ctx1) {$ctx1.fill(self,"method",{method:method,lookupClass:lookupClass,receiverClass:receiverClass,supercall:supercall},$globals.MethodContext)});
},
args: [],
source: "method\x0a\x09| method lookupClass receiverClass supercall |\x0a\x09\x0a\x09self methodContext ifNil: [ ^ nil ].\x0a\x0a\x09receiverClass := self methodContext receiver class.\x0a\x09method := receiverClass lookupSelector: self methodContext selector.\x0a\x09supercall := self outerContext \x0a\x09\x09ifNil: [ false ]\x0a\x09\x09ifNotNil: [ :outer | outer supercall ].\x0a\x0a\x09^ supercall\x0a\x09\x09ifFalse: [ method ]\x0a\x09\x09ifTrue: [ method methodClass superclass lookupSelector: self methodContext selector ]",
referencedClasses: [],
messageSends: ["ifNil:", "methodContext", "class", "receiver", "lookupSelector:", "selector", "ifNil:ifNotNil:", "outerContext", "supercall", "ifFalse:ifTrue:", "superclass", "methodClass"]
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "methodContext",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
$1=self._isBlockContext();
if(!$core.assert($1)){
return self;
};
$2=self._outerContext();
if(($receiver = $2) == null || $receiver.isNil){
return $2;
} else {
var outer;
outer=$receiver;
return $recv(outer)._methodContext();
};
}, function($ctx1) {$ctx1.fill(self,"methodContext",{},$globals.MethodContext)});
},
args: [],
source: "methodContext\x0a\x09self isBlockContext ifFalse: [ ^ self ].\x0a\x09\x0a\x09^ self outerContext ifNotNil: [ :outer |\x0a\x09\x09outer methodContext ]",
referencedClasses: [],
messageSends: ["ifFalse:", "isBlockContext", "ifNotNil:", "outerContext", "methodContext"]
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "outerContext",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.outerContext || self.homeContext;
return self;
}, function($ctx1) {$ctx1.fill(self,"outerContext",{},$globals.MethodContext)});
},
args: [],
source: "outerContext\x0a\x09<return self.outerContext || self.homeContext>",
referencedClasses: [],
messageSends: []
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.MethodContext.superclass||$boot.dnu).fn.prototype._printOn_.apply($recv(self), [aStream]));
$ctx1.supercall = false;
$recv(aStream)._nextPutAll_("(");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_(self._asString());
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.MethodContext)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09aStream \x0a\x09\x09nextPutAll: '(';\x0a\x09\x09nextPutAll: self asString;\x0a\x09\x09nextPutAll: ')'",
referencedClasses: [],
messageSends: ["printOn:", "nextPutAll:", "asString"]
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$1=$recv(self._isBlockContext())._and_((function(){
return $core.withContext(function($ctx2) {
$2=self._outerContext();
$ctx2.sendIdx["outerContext"]=1;
return $recv($2)._notNil();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
if($core.assert($1)){
return $recv(self._outerContext())._receiver();
} else {
return self._basicReceiver();
};
}, function($ctx1) {$ctx1.fill(self,"receiver",{},$globals.MethodContext)});
},
args: [],
source: "receiver\x0a\x09^ (self isBlockContext and: [ self outerContext notNil ])\x0a\x09\x09ifTrue: [ self outerContext receiver ]\x0a\x09\x09ifFalse: [ self basicReceiver ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "and:", "isBlockContext", "notNil", "outerContext", "receiver", "basicReceiver"]
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		if(self.selector) {
			return $core.js2st(self.selector);
		} else {
			return nil;
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"selector",{},$globals.MethodContext)});
},
args: [],
source: "selector\x0a\x09<\x0a\x09\x09if(self.selector) {\x0a\x09\x09\x09return $core.js2st(self.selector);\x0a\x09\x09} else {\x0a\x09\x09\x09return nil;\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "sendIndexAt:",
protocol: 'accessing',
fn: function (aSelector){
var self=this;
return $core.withContext(function($ctx1) {
return self.sendIdx[aSelector] || 0;
return self;
}, function($ctx1) {$ctx1.fill(self,"sendIndexAt:",{aSelector:aSelector},$globals.MethodContext)});
},
args: ["aSelector"],
source: "sendIndexAt: aSelector\x0a\x09<return self.sendIdx[aSelector] || 0>",
referencedClasses: [],
messageSends: []
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "sendIndexes",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.sendIdx;
return self;
}, function($ctx1) {$ctx1.fill(self,"sendIndexes",{},$globals.MethodContext)});
},
args: [],
source: "sendIndexes\x0a\x09<return self.sendIdx>",
referencedClasses: [],
messageSends: []
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "supercall",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.supercall == true;
return self;
}, function($ctx1) {$ctx1.fill(self,"supercall",{},$globals.MethodContext)});
},
args: [],
source: "supercall\x0a\x09<return self.supercall == true>",
referencedClasses: [],
messageSends: []
}),
$globals.MethodContext);



$core.addClass('NativeFunction', $globals.Object, [], 'Kernel-Methods');
$globals.NativeFunction.comment="I am a wrapper around native functions, such as `WebSocket`.\x0aFor 'normal' functions (whose constructor is the JavaScript `Function` object), use `BlockClosure`.\x0a\x0a## API\x0a\x0aSee the class-side `instance creation` methods for instance creation.\x0a\x0aCreated instances will most probably be instance of `JSObjectProxy`.\x0a\x0a## Usage example:\x0a\x0a\x09| ws |\x0a\x09ws := NativeFunction constructor: 'WebSocket' value: 'ws://localhost'.\x0a\x09ws at: 'onopen' put: [ ws send: 'hey there from Amber' ]";

$core.addMethod(
$core.method({
selector: "constructor:",
protocol: 'instance creation',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {

		self._deprecatedAPI_("Use constructorNamed:");
		var nativeFunc=eval(aString);
		return new nativeFunc();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructor:",{aString:aString},$globals.NativeFunction.klass)});
},
args: ["aString"],
source: "constructor: aString\x0a\x09<\x0a\x09\x09self._deprecatedAPI_(\x22Use constructorNamed:\x22);\x0a\x09\x09var nativeFunc=eval(aString);\x0a\x09\x09return new nativeFunc();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructor:value:",
protocol: 'instance creation',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {

		self._deprecatedAPI_("Use constructorNamed:value:");
		var nativeFunc=eval(aString);
		return new nativeFunc(anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructor:value:",{aString:aString,anObject:anObject},$globals.NativeFunction.klass)});
},
args: ["aString", "anObject"],
source: "constructor: aString value:anObject\x0a\x09<\x0a\x09\x09self._deprecatedAPI_(\x22Use constructorNamed:value:\x22);\x0a\x09\x09var nativeFunc=eval(aString);\x0a\x09\x09return new nativeFunc(anObject);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructor:value:value:",
protocol: 'instance creation',
fn: function (aString,anObject,anObject2){
var self=this;
return $core.withContext(function($ctx1) {

		self._deprecatedAPI_("Use constructorNamed:value:value:");
		var nativeFunc=eval(aString);
		return new nativeFunc(anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructor:value:value:",{aString:aString,anObject:anObject,anObject2:anObject2},$globals.NativeFunction.klass)});
},
args: ["aString", "anObject", "anObject2"],
source: "constructor: aString value:anObject value: anObject2\x0a\x09<\x0a\x09\x09self._deprecatedAPI_(\x22Use constructorNamed:value:value:\x22);\x0a\x09\x09var nativeFunc=eval(aString);\x0a\x09\x09return new nativeFunc(anObject,anObject2);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructor:value:value:value:",
protocol: 'instance creation',
fn: function (aString,anObject,anObject2,anObject3){
var self=this;
return $core.withContext(function($ctx1) {

		self._deprecatedAPI_("Use constructorNamed:value:value:value");
		var nativeFunc=eval(aString);
		return new nativeFunc(anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructor:value:value:value:",{aString:aString,anObject:anObject,anObject2:anObject2,anObject3:anObject3},$globals.NativeFunction.klass)});
},
args: ["aString", "anObject", "anObject2", "anObject3"],
source: "constructor: aString value:anObject value: anObject2 value:anObject3\x0a\x09<\x0a\x09\x09self._deprecatedAPI_(\x22Use constructorNamed:value:value:value\x22);\x0a\x09\x09var nativeFunc=eval(aString);\x0a\x09\x09return new nativeFunc(anObject,anObject2, anObject3);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructorNamed:",
protocol: 'instance creation',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=(new Function('return this'))()[aString];
		return new nativeFunc();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorNamed:",{aString:aString},$globals.NativeFunction.klass)});
},
args: ["aString"],
source: "constructorNamed: aString\x0a\x09<\x0a\x09\x09var nativeFunc=(new Function('return this'))()[aString];\x0a\x09\x09return new nativeFunc();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructorNamed:value:",
protocol: 'instance creation',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=(new Function('return this'))()[aString];
		return new nativeFunc(anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorNamed:value:",{aString:aString,anObject:anObject},$globals.NativeFunction.klass)});
},
args: ["aString", "anObject"],
source: "constructorNamed: aString value: anObject\x0a\x09<\x0a\x09\x09var nativeFunc=(new Function('return this'))()[aString];\x0a\x09\x09return new nativeFunc(anObject);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructorNamed:value:value:",
protocol: 'instance creation',
fn: function (aString,anObject,anObject2){
var self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=(new Function('return this'))()[aString];
		return new nativeFunc(anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorNamed:value:value:",{aString:aString,anObject:anObject,anObject2:anObject2},$globals.NativeFunction.klass)});
},
args: ["aString", "anObject", "anObject2"],
source: "constructorNamed: aString value: anObject value: anObject2\x0a\x09<\x0a\x09\x09var nativeFunc=(new Function('return this'))()[aString];\x0a\x09\x09return new nativeFunc(anObject,anObject2);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructorNamed:value:value:value:",
protocol: 'instance creation',
fn: function (aString,anObject,anObject2,anObject3){
var self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=(new Function('return this'))()[aString];
		return new nativeFunc(anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorNamed:value:value:value:",{aString:aString,anObject:anObject,anObject2:anObject2,anObject3:anObject3},$globals.NativeFunction.klass)});
},
args: ["aString", "anObject", "anObject2", "anObject3"],
source: "constructorNamed: aString value: anObject value: anObject2 value: anObject3\x0a\x09<\x0a\x09\x09var nativeFunc=(new Function('return this'))()[aString];\x0a\x09\x09return new nativeFunc(anObject,anObject2, anObject3);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructorOf:",
protocol: 'instance creation',
fn: function (nativeFunc){
var self=this;
return $core.withContext(function($ctx1) {

		return new nativeFunc();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorOf:",{nativeFunc:nativeFunc},$globals.NativeFunction.klass)});
},
args: ["nativeFunc"],
source: "constructorOf: nativeFunc\x0a\x09<\x0a\x09\x09return new nativeFunc();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructorOf:value:",
protocol: 'instance creation',
fn: function (nativeFunc,anObject){
var self=this;
return $core.withContext(function($ctx1) {

		return new nativeFunc(anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorOf:value:",{nativeFunc:nativeFunc,anObject:anObject},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "anObject"],
source: "constructorOf: nativeFunc value: anObject\x0a\x09<\x0a\x09\x09return new nativeFunc(anObject);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructorOf:value:value:",
protocol: 'instance creation',
fn: function (nativeFunc,anObject,anObject2){
var self=this;
return $core.withContext(function($ctx1) {

		return new nativeFunc(anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorOf:value:value:",{nativeFunc:nativeFunc,anObject:anObject,anObject2:anObject2},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "anObject", "anObject2"],
source: "constructorOf: nativeFunc value: anObject value: anObject2\x0a\x09<\x0a\x09\x09return new nativeFunc(anObject,anObject2);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "constructorOf:value:value:value:",
protocol: 'instance creation',
fn: function (nativeFunc,anObject,anObject2,anObject3){
var self=this;
return $core.withContext(function($ctx1) {

		return new nativeFunc(anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorOf:value:value:value:",{nativeFunc:nativeFunc,anObject:anObject,anObject2:anObject2,anObject3:anObject3},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "anObject", "anObject2", "anObject3"],
source: "constructorOf: nativeFunc value: anObject value: anObject2 value: anObject3\x0a\x09<\x0a\x09\x09return new nativeFunc(anObject,anObject2, anObject3);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "exists:",
protocol: 'testing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._existsJsGlobal_(aString);
}, function($ctx1) {$ctx1.fill(self,"exists:",{aString:aString},$globals.NativeFunction.klass)});
},
args: ["aString"],
source: "exists: aString\x0a\x09^ Smalltalk existsJsGlobal: aString",
referencedClasses: ["Smalltalk"],
messageSends: ["existsJsGlobal:"]
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "functionNamed:",
protocol: 'function calling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=(new Function('return this'))()[aString];
		return nativeFunc();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionNamed:",{aString:aString},$globals.NativeFunction.klass)});
},
args: ["aString"],
source: "functionNamed: aString\x0a\x09<\x0a\x09\x09var nativeFunc=(new Function('return this'))()[aString];\x0a\x09\x09return nativeFunc();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "functionNamed:value:",
protocol: 'function calling',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=(new Function('return this'))()[aString];
		return nativeFunc(anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionNamed:value:",{aString:aString,anObject:anObject},$globals.NativeFunction.klass)});
},
args: ["aString", "anObject"],
source: "functionNamed: aString value: anObject\x0a\x09<\x0a\x09\x09var nativeFunc=(new Function('return this'))()[aString];\x0a\x09\x09return nativeFunc(anObject);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "functionNamed:value:value:",
protocol: 'function calling',
fn: function (aString,anObject,anObject2){
var self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=(new Function('return this'))()[aString];
		return nativeFunc(anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionNamed:value:value:",{aString:aString,anObject:anObject,anObject2:anObject2},$globals.NativeFunction.klass)});
},
args: ["aString", "anObject", "anObject2"],
source: "functionNamed: aString value: anObject value: anObject2\x0a\x09<\x0a\x09\x09var nativeFunc=(new Function('return this'))()[aString];\x0a\x09\x09return nativeFunc(anObject,anObject2);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "functionNamed:value:value:value:",
protocol: 'function calling',
fn: function (aString,anObject,anObject2,anObject3){
var self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=(new Function('return this'))()[aString];
		return nativeFunc(anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionNamed:value:value:value:",{aString:aString,anObject:anObject,anObject2:anObject2,anObject3:anObject3},$globals.NativeFunction.klass)});
},
args: ["aString", "anObject", "anObject2", "anObject3"],
source: "functionNamed: aString value: anObject value: anObject2 value: anObject3\x0a\x09<\x0a\x09\x09var nativeFunc=(new Function('return this'))()[aString];\x0a\x09\x09return nativeFunc(anObject,anObject2, anObject3);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "functionNamed:valueWithArgs:",
protocol: 'function calling',
fn: function (aString,args){
var self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=(new Function('return this'))()[aString];
		return Function.prototype.apply.call(nativeFunc, null, args);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionNamed:valueWithArgs:",{aString:aString,args:args},$globals.NativeFunction.klass)});
},
args: ["aString", "args"],
source: "functionNamed: aString valueWithArgs: args\x0a\x09<\x0a\x09\x09var nativeFunc=(new Function('return this'))()[aString];\x0a\x09\x09return Function.prototype.apply.call(nativeFunc, null, args);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "functionOf:",
protocol: 'function calling',
fn: function (nativeFunc){
var self=this;
return $core.withContext(function($ctx1) {

		return nativeFunc();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionOf:",{nativeFunc:nativeFunc},$globals.NativeFunction.klass)});
},
args: ["nativeFunc"],
source: "functionOf: nativeFunc\x0a\x09<\x0a\x09\x09return nativeFunc();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "functionOf:value:",
protocol: 'function calling',
fn: function (nativeFunc,anObject){
var self=this;
return $core.withContext(function($ctx1) {

		return nativeFunc(anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionOf:value:",{nativeFunc:nativeFunc,anObject:anObject},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "anObject"],
source: "functionOf: nativeFunc value: anObject\x0a\x09<\x0a\x09\x09return nativeFunc(anObject);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "functionOf:value:value:",
protocol: 'function calling',
fn: function (nativeFunc,anObject,anObject2){
var self=this;
return $core.withContext(function($ctx1) {

		return nativeFunc(anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionOf:value:value:",{nativeFunc:nativeFunc,anObject:anObject,anObject2:anObject2},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "anObject", "anObject2"],
source: "functionOf: nativeFunc value: anObject value: anObject2\x0a\x09<\x0a\x09\x09return nativeFunc(anObject,anObject2);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "functionOf:value:value:value:",
protocol: 'function calling',
fn: function (nativeFunc,anObject,anObject2,anObject3){
var self=this;
return $core.withContext(function($ctx1) {

		return nativeFunc(anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionOf:value:value:value:",{nativeFunc:nativeFunc,anObject:anObject,anObject2:anObject2,anObject3:anObject3},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "anObject", "anObject2", "anObject3"],
source: "functionOf: nativeFunc value: anObject value: anObject2 value: anObject3\x0a\x09<\x0a\x09\x09return nativeFunc(anObject,anObject2, anObject3);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "functionOf:valueWithArgs:",
protocol: 'function calling',
fn: function (nativeFunc,args){
var self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.apply.call(nativeFunc, null, args);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionOf:valueWithArgs:",{nativeFunc:nativeFunc,args:args},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "args"],
source: "functionOf: nativeFunc valueWithArgs: args\x0a\x09<\x0a\x09\x09return Function.prototype.apply.call(nativeFunc, null, args);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "methodOf:this:",
protocol: 'method calling',
fn: function (nativeFunc,thisObject){
var self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.call.call(nativeFunc, thisObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOf:this:",{nativeFunc:nativeFunc,thisObject:thisObject},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "thisObject"],
source: "methodOf: nativeFunc this: thisObject\x0a\x09<\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "methodOf:this:value:",
protocol: 'method calling',
fn: function (nativeFunc,thisObject,anObject){
var self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.call.call(nativeFunc, thisObject, anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOf:this:value:",{nativeFunc:nativeFunc,thisObject:thisObject,anObject:anObject},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "thisObject", "anObject"],
source: "methodOf: nativeFunc this: thisObject value: anObject\x0a\x09<\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject, anObject);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "methodOf:this:value:value:",
protocol: 'method calling',
fn: function (nativeFunc,thisObject,anObject,anObject2){
var self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.call.call(nativeFunc, thisObject,anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOf:this:value:value:",{nativeFunc:nativeFunc,thisObject:thisObject,anObject:anObject,anObject2:anObject2},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "thisObject", "anObject", "anObject2"],
source: "methodOf: nativeFunc this: thisObject value: anObject value: anObject2\x0a\x09<\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject,anObject,anObject2);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "methodOf:this:value:value:value:",
protocol: 'method calling',
fn: function (nativeFunc,thisObject,anObject,anObject2,anObject3){
var self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.call.call(nativeFunc, thisObject,anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOf:this:value:value:value:",{nativeFunc:nativeFunc,thisObject:thisObject,anObject:anObject,anObject2:anObject2,anObject3:anObject3},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "thisObject", "anObject", "anObject2", "anObject3"],
source: "methodOf: nativeFunc this: thisObject value: anObject value: anObject2 value: anObject3\x0a\x09<\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject,anObject,anObject2, anObject3);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);

$core.addMethod(
$core.method({
selector: "methodOf:this:valueWithArgs:",
protocol: 'method calling',
fn: function (nativeFunc,thisObject,args){
var self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.apply.call(nativeFunc, thisObject, args);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOf:this:valueWithArgs:",{nativeFunc:nativeFunc,thisObject:thisObject,args:args},$globals.NativeFunction.klass)});
},
args: ["nativeFunc", "thisObject", "args"],
source: "methodOf: nativeFunc this: thisObject valueWithArgs: args\x0a\x09<\x0a\x09\x09return Function.prototype.apply.call(nativeFunc, thisObject, args);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.NativeFunction.klass);


$core.addClass('Timeout', $globals.Object, ['rawTimeout'], 'Kernel-Methods');
$globals.Timeout.comment="I am wrapping the returns from `set{Timeout,Interval}`.\x0a\x0a## Motivation\x0a\x0aNumber suffices in browsers, but node.js returns an object.";
$core.addMethod(
$core.method({
selector: "clearInterval",
protocol: 'timeout/interval',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		var interval = self["@rawTimeout"];
		clearInterval(interval);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"clearInterval",{},$globals.Timeout)});
},
args: [],
source: "clearInterval\x0a\x09<\x0a\x09\x09var interval = self[\x22@rawTimeout\x22];\x0a\x09\x09clearInterval(interval);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Timeout);

$core.addMethod(
$core.method({
selector: "clearTimeout",
protocol: 'timeout/interval',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		var timeout = self["@rawTimeout"];
		clearTimeout(timeout);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"clearTimeout",{},$globals.Timeout)});
},
args: [],
source: "clearTimeout\x0a\x09<\x0a\x09\x09var timeout = self[\x22@rawTimeout\x22];\x0a\x09\x09clearTimeout(timeout);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Timeout);

$core.addMethod(
$core.method({
selector: "rawTimeout:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@rawTimeout"]=anObject;
return self;

},
args: ["anObject"],
source: "rawTimeout: anObject\x0a\x09rawTimeout := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.Timeout);


$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._rawTimeout_(anObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{anObject:anObject},$globals.Timeout.klass)});
},
args: ["anObject"],
source: "on: anObject\x0a\x09^ self new rawTimeout: anObject; yourself",
referencedClasses: [],
messageSends: ["rawTimeout:", "new", "yourself"]
}),
$globals.Timeout.klass);

});

define("amber_core/Kernel-Collections", ["amber/boot", "amber_core/Kernel-Objects"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Kernel-Collections');
$core.packages["Kernel-Collections"].innerEval = function (expr) { return eval(expr); };
$core.packages["Kernel-Collections"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('Association', $globals.Object, ['key', 'value'], 'Kernel-Collections');
$globals.Association.comment="I represent a pair of associated objects, a key and a value. My instances can serve as entries in a dictionary.\x0a\x0aInstances can be created with the class-side method `#key:value:`";
$core.addMethod(
$core.method({
selector: "=",
protocol: 'comparing',
fn: function (anAssociation){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$5,$4,$6,$1;
$3=self._class();
$ctx1.sendIdx["class"]=1;
$2=$recv($3).__eq($recv(anAssociation)._class());
$ctx1.sendIdx["="]=1;
$1=$recv($2)._and_((function(){
return $core.withContext(function($ctx2) {
$5=self._key();
$ctx2.sendIdx["key"]=1;
$4=$recv($5).__eq($recv(anAssociation)._key());
$ctx2.sendIdx["="]=2;
return $recv($4)._and_((function(){
return $core.withContext(function($ctx3) {
$6=self._value();
$ctx3.sendIdx["value"]=1;
return $recv($6).__eq($recv(anAssociation)._value());
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["and:"]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"=",{anAssociation:anAssociation},$globals.Association)});
},
args: ["anAssociation"],
source: "= anAssociation\x0a\x09^ self class = anAssociation class and: [\x0a\x09\x09self key = anAssociation key and: [\x0a\x09\x09self value = anAssociation value ]]",
referencedClasses: [],
messageSends: ["and:", "=", "class", "key", "value"]
}),
$globals.Association);

$core.addMethod(
$core.method({
selector: "key",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@key"];

},
args: [],
source: "key\x0a\x09^ key",
referencedClasses: [],
messageSends: []
}),
$globals.Association);

$core.addMethod(
$core.method({
selector: "key:",
protocol: 'accessing',
fn: function (aKey){
var self=this;
self["@key"]=aKey;
return self;

},
args: ["aKey"],
source: "key: aKey\x0a\x09key := aKey",
referencedClasses: [],
messageSends: []
}),
$globals.Association);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._key())._printOn_(aStream);
$ctx1.sendIdx["printOn:"]=1;
$recv(aStream)._nextPutAll_(" -> ");
$recv(self._value())._printOn_(aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Association)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09self key printOn: aStream.\x0a\x09aStream nextPutAll: ' -> '.\x0a\x09self value printOn: aStream",
referencedClasses: [],
messageSends: ["printOn:", "key", "nextPutAll:", "value"]
}),
$globals.Association);

$core.addMethod(
$core.method({
selector: "value",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@value"];

},
args: [],
source: "value\x0a\x09^ value",
referencedClasses: [],
messageSends: []
}),
$globals.Association);

$core.addMethod(
$core.method({
selector: "value:",
protocol: 'accessing',
fn: function (aValue){
var self=this;
self["@value"]=aValue;
return self;

},
args: ["aValue"],
source: "value: aValue\x0a\x09value := aValue",
referencedClasses: [],
messageSends: []
}),
$globals.Association);


$core.addMethod(
$core.method({
selector: "key:value:",
protocol: 'instance creation',
fn: function (aKey,aValue){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._key_(aKey);
$recv($1)._value_(aValue);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"key:value:",{aKey:aKey,aValue:aValue},$globals.Association.klass)});
},
args: ["aKey", "aValue"],
source: "key: aKey value: aValue\x0a\x09\x09^ self new\x0a\x09\x09key: aKey;\x0a\x09\x09value: aValue;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["key:", "new", "value:", "yourself"]
}),
$globals.Association.klass);


$core.addClass('BucketStore', $globals.Object, ['buckets', 'hashBlock'], 'Kernel-Collections');
$globals.BucketStore.comment="I am an helper class for hash-based stores.\x0a\x0aI hold buckets which are selected by a hash, specified using `#hashBlock:`.\x0aThe hash can be any object, and\x0ait is used as a JS property (that is, in ES5\x0aits toString() value counts).\x0a\x0a## API\x0aI maintain a list of buckets. Client code can use this API:\x0a - `#bucketOfElement:` (to ask a bucket for element, I can return JS null if n/a)\x0a - `#do:` (to enumerate all elements of all buckets)\x0a - `#removeAll` (to remove all buckets)\x0a\x0aClient code itself should add/remove elements\x0ain a bucket. The `nil` object should not be put into any bucket.\x0a\x0aTypes of buckets are the responsibility of subclasses via `#newBucket`.";
$core.addMethod(
$core.method({
selector: "bucketOfElement:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {

		var hash = self['@hashBlock'](anObject);
		if (!hash) return null;
		var buckets = self['@buckets'],
			bucket = buckets[hash];
		if (!bucket) { bucket = buckets[hash] = self._newBucket(); }
		return bucket;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"bucketOfElement:",{anObject:anObject},$globals.BucketStore)});
},
args: ["anObject"],
source: "bucketOfElement: anObject\x0a\x09<\x0a\x09\x09var hash = self['@hashBlock'](anObject);\x0a\x09\x09if (!hash) return null;\x0a\x09\x09var buckets = self['@buckets'],\x0a\x09\x09\x09bucket = buckets[hash];\x0a\x09\x09if (!bucket) { bucket = buckets[hash] = self._newBucket(); }\x0a\x09\x09return bucket;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.BucketStore);

$core.addMethod(
$core.method({
selector: "do:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		var buckets = self['@buckets'];
		var keys = Object.keys(buckets);
		for (var i = 0; i < keys.length; ++i) { buckets[keys[i]]._do_(aBlock); }
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock},$globals.BucketStore)});
},
args: ["aBlock"],
source: "do: aBlock\x0a\x09<\x0a\x09\x09var buckets = self['@buckets'];\x0a\x09\x09var keys = Object.keys(buckets);\x0a\x09\x09for (var i = 0; i < keys.length; ++i) { buckets[keys[i]]._do_(aBlock); }\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.BucketStore);

$core.addMethod(
$core.method({
selector: "hashBlock:",
protocol: 'accessing',
fn: function (aBlock){
var self=this;
self["@hashBlock"]=aBlock;
return self;

},
args: ["aBlock"],
source: "hashBlock: aBlock\x0a\x09hashBlock := aBlock",
referencedClasses: [],
messageSends: []
}),
$globals.BucketStore);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.BucketStore.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self._removeAll();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.BucketStore)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09self removeAll",
referencedClasses: [],
messageSends: ["initialize", "removeAll"]
}),
$globals.BucketStore);

$core.addMethod(
$core.method({
selector: "newBucket",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"newBucket",{},$globals.BucketStore)});
},
args: [],
source: "newBucket\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.BucketStore);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: 'adding/removing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self['@buckets'] = Object.create(null);;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeAll",{},$globals.BucketStore)});
},
args: [],
source: "removeAll\x0a\x09<self['@buckets'] = Object.create(null);>",
referencedClasses: [],
messageSends: []
}),
$globals.BucketStore);


$core.addMethod(
$core.method({
selector: "hashBlock:",
protocol: 'instance creation',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._hashBlock_(aBlock);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"hashBlock:",{aBlock:aBlock},$globals.BucketStore.klass)});
},
args: ["aBlock"],
source: "hashBlock: aBlock\x0a\x09^ self new\x0a\x09\x09hashBlock: aBlock;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["hashBlock:", "new", "yourself"]
}),
$globals.BucketStore.klass);


$core.addClass('ArrayBucketStore', $globals.BucketStore, [], 'Kernel-Collections');
$globals.ArrayBucketStore.comment="I am a concrete `BucketStore` with buckets being instance of `Array`.";
$core.addMethod(
$core.method({
selector: "newBucket",
protocol: 'private',
fn: function (){
var self=this;
return [];

},
args: [],
source: "newBucket\x0a\x09^ #()",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayBucketStore);



$core.addClass('Collection', $globals.Object, [], 'Kernel-Collections');
$globals.Collection.comment="I am the abstract superclass of all classes that represent a group of elements.\x0a\x0aI provide a set of useful methods to the Collection hierarchy such as enumerating and converting methods.";
$core.addMethod(
$core.method({
selector: ",",
protocol: 'copying',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._copy();
$recv($1)._addAll_(aCollection);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,",",{aCollection:aCollection},$globals.Collection)});
},
args: ["aCollection"],
source: ", aCollection\x0a\x09^ self copy\x0a\x09\x09addAll: aCollection;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["addAll:", "copy", "yourself"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "add:",
protocol: 'adding/removing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"add:",{anObject:anObject},$globals.Collection)});
},
args: ["anObject"],
source: "add: anObject\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "addAll:",
protocol: 'adding/removing',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return self._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return aCollection;
}, function($ctx1) {$ctx1.fill(self,"addAll:",{aCollection:aCollection},$globals.Collection)});
},
args: ["aCollection"],
source: "addAll: aCollection\x0a\x09aCollection do: [ :each |\x0a\x09\x09self add: each ].\x0a\x09^ aCollection",
referencedClasses: [],
messageSends: ["do:", "add:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "allSatisfy:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
self._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(aBlock)._value_(each);
if(!$core.assert($1)){
throw $early=[false];
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return true;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"allSatisfy:",{aBlock:aBlock},$globals.Collection)});
},
args: ["aBlock"],
source: "allSatisfy: aBlock\x0a\x09\x22Evaluate aBlock with the elements of the receiver.\x0a\x09If aBlock returns false for any element return false.\x0a\x09Otherwise return true.\x22\x0a\x0a\x09self do: [ :each | (aBlock value: each) ifFalse: [ ^ false ] ].\x0a\x09^ true",
referencedClasses: [],
messageSends: ["do:", "ifFalse:", "value:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "anyOne",
protocol: 'adding/removing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
self._ifEmpty_((function(){
return $core.withContext(function($ctx2) {
return self._error_("Collection is empty");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
self._do_((function(each){
throw $early=[each];

}));
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"anyOne",{},$globals.Collection)});
},
args: [],
source: "anyOne\x0a\x09\x22Answer a representative sample of the receiver. This method can\x0a\x09be helpful when needing to preinfer the nature of the contents of \x0a\x09semi-homogeneous collections.\x22\x0a\x0a\x09self ifEmpty: [ self error: 'Collection is empty' ].\x0a\x09self do: [ :each | ^ each ]",
referencedClasses: [],
messageSends: ["ifEmpty:", "error:", "do:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "anySatisfy:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
self._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(aBlock)._value_(each);
if($core.assert($1)){
throw $early=[true];
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return false;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"anySatisfy:",{aBlock:aBlock},$globals.Collection)});
},
args: ["aBlock"],
source: "anySatisfy: aBlock\x0a\x09\x22Evaluate aBlock with the elements of the receiver.\x0a\x09If aBlock returns true for any element return true.\x0a\x09Otherwise return false.\x22\x0a\x0a\x09self do: [ :each | (aBlock value: each) ifTrue: [ ^ true ] ].\x0a\x09^ false",
referencedClasses: [],
messageSends: ["do:", "ifTrue:", "value:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "asArray",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Array)._withAll_(self);
}, function($ctx1) {$ctx1.fill(self,"asArray",{},$globals.Collection)});
},
args: [],
source: "asArray\x0a\x09^ Array withAll: self",
referencedClasses: ["Array"],
messageSends: ["withAll:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "asJSON",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._asArray())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._asJSON();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"asJSON",{},$globals.Collection)});
},
args: [],
source: "asJSON\x0a\x09^ self asArray collect: [ :each | each asJSON ]",
referencedClasses: [],
messageSends: ["collect:", "asArray", "asJSON"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "asOrderedCollection",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._asArray();
}, function($ctx1) {$ctx1.fill(self,"asOrderedCollection",{},$globals.Collection)});
},
args: [],
source: "asOrderedCollection\x0a\x09^ self asArray",
referencedClasses: [],
messageSends: ["asArray"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "asSet",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Set)._withAll_(self);
}, function($ctx1) {$ctx1.fill(self,"asSet",{},$globals.Collection)});
},
args: [],
source: "asSet\x0a\x09^ Set withAll: self",
referencedClasses: ["Set"],
messageSends: ["withAll:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "collect:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
var stream;
return $core.withContext(function($ctx1) {
stream=$recv($recv(self._class())._new())._writeStream();
self._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(stream)._nextPut_($recv(aBlock)._value_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(stream)._contents();
}, function($ctx1) {$ctx1.fill(self,"collect:",{aBlock:aBlock,stream:stream},$globals.Collection)});
},
args: ["aBlock"],
source: "collect: aBlock\x0a\x09| stream |\x0a\x09stream := self class new writeStream.\x0a\x09self do: [ :each |\x0a\x09\x09stream nextPut: (aBlock value: each) ].\x0a\x09^ stream contents",
referencedClasses: [],
messageSends: ["writeStream", "new", "class", "do:", "nextPut:", "value:", "contents"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "copyWith:",
protocol: 'copying',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._copy();
$recv($1)._add_(anObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"copyWith:",{anObject:anObject},$globals.Collection)});
},
args: ["anObject"],
source: "copyWith: anObject\x0a\x09^ self copy add: anObject; yourself",
referencedClasses: [],
messageSends: ["add:", "copy", "yourself"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "copyWithAll:",
protocol: 'copying',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._copy();
$recv($1)._addAll_(aCollection);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"copyWithAll:",{aCollection:aCollection},$globals.Collection)});
},
args: ["aCollection"],
source: "copyWithAll: aCollection\x0a\x09^ self copy addAll: aCollection; yourself",
referencedClasses: [],
messageSends: ["addAll:", "copy", "yourself"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "copyWithoutAll:",
protocol: 'copying',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
return self._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv(aCollection)._includes_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"copyWithoutAll:",{aCollection:aCollection},$globals.Collection)});
},
args: ["aCollection"],
source: "copyWithoutAll: aCollection\x0a\x09\x22Answer a copy of the receiver that does not contain any elements\x0a\x09equal to those in aCollection.\x22\x0a\x0a\x09^ self reject: [ :each | aCollection includes: each ]",
referencedClasses: [],
messageSends: ["reject:", "includes:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: 'copying',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._deepCopy();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"deepCopy",{},$globals.Collection)});
},
args: [],
source: "deepCopy\x0a\x09^ self collect: [ :each | each deepCopy ]",
referencedClasses: [],
messageSends: ["collect:", "deepCopy"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "detect:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._detect_ifNone_(aBlock,(function(){
return $core.withContext(function($ctx2) {
return self._errorNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"detect:",{aBlock:aBlock},$globals.Collection)});
},
args: ["aBlock"],
source: "detect: aBlock\x0a\x09^ self detect: aBlock ifNone: [ self errorNotFound ]",
referencedClasses: [],
messageSends: ["detect:ifNone:", "errorNotFound"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "detect:ifNone:",
protocol: 'enumerating',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"detect:ifNone:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.Collection)});
},
args: ["aBlock", "anotherBlock"],
source: "detect: aBlock ifNone: anotherBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "do:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock},$globals.Collection)});
},
args: ["aBlock"],
source: "do: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "do:separatedBy:",
protocol: 'enumerating',
fn: function (aBlock,anotherBlock){
var self=this;
var actionBeforeElement;
return $core.withContext(function($ctx1) {
actionBeforeElement=(function(){
actionBeforeElement=anotherBlock;
return actionBeforeElement;

});
self._do_((function(each){
return $core.withContext(function($ctx2) {
$recv(actionBeforeElement)._value();
return $recv(aBlock)._value_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"do:separatedBy:",{aBlock:aBlock,anotherBlock:anotherBlock,actionBeforeElement:actionBeforeElement},$globals.Collection)});
},
args: ["aBlock", "anotherBlock"],
source: "do: aBlock separatedBy: anotherBlock\x0a\x09| actionBeforeElement |\x0a\x09actionBeforeElement := [ actionBeforeElement := anotherBlock ].\x0a\x09self do: [ :each |\x0a\x09\x09actionBeforeElement value.\x0a\x09\x09aBlock value: each ]",
referencedClasses: [],
messageSends: ["do:", "value", "value:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "errorNotFound",
protocol: 'error handling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._error_("Object is not in the collection");
return self;
}, function($ctx1) {$ctx1.fill(self,"errorNotFound",{},$globals.Collection)});
},
args: [],
source: "errorNotFound\x0a\x09self error: 'Object is not in the collection'",
referencedClasses: [],
messageSends: ["error:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "ifEmpty:",
protocol: 'testing',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._isEmpty();
return $recv($1)._ifTrue_ifFalse_(aBlock,(function(){
return self;

}));
}, function($ctx1) {$ctx1.fill(self,"ifEmpty:",{aBlock:aBlock},$globals.Collection)});
},
args: ["aBlock"],
source: "ifEmpty: aBlock\x0a\x09\x22Evaluate the given block with the receiver as argument, answering its value if the receiver is empty, otherwise answer the receiver. \x0a\x09Note that the fact that this method returns its argument in case the receiver is not empty allows one to write expressions like the following ones: \x0a\x09\x09self classifyMethodAs:\x0a\x09\x09\x09(myProtocol ifEmpty: ['As yet unclassified'])\x22\x0a\x09^ self isEmpty\x0a\x09\x09ifTrue: aBlock\x0a\x09\x09ifFalse: [ self ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "isEmpty"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "ifEmpty:ifNotEmpty:",
protocol: 'testing',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._isEmpty();
return $recv($1)._ifTrue_ifFalse_(aBlock,(function(){
return $core.withContext(function($ctx2) {
return $recv(anotherBlock)._value_(self);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"ifEmpty:ifNotEmpty:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.Collection)});
},
args: ["aBlock", "anotherBlock"],
source: "ifEmpty: aBlock ifNotEmpty: anotherBlock\x0a\x09^ self isEmpty\x0a\x09\x09ifTrue: aBlock\x0a\x09\x09ifFalse: [ anotherBlock value: self ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "isEmpty", "value:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "ifNotEmpty:",
protocol: 'testing',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._notEmpty();
if($core.assert($1)){
return $recv(aBlock)._value_(self);
} else {
return self;
};
}, function($ctx1) {$ctx1.fill(self,"ifNotEmpty:",{aBlock:aBlock},$globals.Collection)});
},
args: ["aBlock"],
source: "ifNotEmpty: aBlock\x0a\x09^ self notEmpty\x0a\x09\x09ifTrue: [ aBlock value: self ]\x0a\x09\x09ifFalse: [ self ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "notEmpty", "value:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "ifNotEmpty:ifEmpty:",
protocol: 'testing',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._notEmpty();
return $recv($1)._ifTrue_ifFalse_((function(){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_(self);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),anotherBlock);
}, function($ctx1) {$ctx1.fill(self,"ifNotEmpty:ifEmpty:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.Collection)});
},
args: ["aBlock", "anotherBlock"],
source: "ifNotEmpty: aBlock ifEmpty: anotherBlock\x0a\x09^ self notEmpty\x0a\x09\x09ifTrue: [ aBlock value: self ]\x0a\x09\x09ifFalse: anotherBlock",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "notEmpty", "value:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "includes:",
protocol: 'testing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self._anySatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq(anObject);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"includes:",{anObject:anObject},$globals.Collection)});
},
args: ["anObject"],
source: "includes: anObject\x0a\x09^ self anySatisfy: [ :each | each = anObject ]",
referencedClasses: [],
messageSends: ["anySatisfy:", "="]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "inject:into:",
protocol: 'enumerating',
fn: function (anObject,aBlock){
var self=this;
var result;
return $core.withContext(function($ctx1) {
result=anObject;
self._do_((function(each){
return $core.withContext(function($ctx2) {
result=$recv(aBlock)._value_value_(result,each);
return result;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return result;
}, function($ctx1) {$ctx1.fill(self,"inject:into:",{anObject:anObject,aBlock:aBlock,result:result},$globals.Collection)});
},
args: ["anObject", "aBlock"],
source: "inject: anObject into: aBlock\x0a\x09| result |\x0a\x09result := anObject.\x0a\x09self do: [ :each |\x0a\x09\x09result := aBlock value: result value: each ].\x0a\x09^ result",
referencedClasses: [],
messageSends: ["do:", "value:value:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "intersection:",
protocol: 'enumerating',
fn: function (aCollection){
var self=this;
var set,outputSet;
return $core.withContext(function($ctx1) {
var $2,$1;
set=self._asSet();
outputSet=$recv($globals.Set)._new();
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
$2=$recv(set)._includes_(each);
$ctx2.sendIdx["includes:"]=1;
$1=$recv($2)._and_((function(){
return $core.withContext(function($ctx3) {
return $recv($recv(outputSet)._includes_(each))._not();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
if($core.assert($1)){
return $recv(outputSet)._add_(each);
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(self._class())._withAll_($recv(outputSet)._asArray());
}, function($ctx1) {$ctx1.fill(self,"intersection:",{aCollection:aCollection,set:set,outputSet:outputSet},$globals.Collection)});
},
args: ["aCollection"],
source: "intersection: aCollection\x0a\x09\x22Answer the set theoretic intersection of two collections.\x22\x0a\x0a\x09| set outputSet |\x0a\x09\x0a\x09set := self asSet.\x0a\x09outputSet := Set new.\x0a\x09\x0a\x09aCollection do: [ :each |\x0a\x09\x09((set includes: each) and: [ (outputSet includes: each) not ])\x0a\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09outputSet add: each ]].\x0a\x09\x09\x0a\x09^ self class withAll: outputSet asArray",
referencedClasses: ["Set"],
messageSends: ["asSet", "new", "do:", "ifTrue:", "and:", "includes:", "not", "add:", "withAll:", "class", "asArray"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "isEmpty",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._size()).__eq((0));
}, function($ctx1) {$ctx1.fill(self,"isEmpty",{},$globals.Collection)});
},
args: [],
source: "isEmpty\x0a\x09^ self size = 0",
referencedClasses: [],
messageSends: ["=", "size"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "noneSatisfy:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
self._do_((function(item){
return $core.withContext(function($ctx2) {
$1=$recv(aBlock)._value_(item);
if($core.assert($1)){
throw $early=[false];
};
}, function($ctx2) {$ctx2.fillBlock({item:item},$ctx1,1)});
}));
return true;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"noneSatisfy:",{aBlock:aBlock},$globals.Collection)});
},
args: ["aBlock"],
source: "noneSatisfy: aBlock\x0a\x09\x22Evaluate aBlock with the elements of the receiver.\x0a\x09If aBlock returns false for all elements return true.\x0a\x09Otherwise return false\x22\x0a\x0a\x09self do: [ :item | (aBlock value: item) ifTrue: [ ^ false ] ].\x0a\x09^ true",
referencedClasses: [],
messageSends: ["do:", "ifTrue:", "value:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "notEmpty",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._isEmpty())._not();
}, function($ctx1) {$ctx1.fill(self,"notEmpty",{},$globals.Collection)});
},
args: [],
source: "notEmpty\x0a\x09^ self isEmpty not",
referencedClasses: [],
messageSends: ["not", "isEmpty"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "occurrencesOf:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
var tally;
return $core.withContext(function($ctx1) {
var $1;
tally=(0);
self._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(anObject).__eq(each);
if($core.assert($1)){
tally=$recv(tally).__plus((1));
return tally;
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return tally;
}, function($ctx1) {$ctx1.fill(self,"occurrencesOf:",{anObject:anObject,tally:tally},$globals.Collection)});
},
args: ["anObject"],
source: "occurrencesOf: anObject\x0a\x09\x22Answer how many of the receiver's elements are equal to anObject.\x22\x0a\x0a\x09| tally |\x0a\x09tally := 0.\x0a\x09self do: [ :each | anObject = each ifTrue: [ tally := tally + 1 ]].\x0a\x09^ tally",
referencedClasses: [],
messageSends: ["do:", "ifTrue:", "=", "+"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "putOn:",
protocol: 'streaming',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
self._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._putOn_(aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"putOn:",{aStream:aStream},$globals.Collection)});
},
args: ["aStream"],
source: "putOn: aStream\x0a\x09self do: [ :each | each putOn: aStream ]",
referencedClasses: [],
messageSends: ["do:", "putOn:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "reject:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(aBlock)._value_(each)).__eq(false);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"reject:",{aBlock:aBlock},$globals.Collection)});
},
args: ["aBlock"],
source: "reject: aBlock\x0a\x09^ self select: [ :each | (aBlock value: each) = false ]",
referencedClasses: [],
messageSends: ["select:", "=", "value:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "remove:",
protocol: 'adding/removing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self._remove_ifAbsent_(anObject,(function(){
return $core.withContext(function($ctx2) {
return self._errorNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"remove:",{anObject:anObject},$globals.Collection)});
},
args: ["anObject"],
source: "remove: anObject\x0a\x09^ self remove: anObject ifAbsent: [ self errorNotFound ]",
referencedClasses: [],
messageSends: ["remove:ifAbsent:", "errorNotFound"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "remove:ifAbsent:",
protocol: 'adding/removing',
fn: function (anObject,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"remove:ifAbsent:",{anObject:anObject,aBlock:aBlock},$globals.Collection)});
},
args: ["anObject", "aBlock"],
source: "remove: anObject ifAbsent: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: 'adding/removing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"removeAll",{},$globals.Collection)});
},
args: [],
source: "removeAll\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "select:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
var stream;
return $core.withContext(function($ctx1) {
var $1;
stream=$recv($recv(self._class())._new())._writeStream();
self._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(aBlock)._value_(each);
if($core.assert($1)){
return $recv(stream)._nextPut_(each);
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(stream)._contents();
}, function($ctx1) {$ctx1.fill(self,"select:",{aBlock:aBlock,stream:stream},$globals.Collection)});
},
args: ["aBlock"],
source: "select: aBlock\x0a\x09| stream |\x0a\x09stream := self class new writeStream.\x0a\x09self do: [ :each |\x0a\x09\x09(aBlock value: each) ifTrue: [\x0a\x09\x09stream nextPut: each ] ].\x0a\x09^ stream contents",
referencedClasses: [],
messageSends: ["writeStream", "new", "class", "do:", "ifTrue:", "value:", "nextPut:", "contents"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "select:thenCollect:",
protocol: 'enumerating',
fn: function (selectBlock,collectBlock){
var self=this;
var stream;
return $core.withContext(function($ctx1) {
var $1;
stream=$recv($recv(self._class())._new())._writeStream();
self._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(selectBlock)._value_(each);
$ctx2.sendIdx["value:"]=1;
if($core.assert($1)){
return $recv(stream)._nextPut_($recv(collectBlock)._value_(each));
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(stream)._contents();
}, function($ctx1) {$ctx1.fill(self,"select:thenCollect:",{selectBlock:selectBlock,collectBlock:collectBlock,stream:stream},$globals.Collection)});
},
args: ["selectBlock", "collectBlock"],
source: "select: selectBlock thenCollect: collectBlock\x0a\x09| stream |\x0a\x09stream := self class new writeStream.\x0a\x09self do: [ :each |\x0a\x09\x09(selectBlock value: each) ifTrue: [\x0a\x09\x09stream nextPut: (collectBlock value: each) ] ].\x0a\x09^ stream contents",
referencedClasses: [],
messageSends: ["writeStream", "new", "class", "do:", "ifTrue:", "value:", "nextPut:", "contents"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: 'copying',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._collect_((function(each){
return each;

}));
}, function($ctx1) {$ctx1.fill(self,"shallowCopy",{},$globals.Collection)});
},
args: [],
source: "shallowCopy\x0a\x09^ self collect: [ :each | each ]",
referencedClasses: [],
messageSends: ["collect:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "size",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"size",{},$globals.Collection)});
},
args: [],
source: "size\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Collection);


$core.addMethod(
$core.method({
selector: "classTag",
protocol: 'accessing',
fn: function (){
var self=this;
return "collection";

},
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'collection'",
referencedClasses: [],
messageSends: []
}),
$globals.Collection.klass);

$core.addMethod(
$core.method({
selector: "new:",
protocol: 'instance creation',
fn: function (anInteger){
var self=this;
return $core.withContext(function($ctx1) {
return self._new();
}, function($ctx1) {$ctx1.fill(self,"new:",{anInteger:anInteger},$globals.Collection.klass)});
},
args: ["anInteger"],
source: "new: anInteger\x0a\x09^ self new",
referencedClasses: [],
messageSends: ["new"]
}),
$globals.Collection.klass);

$core.addMethod(
$core.method({
selector: "with:",
protocol: 'instance creation',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._add_(anObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:",{anObject:anObject},$globals.Collection.klass)});
},
args: ["anObject"],
source: "with: anObject\x0a\x09\x09^ self new\x0a\x09\x09add: anObject;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["add:", "new", "yourself"]
}),
$globals.Collection.klass);

$core.addMethod(
$core.method({
selector: "with:with:",
protocol: 'instance creation',
fn: function (anObject,anotherObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._add_(anObject);
$ctx1.sendIdx["add:"]=1;
$recv($1)._add_(anotherObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:with:",{anObject:anObject,anotherObject:anotherObject},$globals.Collection.klass)});
},
args: ["anObject", "anotherObject"],
source: "with: anObject with: anotherObject\x0a\x09\x09^ self new\x0a\x09\x09add: anObject;\x0a\x09\x09add: anotherObject;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["add:", "new", "yourself"]
}),
$globals.Collection.klass);

$core.addMethod(
$core.method({
selector: "with:with:with:",
protocol: 'instance creation',
fn: function (firstObject,secondObject,thirdObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._add_(firstObject);
$ctx1.sendIdx["add:"]=1;
$recv($1)._add_(secondObject);
$ctx1.sendIdx["add:"]=2;
$recv($1)._add_(thirdObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:with:with:",{firstObject:firstObject,secondObject:secondObject,thirdObject:thirdObject},$globals.Collection.klass)});
},
args: ["firstObject", "secondObject", "thirdObject"],
source: "with: firstObject with: secondObject with: thirdObject\x0a\x09\x09^ self new\x0a\x09\x09add: firstObject;\x0a\x09\x09add: secondObject;\x0a\x09\x09add: thirdObject;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["add:", "new", "yourself"]
}),
$globals.Collection.klass);

$core.addMethod(
$core.method({
selector: "withAll:",
protocol: 'instance creation',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._addAll_(aCollection);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"withAll:",{aCollection:aCollection},$globals.Collection.klass)});
},
args: ["aCollection"],
source: "withAll: aCollection\x0a\x09\x09^ self new\x0a\x09\x09addAll: aCollection;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["addAll:", "new", "yourself"]
}),
$globals.Collection.klass);


$core.addClass('IndexableCollection', $globals.Collection, [], 'Kernel-Collections');
$globals.IndexableCollection.comment="I am a key-value store collection, that is,\x0aI store values under indexes.\x0a\x0aAs a rule of thumb, if a collection has `#at:` and `#at:put:`,\x0ait is an IndexableCollection.";
$core.addMethod(
$core.method({
selector: "at:",
protocol: 'accessing',
fn: function (anIndex){
var self=this;
return $core.withContext(function($ctx1) {
return self._at_ifAbsent_(anIndex,(function(){
return $core.withContext(function($ctx2) {
return self._errorNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"at:",{anIndex:anIndex},$globals.IndexableCollection)});
},
args: ["anIndex"],
source: "at: anIndex\x0a\x09\x22Lookup the given index in the receiver.\x0a\x09If it is present, answer the value stored at anIndex.\x0a\x09Otherwise, raise an error.\x22\x0a\x0a\x09^ self at: anIndex ifAbsent: [ self errorNotFound ]",
referencedClasses: [],
messageSends: ["at:ifAbsent:", "errorNotFound"]
}),
$globals.IndexableCollection);

$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: 'accessing',
fn: function (anIndex,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{anIndex:anIndex,aBlock:aBlock},$globals.IndexableCollection)});
},
args: ["anIndex", "aBlock"],
source: "at: anIndex ifAbsent: aBlock\x0a\x09\x22Lookup the given index in the receiver.\x0a\x09If it is present, answer the value stored at anIndex.\x0a\x09Otherwise, answer the value of aBlock.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.IndexableCollection);

$core.addMethod(
$core.method({
selector: "at:ifAbsentPut:",
protocol: 'accessing',
fn: function (aKey,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._at_ifAbsent_(aKey,(function(){
return $core.withContext(function($ctx2) {
return self._at_put_(aKey,$recv(aBlock)._value());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsentPut:",{aKey:aKey,aBlock:aBlock},$globals.IndexableCollection)});
},
args: ["aKey", "aBlock"],
source: "at: aKey ifAbsentPut: aBlock\x0a\x09^ self at: aKey ifAbsent: [\x0a\x09\x09self at: aKey put: aBlock value ]",
referencedClasses: [],
messageSends: ["at:ifAbsent:", "at:put:", "value"]
}),
$globals.IndexableCollection);

$core.addMethod(
$core.method({
selector: "at:ifPresent:",
protocol: 'accessing',
fn: function (anIndex,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._at_ifPresent_ifAbsent_(anIndex,aBlock,(function(){
return nil;

}));
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:",{anIndex:anIndex,aBlock:aBlock},$globals.IndexableCollection)});
},
args: ["anIndex", "aBlock"],
source: "at: anIndex ifPresent: aBlock\x0a\x09\x22Lookup the given index in the receiver.\x0a\x09If it is present, answer the value of evaluating aBlock with the value stored at anIndex.\x0a\x09Otherwise, answer nil.\x22\x0a\x0a\x09^ self at: anIndex ifPresent: aBlock ifAbsent: [ nil ]",
referencedClasses: [],
messageSends: ["at:ifPresent:ifAbsent:"]
}),
$globals.IndexableCollection);

$core.addMethod(
$core.method({
selector: "at:ifPresent:ifAbsent:",
protocol: 'accessing',
fn: function (anIndex,aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:ifAbsent:",{anIndex:anIndex,aBlock:aBlock,anotherBlock:anotherBlock},$globals.IndexableCollection)});
},
args: ["anIndex", "aBlock", "anotherBlock"],
source: "at: anIndex ifPresent: aBlock ifAbsent: anotherBlock\x0a\x09\x22Lookup the given index in the receiver.\x0a\x09If it is present, answer the value of evaluating aBlock with the value stored at anIndex.\x0a\x09Otherwise, answer the value of anotherBlock.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.IndexableCollection);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: 'accessing',
fn: function (anIndex,anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"at:put:",{anIndex:anIndex,anObject:anObject},$globals.IndexableCollection)});
},
args: ["anIndex", "anObject"],
source: "at: anIndex put: anObject\x0a\x09\x22Store anObject under the given index in the receiver.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.IndexableCollection);

$core.addMethod(
$core.method({
selector: "indexOf:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self._indexOf_ifAbsent_(anObject,(function(){
return $core.withContext(function($ctx2) {
return self._errorNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"indexOf:",{anObject:anObject},$globals.IndexableCollection)});
},
args: ["anObject"],
source: "indexOf: anObject\x0a\x09\x22Lookup index at which anObject is stored in the receiver.\x0a\x09If not present, raise an error.\x22\x0a\x0a\x09^ self indexOf: anObject ifAbsent: [ self errorNotFound ]",
referencedClasses: [],
messageSends: ["indexOf:ifAbsent:", "errorNotFound"]
}),
$globals.IndexableCollection);

$core.addMethod(
$core.method({
selector: "indexOf:ifAbsent:",
protocol: 'accessing',
fn: function (anObject,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"indexOf:ifAbsent:",{anObject:anObject,aBlock:aBlock},$globals.IndexableCollection)});
},
args: ["anObject", "aBlock"],
source: "indexOf: anObject ifAbsent: aBlock\x0a\x09\x22Lookup index at which anObject is stored in the receiver.\x0a\x09If not present, return value of executing aBlock.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.IndexableCollection);

$core.addMethod(
$core.method({
selector: "with:do:",
protocol: 'enumerating',
fn: function (anotherCollection,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._withIndexDo_((function(each,index){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_value_(each,$recv(anotherCollection)._at_(index));
}, function($ctx2) {$ctx2.fillBlock({each:each,index:index},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"with:do:",{anotherCollection:anotherCollection,aBlock:aBlock},$globals.IndexableCollection)});
},
args: ["anotherCollection", "aBlock"],
source: "with: anotherCollection do: aBlock\x0a\x09\x22Calls aBlock with every value from self\x0a\x09and with indetically-indexed value from anotherCollection\x22\x0a\x0a\x09self withIndexDo: [ :each :index |\x0a\x09\x09aBlock value: each value: (anotherCollection at: index) ]",
referencedClasses: [],
messageSends: ["withIndexDo:", "value:value:", "at:"]
}),
$globals.IndexableCollection);

$core.addMethod(
$core.method({
selector: "withIndexDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"withIndexDo:",{aBlock:aBlock},$globals.IndexableCollection)});
},
args: ["aBlock"],
source: "withIndexDo: aBlock\x0a\x09\x22Calls aBlock with every value from self\x0a\x09and with its index as the second argument\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.IndexableCollection);



$core.addClass('AssociativeCollection', $globals.IndexableCollection, [], 'Kernel-Collections');
$globals.AssociativeCollection.comment="I am a base class for object-indexed collections (Dictionary et.al.).";
$core.addMethod(
$core.method({
selector: "=",
protocol: 'comparing',
fn: function (anAssocitativeCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$5;
$2=self._class();
$ctx1.sendIdx["class"]=1;
$1=$recv($2).__eq($recv(anAssocitativeCollection)._class());
$ctx1.sendIdx["="]=1;
if(!$core.assert($1)){
return false;
};
$4=self._size();
$ctx1.sendIdx["size"]=1;
$3=$recv($4).__eq($recv(anAssocitativeCollection)._size());
$ctx1.sendIdx["="]=2;
if(!$core.assert($3)){
return false;
};
$5=self._associations();
$ctx1.sendIdx["associations"]=1;
return $recv($5).__eq($recv(anAssocitativeCollection)._associations());
}, function($ctx1) {$ctx1.fill(self,"=",{anAssocitativeCollection:anAssocitativeCollection},$globals.AssociativeCollection)});
},
args: ["anAssocitativeCollection"],
source: "= anAssocitativeCollection\x0a\x09self class = anAssocitativeCollection class ifFalse: [ ^ false ].\x0a\x09self size = anAssocitativeCollection size ifFalse: [ ^ false ].\x0a\x09^ self associations = anAssocitativeCollection associations",
referencedClasses: [],
messageSends: ["ifFalse:", "=", "class", "size", "associations"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "add:",
protocol: 'adding/removing',
fn: function (anAssociation){
var self=this;
return $core.withContext(function($ctx1) {
self._at_put_($recv(anAssociation)._key(),$recv(anAssociation)._value());
return self;
}, function($ctx1) {$ctx1.fill(self,"add:",{anAssociation:anAssociation},$globals.AssociativeCollection)});
},
args: ["anAssociation"],
source: "add: anAssociation\x0a\x09self at: anAssociation key put: anAssociation value",
referencedClasses: [],
messageSends: ["at:put:", "key", "value"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "addAll:",
protocol: 'adding/removing',
fn: function (anAssociativeCollection){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.AssociativeCollection.superclass||$boot.dnu).fn.prototype._addAll_.apply($recv(self), [$recv(anAssociativeCollection)._associations()]));
$ctx1.supercall = false;
return anAssociativeCollection;
}, function($ctx1) {$ctx1.fill(self,"addAll:",{anAssociativeCollection:anAssociativeCollection},$globals.AssociativeCollection)});
},
args: ["anAssociativeCollection"],
source: "addAll: anAssociativeCollection\x0a\x09super addAll: anAssociativeCollection associations.\x0a\x09^ anAssociativeCollection",
referencedClasses: [],
messageSends: ["addAll:", "associations"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "asDictionary",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Dictionary)._from_(self._associations());
}, function($ctx1) {$ctx1.fill(self,"asDictionary",{},$globals.AssociativeCollection)});
},
args: [],
source: "asDictionary\x0a\x09^ Dictionary from: self associations",
referencedClasses: ["Dictionary"],
messageSends: ["from:", "associations"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "asHashedCollection",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.HashedCollection)._from_(self._associations());
}, function($ctx1) {$ctx1.fill(self,"asHashedCollection",{},$globals.AssociativeCollection)});
},
args: [],
source: "asHashedCollection\x0a\x09^ HashedCollection from: self associations",
referencedClasses: ["HashedCollection"],
messageSends: ["from:", "associations"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "asJSON",
protocol: 'converting',
fn: function (){
var self=this;
var hash;
return $core.withContext(function($ctx1) {
hash=$recv($globals.HashedCollection)._new();
self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(hash)._at_put_(key,$recv(value)._asJSON());
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return hash;
}, function($ctx1) {$ctx1.fill(self,"asJSON",{hash:hash},$globals.AssociativeCollection)});
},
args: [],
source: "asJSON\x0a\x09| hash |\x0a\x09hash := HashedCollection new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09hash at: key put: value asJSON ].\x0a\x09^ hash",
referencedClasses: ["HashedCollection"],
messageSends: ["new", "keysAndValuesDo:", "at:put:", "asJSON"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "associations",
protocol: 'accessing',
fn: function (){
var self=this;
var associations;
return $core.withContext(function($ctx1) {
associations=[];
self._associationsDo_((function(each){
return $core.withContext(function($ctx2) {
return $recv(associations)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return associations;
}, function($ctx1) {$ctx1.fill(self,"associations",{associations:associations},$globals.AssociativeCollection)});
},
args: [],
source: "associations\x0a\x09| associations |\x0a\x09associations := #().\x0a\x09self associationsDo: [ :each | associations add: each ].\x0a\x09^ associations",
referencedClasses: [],
messageSends: ["associationsDo:", "add:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "associationsDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_($recv($globals.Association)._key_value_(key,value));
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"associationsDo:",{aBlock:aBlock},$globals.AssociativeCollection)});
},
args: ["aBlock"],
source: "associationsDo: aBlock\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09aBlock value: (Association key: key value: value) ]",
referencedClasses: ["Association"],
messageSends: ["keysAndValuesDo:", "value:", "key:value:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "at:ifPresent:ifAbsent:",
protocol: 'accessing',
fn: function (aKey,aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._includesKey_(aKey);
if($core.assert($1)){
return $recv(aBlock)._value_(self._at_(aKey));
} else {
return $recv(anotherBlock)._value();
};
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:ifAbsent:",{aKey:aKey,aBlock:aBlock,anotherBlock:anotherBlock},$globals.AssociativeCollection)});
},
args: ["aKey", "aBlock", "anotherBlock"],
source: "at: aKey ifPresent: aBlock ifAbsent: anotherBlock\x0a\x09\x22Lookup the given key in the receiver.\x0a\x09If it is present, answer the value of evaluating the oneArgBlock \x0a\x09with the value associated with the key, otherwise answer the value \x0a\x09of absentBlock.\x22\x0a\x09\x0a\x09^ (self includesKey: aKey)\x0a\x09\x09ifTrue: [ aBlock value: (self at: aKey) ]\x0a\x09\x09ifFalse: [ anotherBlock value ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "includesKey:", "value:", "at:", "value"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "collect:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
var newDict;
return $core.withContext(function($ctx1) {
newDict=$recv(self._class())._new();
self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(newDict)._at_put_(key,$recv(aBlock)._value_(value));
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return newDict;
}, function($ctx1) {$ctx1.fill(self,"collect:",{aBlock:aBlock,newDict:newDict},$globals.AssociativeCollection)});
},
args: ["aBlock"],
source: "collect: aBlock\x0a\x09| newDict |\x0a\x09newDict := self class new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09newDict at: key put: (aBlock value: value) ].\x0a\x09^ newDict",
referencedClasses: [],
messageSends: ["new", "class", "keysAndValuesDo:", "at:put:", "value:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: 'copying',
fn: function (){
var self=this;
var copy;
return $core.withContext(function($ctx1) {
copy=$recv(self._class())._new();
self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(copy)._at_put_(key,$recv(value)._deepCopy());
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return copy;
}, function($ctx1) {$ctx1.fill(self,"deepCopy",{copy:copy},$globals.AssociativeCollection)});
},
args: [],
source: "deepCopy\x0a\x09| copy |\x0a\x09copy := self class new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09copy at: key put: value deepCopy ].\x0a\x09^ copy",
referencedClasses: [],
messageSends: ["new", "class", "keysAndValuesDo:", "at:put:", "deepCopy"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "detect:ifNone:",
protocol: 'enumerating',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._values())._detect_ifNone_(aBlock,anotherBlock);
}, function($ctx1) {$ctx1.fill(self,"detect:ifNone:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.AssociativeCollection)});
},
args: ["aBlock", "anotherBlock"],
source: "detect: aBlock ifNone: anotherBlock\x0a\x09^ self values detect: aBlock ifNone: anotherBlock",
referencedClasses: [],
messageSends: ["detect:ifNone:", "values"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "do:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._valuesDo_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock},$globals.AssociativeCollection)});
},
args: ["aBlock"],
source: "do: aBlock\x0a\x09self valuesDo: aBlock",
referencedClasses: [],
messageSends: ["valuesDo:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "includes:",
protocol: 'enumerating',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._values())._includes_(anObject);
}, function($ctx1) {$ctx1.fill(self,"includes:",{anObject:anObject},$globals.AssociativeCollection)});
},
args: ["anObject"],
source: "includes: anObject\x0a\x09^ self values includes: anObject",
referencedClasses: [],
messageSends: ["includes:", "values"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "includesKey:",
protocol: 'testing',
fn: function (aKey){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"includesKey:",{aKey:aKey},$globals.AssociativeCollection)});
},
args: ["aKey"],
source: "includesKey: aKey\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "indexOf:ifAbsent:",
protocol: 'accessing',
fn: function (anObject,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._keys())._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
return $recv(self._at_(each)).__eq(anObject);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),aBlock);
}, function($ctx1) {$ctx1.fill(self,"indexOf:ifAbsent:",{anObject:anObject,aBlock:aBlock},$globals.AssociativeCollection)});
},
args: ["anObject", "aBlock"],
source: "indexOf: anObject ifAbsent: aBlock\x0a\x09^ self keys \x0a\x09\x09detect: [ :each | (self at: each) = anObject ] \x0a\x09\x09ifNone: aBlock",
referencedClasses: [],
messageSends: ["detect:ifNone:", "keys", "=", "at:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "keyAtValue:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self._keyAtValue_ifAbsent_(anObject,(function(){
return $core.withContext(function($ctx2) {
return self._errorNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"keyAtValue:",{anObject:anObject},$globals.AssociativeCollection)});
},
args: ["anObject"],
source: "keyAtValue: anObject\x0a\x09^ self keyAtValue: anObject ifAbsent: [ self errorNotFound ]",
referencedClasses: [],
messageSends: ["keyAtValue:ifAbsent:", "errorNotFound"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "keyAtValue:ifAbsent:",
protocol: 'accessing',
fn: function (anObject,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._indexOf_ifAbsent_(anObject,aBlock);
}, function($ctx1) {$ctx1.fill(self,"keyAtValue:ifAbsent:",{anObject:anObject,aBlock:aBlock},$globals.AssociativeCollection)});
},
args: ["anObject", "aBlock"],
source: "keyAtValue: anObject ifAbsent: aBlock\x0a\x09^ self indexOf: anObject ifAbsent: aBlock",
referencedClasses: [],
messageSends: ["indexOf:ifAbsent:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "keys",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"keys",{},$globals.AssociativeCollection)});
},
args: [],
source: "keys\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "keysAndValuesDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._keysDo_((function(each){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_value_(each,self._at_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"keysAndValuesDo:",{aBlock:aBlock},$globals.AssociativeCollection)});
},
args: ["aBlock"],
source: "keysAndValuesDo: aBlock\x0a\x09self keysDo: [ :each |\x0a\x09\x09aBlock value: each value: (self at: each) ]",
referencedClasses: [],
messageSends: ["keysDo:", "value:value:", "at:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "keysDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"keysDo:",{aBlock:aBlock},$globals.AssociativeCollection)});
},
args: ["aBlock"],
source: "keysDo: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.AssociativeCollection.superclass||$boot.dnu).fn.prototype._printOn_.apply($recv(self), [aStream]));
$ctx1.supercall = false;
$ctx1.sendIdx["printOn:"]=1;
$recv(aStream)._nextPutAll_(" (");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(self._associations())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._printOn_(aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(aStream)._nextPutAll_(" , ");
$ctx2.sendIdx["nextPutAll:"]=2;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.AssociativeCollection)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09\x0a\x09aStream nextPutAll: ' ('.\x0a\x09self associations\x0a\x09\x09do: [ :each | each printOn: aStream ]\x0a\x09\x09separatedBy: [ aStream nextPutAll: ' , ' ].\x0a\x09aStream nextPutAll: ')'",
referencedClasses: [],
messageSends: ["printOn:", "nextPutAll:", "do:separatedBy:", "associations"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "remove:ifAbsent:",
protocol: 'adding/removing',
fn: function (aKey,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._removeKey_ifAbsent_(aKey,aBlock);
}, function($ctx1) {$ctx1.fill(self,"remove:ifAbsent:",{aKey:aKey,aBlock:aBlock},$globals.AssociativeCollection)});
},
args: ["aKey", "aBlock"],
source: "remove: aKey ifAbsent: aBlock\x0a\x09^ self removeKey: aKey ifAbsent: aBlock",
referencedClasses: [],
messageSends: ["removeKey:ifAbsent:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: 'adding/removing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._keys())._do_((function(each){
return $core.withContext(function($ctx2) {
return self._removeKey_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"removeAll",{},$globals.AssociativeCollection)});
},
args: [],
source: "removeAll\x0a\x09^ self keys do: [ :each | self removeKey: each ]",
referencedClasses: [],
messageSends: ["do:", "keys", "removeKey:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "removeKey:",
protocol: 'adding/removing',
fn: function (aKey){
var self=this;
return $core.withContext(function($ctx1) {
return self._remove_(aKey);
}, function($ctx1) {$ctx1.fill(self,"removeKey:",{aKey:aKey},$globals.AssociativeCollection)});
},
args: ["aKey"],
source: "removeKey: aKey\x0a\x09^ self remove: aKey",
referencedClasses: [],
messageSends: ["remove:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "removeKey:ifAbsent:",
protocol: 'adding/removing',
fn: function (aKey,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"removeKey:ifAbsent:",{aKey:aKey,aBlock:aBlock},$globals.AssociativeCollection)});
},
args: ["aKey", "aBlock"],
source: "removeKey: aKey ifAbsent: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "select:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
var newDict;
return $core.withContext(function($ctx1) {
var $1;
newDict=$recv(self._class())._new();
self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
$1=$recv(aBlock)._value_(value);
if($core.assert($1)){
return $recv(newDict)._at_put_(key,value);
};
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return newDict;
}, function($ctx1) {$ctx1.fill(self,"select:",{aBlock:aBlock,newDict:newDict},$globals.AssociativeCollection)});
},
args: ["aBlock"],
source: "select: aBlock\x0a\x09| newDict |\x0a\x09newDict := self class new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09(aBlock value: value) ifTrue: [ newDict at: key put: value ]].\x0a\x09^ newDict",
referencedClasses: [],
messageSends: ["new", "class", "keysAndValuesDo:", "ifTrue:", "value:", "at:put:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: 'copying',
fn: function (){
var self=this;
var copy;
return $core.withContext(function($ctx1) {
copy=$recv(self._class())._new();
self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(copy)._at_put_(key,value);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return copy;
}, function($ctx1) {$ctx1.fill(self,"shallowCopy",{copy:copy},$globals.AssociativeCollection)});
},
args: [],
source: "shallowCopy\x0a\x09| copy |\x0a\x09copy := self class new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09copy at: key put: value ].\x0a\x09^ copy",
referencedClasses: [],
messageSends: ["new", "class", "keysAndValuesDo:", "at:put:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "size",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._keys())._size();
}, function($ctx1) {$ctx1.fill(self,"size",{},$globals.AssociativeCollection)});
},
args: [],
source: "size\x0a\x09^ self keys size",
referencedClasses: [],
messageSends: ["size", "keys"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "values",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"values",{},$globals.AssociativeCollection)});
},
args: [],
source: "values\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "valuesDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"valuesDo:",{aBlock:aBlock},$globals.AssociativeCollection)});
},
args: ["aBlock"],
source: "valuesDo: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "withIndexDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_value_(value,key);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"withIndexDo:",{aBlock:aBlock},$globals.AssociativeCollection)});
},
args: ["aBlock"],
source: "withIndexDo: aBlock\x0a\x09self keysAndValuesDo: [ :key :value | aBlock value: value value: key ]",
referencedClasses: [],
messageSends: ["keysAndValuesDo:", "value:value:"]
}),
$globals.AssociativeCollection);


$core.addMethod(
$core.method({
selector: "from:",
protocol: 'instance creation',
fn: function (aCollection){
var self=this;
var newCollection;
return $core.withContext(function($ctx1) {
newCollection=self._new();
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(newCollection)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return newCollection;
}, function($ctx1) {$ctx1.fill(self,"from:",{aCollection:aCollection,newCollection:newCollection},$globals.AssociativeCollection.klass)});
},
args: ["aCollection"],
source: "from: aCollection\x0a\x09| newCollection |\x0a\x09newCollection := self new.\x0a\x09aCollection do: [ :each | newCollection add: each ].\x0a\x09^ newCollection",
referencedClasses: [],
messageSends: ["new", "do:", "add:"]
}),
$globals.AssociativeCollection.klass);

$core.addMethod(
$core.method({
selector: "fromPairs:",
protocol: 'instance creation',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
return self._from_(aCollection);
}, function($ctx1) {$ctx1.fill(self,"fromPairs:",{aCollection:aCollection},$globals.AssociativeCollection.klass)});
},
args: ["aCollection"],
source: "fromPairs: aCollection\x0a\x09\x22This message is poorly named and has been replaced by #from:\x22\x0a\x09^ self from: aCollection",
referencedClasses: [],
messageSends: ["from:"]
}),
$globals.AssociativeCollection.klass);

$core.addMethod(
$core.method({
selector: "newFromPairs:",
protocol: 'instance creation',
fn: function (aCollection){
var self=this;
var newCollection;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$4;
$2=$recv(aCollection)._size();
$ctx1.sendIdx["size"]=1;
$1=$recv($2)._even();
if(!$core.assert($1)){
self._error_("#newFromPairs only accepts arrays of an even length");
};
newCollection=self._new();
$recv((1)._to_by_($recv(aCollection)._size(),(2)))._do_((function(each){
return $core.withContext(function($ctx2) {
$3=newCollection;
$4=$recv(aCollection)._at_(each);
$ctx2.sendIdx["at:"]=1;
return $recv($3)._at_put_($4,$recv(aCollection)._at_($recv(each).__plus((1))));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
return newCollection;
}, function($ctx1) {$ctx1.fill(self,"newFromPairs:",{aCollection:aCollection,newCollection:newCollection},$globals.AssociativeCollection.klass)});
},
args: ["aCollection"],
source: "newFromPairs: aCollection\x0a\x09\x22Accept an array of elements where every two elements form an \x0a\x09association - the odd element being the key, and the even element the value.\x22\x0a\x09\x0a\x09| newCollection |\x0a\x09\x0a\x09aCollection size even ifFalse: [ \x0a\x09\x09self error: '#newFromPairs only accepts arrays of an even length' ].\x0a\x09\x09\x0a\x09newCollection := self new.\x0a\x09( 1 to: aCollection size by: 2 ) do: [ :each | \x0a\x09\x09newCollection at: (aCollection at: each) put: (aCollection at: each + 1) ].\x0a\x09\x09\x0a\x09^ newCollection",
referencedClasses: [],
messageSends: ["ifFalse:", "even", "size", "error:", "new", "do:", "to:by:", "at:put:", "at:", "+"]
}),
$globals.AssociativeCollection.klass);


$core.addClass('Dictionary', $globals.AssociativeCollection, ['keys', 'values'], 'Kernel-Collections');
$globals.Dictionary.comment="I represent a set of elements that can be viewed from one of two perspectives: a set of associations,\x0aor a container of values that are externally named where the name can be any object that responds to `=`.\x0a\x0aThe external name is referred to as the key.";
$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: 'accessing',
fn: function (aKey,aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		var index = self._positionOfKey_(aKey);
		return index >=0 ? self['@values'][index] : aBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{aKey:aKey,aBlock:aBlock},$globals.Dictionary)});
},
args: ["aKey", "aBlock"],
source: "at: aKey ifAbsent: aBlock\x0a\x09<\x0a\x09\x09var index = self._positionOfKey_(aKey);\x0a\x09\x09return index >>=0 ? self['@values'][index] : aBlock._value();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: 'accessing',
fn: function (aKey,aValue){
var self=this;
return $core.withContext(function($ctx1) {

		var index = self._positionOfKey_(aKey);
		if(index === -1) {
			var keys = self['@keys'];
			index = keys.length;
			keys.push(aKey);
		}

		return self['@values'][index] = aValue;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:put:",{aKey:aKey,aValue:aValue},$globals.Dictionary)});
},
args: ["aKey", "aValue"],
source: "at: aKey put: aValue\x0a\x09<\x0a\x09\x09var index = self._positionOfKey_(aKey);\x0a\x09\x09if(index === -1) {\x0a\x09\x09\x09var keys = self['@keys'];\x0a\x09\x09\x09index = keys.length;\x0a\x09\x09\x09keys.push(aKey);\x0a\x09\x09}\x0a\x0a\x09\x09return self['@values'][index] = aValue;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "includesKey:",
protocol: 'testing',
fn: function (aKey){
var self=this;
return $core.withContext(function($ctx1) {
 return self._positionOfKey_(aKey) >= 0; ;
return self;
}, function($ctx1) {$ctx1.fill(self,"includesKey:",{aKey:aKey},$globals.Dictionary)});
},
args: ["aKey"],
source: "includesKey: aKey\x0a\x09< return self._positionOfKey_(aKey) >>= 0; >",
referencedClasses: [],
messageSends: []
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "indexOf:ifAbsent:",
protocol: 'accessing',
fn: function (anObject,aBlock){
var self=this;
var index;
return $core.withContext(function($ctx1) {
var $1;
index=$recv(self["@values"])._indexOf_ifAbsent_(anObject,(function(){
return (0);

}));
$1=$recv(index).__eq((0));
if($core.assert($1)){
return $recv(aBlock)._value();
} else {
return $recv(self["@keys"])._at_(index);
};
}, function($ctx1) {$ctx1.fill(self,"indexOf:ifAbsent:",{anObject:anObject,aBlock:aBlock,index:index},$globals.Dictionary)});
},
args: ["anObject", "aBlock"],
source: "indexOf: anObject ifAbsent: aBlock\x0a\x09| index |\x0a\x09index := values \x0a\x09\x09indexOf: anObject \x0a\x09\x09ifAbsent: [ 0 ].\x0a\x09^ index = 0 \x0a\x09\x09ifTrue: [ aBlock value ] \x0a\x09\x09ifFalse: [ keys at: index ]",
referencedClasses: [],
messageSends: ["indexOf:ifAbsent:", "ifTrue:ifFalse:", "=", "value", "at:"]
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Dictionary.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@keys"]=[];
self["@values"]=[];
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.Dictionary)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09keys := #().\x0a\x09values := #()",
referencedClasses: [],
messageSends: ["initialize"]
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "keys",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@keys"])._copy();
}, function($ctx1) {$ctx1.fill(self,"keys",{},$globals.Dictionary)});
},
args: [],
source: "keys\x0a\x09^ keys copy",
referencedClasses: [],
messageSends: ["copy"]
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "keysAndValuesDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@keys"])._with_do_(self["@values"],aBlock);
}, function($ctx1) {$ctx1.fill(self,"keysAndValuesDo:",{aBlock:aBlock},$globals.Dictionary)});
},
args: ["aBlock"],
source: "keysAndValuesDo: aBlock\x0a\x09^ keys with: values do: aBlock",
referencedClasses: [],
messageSends: ["with:do:"]
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "keysDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@keys"])._do_(aBlock);
}, function($ctx1) {$ctx1.fill(self,"keysDo:",{aBlock:aBlock},$globals.Dictionary)});
},
args: ["aBlock"],
source: "keysDo: aBlock\x0a\x09^ keys do: aBlock",
referencedClasses: [],
messageSends: ["do:"]
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "positionOfKey:",
protocol: 'private',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {

		var keys = self['@keys'];
		for(var i=0;i<keys.length;i++){
			if(keys[i].__eq(anObject)) { return i;}
		}
		return -1;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"positionOfKey:",{anObject:anObject},$globals.Dictionary)});
},
args: ["anObject"],
source: "positionOfKey: anObject\x0a\x09<\x0a\x09\x09var keys = self['@keys'];\x0a\x09\x09for(var i=0;i<keys.length;i++){\x0a\x09\x09\x09if(keys[i].__eq(anObject)) { return i;}\x0a\x09\x09}\x0a\x09\x09return -1;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: 'adding/removing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@keys"])._removeAll();
$ctx1.sendIdx["removeAll"]=1;
$recv(self["@values"])._removeAll();
return self;
}, function($ctx1) {$ctx1.fill(self,"removeAll",{},$globals.Dictionary)});
},
args: [],
source: "removeAll\x0a\x09keys removeAll.\x0a\x09values removeAll",
referencedClasses: [],
messageSends: ["removeAll"]
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "removeKey:ifAbsent:",
protocol: 'adding/removing',
fn: function (aKey,aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		var index = self._positionOfKey_(aKey);
		if(index === -1) {
			return aBlock._value()
		} else {
			var keys = self['@keys'], values = self['@values'];
			var value = values[index], l = keys.length;
			keys[index] = keys[l-1];
			keys.pop();
			values[index] = values[l-1];
			values.pop();
			return value;
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeKey:ifAbsent:",{aKey:aKey,aBlock:aBlock},$globals.Dictionary)});
},
args: ["aKey", "aBlock"],
source: "removeKey: aKey ifAbsent: aBlock\x0a\x09<\x0a\x09\x09var index = self._positionOfKey_(aKey);\x0a\x09\x09if(index === -1) {\x0a\x09\x09\x09return aBlock._value()\x0a\x09\x09} else {\x0a\x09\x09\x09var keys = self['@keys'], values = self['@values'];\x0a\x09\x09\x09var value = values[index], l = keys.length;\x0a\x09\x09\x09keys[index] = keys[l-1];\x0a\x09\x09\x09keys.pop();\x0a\x09\x09\x09values[index] = values[l-1];\x0a\x09\x09\x09values.pop();\x0a\x09\x09\x09return value;\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "values",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@values"];

},
args: [],
source: "values\x0a\x09^ values",
referencedClasses: [],
messageSends: []
}),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "valuesDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@values"])._do_(aBlock);
}, function($ctx1) {$ctx1.fill(self,"valuesDo:",{aBlock:aBlock},$globals.Dictionary)});
},
args: ["aBlock"],
source: "valuesDo: aBlock\x0a\x09^ values do: aBlock",
referencedClasses: [],
messageSends: ["do:"]
}),
$globals.Dictionary);



$core.addClass('HashedCollection', $globals.AssociativeCollection, [], 'Kernel-Collections');
$globals.HashedCollection.comment="I am a traditional JavaScript object, or a Smalltalk `Dictionary`.\x0a\x0aUnlike a `Dictionary`, I can only have strings as keys.";
$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: 'accessing',
fn: function (aKey,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._includesKey_(aKey);
if($core.assert($1)){
return self._basicAt_(aKey);
} else {
return $recv(aBlock)._value();
};
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{aKey:aKey,aBlock:aBlock},$globals.HashedCollection)});
},
args: ["aKey", "aBlock"],
source: "at: aKey ifAbsent: aBlock\x0a\x09^ (self includesKey: aKey)\x0a\x09\x09ifTrue: [ self basicAt: aKey ]\x0a\x09\x09ifFalse: [ aBlock value ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "includesKey:", "basicAt:", "value"]
}),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: 'accessing',
fn: function (aKey,aValue){
var self=this;
return $core.withContext(function($ctx1) {
return self._basicAt_put_(aKey,aValue);
}, function($ctx1) {$ctx1.fill(self,"at:put:",{aKey:aKey,aValue:aValue},$globals.HashedCollection)});
},
args: ["aKey", "aValue"],
source: "at: aKey put: aValue\x0a\x09^ self basicAt: aKey put: aValue",
referencedClasses: [],
messageSends: ["basicAt:put:"]
}),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "includesKey:",
protocol: 'testing',
fn: function (aKey){
var self=this;
return $core.withContext(function($ctx1) {
return self.hasOwnProperty(aKey);
return self;
}, function($ctx1) {$ctx1.fill(self,"includesKey:",{aKey:aKey},$globals.HashedCollection)});
},
args: ["aKey"],
source: "includesKey: aKey\x0a\x09<return self.hasOwnProperty(aKey)>",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "keys",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Object.keys(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"keys",{},$globals.HashedCollection)});
},
args: [],
source: "keys\x0a\x09<return Object.keys(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "keysDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._keys())._do_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"keysDo:",{aBlock:aBlock},$globals.HashedCollection)});
},
args: ["aBlock"],
source: "keysDo: aBlock\x0a\x09self keys do: aBlock",
referencedClasses: [],
messageSends: ["do:", "keys"]
}),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "removeKey:ifAbsent:",
protocol: 'adding/removing',
fn: function (aKey,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self._at_ifPresent_ifAbsent_(aKey,(function(removed){
return $core.withContext(function($ctx2) {
self._basicDelete_(aKey);
return removed;
}, function($ctx2) {$ctx2.fillBlock({removed:removed},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"removeKey:ifAbsent:",{aKey:aKey,aBlock:aBlock},$globals.HashedCollection)});
},
args: ["aKey", "aBlock"],
source: "removeKey: aKey ifAbsent: aBlock\x0a\x09^ self\x0a\x09\x09at: aKey\x0a\x09\x09ifPresent: [ :removed | self basicDelete: aKey. removed ]\x0a\x09\x09ifAbsent: [ aBlock value ]",
referencedClasses: [],
messageSends: ["at:ifPresent:ifAbsent:", "basicDelete:", "value"]
}),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "values",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		return self._keys().map(function(key){
			return self._at_(key);
		});
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"values",{},$globals.HashedCollection)});
},
args: [],
source: "values\x0a\x09<\x0a\x09\x09return self._keys().map(function(key){\x0a\x09\x09\x09return self._at_(key);\x0a\x09\x09});\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "valuesDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._values())._do_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"valuesDo:",{aBlock:aBlock},$globals.HashedCollection)});
},
args: ["aBlock"],
source: "valuesDo: aBlock\x0a\x09self values do: aBlock",
referencedClasses: [],
messageSends: ["do:", "values"]
}),
$globals.HashedCollection);



$core.addClass('SequenceableCollection', $globals.IndexableCollection, [], 'Kernel-Collections');
$globals.SequenceableCollection.comment="I am an IndexableCollection\x0awith numeric indexes starting with 1.";
$core.addMethod(
$core.method({
selector: "=",
protocol: 'comparing',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$4,$1,$5;
var $early={};
try {
$3=self._class();
$ctx1.sendIdx["class"]=1;
$2=$recv($3).__eq($recv(aCollection)._class());
$ctx1.sendIdx["="]=1;
$1=$recv($2)._and_((function(){
return $core.withContext(function($ctx2) {
$4=self._size();
$ctx2.sendIdx["size"]=1;
return $recv($4).__eq($recv(aCollection)._size());
$ctx2.sendIdx["="]=2;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
if(!$core.assert($1)){
return false;
};
self._withIndexDo_((function(each,i){
return $core.withContext(function($ctx2) {
$5=$recv($recv(aCollection)._at_(i)).__eq(each);
if(!$core.assert($5)){
throw $early=[false];
};
}, function($ctx2) {$ctx2.fillBlock({each:each,i:i},$ctx1,3)});
}));
return true;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"=",{aCollection:aCollection},$globals.SequenceableCollection)});
},
args: ["aCollection"],
source: "= aCollection\x0a\x09(self class = aCollection class and: [\x0a\x09\x09self size = aCollection size ]) ifFalse: [ ^ false ].\x0a\x09self withIndexDo: [ :each :i |\x0a\x09\x09\x09\x09(aCollection at: i) = each ifFalse: [ ^ false ]].\x0a\x09^ true",
referencedClasses: [],
messageSends: ["ifFalse:", "and:", "=", "class", "size", "withIndexDo:", "at:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "addLast:",
protocol: 'adding/removing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._add_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"addLast:",{anObject:anObject},$globals.SequenceableCollection)});
},
args: ["anObject"],
source: "addLast: anObject\x0a\x09self add: anObject",
referencedClasses: [],
messageSends: ["add:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "allButFirst",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._copyFrom_to_((2),self._size());
}, function($ctx1) {$ctx1.fill(self,"allButFirst",{},$globals.SequenceableCollection)});
},
args: [],
source: "allButFirst\x0a\x09^ self copyFrom: 2 to: self size",
referencedClasses: [],
messageSends: ["copyFrom:to:", "size"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "allButLast",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._copyFrom_to_((1),$recv(self._size()).__minus((1)));
}, function($ctx1) {$ctx1.fill(self,"allButLast",{},$globals.SequenceableCollection)});
},
args: [],
source: "allButLast\x0a\x09^ self copyFrom: 1 to: self size - 1",
referencedClasses: [],
messageSends: ["copyFrom:to:", "-", "size"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "atRandom",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._at_($recv(self._size())._atRandom());
}, function($ctx1) {$ctx1.fill(self,"atRandom",{},$globals.SequenceableCollection)});
},
args: [],
source: "atRandom\x0a\x09^ self at: self size atRandom",
referencedClasses: [],
messageSends: ["at:", "atRandom", "size"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "beginsWith:",
protocol: 'testing',
fn: function (prefix){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1;
$2=self._size();
$ctx1.sendIdx["size"]=1;
$3=$recv(prefix)._size();
$ctx1.sendIdx["size"]=2;
$1=$recv($2).__lt($3);
if($core.assert($1)){
return false;
};
return $recv(self._first_($recv(prefix)._size())).__eq(prefix);
}, function($ctx1) {$ctx1.fill(self,"beginsWith:",{prefix:prefix},$globals.SequenceableCollection)});
},
args: ["prefix"],
source: "beginsWith: prefix\x0a\x09self size < prefix size ifTrue: [ ^ false ].\x0a\x09^ (self first: prefix size) = prefix",
referencedClasses: [],
messageSends: ["ifTrue:", "<", "size", "=", "first:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "copyFrom:to:",
protocol: 'copying',
fn: function (anIndex,anotherIndex){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"copyFrom:to:",{anIndex:anIndex,anotherIndex:anotherIndex},$globals.SequenceableCollection)});
},
args: ["anIndex", "anotherIndex"],
source: "copyFrom: anIndex to: anotherIndex\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "detect:ifNone:",
protocol: 'enumerating',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {

		self = self._numericallyIndexable();
		for(var i = 0; i < self.length; i++)
			if(aBlock._value_(self[i]))
				return self[i];
		return anotherBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"detect:ifNone:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.SequenceableCollection)});
},
args: ["aBlock", "anotherBlock"],
source: "detect: aBlock ifNone: anotherBlock\x0a\x09<\x0a\x09\x09self = self._numericallyIndexable();\x0a\x09\x09for(var i = 0; i < self.length; i++)\x0a\x09\x09\x09if(aBlock._value_(self[i]))\x0a\x09\x09\x09\x09return self[i];\x0a\x09\x09return anotherBlock._value();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "do:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		self = self._numericallyIndexable();
		for(var i=0; i < self.length; i++) {
			aBlock._value_(self[i]);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock},$globals.SequenceableCollection)});
},
args: ["aBlock"],
source: "do: aBlock\x0a\x09<\x0a\x09\x09self = self._numericallyIndexable();\x0a\x09\x09for(var i=0; i < self.length; i++) {\x0a\x09\x09\x09aBlock._value_(self[i]);\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "endsWith:",
protocol: 'testing',
fn: function (suffix){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1;
$2=self._size();
$ctx1.sendIdx["size"]=1;
$3=$recv(suffix)._size();
$ctx1.sendIdx["size"]=2;
$1=$recv($2).__lt($3);
if($core.assert($1)){
return false;
};
return $recv(self._last_($recv(suffix)._size())).__eq(suffix);
}, function($ctx1) {$ctx1.fill(self,"endsWith:",{suffix:suffix},$globals.SequenceableCollection)});
},
args: ["suffix"],
source: "endsWith: suffix\x0a\x09self size < suffix size ifTrue: [ ^ false ].\x0a\x09^ (self last: suffix size) = suffix",
referencedClasses: [],
messageSends: ["ifTrue:", "<", "size", "=", "last:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "first",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._at_((1));
}, function($ctx1) {$ctx1.fill(self,"first",{},$globals.SequenceableCollection)});
},
args: [],
source: "first\x0a\x09^ self at: 1",
referencedClasses: [],
messageSends: ["at:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "first:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self._size()).__lt(aNumber);
if($core.assert($1)){
self._error_("Invalid number of elements");
};
return self._copyFrom_to_((1),aNumber);
}, function($ctx1) {$ctx1.fill(self,"first:",{aNumber:aNumber},$globals.SequenceableCollection)});
},
args: ["aNumber"],
source: "first: aNumber\x0a\x09\x22Answer the first `aNumber` elements of the receiver.\x0a\x09Raise an error if there are not enough elements in the receiver.\x22\x0a\x0a\x09self size < aNumber ifTrue: [ self error: 'Invalid number of elements' ].\x0a\x0a\x09^ self copyFrom: 1 to: aNumber",
referencedClasses: [],
messageSends: ["ifTrue:", "<", "size", "error:", "copyFrom:to:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "fourth",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._at_((4));
}, function($ctx1) {$ctx1.fill(self,"fourth",{},$globals.SequenceableCollection)});
},
args: [],
source: "fourth\x0a\x09^ self at: 4",
referencedClasses: [],
messageSends: ["at:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "includes:",
protocol: 'testing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._indexOf_ifAbsent_(anObject,(function(){
return nil;

})))._notNil();
}, function($ctx1) {$ctx1.fill(self,"includes:",{anObject:anObject},$globals.SequenceableCollection)});
},
args: ["anObject"],
source: "includes: anObject\x0a\x09^ (self indexOf: anObject ifAbsent: [ nil ]) notNil",
referencedClasses: [],
messageSends: ["notNil", "indexOf:ifAbsent:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "indexOf:ifAbsent:",
protocol: 'accessing',
fn: function (anObject,aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		self = self._numericallyIndexable();
		for(var i=0; i < self.length; i++) {
			if($recv(self[i]).__eq(anObject)) {return i+1}
		};
		return aBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"indexOf:ifAbsent:",{anObject:anObject,aBlock:aBlock},$globals.SequenceableCollection)});
},
args: ["anObject", "aBlock"],
source: "indexOf: anObject ifAbsent: aBlock\x0a\x09<\x0a\x09\x09self = self._numericallyIndexable();\x0a\x09\x09for(var i=0; i < self.length; i++) {\x0a\x09\x09\x09if($recv(self[i]).__eq(anObject)) {return i+1}\x0a\x09\x09};\x0a\x09\x09return aBlock._value();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "indexOf:startingAt:",
protocol: 'accessing',
fn: function (anObject,start){
var self=this;
return $core.withContext(function($ctx1) {
return self._indexOf_startingAt_ifAbsent_(anObject,start,(function(){
return (0);

}));
}, function($ctx1) {$ctx1.fill(self,"indexOf:startingAt:",{anObject:anObject,start:start},$globals.SequenceableCollection)});
},
args: ["anObject", "start"],
source: "indexOf: anObject startingAt: start\x0a\x09\x22Answer the index of the first occurence of anElement after start\x0a\x09within the receiver. If the receiver does not contain anElement,\x0a\x09answer 0.\x22\x0a\x09^ self indexOf: anObject startingAt: start ifAbsent: [ 0 ]",
referencedClasses: [],
messageSends: ["indexOf:startingAt:ifAbsent:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "indexOf:startingAt:ifAbsent:",
protocol: 'accessing',
fn: function (anObject,start,aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		self = self._numericallyIndexable();
		for(var i=start - 1; i < self.length; i++){
			if($recv(self[i]).__eq(anObject)) {return i+1}
		}
		return aBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"indexOf:startingAt:ifAbsent:",{anObject:anObject,start:start,aBlock:aBlock},$globals.SequenceableCollection)});
},
args: ["anObject", "start", "aBlock"],
source: "indexOf: anObject startingAt: start ifAbsent: aBlock\x0a\x09<\x0a\x09\x09self = self._numericallyIndexable();\x0a\x09\x09for(var i=start - 1; i < self.length; i++){\x0a\x09\x09\x09if($recv(self[i]).__eq(anObject)) {return i+1}\x0a\x09\x09}\x0a\x09\x09return aBlock._value();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "last",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._at_(self._size());
}, function($ctx1) {$ctx1.fill(self,"last",{},$globals.SequenceableCollection)});
},
args: [],
source: "last\x0a\x09^ self at: self size",
referencedClasses: [],
messageSends: ["at:", "size"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "last:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$5,$4,$3;
$2=self._size();
$ctx1.sendIdx["size"]=1;
$1=$recv($2).__lt(aNumber);
if($core.assert($1)){
self._error_("Invalid number of elements");
};
$5=self._size();
$ctx1.sendIdx["size"]=2;
$4=$recv($5).__minus(aNumber);
$3=$recv($4).__plus((1));
return self._copyFrom_to_($3,self._size());
}, function($ctx1) {$ctx1.fill(self,"last:",{aNumber:aNumber},$globals.SequenceableCollection)});
},
args: ["aNumber"],
source: "last: aNumber\x0a\x09\x22Answer the last aNumber elements of the receiver.\x0a\x09Raise an error if there are not enough elements in the receiver.\x22\x0a\x0a\x09self size < aNumber ifTrue: [ self error: 'Invalid number of elements' ].\x0a\x0a\x09^ self copyFrom: self size - aNumber + 1 to: self size",
referencedClasses: [],
messageSends: ["ifTrue:", "<", "size", "error:", "copyFrom:to:", "+", "-"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "newStream",
protocol: 'streaming',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._streamClass())._on_(self);
}, function($ctx1) {$ctx1.fill(self,"newStream",{},$globals.SequenceableCollection)});
},
args: [],
source: "newStream\x0a\x09^ self streamClass on: self",
referencedClasses: [],
messageSends: ["on:", "streamClass"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "numericallyIndexable",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"numericallyIndexable",{},$globals.SequenceableCollection)});
},
args: [],
source: "numericallyIndexable\x0a\x09\x22This is an internal converting message.\x0a\x09It answeres a representation of the receiver\x0a\x09that can use foo[i] in JavaScript code.\x0a\x09\x0a\x09It fixes IE8, where boxed String is unable\x0a\x09to numerically index its characters,\x0a\x09but primitive string can.\x22\x0a\x09\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "readStream",
protocol: 'streaming',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._stream();
}, function($ctx1) {$ctx1.fill(self,"readStream",{},$globals.SequenceableCollection)});
},
args: [],
source: "readStream\x0a\x09\x22For Pharo compatibility\x22\x0a\x09\x0a\x09^ self stream",
referencedClasses: [],
messageSends: ["stream"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "removeLast",
protocol: 'adding/removing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._remove_(self._last());
}, function($ctx1) {$ctx1.fill(self,"removeLast",{},$globals.SequenceableCollection)});
},
args: [],
source: "removeLast\x0a\x09^ self remove: self last",
referencedClasses: [],
messageSends: ["remove:", "last"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "reversed",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"reversed",{},$globals.SequenceableCollection)});
},
args: [],
source: "reversed\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "second",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._at_((2));
}, function($ctx1) {$ctx1.fill(self,"second",{},$globals.SequenceableCollection)});
},
args: [],
source: "second\x0a\x09^ self at: 2",
referencedClasses: [],
messageSends: ["at:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "stream",
protocol: 'streaming',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._newStream();
}, function($ctx1) {$ctx1.fill(self,"stream",{},$globals.SequenceableCollection)});
},
args: [],
source: "stream\x0a\x09^ self newStream",
referencedClasses: [],
messageSends: ["newStream"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "streamClass",
protocol: 'streaming',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._class())._streamClass();
}, function($ctx1) {$ctx1.fill(self,"streamClass",{},$globals.SequenceableCollection)});
},
args: [],
source: "streamClass\x0a\x09^ self class streamClass",
referencedClasses: [],
messageSends: ["streamClass", "class"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "third",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._at_((3));
}, function($ctx1) {$ctx1.fill(self,"third",{},$globals.SequenceableCollection)});
},
args: [],
source: "third\x0a\x09^ self at: 3",
referencedClasses: [],
messageSends: ["at:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "with:do:",
protocol: 'enumerating',
fn: function (anotherCollection,aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		self = self._numericallyIndexable();
		anotherCollection = anotherCollection._numericallyIndexable();
		for(var i=0; i<self.length; i++) {
			aBlock._value_value_(self[i], anotherCollection[i]);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"with:do:",{anotherCollection:anotherCollection,aBlock:aBlock},$globals.SequenceableCollection)});
},
args: ["anotherCollection", "aBlock"],
source: "with: anotherCollection do: aBlock\x0a\x09<\x0a\x09\x09self = self._numericallyIndexable();\x0a\x09\x09anotherCollection = anotherCollection._numericallyIndexable();\x0a\x09\x09for(var i=0; i<self.length; i++) {\x0a\x09\x09\x09aBlock._value_value_(self[i], anotherCollection[i]);\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "withIndexDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		self = self._numericallyIndexable();
		for(var i=0; i < self.length; i++) {
			aBlock._value_value_(self[i], i+1);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"withIndexDo:",{aBlock:aBlock},$globals.SequenceableCollection)});
},
args: ["aBlock"],
source: "withIndexDo: aBlock\x0a\x09<\x0a\x09\x09self = self._numericallyIndexable();\x0a\x09\x09for(var i=0; i < self.length; i++) {\x0a\x09\x09\x09aBlock._value_value_(self[i], i+1);\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "writeStream",
protocol: 'streaming',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._stream();
}, function($ctx1) {$ctx1.fill(self,"writeStream",{},$globals.SequenceableCollection)});
},
args: [],
source: "writeStream\x0a\x09\x22For Pharo compatibility\x22\x0a\x09\x0a\x09^ self stream",
referencedClasses: [],
messageSends: ["stream"]
}),
$globals.SequenceableCollection);


$core.addMethod(
$core.method({
selector: "streamClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.Stream;

},
args: [],
source: "streamClass\x0a\x09\x09^ Stream",
referencedClasses: ["Stream"],
messageSends: []
}),
$globals.SequenceableCollection.klass);

$core.addMethod(
$core.method({
selector: "streamContents:",
protocol: 'streaming',
fn: function (aBlock){
var self=this;
var stream;
return $core.withContext(function($ctx1) {
stream=$recv(self._streamClass())._on_(self._new());
$recv(aBlock)._value_(stream);
return $recv(stream)._contents();
}, function($ctx1) {$ctx1.fill(self,"streamContents:",{aBlock:aBlock,stream:stream},$globals.SequenceableCollection.klass)});
},
args: ["aBlock"],
source: "streamContents: aBlock\x0a\x09| stream |\x0a\x09stream := (self streamClass on: self new).\x0a\x09aBlock value: stream.\x0a\x09^ stream contents",
referencedClasses: [],
messageSends: ["on:", "streamClass", "new", "value:", "contents"]
}),
$globals.SequenceableCollection.klass);


$core.addClass('Array', $globals.SequenceableCollection, [], 'Kernel-Collections');
$globals.Array.comment="I represent a collection of objects ordered by the collector. The size of arrays is dynamic.\x0a\x0aI am directly mapped to JavaScript Number.\x0a\x0a*Note* In Amber, `OrderedCollection` is an alias for `Array`.";
$core.addMethod(
$core.method({
selector: "add:",
protocol: 'adding/removing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self.push(anObject); return anObject;;
return self;
}, function($ctx1) {$ctx1.fill(self,"add:",{anObject:anObject},$globals.Array)});
},
args: ["anObject"],
source: "add: anObject\x0a\x09<self.push(anObject); return anObject;>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "addAll:",
protocol: 'adding/removing',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {

	if (Array.isArray(aCollection) && aCollection.length < 65000) self.push.apply(self, aCollection);
	else $globals.Array.superclass.fn.prototype._addAll_.call(self, aCollection);
	return aCollection;;
return self;
}, function($ctx1) {$ctx1.fill(self,"addAll:",{aCollection:aCollection},$globals.Array)});
},
args: ["aCollection"],
source: "addAll: aCollection\x0a<\x0a\x09if (Array.isArray(aCollection) && aCollection.length < 65000) self.push.apply(self, aCollection);\x0a\x09else $globals.Array.superclass.fn.prototype._addAll_.call(self, aCollection);\x0a\x09return aCollection;\x0a>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "addFirst:",
protocol: 'adding/removing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self.unshift(anObject); return anObject;;
return self;
}, function($ctx1) {$ctx1.fill(self,"addFirst:",{anObject:anObject},$globals.Array)});
},
args: ["anObject"],
source: "addFirst: anObject\x0a\x09<self.unshift(anObject); return anObject;>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "asJavascript",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv("[".__comma($recv(self._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._asJavascript();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._join_(", "))).__comma("]");
$ctx1.sendIdx[","]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"asJavascript",{},$globals.Array)});
},
args: [],
source: "asJavascript\x0a\x09^ '[', ((self collect: [:each | each asJavascript ]) join: ', '), ']'",
referencedClasses: [],
messageSends: [",", "join:", "collect:", "asJavascript"]
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: 'accessing',
fn: function (anIndex,aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		return anIndex >= 1 && anIndex <= self.length
			? self[anIndex - 1]
			: aBlock._value()
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{anIndex:anIndex,aBlock:aBlock},$globals.Array)});
},
args: ["anIndex", "aBlock"],
source: "at: anIndex ifAbsent: aBlock\x0a\x09<\x0a\x09\x09return anIndex >>= 1 && anIndex <= self.length\x0a\x09\x09\x09? self[anIndex - 1]\x0a\x09\x09\x09: aBlock._value()\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "at:ifPresent:ifAbsent:",
protocol: 'accessing',
fn: function (anIndex,aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {

		return anIndex >= 1 && anIndex <= self.length
			? aBlock._value_(self[anIndex - 1])
			: anotherBlock._value()
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:ifAbsent:",{anIndex:anIndex,aBlock:aBlock,anotherBlock:anotherBlock},$globals.Array)});
},
args: ["anIndex", "aBlock", "anotherBlock"],
source: "at: anIndex ifPresent: aBlock ifAbsent: anotherBlock\x0a\x09<\x0a\x09\x09return anIndex >>= 1 && anIndex <= self.length\x0a\x09\x09\x09? aBlock._value_(self[anIndex - 1])\x0a\x09\x09\x09: anotherBlock._value()\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: 'accessing',
fn: function (anIndex,anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self[anIndex - 1] = anObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:put:",{anIndex:anIndex,anObject:anObject},$globals.Array)});
},
args: ["anIndex", "anObject"],
source: "at: anIndex put: anObject\x0a\x09<return self[anIndex - 1] = anObject>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "collect:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self.map(function(each) {return aBlock._value_(each)});
return self;
}, function($ctx1) {$ctx1.fill(self,"collect:",{aBlock:aBlock},$globals.Array)});
},
args: ["aBlock"],
source: "collect: aBlock\x0a\x09\x22Optimized version\x22\x0a\x09\x0a\x09<return self.map(function(each) {return aBlock._value_(each)})>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "copyFrom:to:",
protocol: 'copying',
fn: function (anIndex,anotherIndex){
var self=this;
return $core.withContext(function($ctx1) {

	if (anIndex >= 1 && anotherIndex <= self.length) {
		return self.slice(anIndex - 1, anotherIndex);
	} else {
		self._at_(anIndex);
		self._at_(self.length + 1);
		throw new Error("Incorrect indexes in #copyFrom:to: not caught by #at:");
	};
return self;
}, function($ctx1) {$ctx1.fill(self,"copyFrom:to:",{anIndex:anIndex,anotherIndex:anotherIndex},$globals.Array)});
},
args: ["anIndex", "anotherIndex"],
source: "copyFrom: anIndex to: anotherIndex\x0a<\x0a\x09if (anIndex >>= 1 && anotherIndex <= self.length) {\x0a\x09\x09return self.slice(anIndex - 1, anotherIndex);\x0a\x09} else {\x0a\x09\x09self._at_(anIndex);\x0a\x09\x09self._at_(self.length + 1);\x0a\x09\x09throw new Error(\x22Incorrect indexes in #copyFrom:to: not caught by #at:\x22);\x0a\x09}\x0a>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "join:",
protocol: 'enumerating',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self.join(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"join:",{aString:aString},$globals.Array)});
},
args: ["aString"],
source: "join: aString\x0a\x09<return self.join(aString)>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "numericallyIndexable",
protocol: 'private',
fn: function (){
var self=this;
return self;

},
args: [],
source: "numericallyIndexable\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Array.superclass||$boot.dnu).fn.prototype._printOn_.apply($recv(self), [aStream]));
$ctx1.supercall = false;
$ctx1.sendIdx["printOn:"]=1;
$recv(aStream)._nextPutAll_(" (");
$ctx1.sendIdx["nextPutAll:"]=1;
self._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._printOn_(aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(aStream)._nextPutAll_(" ");
$ctx2.sendIdx["nextPutAll:"]=2;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Array)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09\x0a\x09aStream nextPutAll: ' ('.\x0a\x09self \x0a\x09\x09do: [ :each | each printOn: aStream ]\x0a\x09\x09separatedBy: [ aStream nextPutAll: ' ' ].\x0a\x09aStream nextPutAll: ')'",
referencedClasses: [],
messageSends: ["printOn:", "nextPutAll:", "do:separatedBy:"]
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "remove:ifAbsent:",
protocol: 'adding/removing',
fn: function (anObject,aBlock){
var self=this;
var index;
return $core.withContext(function($ctx1) {
var $1;
index=self._indexOf_ifAbsent_(anObject,(function(){
return (0);

}));
$1=$recv(index).__eq((0));
if($core.assert($1)){
return $recv(aBlock)._value();
} else {
self._removeIndex_(index);
return anObject;
};
}, function($ctx1) {$ctx1.fill(self,"remove:ifAbsent:",{anObject:anObject,aBlock:aBlock,index:index},$globals.Array)});
},
args: ["anObject", "aBlock"],
source: "remove: anObject ifAbsent: aBlock\x0a\x09| index |\x0a\x09index := self indexOf: anObject ifAbsent: [ 0 ].\x0a\x09^ index = 0\x0a\x09\x09ifFalse: [ self removeIndex: index. anObject ]\x0a\x09\x09ifTrue: [ aBlock value ]",
referencedClasses: [],
messageSends: ["indexOf:ifAbsent:", "ifFalse:ifTrue:", "=", "removeIndex:", "value"]
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: 'adding/removing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self.length = 0;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeAll",{},$globals.Array)});
},
args: [],
source: "removeAll\x0a\x09<self.length = 0>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "removeFrom:to:",
protocol: 'adding/removing',
fn: function (aNumber,anotherNumber){
var self=this;
return $core.withContext(function($ctx1) {
self.splice(aNumber -1, anotherNumber - aNumber + 1);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeFrom:to:",{aNumber:aNumber,anotherNumber:anotherNumber},$globals.Array)});
},
args: ["aNumber", "anotherNumber"],
source: "removeFrom: aNumber to: anotherNumber\x0a\x09<self.splice(aNumber -1, anotherNumber - aNumber + 1)>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "removeIndex:",
protocol: 'adding/removing',
fn: function (anInteger){
var self=this;
return $core.withContext(function($ctx1) {
self.splice(anInteger - 1, 1);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeIndex:",{anInteger:anInteger},$globals.Array)});
},
args: ["anInteger"],
source: "removeIndex: anInteger\x0a\x09<self.splice(anInteger - 1, 1)>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "removeLast",
protocol: 'adding/removing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.pop();;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeLast",{},$globals.Array)});
},
args: [],
source: "removeLast\x0a\x09<return self.pop();>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "reversed",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.slice().reverse();
return self;
}, function($ctx1) {$ctx1.fill(self,"reversed",{},$globals.Array)});
},
args: [],
source: "reversed\x0a\x09<return self.slice().reverse()>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "select:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return self.filter(function(each) {return aBlock._value_(each)});
return self;
}, function($ctx1) {$ctx1.fill(self,"select:",{aBlock:aBlock},$globals.Array)});
},
args: ["aBlock"],
source: "select: aBlock\x0a\x09\x22Optimized version\x22\x0a\x09\x0a\x09<return self.filter(function(each) {return aBlock._value_(each)})>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: 'copying',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.slice();
return self;
}, function($ctx1) {$ctx1.fill(self,"shallowCopy",{},$globals.Array)});
},
args: [],
source: "shallowCopy\x0a\x09<return self.slice()>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "size",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.length;
return self;
}, function($ctx1) {$ctx1.fill(self,"size",{},$globals.Array)});
},
args: [],
source: "size\x0a\x09<return self.length>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "sort",
protocol: 'enumerating',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._sort_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv(a).__lt(b);
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"sort",{},$globals.Array)});
},
args: [],
source: "sort\x0a\x09^ self sort: [ :a :b | a < b ]",
referencedClasses: [],
messageSends: ["sort:", "<"]
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "sort:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		return self.sort(function(a, b) {
			if(aBlock._value_value_(a,b)) {return -1} else {return 1}
		})
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"sort:",{aBlock:aBlock},$globals.Array)});
},
args: ["aBlock"],
source: "sort: aBlock\x0a\x09<\x0a\x09\x09return self.sort(function(a, b) {\x0a\x09\x09\x09if(aBlock._value_value_(a,b)) {return -1} else {return 1}\x0a\x09\x09})\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "sorted",
protocol: 'enumerating',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._copy())._sort();
}, function($ctx1) {$ctx1.fill(self,"sorted",{},$globals.Array)});
},
args: [],
source: "sorted\x0a\x09^ self copy sort",
referencedClasses: [],
messageSends: ["sort", "copy"]
}),
$globals.Array);

$core.addMethod(
$core.method({
selector: "sorted:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._copy())._sort_(aBlock);
}, function($ctx1) {$ctx1.fill(self,"sorted:",{aBlock:aBlock},$globals.Array)});
},
args: ["aBlock"],
source: "sorted: aBlock\x0a\x09^ self copy sort: aBlock",
referencedClasses: [],
messageSends: ["sort:", "copy"]
}),
$globals.Array);


$core.addMethod(
$core.method({
selector: "new:",
protocol: 'instance creation',
fn: function (anInteger){
var self=this;
return $core.withContext(function($ctx1) {
return new Array(anInteger);
return self;
}, function($ctx1) {$ctx1.fill(self,"new:",{anInteger:anInteger},$globals.Array.klass)});
},
args: ["anInteger"],
source: "new: anInteger\x0a\x09<return new Array(anInteger)>",
referencedClasses: [],
messageSends: []
}),
$globals.Array.klass);

$core.addMethod(
$core.method({
selector: "with:",
protocol: 'instance creation',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new_((1));
$recv($1)._at_put_((1),anObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:",{anObject:anObject},$globals.Array.klass)});
},
args: ["anObject"],
source: "with: anObject\x0a\x09\x09^ (self new: 1)\x0a\x09\x09at: 1 put: anObject;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["at:put:", "new:", "yourself"]
}),
$globals.Array.klass);

$core.addMethod(
$core.method({
selector: "with:with:",
protocol: 'instance creation',
fn: function (anObject,anObject2){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new_((2));
$recv($1)._at_put_((1),anObject);
$ctx1.sendIdx["at:put:"]=1;
$recv($1)._at_put_((2),anObject2);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:with:",{anObject:anObject,anObject2:anObject2},$globals.Array.klass)});
},
args: ["anObject", "anObject2"],
source: "with: anObject with: anObject2\x0a\x09\x09^ (self new: 2)\x0a\x09\x09at: 1 put: anObject;\x0a\x09\x09at: 2 put: anObject2;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["at:put:", "new:", "yourself"]
}),
$globals.Array.klass);

$core.addMethod(
$core.method({
selector: "with:with:with:",
protocol: 'instance creation',
fn: function (anObject,anObject2,anObject3){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new_((3));
$recv($1)._at_put_((1),anObject);
$ctx1.sendIdx["at:put:"]=1;
$recv($1)._at_put_((2),anObject2);
$ctx1.sendIdx["at:put:"]=2;
$recv($1)._at_put_((3),anObject3);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:with:with:",{anObject:anObject,anObject2:anObject2,anObject3:anObject3},$globals.Array.klass)});
},
args: ["anObject", "anObject2", "anObject3"],
source: "with: anObject with: anObject2 with: anObject3\x0a\x09\x09^ (self new: 3)\x0a\x09\x09at: 1 put: anObject;\x0a\x09\x09at: 2 put: anObject2;\x0a\x09\x09at: 3 put: anObject3;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["at:put:", "new:", "yourself"]
}),
$globals.Array.klass);

$core.addMethod(
$core.method({
selector: "withAll:",
protocol: 'instance creation',
fn: function (aCollection){
var self=this;
var instance,index;
return $core.withContext(function($ctx1) {
index=(1);
instance=self._new_($recv(aCollection)._size());
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
$recv(instance)._at_put_(index,each);
index=$recv(index).__plus((1));
return index;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return instance;
}, function($ctx1) {$ctx1.fill(self,"withAll:",{aCollection:aCollection,instance:instance,index:index},$globals.Array.klass)});
},
args: ["aCollection"],
source: "withAll: aCollection\x0a\x09| instance index |\x0a\x09index := 1.\x0a\x09instance := self new: aCollection size.\x0a\x09aCollection do: [ :each |\x0a\x09\x09instance at: index put: each.\x0a\x09\x09index := index + 1 ].\x0a\x09^ instance",
referencedClasses: [],
messageSends: ["new:", "size", "do:", "at:put:", "+"]
}),
$globals.Array.klass);


$core.addClass('CharacterArray', $globals.SequenceableCollection, [], 'Kernel-Collections');
$globals.CharacterArray.comment="I am the abstract superclass of string-like collections.";
$core.addMethod(
$core.method({
selector: ",",
protocol: 'copying',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._asString();
$ctx1.sendIdx["asString"]=1;
return $recv($1).__comma($recv(aString)._asString());
}, function($ctx1) {$ctx1.fill(self,",",{aString:aString},$globals.CharacterArray)});
},
args: ["aString"],
source: ", aString\x0a\x09^ self asString, aString asString",
referencedClasses: [],
messageSends: [",", "asString"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "add:",
protocol: 'adding/removing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._errorReadOnly();
return self;
}, function($ctx1) {$ctx1.fill(self,"add:",{anObject:anObject},$globals.CharacterArray)});
},
args: ["anObject"],
source: "add: anObject\x0a\x09self errorReadOnly",
referencedClasses: [],
messageSends: ["errorReadOnly"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "asLowercase",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._class())._fromString_($recv(self._asString())._asLowercase());
}, function($ctx1) {$ctx1.fill(self,"asLowercase",{},$globals.CharacterArray)});
},
args: [],
source: "asLowercase\x0a\x09^ self class fromString: self asString asLowercase",
referencedClasses: [],
messageSends: ["fromString:", "class", "asLowercase", "asString"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "asNumber",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._asString())._asNumber();
}, function($ctx1) {$ctx1.fill(self,"asNumber",{},$globals.CharacterArray)});
},
args: [],
source: "asNumber\x0a\x09^ self asString asNumber",
referencedClasses: [],
messageSends: ["asNumber", "asString"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "asString",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._subclassResponsibility();
}, function($ctx1) {$ctx1.fill(self,"asString",{},$globals.CharacterArray)});
},
args: [],
source: "asString\x0a\x09^ self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "asSymbol",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._asString();
}, function($ctx1) {$ctx1.fill(self,"asSymbol",{},$globals.CharacterArray)});
},
args: [],
source: "asSymbol\x0a\x09^ self asString",
referencedClasses: [],
messageSends: ["asString"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "asUppercase",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._class())._fromString_($recv(self._asString())._asUppercase());
}, function($ctx1) {$ctx1.fill(self,"asUppercase",{},$globals.CharacterArray)});
},
args: [],
source: "asUppercase\x0a\x09^ self class fromString: self asString asUppercase",
referencedClasses: [],
messageSends: ["fromString:", "class", "asUppercase", "asString"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: 'accessing',
fn: function (anIndex,anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._errorReadOnly();
return self;
}, function($ctx1) {$ctx1.fill(self,"at:put:",{anIndex:anIndex,anObject:anObject},$globals.CharacterArray)});
},
args: ["anIndex", "anObject"],
source: "at: anIndex put: anObject\x0a\x09self errorReadOnly",
referencedClasses: [],
messageSends: ["errorReadOnly"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "errorReadOnly",
protocol: 'error handling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._error_("Object is read-only");
return self;
}, function($ctx1) {$ctx1.fill(self,"errorReadOnly",{},$globals.CharacterArray)});
},
args: [],
source: "errorReadOnly\x0a\x09self error: 'Object is read-only'",
referencedClasses: [],
messageSends: ["error:"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._asString())._printOn_(aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.CharacterArray)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09self asString printOn: aStream",
referencedClasses: [],
messageSends: ["printOn:", "asString"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "putOn:",
protocol: 'streaming',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutString_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"putOn:",{aStream:aStream},$globals.CharacterArray)});
},
args: ["aStream"],
source: "putOn: aStream\x0a\x09aStream nextPutString: self",
referencedClasses: [],
messageSends: ["nextPutString:"]
}),
$globals.CharacterArray);

$core.addMethod(
$core.method({
selector: "remove:",
protocol: 'adding/removing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._errorReadOnly();
return self;
}, function($ctx1) {$ctx1.fill(self,"remove:",{anObject:anObject},$globals.CharacterArray)});
},
args: ["anObject"],
source: "remove: anObject\x0a\x09self errorReadOnly",
referencedClasses: [],
messageSends: ["errorReadOnly"]
}),
$globals.CharacterArray);


$core.addMethod(
$core.method({
selector: "fromString:",
protocol: 'instance creation',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"fromString:",{aString:aString},$globals.CharacterArray.klass)});
},
args: ["aString"],
source: "fromString: aString\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.CharacterArray.klass);


$core.addClass('String', $globals.CharacterArray, [], 'Kernel-Collections');
$globals.String.comment="I am an indexed collection of Characters. Unlike most Smalltalk dialects, Amber doesn't provide the Character class. Instead, elements of a String are single character strings.\x0a\x0aString inherits many useful methods from its hierarchy, such as\x0a\x09`Collection >> #,`";
$core.addMethod(
$core.method({
selector: ",",
protocol: 'copying',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return String(self) + aString;
return self;
}, function($ctx1) {$ctx1.fill(self,",",{aString:aString},$globals.String)});
},
args: ["aString"],
source: ", aString\x0a\x09<return String(self) + aString>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "<",
protocol: 'comparing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return String(self) < aString._asString();
return self;
}, function($ctx1) {$ctx1.fill(self,"<",{aString:aString},$globals.String)});
},
args: ["aString"],
source: "< aString\x0a\x09<return String(self) < aString._asString()>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "<=",
protocol: 'comparing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return String(self) <= aString._asString();
return self;
}, function($ctx1) {$ctx1.fill(self,"<=",{aString:aString},$globals.String)});
},
args: ["aString"],
source: "<= aString\x0a\x09<return String(self) <= aString._asString()>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "=",
protocol: 'comparing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return aString != null && String(self) === (typeof aString === "string" ? aString : aString.valueOf());
return self;
}, function($ctx1) {$ctx1.fill(self,"=",{aString:aString},$globals.String)});
},
args: ["aString"],
source: "= aString\x0a<return aString != null && String(self) === (typeof aString === \x22string\x22 ? aString : aString.valueOf())>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "==",
protocol: 'comparing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {

	if (typeof aString === "string") return String(self) === aString;
	else if (aString != null && typeof aString === "object") return String(self) === aString.valueOf();
	else return false;;
return self;
}, function($ctx1) {$ctx1.fill(self,"==",{aString:aString},$globals.String)});
},
args: ["aString"],
source: "== aString\x0a<\x0a\x09if (typeof aString === \x22string\x22) return String(self) === aString;\x0a\x09else if (aString != null && typeof aString === \x22object\x22) return String(self) === aString.valueOf();\x0a\x09else return false;\x0a>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: ">",
protocol: 'comparing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return String(self) > aString._asString();
return self;
}, function($ctx1) {$ctx1.fill(self,">",{aString:aString},$globals.String)});
},
args: ["aString"],
source: "> aString\x0a\x09<return String(self) >> aString._asString()>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: ">=",
protocol: 'comparing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return String(self) >= aString._asString();
return self;
}, function($ctx1) {$ctx1.fill(self,">=",{aString:aString},$globals.String)});
},
args: ["aString"],
source: ">= aString\x0a\x09<return String(self) >>= aString._asString()>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asJSON",
protocol: 'converting',
fn: function (){
var self=this;
return self;

},
args: [],
source: "asJSON\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asJavaScriptMethodName",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $core.st2js(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptMethodName",{},$globals.String)});
},
args: [],
source: "asJavaScriptMethodName\x0a\x09<return $core.st2js(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asJavascript",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		if(self.search(/^[a-zA-Z0-9_:.$ ]*$/) == -1)
			return "\"" + self.replace(/[\x00-\x1f"\\\x7f-\x9f]/g, function(ch){var c=ch.charCodeAt(0);return "\\x"+("0"+c.toString(16)).slice(-2)}) + "\"";
		else
			return "\"" + self + "\"";
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"asJavascript",{},$globals.String)});
},
args: [],
source: "asJavascript\x0a\x09<\x0a\x09\x09if(self.search(/^[a-zA-Z0-9_:.$ ]*$/) == -1)\x0a\x09\x09\x09return \x22\x5c\x22\x22 + self.replace(/[\x5cx00-\x5cx1f\x22\x5c\x5c\x5cx7f-\x5cx9f]/g, function(ch){var c=ch.charCodeAt(0);return \x22\x5c\x5cx\x22+(\x220\x22+c.toString(16)).slice(-2)}) + \x22\x5c\x22\x22;\x0a\x09\x09else\x0a\x09\x09\x09return \x22\x5c\x22\x22 + self + \x22\x5c\x22\x22;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asLowercase",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.toLowerCase();
return self;
}, function($ctx1) {$ctx1.fill(self,"asLowercase",{},$globals.String)});
},
args: [],
source: "asLowercase\x0a\x09<return self.toLowerCase()>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asMutator",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self._last()).__eq(":");
if(!$core.assert($1)){
return self.__comma(":");
};
return self;
}, function($ctx1) {$ctx1.fill(self,"asMutator",{},$globals.String)});
},
args: [],
source: "asMutator\x0a\x09\x22Answer a setter selector. For example,\x0a\x09#name asMutator returns #name:\x22\x0a\x0a\x09self last = ':' ifFalse: [  ^ self, ':' ].\x0a\x09^ self",
referencedClasses: [],
messageSends: ["ifFalse:", "=", "last", ","]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asNumber",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return Number(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"asNumber",{},$globals.String)});
},
args: [],
source: "asNumber\x0a\x09<return Number(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asRegexp",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.RegularExpression)._fromString_(self);
}, function($ctx1) {$ctx1.fill(self,"asRegexp",{},$globals.String)});
},
args: [],
source: "asRegexp\x0a\x09^ RegularExpression fromString: self",
referencedClasses: ["RegularExpression"],
messageSends: ["fromString:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asString",
protocol: 'converting',
fn: function (){
var self=this;
return self;

},
args: [],
source: "asString\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asSymbol",
protocol: 'converting',
fn: function (){
var self=this;
return self;

},
args: [],
source: "asSymbol\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asUppercase",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.toUpperCase();
return self;
}, function($ctx1) {$ctx1.fill(self,"asUppercase",{},$globals.String)});
},
args: [],
source: "asUppercase\x0a\x09<return self.toUpperCase()>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asciiValue",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.charCodeAt(0);;
return self;
}, function($ctx1) {$ctx1.fill(self,"asciiValue",{},$globals.String)});
},
args: [],
source: "asciiValue\x0a\x09<return self.charCodeAt(0);>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: 'accessing',
fn: function (anIndex,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return String(self)[anIndex - 1] || aBlock._value();
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{anIndex:anIndex,aBlock:aBlock},$globals.String)});
},
args: ["anIndex", "aBlock"],
source: "at: anIndex ifAbsent: aBlock\x0a\x09<return String(self)[anIndex - 1] || aBlock._value()>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "at:ifPresent:ifAbsent:",
protocol: 'accessing',
fn: function (anIndex,aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {

		var result = String(self)[anIndex - 1];
		return result ? aBlock._value_(result) : anotherBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:ifAbsent:",{anIndex:anIndex,aBlock:aBlock,anotherBlock:anotherBlock},$globals.String)});
},
args: ["anIndex", "aBlock", "anotherBlock"],
source: "at: anIndex ifPresent: aBlock ifAbsent: anotherBlock\x0a\x09<\x0a\x09\x09var result = String(self)[anIndex - 1];\x0a\x09\x09return result ? aBlock._value_(result) : anotherBlock._value();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "capitalized",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._isEmpty();
if($core.assert($1)){
return self;
} else {
return $recv($recv(self._first())._asUppercase()).__comma(self._allButFirst());
};
}, function($ctx1) {$ctx1.fill(self,"capitalized",{},$globals.String)});
},
args: [],
source: "capitalized\x0a\x09^ self isEmpty\x0a\x09\x09ifTrue: [ self ]\x0a\x09\x09ifFalse: [ self first asUppercase, self allButFirst ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "isEmpty", ",", "asUppercase", "first", "allButFirst"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "charCodeAt:",
protocol: 'accessing',
fn: function (anInteger){
var self=this;
return $core.withContext(function($ctx1) {
return self.charCodeAt(anInteger - 1);
return self;
}, function($ctx1) {$ctx1.fill(self,"charCodeAt:",{anInteger:anInteger},$globals.String)});
},
args: ["anInteger"],
source: "charCodeAt: anInteger\x0a\x09<return self.charCodeAt(anInteger - 1)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "copyFrom:to:",
protocol: 'copying',
fn: function (anIndex,anotherIndex){
var self=this;
return $core.withContext(function($ctx1) {
return self.substring(anIndex - 1, anotherIndex);
return self;
}, function($ctx1) {$ctx1.fill(self,"copyFrom:to:",{anIndex:anIndex,anotherIndex:anotherIndex},$globals.String)});
},
args: ["anIndex", "anotherIndex"],
source: "copyFrom: anIndex to: anotherIndex\x0a\x09<return self.substring(anIndex - 1, anotherIndex)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "crlfSanitized",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._lines())._join_($recv($globals.String)._lf());
}, function($ctx1) {$ctx1.fill(self,"crlfSanitized",{},$globals.String)});
},
args: [],
source: "crlfSanitized\x0a\x09^ self lines join: String lf",
referencedClasses: ["String"],
messageSends: ["join:", "lines", "lf"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: 'copying',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._shallowCopy();
}, function($ctx1) {$ctx1.fill(self,"deepCopy",{},$globals.String)});
},
args: [],
source: "deepCopy\x0a\x09^ self shallowCopy",
referencedClasses: [],
messageSends: ["shallowCopy"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "escaped",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return escape(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"escaped",{},$globals.String)});
},
args: [],
source: "escaped\x0a\x09<return escape(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "includesSubString:",
protocol: 'testing',
fn: function (subString){
var self=this;
return $core.withContext(function($ctx1) {
return self.indexOf(subString) != -1;
return self;
}, function($ctx1) {$ctx1.fill(self,"includesSubString:",{subString:subString},$globals.String)});
},
args: ["subString"],
source: "includesSubString: subString\x0a\x09<return self.indexOf(subString) != -1>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "isCapitalized",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=self._first();
$ctx1.sendIdx["first"]=1;
$1=$recv($2)._asUppercase();
return $recv($1).__eq_eq(self._first());
}, function($ctx1) {$ctx1.fill(self,"isCapitalized",{},$globals.String)});
},
args: [],
source: "isCapitalized\x0a\x09^ self first asUppercase == self first",
referencedClasses: [],
messageSends: ["==", "asUppercase", "first"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "isString",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isString\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "isVowel",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._size()).__eq((1)))._and_((function(){
return $core.withContext(function($ctx2) {
return "aeiou"._includes_(self._asLowercase());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"isVowel",{},$globals.String)});
},
args: [],
source: "isVowel\x0a\x09\x22Answer true if the receiver is a one character string containing a voyel\x22\x0a\x09\x0a\x09^ self size = 1 and: [ 'aeiou' includes: self asLowercase ]",
referencedClasses: [],
messageSends: ["and:", "=", "size", "includes:", "asLowercase"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "join:",
protocol: 'split join',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
return $recv(aCollection)._do_separatedBy_((function(each){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPutAll_($recv(each)._asString());
$ctx3.sendIdx["nextPutAll:"]=1;
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPutAll_(self);
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"join:",{aCollection:aCollection},$globals.String)});
},
args: ["aCollection"],
source: "join: aCollection\x0a\x09^ String\x0a\x09\x09streamContents: [ :stream | aCollection\x0a\x09\x09\x09\x09do: [ :each | stream nextPutAll: each asString ]\x0a\x09\x09\x09\x09separatedBy: [ stream nextPutAll: self ]]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "do:separatedBy:", "nextPutAll:", "asString"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "lineIndicesDo:",
protocol: 'split join',
fn: function (aBlock){
var self=this;
var cr,lf,start,sz,nextLF,nextCR;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$5,$3,$6,$7,$9,$8,$10,$11;
var $early={};
try {
start=(1);
sz=self._size();
cr=$recv($globals.String)._cr();
nextCR=self._indexOf_startingAt_(cr,(1));
$ctx1.sendIdx["indexOf:startingAt:"]=1;
lf=$recv($globals.String)._lf();
nextLF=self._indexOf_startingAt_(lf,(1));
$ctx1.sendIdx["indexOf:startingAt:"]=2;
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(start).__lt_eq(sz);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
$2=$recv(nextLF).__eq((0));
$ctx2.sendIdx["="]=1;
$1=$recv($2)._and_((function(){
return $core.withContext(function($ctx3) {
return $recv(nextCR).__eq((0));
$ctx3.sendIdx["="]=2;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
$ctx2.sendIdx["and:"]=1;
if($core.assert($1)){
$recv(aBlock)._value_value_value_(start,sz,sz);
$ctx2.sendIdx["value:value:value:"]=1;
throw $early=[self];
};
$4=$recv(nextCR).__eq((0));
$ctx2.sendIdx["="]=3;
$3=$recv($4)._or_((function(){
return $core.withContext(function($ctx3) {
$5=(0).__lt(nextLF);
$ctx3.sendIdx["<"]=1;
return $recv($5)._and_((function(){
return $core.withContext(function($ctx4) {
return $recv(nextLF).__lt(nextCR);
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,6)});
}));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,5)});
}));
if($core.assert($3)){
$6=start;
$7=$recv(nextLF).__minus((1));
$ctx2.sendIdx["-"]=1;
$recv(aBlock)._value_value_value_($6,$7,nextLF);
$ctx2.sendIdx["value:value:value:"]=2;
start=(1).__plus(nextLF);
$ctx2.sendIdx["+"]=1;
start;
nextLF=self._indexOf_startingAt_(lf,start);
$ctx2.sendIdx["indexOf:startingAt:"]=3;
return nextLF;
} else {
$9=(1).__plus(nextCR);
$ctx2.sendIdx["+"]=2;
$8=$recv($9).__eq(nextLF);
if($core.assert($8)){
$10=start;
$11=$recv(nextCR).__minus((1));
$ctx2.sendIdx["-"]=2;
$recv(aBlock)._value_value_value_($10,$11,nextLF);
$ctx2.sendIdx["value:value:value:"]=3;
start=(1).__plus(nextLF);
$ctx2.sendIdx["+"]=3;
start;
nextCR=self._indexOf_startingAt_(cr,start);
$ctx2.sendIdx["indexOf:startingAt:"]=4;
nextCR;
nextLF=self._indexOf_startingAt_(lf,start);
$ctx2.sendIdx["indexOf:startingAt:"]=5;
return nextLF;
} else {
$recv(aBlock)._value_value_value_(start,$recv(nextCR).__minus((1)),nextCR);
start=(1).__plus(nextCR);
start;
nextCR=self._indexOf_startingAt_(cr,start);
return nextCR;
};
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"lineIndicesDo:",{aBlock:aBlock,cr:cr,lf:lf,start:start,sz:sz,nextLF:nextLF,nextCR:nextCR},$globals.String)});
},
args: ["aBlock"],
source: "lineIndicesDo: aBlock\x0a\x09\x22execute aBlock with 3 arguments for each line:\x0a\x09- start index of line\x0a\x09- end index of line without line delimiter\x0a\x09- end index of line including line delimiter(s) CR, LF or CRLF\x22\x0a\x09\x0a\x09| cr lf start sz nextLF nextCR |\x0a\x09start := 1.\x0a\x09sz := self size.\x0a\x09cr := String cr.\x0a\x09nextCR := self indexOf: cr startingAt: 1.\x0a\x09lf := String lf.\x0a\x09nextLF := self indexOf: lf startingAt: 1.\x0a\x09[ start <= sz ] whileTrue: [ \x0a\x09\x09(nextLF = 0 and: [ nextCR = 0 ])\x0a\x09\x09\x09ifTrue: [ \x22No more CR, nor LF, the string is over\x22\x0a\x09\x09\x09\x09\x09aBlock value: start value: sz value: sz.\x0a\x09\x09\x09\x09\x09^ self ].\x0a\x09\x09(nextCR = 0 or: [ 0 < nextLF and: [ nextLF < nextCR ] ])\x0a\x09\x09\x09ifTrue: [ \x22Found a LF\x22\x0a\x09\x09\x09\x09\x09aBlock value: start value: nextLF - 1 value: nextLF.\x0a\x09\x09\x09\x09\x09start := 1 + nextLF.\x0a\x09\x09\x09\x09\x09nextLF := self indexOf: lf startingAt: start ]\x0a\x09\x09\x09ifFalse: [ 1 + nextCR = nextLF\x0a\x09\x09\x09\x09ifTrue: [ \x22Found a CR-LF pair\x22\x0a\x09\x09\x09\x09\x09aBlock value: start value: nextCR - 1 value: nextLF.\x0a\x09\x09\x09\x09\x09start := 1 + nextLF.\x0a\x09\x09\x09\x09\x09nextCR := self indexOf: cr startingAt: start.\x0a\x09\x09\x09\x09\x09nextLF := self indexOf: lf startingAt: start ]\x0a\x09\x09\x09\x09ifFalse: [ \x22Found a CR\x22\x0a\x09\x09\x09\x09\x09aBlock value: start value: nextCR - 1 value: nextCR.\x0a\x09\x09\x09\x09\x09start := 1 + nextCR.\x0a\x09\x09\x09\x09\x09nextCR := self indexOf: cr startingAt: start ] ]]",
referencedClasses: ["String"],
messageSends: ["size", "cr", "indexOf:startingAt:", "lf", "whileTrue:", "<=", "ifTrue:", "and:", "=", "value:value:value:", "ifTrue:ifFalse:", "or:", "<", "-", "+"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "lineNumber:",
protocol: 'split join',
fn: function (anIndex){
var self=this;
var lineCount;
return $core.withContext(function($ctx1) {
var $2,$1;
var $early={};
try {
lineCount=(0);
self._lineIndicesDo_((function(start,endWithoutDelimiters,end){
return $core.withContext(function($ctx2) {
lineCount=$recv(lineCount).__plus((1));
$2=lineCount;
$1=$recv($2).__eq(anIndex);
if($core.assert($1)){
throw $early=[self._copyFrom_to_(start,endWithoutDelimiters)];
};
}, function($ctx2) {$ctx2.fillBlock({start:start,endWithoutDelimiters:endWithoutDelimiters,end:end},$ctx1,1)});
}));
return nil;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"lineNumber:",{anIndex:anIndex,lineCount:lineCount},$globals.String)});
},
args: ["anIndex"],
source: "lineNumber: anIndex\x0a\x09\x22Answer a string containing the characters in the given line number.\x22\x0a\x0a\x09| lineCount |\x0a\x09lineCount := 0.\x0a\x09self lineIndicesDo: [ :start :endWithoutDelimiters :end |\x0a\x09\x09(lineCount := lineCount + 1) = anIndex ifTrue: [ ^ self copyFrom: start to: endWithoutDelimiters ]].\x0a\x09^ nil",
referencedClasses: [],
messageSends: ["lineIndicesDo:", "ifTrue:", "=", "+", "copyFrom:to:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "lines",
protocol: 'split join',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

	var result = self.split(/\r\n|\r|\n/);
	if (!result[result.length-1]) result.pop();
	return result;;
return self;
}, function($ctx1) {$ctx1.fill(self,"lines",{},$globals.String)});
},
args: [],
source: "lines\x0a\x09\x22Answer an array of lines composing this receiver without the line ending delimiters.\x22\x0a<\x0a\x09var result = self.split(/\x5cr\x5cn|\x5cr|\x5cn/);\x0a\x09if (!result[result.length-1]) result.pop();\x0a\x09return result;\x0a>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "linesDo:",
protocol: 'split join',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._lines())._do_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"linesDo:",{aBlock:aBlock},$globals.String)});
},
args: ["aBlock"],
source: "linesDo: aBlock\x0a\x09\x22Execute aBlock with each line in this string. The terminating line\x0a\x09delimiters CR, LF or CRLF pairs are not included in what is passed to aBlock\x22\x0a\x0a\x09self lines do: aBlock",
referencedClasses: [],
messageSends: ["do:", "lines"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "match:",
protocol: 'regular expressions',
fn: function (aRegexp){
var self=this;
return $core.withContext(function($ctx1) {
return self.search(aRegexp) != -1;
return self;
}, function($ctx1) {$ctx1.fill(self,"match:",{aRegexp:aRegexp},$globals.String)});
},
args: ["aRegexp"],
source: "match: aRegexp\x0a\x09<return self.search(aRegexp) != -1>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "matchesOf:",
protocol: 'regular expressions',
fn: function (aRegularExpression){
var self=this;
return $core.withContext(function($ctx1) {
return self.match(aRegularExpression);
return self;
}, function($ctx1) {$ctx1.fill(self,"matchesOf:",{aRegularExpression:aRegularExpression},$globals.String)});
},
args: ["aRegularExpression"],
source: "matchesOf: aRegularExpression\x0a\x09<return self.match(aRegularExpression)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "numericallyIndexable",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return String(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"numericallyIndexable",{},$globals.String)});
},
args: [],
source: "numericallyIndexable\x0a\x09<return String(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "printNl",
protocol: 'printing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
console.log(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"printNl",{},$globals.String)});
},
args: [],
source: "printNl\x0a\x09<console.log(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_("'");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_(self);
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_("'");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.String)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream \x0a\x09\x09nextPutAll: '''';\x0a\x09\x09nextPutAll: self;\x0a\x09\x09nextPutAll: ''''",
referencedClasses: [],
messageSends: ["nextPutAll:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "replace:with:",
protocol: 'regular expressions',
fn: function (aString,anotherString){
var self=this;
return $core.withContext(function($ctx1) {
return self._replaceRegexp_with_($recv($globals.RegularExpression)._fromString_flag_(aString,"g"),anotherString);
}, function($ctx1) {$ctx1.fill(self,"replace:with:",{aString:aString,anotherString:anotherString},$globals.String)});
},
args: ["aString", "anotherString"],
source: "replace: aString with: anotherString\x0a\x09^ self replaceRegexp: (RegularExpression fromString: aString flag: 'g') with: anotherString",
referencedClasses: ["RegularExpression"],
messageSends: ["replaceRegexp:with:", "fromString:flag:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "replaceRegexp:with:",
protocol: 'regular expressions',
fn: function (aRegexp,aString){
var self=this;
return $core.withContext(function($ctx1) {
return self.replace(aRegexp, aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"replaceRegexp:with:",{aRegexp:aRegexp,aString:aString},$globals.String)});
},
args: ["aRegexp", "aString"],
source: "replaceRegexp: aRegexp with: aString\x0a\x09<return self.replace(aRegexp, aString)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "reversed",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.split("").reverse().join("");
return self;
}, function($ctx1) {$ctx1.fill(self,"reversed",{},$globals.String)});
},
args: [],
source: "reversed\x0a\x09<return self.split(\x22\x22).reverse().join(\x22\x22)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: 'copying',
fn: function (){
var self=this;
return self;

},
args: [],
source: "shallowCopy\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "size",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.length;
return self;
}, function($ctx1) {$ctx1.fill(self,"size",{},$globals.String)});
},
args: [],
source: "size\x0a\x09<return self.length>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "subStrings:",
protocol: 'split join',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self._tokenize_(aString);
}, function($ctx1) {$ctx1.fill(self,"subStrings:",{aString:aString},$globals.String)});
},
args: ["aString"],
source: "subStrings: aString\x0a\x09^ self tokenize: aString",
referencedClasses: [],
messageSends: ["tokenize:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "tokenize:",
protocol: 'split join',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self.split(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"tokenize:",{aString:aString},$globals.String)});
},
args: ["aString"],
source: "tokenize: aString\x0a\x09<return self.split(aString)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimBoth",
protocol: 'regular expressions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._trimBoth_("\x5cs");
}, function($ctx1) {$ctx1.fill(self,"trimBoth",{},$globals.String)});
},
args: [],
source: "trimBoth\x0a\x09^ self trimBoth: '\x5cs'",
referencedClasses: [],
messageSends: ["trimBoth:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimBoth:",
protocol: 'regular expressions',
fn: function (separators){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._trimLeft_(separators))._trimRight_(separators);
}, function($ctx1) {$ctx1.fill(self,"trimBoth:",{separators:separators},$globals.String)});
},
args: ["separators"],
source: "trimBoth: separators\x0a\x09^ (self trimLeft: separators) trimRight: separators",
referencedClasses: [],
messageSends: ["trimRight:", "trimLeft:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimLeft",
protocol: 'regular expressions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._trimLeft_("\x5cs");
}, function($ctx1) {$ctx1.fill(self,"trimLeft",{},$globals.String)});
},
args: [],
source: "trimLeft\x0a\x09^ self trimLeft: '\x5cs'",
referencedClasses: [],
messageSends: ["trimLeft:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimLeft:",
protocol: 'regular expressions',
fn: function (separators){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=$recv("^[".__comma(separators)).__comma("]+");
$ctx1.sendIdx[","]=1;
$1=$recv($globals.RegularExpression)._fromString_flag_($2,"g");
return self._replaceRegexp_with_($1,"");
}, function($ctx1) {$ctx1.fill(self,"trimLeft:",{separators:separators},$globals.String)});
},
args: ["separators"],
source: "trimLeft: separators\x0a\x09^ self replaceRegexp: (RegularExpression fromString: '^[', separators, ']+' flag: 'g') with: ''",
referencedClasses: ["RegularExpression"],
messageSends: ["replaceRegexp:with:", "fromString:flag:", ","]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimRight",
protocol: 'regular expressions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._trimRight_("\x5cs");
}, function($ctx1) {$ctx1.fill(self,"trimRight",{},$globals.String)});
},
args: [],
source: "trimRight\x0a\x09^ self trimRight: '\x5cs'",
referencedClasses: [],
messageSends: ["trimRight:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimRight:",
protocol: 'regular expressions',
fn: function (separators){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=$recv("[".__comma(separators)).__comma("]+$");
$ctx1.sendIdx[","]=1;
$1=$recv($globals.RegularExpression)._fromString_flag_($2,"g");
return self._replaceRegexp_with_($1,"");
}, function($ctx1) {$ctx1.fill(self,"trimRight:",{separators:separators},$globals.String)});
},
args: ["separators"],
source: "trimRight: separators\x0a\x09^ self replaceRegexp: (RegularExpression fromString: '[', separators, ']+$' flag: 'g') with: ''",
referencedClasses: ["RegularExpression"],
messageSends: ["replaceRegexp:with:", "fromString:flag:", ","]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "unescaped",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return unescape(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"unescaped",{},$globals.String)});
},
args: [],
source: "unescaped\x0a\x09<return unescape(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "uriComponentDecoded",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return decodeURIComponent(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"uriComponentDecoded",{},$globals.String)});
},
args: [],
source: "uriComponentDecoded\x0a\x09<return decodeURIComponent(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "uriComponentEncoded",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return encodeURIComponent(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"uriComponentEncoded",{},$globals.String)});
},
args: [],
source: "uriComponentEncoded\x0a\x09<return encodeURIComponent(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "uriDecoded",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return decodeURI(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"uriDecoded",{},$globals.String)});
},
args: [],
source: "uriDecoded\x0a\x09<return decodeURI(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "uriEncoded",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return encodeURI(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"uriEncoded",{},$globals.String)});
},
args: [],
source: "uriEncoded\x0a\x09<return encodeURI(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "value:",
protocol: 'evaluating',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(anObject)._perform_(self);
}, function($ctx1) {$ctx1.fill(self,"value:",{anObject:anObject},$globals.String)});
},
args: ["anObject"],
source: "value: anObject \x0a\x09^ anObject perform: self",
referencedClasses: [],
messageSends: ["perform:"]
}),
$globals.String);


$core.addMethod(
$core.method({
selector: "cr",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return '\r';
return self;
}, function($ctx1) {$ctx1.fill(self,"cr",{},$globals.String.klass)});
},
args: [],
source: "cr\x0a\x09<return '\x5cr'>",
referencedClasses: [],
messageSends: []
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "crlf",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return '\r\n';
return self;
}, function($ctx1) {$ctx1.fill(self,"crlf",{},$globals.String.klass)});
},
args: [],
source: "crlf\x0a\x09<return '\x5cr\x5cn'>",
referencedClasses: [],
messageSends: []
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "esc",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._fromCharCode_((27));
}, function($ctx1) {$ctx1.fill(self,"esc",{},$globals.String.klass)});
},
args: [],
source: "esc\x0a\x09^ self fromCharCode: 27",
referencedClasses: [],
messageSends: ["fromCharCode:"]
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "fromCharCode:",
protocol: 'instance creation',
fn: function (anInteger){
var self=this;
return $core.withContext(function($ctx1) {
return String.fromCharCode(anInteger);
return self;
}, function($ctx1) {$ctx1.fill(self,"fromCharCode:",{anInteger:anInteger},$globals.String.klass)});
},
args: ["anInteger"],
source: "fromCharCode: anInteger\x0a\x09<return String.fromCharCode(anInteger)>",
referencedClasses: [],
messageSends: []
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "fromString:",
protocol: 'instance creation',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return String(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"fromString:",{aString:aString},$globals.String.klass)});
},
args: ["aString"],
source: "fromString: aString\x0a\x09\x09<return String(aString)>",
referencedClasses: [],
messageSends: []
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "lf",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return '\n';
return self;
}, function($ctx1) {$ctx1.fill(self,"lf",{},$globals.String.klass)});
},
args: [],
source: "lf\x0a\x09<return '\x5cn'>",
referencedClasses: [],
messageSends: []
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "random",
protocol: 'random',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return (Math.random()*(22/32)+(10/32)).toString(32).slice(2);;
return self;
}, function($ctx1) {$ctx1.fill(self,"random",{},$globals.String.klass)});
},
args: [],
source: "random\x0a\x09\x22Returns random alphanumeric string beginning with letter\x22\x0a\x09<return (Math.random()*(22/32)+(10/32)).toString(32).slice(2);>",
referencedClasses: [],
messageSends: []
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "randomNotIn:",
protocol: 'random',
fn: function (aString){
var self=this;
var result;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
result=self._random();
result;
return $recv(aString)._includesSubString_(result);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileTrue();
return result;
}, function($ctx1) {$ctx1.fill(self,"randomNotIn:",{aString:aString,result:result},$globals.String.klass)});
},
args: ["aString"],
source: "randomNotIn: aString\x0a\x09| result |\x0a\x09[ result := self random. aString includesSubString: result ] whileTrue.\x0a\x09^ result",
referencedClasses: [],
messageSends: ["whileTrue", "random", "includesSubString:"]
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "space",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return ' ';
return self;
}, function($ctx1) {$ctx1.fill(self,"space",{},$globals.String.klass)});
},
args: [],
source: "space\x0a\x09<return ' '>",
referencedClasses: [],
messageSends: []
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "streamClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.StringStream;

},
args: [],
source: "streamClass\x0a\x09\x09^ StringStream",
referencedClasses: ["StringStream"],
messageSends: []
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "tab",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return '\t';
return self;
}, function($ctx1) {$ctx1.fill(self,"tab",{},$globals.String.klass)});
},
args: [],
source: "tab\x0a\x09<return '\x5ct'>",
referencedClasses: [],
messageSends: []
}),
$globals.String.klass);

$core.addMethod(
$core.method({
selector: "value:",
protocol: 'instance creation',
fn: function (aUTFCharCode){
var self=this;
return $core.withContext(function($ctx1) {
return String.fromCharCode(aUTFCharCode);;
return self;
}, function($ctx1) {$ctx1.fill(self,"value:",{aUTFCharCode:aUTFCharCode},$globals.String.klass)});
},
args: ["aUTFCharCode"],
source: "value: aUTFCharCode\x0a\x0a\x09<return String.fromCharCode(aUTFCharCode);>",
referencedClasses: [],
messageSends: []
}),
$globals.String.klass);


$core.addClass('Set', $globals.Collection, ['defaultBucket', 'slowBucketStores', 'fastBuckets', 'size'], 'Kernel-Collections');
$globals.Set.comment="I represent an unordered set of objects without duplicates.\x0a\x0a## Implementation notes\x0a\x0aI put elements into different stores based on their type.\x0aThe goal is to store some elements into native JS object property names to be fast.\x0a\x0aIf an unboxed element has typeof 'string', 'boolean' or 'number', or an element is nil, null or undefined,\x0aI store it as a property name in an empty (== Object.create(null)) JS object, different for each type\x0a(for simplicity, nil/null/undefined is treated as one and included with the two booleans).\x0a\x0aIf element happen to be an object, I try to store them in `ArrayBucketStore`. I have two of them by default,\x0aone hashed using the Smalltalk class name, the other one using the JS constructor name. It is possible to have more or less\x0ainstances of `ArrayBucketStores`, see `#initializeSlowBucketStores`.\x0a\x0aAs a last resort, if none of the `ArrayBucketStore` instances can find a suitable bucket, the `defaultBucket` is used,\x0awhich is an `Array`.";
$core.addMethod(
$core.method({
selector: "=",
protocol: 'comparing',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$5;
var $early={};
try {
$2=self._class();
$ctx1.sendIdx["class"]=1;
$1=$recv($2).__eq($recv(aCollection)._class());
$ctx1.sendIdx["="]=1;
if(!$core.assert($1)){
return false;
};
$4=self._size();
$ctx1.sendIdx["size"]=1;
$3=$recv($4).__eq($recv(aCollection)._size());
if(!$core.assert($3)){
return false;
};
self._do_((function(each){
return $core.withContext(function($ctx2) {
$5=$recv(aCollection)._includes_(each);
if(!$core.assert($5)){
throw $early=[false];
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
return true;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"=",{aCollection:aCollection},$globals.Set)});
},
args: ["aCollection"],
source: "= aCollection\x0a\x09self class = aCollection class ifFalse: [ ^ false ].\x0a\x09self size = aCollection size ifFalse: [ ^ false ].\x0a\x09self do: [ :each | (aCollection includes: each) ifFalse: [ ^ false ] ].\x0a\x09^ true",
referencedClasses: [],
messageSends: ["ifFalse:", "=", "class", "size", "do:", "includes:"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "add:",
protocol: 'adding/removing',
fn: function (anObject){
var self=this;
var bucket;
return $core.withContext(function($ctx1) {
var $1,$receiver;
bucket=self._bucketsOfElement_(anObject);
$1=$recv(bucket)._second();
if(($receiver = $1) == null || $receiver.isNil){
var object,slowBucket;
object=$recv(bucket)._first();
$ctx1.sendIdx["first"]=1;
object;
slowBucket=$recv(bucket)._third();
slowBucket;
$recv(slowBucket)._indexOf_ifAbsent_(object,(function(){
return $core.withContext(function($ctx2) {
$recv(slowBucket)._add_(object);
self["@size"]=$recv(self["@size"]).__plus((1));
return self["@size"];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return object;
} else {
var primitiveBucket;
primitiveBucket=$receiver;
return self._add_in_($recv(bucket)._first(),primitiveBucket);
};
}, function($ctx1) {$ctx1.fill(self,"add:",{anObject:anObject,bucket:bucket},$globals.Set)});
},
args: ["anObject"],
source: "add: anObject\x0a\x09| bucket |\x0a\x09bucket := self bucketsOfElement: anObject.\x0a\x09^ bucket second\x0a\x09\x09ifNil: [\x0a\x09\x09\x09| object slowBucket |\x0a\x09\x09\x09object := bucket first.\x0a\x09\x09\x09slowBucket := bucket third.\x0a\x09\x09\x09slowBucket \x0a\x09\x09\x09\x09indexOf: object \x0a\x09\x09\x09\x09ifAbsent: [ \x0a\x09\x09\x09\x09\x09slowBucket add: object. \x0a\x09\x09\x09\x09\x09size := size + 1 ].\x0a\x09\x09\x09object ]\x0a\x09\x09ifNotNil: [ :primitiveBucket | \x0a\x09\x09\x09self \x0a\x09\x09\x09\x09add: bucket first \x0a\x09\x09\x09\x09in: primitiveBucket ]",
referencedClasses: [],
messageSends: ["bucketsOfElement:", "ifNil:ifNotNil:", "second", "first", "third", "indexOf:ifAbsent:", "add:", "+", "add:in:"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "add:in:",
protocol: 'private',
fn: function (anObject,anotherObject){
var self=this;
return $core.withContext(function($ctx1) {

		if (anObject in anotherObject.store) { return false; }
		self['@size']++;
		anotherObject.store[anObject] = true;
		return anObject;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"add:in:",{anObject:anObject,anotherObject:anotherObject},$globals.Set)});
},
args: ["anObject", "anotherObject"],
source: "add: anObject in: anotherObject\x0a\x09<\x0a\x09\x09if (anObject in anotherObject.store) { return false; }\x0a\x09\x09self['@size']++;\x0a\x09\x09anotherObject.store[anObject] = true;\x0a\x09\x09return anObject;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "bucketsOfElement:",
protocol: 'private',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {

		// include nil to well-known objects under 'boolean' fastBucket
		if (anObject == null || anObject.isNil) return [ null, self['@fastBuckets'].boolean ];
		
		var prim = anObject.valueOf();
		if (typeof prim === "object" || typeof prim === "function" || !self['@fastBuckets'][typeof prim]) {
			var bucket = null;
			self['@slowBucketStores'].some(function (store) {
				return bucket = store._bucketOfElement_(anObject);
			});
			return [ anObject, null, bucket || self['@defaultBucket'] ];
		}
		return [ prim, self['@fastBuckets'][typeof prim] ];
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"bucketsOfElement:",{anObject:anObject},$globals.Set)});
},
args: ["anObject"],
source: "bucketsOfElement: anObject\x0a\x09\x22Find the appropriate bucket for `anObject`.\x0a\x09For optimization purposes, directly answer an array with: \x0a\x09- the object to be store\x0a\x09- the primitive bucket\x0a\x09- the slow bucket\x22\x0a\x09\x0a\x09<\x0a\x09\x09// include nil to well-known objects under 'boolean' fastBucket\x0a\x09\x09if (anObject == null || anObject.isNil) return [ null, self['@fastBuckets'].boolean ];\x0a\x09\x09\x0a\x09\x09var prim = anObject.valueOf();\x0a\x09\x09if (typeof prim === \x22object\x22 || typeof prim === \x22function\x22 || !self['@fastBuckets'][typeof prim]) {\x0a\x09\x09\x09var bucket = null;\x0a\x09\x09\x09self['@slowBucketStores'].some(function (store) {\x0a\x09\x09\x09\x09return bucket = store._bucketOfElement_(anObject);\x0a\x09\x09\x09});\x0a\x09\x09\x09return [ anObject, null, bucket || self['@defaultBucket'] ];\x0a\x09\x09}\x0a\x09\x09return [ prim, self['@fastBuckets'][typeof prim] ];\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "classNameOf:",
protocol: 'private',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return anObject.klass != null && anObject.klass.className;
return self;
}, function($ctx1) {$ctx1.fill(self,"classNameOf:",{anObject:anObject},$globals.Set)});
},
args: ["anObject"],
source: "classNameOf: anObject\x0a\x09\x22Answer the class name of `anObject`, or `undefined` \x0a\x09if `anObject` is not an Smalltalk object\x22\x0a\x09\x0a\x09<return anObject.klass != null && anObject.klass.className>",
referencedClasses: [],
messageSends: []
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "collect:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
var collection;
return $core.withContext(function($ctx1) {
collection=$recv(self._class())._new();
self._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(collection)._add_($recv(aBlock)._value_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return collection;
}, function($ctx1) {$ctx1.fill(self,"collect:",{aBlock:aBlock,collection:collection},$globals.Set)});
},
args: ["aBlock"],
source: "collect: aBlock\x0a\x09| collection |\x0a\x09collection := self class new.\x0a\x09self do: [ :each | collection add: (aBlock value: each) ].\x0a\x09^ collection",
referencedClasses: [],
messageSends: ["new", "class", "do:", "add:", "value:"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "detect:ifNone:",
protocol: 'enumerating',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
self._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(aBlock)._value_(each);
if($core.assert($1)){
throw $early=[each];
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(anotherBlock)._value();
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"detect:ifNone:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.Set)});
},
args: ["aBlock", "anotherBlock"],
source: "detect: aBlock ifNone: anotherBlock\x0a\x09self do: [ :each | (aBlock value: each) ifTrue: [ ^each ] ].\x0a\x09^ anotherBlock value",
referencedClasses: [],
messageSends: ["do:", "ifTrue:", "value:", "value"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "do:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		var el, keys, i;
		el = self['@fastBuckets'];
		keys = Object.keys(el);
		for (i = 0; i < keys.length; ++i) {
			var fastBucket = el[keys[i]], fn = fastBucket.fn, store = Object.keys(fastBucket.store);
			if (fn) { for (var j = 0; j < store.length; ++j) { aBlock._value_(fn(store[j])); } }
			else { store._do_(aBlock); }
		}
		el = self['@slowBucketStores'];
		for (i = 0; i < el.length; ++i) { el[i]._do_(aBlock); }
		self['@defaultBucket']._do_(aBlock);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock},$globals.Set)});
},
args: ["aBlock"],
source: "do: aBlock\x0a\x09<\x0a\x09\x09var el, keys, i;\x0a\x09\x09el = self['@fastBuckets'];\x0a\x09\x09keys = Object.keys(el);\x0a\x09\x09for (i = 0; i < keys.length; ++i) {\x0a\x09\x09\x09var fastBucket = el[keys[i]], fn = fastBucket.fn, store = Object.keys(fastBucket.store);\x0a\x09\x09\x09if (fn) { for (var j = 0; j < store.length; ++j) { aBlock._value_(fn(store[j])); } }\x0a\x09\x09\x09else { store._do_(aBlock); }\x0a\x09\x09}\x0a\x09\x09el = self['@slowBucketStores'];\x0a\x09\x09for (i = 0; i < el.length; ++i) { el[i]._do_(aBlock); }\x0a\x09\x09self['@defaultBucket']._do_(aBlock);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "includes:",
protocol: 'testing',
fn: function (anObject){
var self=this;
var bucket;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$receiver;
bucket=self._bucketsOfElement_(anObject);
$1=$recv(bucket)._second();
if(($receiver = $1) == null || $receiver.isNil){
$2=$recv(bucket)._third();
$3=$recv(bucket)._first();
$ctx1.sendIdx["first"]=1;
return $recv($2)._includes_($3);
} else {
var primitiveBucket;
primitiveBucket=$receiver;
return self._includes_in_($recv(bucket)._first(),primitiveBucket);
};
}, function($ctx1) {$ctx1.fill(self,"includes:",{anObject:anObject,bucket:bucket},$globals.Set)});
},
args: ["anObject"],
source: "includes: anObject\x0a\x09| bucket |\x0a\x09bucket := self bucketsOfElement: anObject.\x0a\x09^ bucket second\x0a\x09\x09ifNil: [ bucket third includes: bucket first ]\x0a\x09\x09ifNotNil: [ :primitiveBucket | self includes: bucket first in: primitiveBucket ]",
referencedClasses: [],
messageSends: ["bucketsOfElement:", "ifNil:ifNotNil:", "second", "includes:", "third", "first", "includes:in:"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "includes:in:",
protocol: 'private',
fn: function (anObject,anotherObject){
var self=this;
return $core.withContext(function($ctx1) {
return anObject in anotherObject.store;
return self;
}, function($ctx1) {$ctx1.fill(self,"includes:in:",{anObject:anObject,anotherObject:anotherObject},$globals.Set)});
},
args: ["anObject", "anotherObject"],
source: "includes: anObject in: anotherObject\x0a\x09<return anObject in anotherObject.store>",
referencedClasses: [],
messageSends: []
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Set.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@defaultBucket"]=[];
self._initializeSlowBucketStores();
self._removeAll();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.Set)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09\x0a\x09defaultBucket := #().\x0a\x09self\x0a\x09\x09initializeSlowBucketStores;\x0a\x09\x09removeAll",
referencedClasses: [],
messageSends: ["initialize", "initializeSlowBucketStores", "removeAll"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "initializeSlowBucketStores",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ArrayBucketStore)._hashBlock_((function(x){
return $core.withContext(function($ctx2) {
return self._classNameOf_(x);
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
}));
$ctx1.sendIdx["hashBlock:"]=1;
self["@slowBucketStores"]=[$1,$recv($globals.ArrayBucketStore)._hashBlock_((function(x){
return $core.withContext(function($ctx2) {
return self._jsConstructorNameOf_(x);
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,2)});
}))];
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeSlowBucketStores",{},$globals.Set)});
},
args: [],
source: "initializeSlowBucketStores\x0a\x09slowBucketStores := {\x0a\x09\x09ArrayBucketStore hashBlock: [ :x | self classNameOf: x ].\x0a\x09\x09ArrayBucketStore hashBlock: [ :x | self jsConstructorNameOf: x ]\x0a\x09}",
referencedClasses: ["ArrayBucketStore"],
messageSends: ["hashBlock:", "classNameOf:", "jsConstructorNameOf:"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "jsConstructorNameOf:",
protocol: 'private',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return anObject.constructor && anObject.constructor.name;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsConstructorNameOf:",{anObject:anObject},$globals.Set)});
},
args: ["anObject"],
source: "jsConstructorNameOf: anObject\x0a\x09<return anObject.constructor && anObject.constructor.name>",
referencedClasses: [],
messageSends: []
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Set.superclass||$boot.dnu).fn.prototype._printOn_.apply($recv(self), [aStream]));
$ctx1.supercall = false;
$ctx1.sendIdx["printOn:"]=1;
$recv(aStream)._nextPutAll_(" (");
$ctx1.sendIdx["nextPutAll:"]=1;
self._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._printOn_(aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(aStream)._nextPutAll_(" ");
$ctx2.sendIdx["nextPutAll:"]=2;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Set)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09\x0a\x09aStream nextPutAll: ' ('.\x0a\x09self \x0a\x09\x09do: [ :each | each printOn: aStream ]\x0a\x09\x09separatedBy: [ aStream nextPutAll: ' ' ].\x0a\x09aStream nextPutAll: ')'",
referencedClasses: [],
messageSends: ["printOn:", "nextPutAll:", "do:separatedBy:"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "remove:ifAbsent:",
protocol: 'adding/removing',
fn: function (anObject,aBlock){
var self=this;
var bucket;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$receiver;
var $early={};
try {
bucket=self._bucketsOfElement_(anObject);
$1=$recv(bucket)._second();
if(($receiver = $1) == null || $receiver.isNil){
$2=$recv(bucket)._third();
$3=$recv(bucket)._first();
$ctx1.sendIdx["first"]=1;
$recv($2)._remove_ifAbsent_($3,(function(){
return $core.withContext(function($ctx2) {
throw $early=[$recv(aBlock)._value()];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
self["@size"]=$recv(self["@size"]).__minus((1));
return self["@size"];
} else {
var primitiveBucket;
primitiveBucket=$receiver;
return self._remove_in_($recv(bucket)._first(),primitiveBucket);
};
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"remove:ifAbsent:",{anObject:anObject,aBlock:aBlock,bucket:bucket},$globals.Set)});
},
args: ["anObject", "aBlock"],
source: "remove: anObject ifAbsent: aBlock\x0a\x09| bucket |\x0a\x09bucket := self bucketsOfElement: anObject.\x0a\x09^ bucket second\x0a\x09\x09ifNil: [ bucket third remove: bucket first ifAbsent: [ ^aBlock value ]. size := size - 1 ]\x0a\x09\x09ifNotNil: [ :primitiveBucket | self remove: bucket first in: primitiveBucket ]",
referencedClasses: [],
messageSends: ["bucketsOfElement:", "ifNil:ifNotNil:", "second", "remove:ifAbsent:", "third", "first", "value", "-", "remove:in:"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "remove:in:",
protocol: 'private',
fn: function (anObject,anotherObject){
var self=this;
return $core.withContext(function($ctx1) {
if (delete anotherObject.store[anObject]) self['@size']--;
return self;
}, function($ctx1) {$ctx1.fill(self,"remove:in:",{anObject:anObject,anotherObject:anotherObject},$globals.Set)});
},
args: ["anObject", "anotherObject"],
source: "remove: anObject in: anotherObject\x0a\x09<if (delete anotherObject.store[anObject]) self['@size']-->",
referencedClasses: [],
messageSends: []
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: 'adding/removing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		self['@fastBuckets'] = {
			'boolean': { store: Object.create(null), fn: function (x) { return {'true': true, 'false': false, 'null': null}[x]; } },
			'number': { store: Object.create(null), fn: Number },
			'string': { store: Object.create(null) }
		};
		self['@slowBucketStores'].forEach(function (x) { x._removeAll(); });
		self['@defaultBucket']._removeAll();
		self['@size'] = 0;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeAll",{},$globals.Set)});
},
args: [],
source: "removeAll\x0a\x09<\x0a\x09\x09self['@fastBuckets'] = {\x0a\x09\x09\x09'boolean': { store: Object.create(null), fn: function (x) { return {'true': true, 'false': false, 'null': null}[x]; } },\x0a\x09\x09\x09'number': { store: Object.create(null), fn: Number },\x0a\x09\x09\x09'string': { store: Object.create(null) }\x0a\x09\x09};\x0a\x09\x09self['@slowBucketStores'].forEach(function (x) { x._removeAll(); });\x0a\x09\x09self['@defaultBucket']._removeAll();\x0a\x09\x09self['@size'] = 0;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "select:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
var collection;
return $core.withContext(function($ctx1) {
var $1;
collection=$recv(self._class())._new();
self._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(aBlock)._value_(each);
if($core.assert($1)){
return $recv(collection)._add_(each);
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return collection;
}, function($ctx1) {$ctx1.fill(self,"select:",{aBlock:aBlock,collection:collection},$globals.Set)});
},
args: ["aBlock"],
source: "select: aBlock\x0a\x09| collection |\x0a\x09collection := self class new.\x0a\x09self do: [ :each |\x0a\x09\x09(aBlock value: each) ifTrue: [\x0a\x09\x09\x09collection add: each ] ].\x0a\x09^ collection",
referencedClasses: [],
messageSends: ["new", "class", "do:", "ifTrue:", "value:", "add:"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "size",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@size"];

},
args: [],
source: "size\x0a\x09^ size",
referencedClasses: [],
messageSends: []
}),
$globals.Set);



$core.addClass('ProtoStream', $globals.Object, [], 'Kernel-Collections');
$globals.ProtoStream.comment="I am the abstract base for different accessor for a sequence of objects. This sequence is referred to as my \x22contents\x22.\x0aMy instances are read/write streams modifying the contents.";
$core.addMethod(
$core.method({
selector: "<<",
protocol: 'writing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._write_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"<<",{anObject:anObject},$globals.ProtoStream)});
},
args: ["anObject"],
source: "<< anObject\x0a\x09self write: anObject",
referencedClasses: [],
messageSends: ["write:"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "atEnd",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"atEnd",{},$globals.ProtoStream)});
},
args: [],
source: "atEnd\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "atStart",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"atStart",{},$globals.ProtoStream)});
},
args: [],
source: "atStart\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "contents",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"contents",{},$globals.ProtoStream)});
},
args: [],
source: "contents\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "do:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return self._atEnd();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_(self._next());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock},$globals.ProtoStream)});
},
args: ["aBlock"],
source: "do: aBlock\x0a\x09[ self atEnd ] whileFalse: [ aBlock value: self next ]",
referencedClasses: [],
messageSends: ["whileFalse:", "atEnd", "value:", "next"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "isEmpty",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._atStart())._and_((function(){
return $core.withContext(function($ctx2) {
return self._atEnd();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"isEmpty",{},$globals.ProtoStream)});
},
args: [],
source: "isEmpty\x0a\x09^ self atStart and: [ self atEnd ]",
referencedClasses: [],
messageSends: ["and:", "atStart", "atEnd"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "next",
protocol: 'reading',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._atEnd();
if($core.assert($1)){
return nil;
} else {
return self._subclassResponsibility();
};
}, function($ctx1) {$ctx1.fill(self,"next",{},$globals.ProtoStream)});
},
args: [],
source: "next\x0a\x09^ self atEnd\x0a\x09\x09ifTrue: [ nil ]\x0a\x09\x09ifFalse: [ self subclassResponsibility ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "atEnd", "subclassResponsibility"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "nextPut:",
protocol: 'writing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPut:",{anObject:anObject},$globals.ProtoStream)});
},
args: ["anObject"],
source: "nextPut: anObject\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "nextPutAll:",
protocol: 'writing',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return self._nextPut_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutAll:",{aCollection:aCollection},$globals.ProtoStream)});
},
args: ["aCollection"],
source: "nextPutAll: aCollection\x0a\x09aCollection do: [ :each |\x0a\x09\x09self nextPut: each ]",
referencedClasses: [],
messageSends: ["do:", "nextPut:"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "nextPutJSObject:",
protocol: 'writing',
fn: function (aJSObject){
var self=this;
return $core.withContext(function($ctx1) {
self._nextPut_(aJSObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutJSObject:",{aJSObject:aJSObject},$globals.ProtoStream)});
},
args: ["aJSObject"],
source: "nextPutJSObject: aJSObject\x0a\x09self nextPut: aJSObject",
referencedClasses: [],
messageSends: ["nextPut:"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "nextPutString:",
protocol: 'writing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._nextPut_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutString:",{aString:aString},$globals.ProtoStream)});
},
args: ["aString"],
source: "nextPutString: aString\x0a\x09self nextPut: aString",
referencedClasses: [],
messageSends: ["nextPut:"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "peek",
protocol: 'reading',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._atEnd();
if($core.assert($1)){
return nil;
} else {
return self._subclassResponsibility();
};
}, function($ctx1) {$ctx1.fill(self,"peek",{},$globals.ProtoStream)});
},
args: [],
source: "peek\x0a\x09^ self atEnd\x0a\x09\x09ifTrue: [ nil ]\x0a\x09\x09ifFalse: [ self subclassResponsibility ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "atEnd", "subclassResponsibility"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "reset",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"reset",{},$globals.ProtoStream)});
},
args: [],
source: "reset\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "resetContents",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"resetContents",{},$globals.ProtoStream)});
},
args: [],
source: "resetContents\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "setToEnd",
protocol: 'positioning',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"setToEnd",{},$globals.ProtoStream)});
},
args: [],
source: "setToEnd\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "setToStart",
protocol: 'positioning',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._reset();
return self;
}, function($ctx1) {$ctx1.fill(self,"setToStart",{},$globals.ProtoStream)});
},
args: [],
source: "setToStart\x0a\x09self reset",
referencedClasses: [],
messageSends: ["reset"]
}),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "write:",
protocol: 'writing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
$recv(anObject)._putOn_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"write:",{anObject:anObject},$globals.ProtoStream)});
},
args: ["anObject"],
source: "write: anObject\x0a\x09anObject putOn: self",
referencedClasses: [],
messageSends: ["putOn:"]
}),
$globals.ProtoStream);


$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._setCollection_(aCollection);
$recv($1)._setStreamSize_($recv(aCollection)._size());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aCollection:aCollection},$globals.ProtoStream.klass)});
},
args: ["aCollection"],
source: "on: aCollection\x0a\x09\x09^ self new\x0a\x09\x09setCollection: aCollection;\x0a\x09\x09setStreamSize: aCollection size;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["setCollection:", "new", "setStreamSize:", "size", "yourself"]
}),
$globals.ProtoStream.klass);


$core.addClass('Stream', $globals.ProtoStream, ['collection', 'position', 'streamSize'], 'Kernel-Collections');
$globals.Stream.comment="I represent an accessor for a sequence of objects. This sequence is referred to as my \x22contents\x22.\x0aMy instances are read/write streams to the contents sequence collection.";
$core.addMethod(
$core.method({
selector: "atEnd",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._position()).__eq(self._size());
}, function($ctx1) {$ctx1.fill(self,"atEnd",{},$globals.Stream)});
},
args: [],
source: "atEnd\x0a\x09^ self position = self size",
referencedClasses: [],
messageSends: ["=", "position", "size"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "atStart",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._position()).__eq((0));
}, function($ctx1) {$ctx1.fill(self,"atStart",{},$globals.Stream)});
},
args: [],
source: "atStart\x0a\x09^ self position = 0",
referencedClasses: [],
messageSends: ["=", "position"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "close",
protocol: 'actions',
fn: function (){
var self=this;
return self;

},
args: [],
source: "close",
referencedClasses: [],
messageSends: []
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "collection",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@collection"];

},
args: [],
source: "collection\x0a\x09^ collection",
referencedClasses: [],
messageSends: []
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "contents",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._collection())._copyFrom_to_((1),self._streamSize());
}, function($ctx1) {$ctx1.fill(self,"contents",{},$globals.Stream)});
},
args: [],
source: "contents\x0a\x09^ self collection\x0a\x09\x09copyFrom: 1\x0a\x09\x09to: self streamSize",
referencedClasses: [],
messageSends: ["copyFrom:to:", "collection", "streamSize"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "flush",
protocol: 'actions',
fn: function (){
var self=this;
return self;

},
args: [],
source: "flush",
referencedClasses: [],
messageSends: []
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "isEmpty",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._size()).__eq((0));
}, function($ctx1) {$ctx1.fill(self,"isEmpty",{},$globals.Stream)});
},
args: [],
source: "isEmpty\x0a\x09^ self size = 0",
referencedClasses: [],
messageSends: ["=", "size"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "next",
protocol: 'reading',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
$1=self._atEnd();
if($core.assert($1)){
return nil;
} else {
$3=self._position();
$ctx1.sendIdx["position"]=1;
$2=$recv($3).__plus((1));
self._position_($2);
return $recv(self["@collection"])._at_(self._position());
};
}, function($ctx1) {$ctx1.fill(self,"next",{},$globals.Stream)});
},
args: [],
source: "next\x0a\x09^ self atEnd\x0a\x09\x09ifTrue: [ nil ]\x0a\x09\x09ifFalse: [\x0a\x09\x09\x09self position: self position + 1.\x0a\x09\x09\x09collection at: self position ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "atEnd", "position:", "+", "position", "at:"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "next:",
protocol: 'reading',
fn: function (anInteger){
var self=this;
var tempCollection;
return $core.withContext(function($ctx1) {
var $1;
tempCollection=$recv($recv(self._collection())._class())._new();
$recv(anInteger)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
$1=self._atEnd();
if(!$core.assert($1)){
return $recv(tempCollection)._add_(self._next());
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return tempCollection;
}, function($ctx1) {$ctx1.fill(self,"next:",{anInteger:anInteger,tempCollection:tempCollection},$globals.Stream)});
},
args: ["anInteger"],
source: "next: anInteger\x0a\x09| tempCollection |\x0a\x09tempCollection := self collection class new.\x0a\x09anInteger timesRepeat: [\x0a\x09\x09self atEnd ifFalse: [\x0a\x09\x09tempCollection add: self next ]].\x0a\x09^ tempCollection",
referencedClasses: [],
messageSends: ["new", "class", "collection", "timesRepeat:", "ifFalse:", "atEnd", "add:", "next"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "nextPut:",
protocol: 'writing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$4;
$2=self._position();
$ctx1.sendIdx["position"]=1;
$1=$recv($2).__plus((1));
self._position_($1);
$3=self._collection();
$4=self._position();
$ctx1.sendIdx["position"]=2;
$recv($3)._at_put_($4,anObject);
self._setStreamSize_($recv(self._streamSize())._max_(self._position()));
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPut:",{anObject:anObject},$globals.Stream)});
},
args: ["anObject"],
source: "nextPut: anObject\x0a\x09self position: self position + 1.\x0a\x09self collection at: self position put: anObject.\x0a\x09self setStreamSize: (self streamSize max: self position)",
referencedClasses: [],
messageSends: ["position:", "+", "position", "at:put:", "collection", "setStreamSize:", "max:", "streamSize"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "peek",
protocol: 'reading',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._atEnd();
if(!$core.assert($1)){
return $recv(self._collection())._at_($recv(self._position()).__plus((1)));
};
}, function($ctx1) {$ctx1.fill(self,"peek",{},$globals.Stream)});
},
args: [],
source: "peek\x0a\x09^ self atEnd ifFalse: [\x0a\x09\x09self collection at: self position + 1 ]",
referencedClasses: [],
messageSends: ["ifFalse:", "atEnd", "at:", "collection", "+", "position"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "position",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@position"];
if(($receiver = $1) == null || $receiver.isNil){
self["@position"]=(0);
return self["@position"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"position",{},$globals.Stream)});
},
args: [],
source: "position\x0a\x09^ position ifNil: [ position := 0 ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "position:",
protocol: 'accessing',
fn: function (anInteger){
var self=this;
self["@position"]=anInteger;
return self;

},
args: ["anInteger"],
source: "position: anInteger\x0a\x09position := anInteger",
referencedClasses: [],
messageSends: []
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "reset",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._position_((0));
return self;
}, function($ctx1) {$ctx1.fill(self,"reset",{},$globals.Stream)});
},
args: [],
source: "reset\x0a\x09self position: 0",
referencedClasses: [],
messageSends: ["position:"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "resetContents",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._reset();
self._setStreamSize_((0));
return self;
}, function($ctx1) {$ctx1.fill(self,"resetContents",{},$globals.Stream)});
},
args: [],
source: "resetContents\x0a\x09self reset.\x0a\x09self setStreamSize: 0",
referencedClasses: [],
messageSends: ["reset", "setStreamSize:"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "setCollection:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
self["@collection"]=aCollection;
return self;

},
args: ["aCollection"],
source: "setCollection: aCollection\x0a\x09collection := aCollection",
referencedClasses: [],
messageSends: []
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "setStreamSize:",
protocol: 'accessing',
fn: function (anInteger){
var self=this;
self["@streamSize"]=anInteger;
return self;

},
args: ["anInteger"],
source: "setStreamSize: anInteger\x0a\x09streamSize := anInteger",
referencedClasses: [],
messageSends: []
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "setToEnd",
protocol: 'positioning',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._position_(self._size());
return self;
}, function($ctx1) {$ctx1.fill(self,"setToEnd",{},$globals.Stream)});
},
args: [],
source: "setToEnd\x0a\x09self position: self size",
referencedClasses: [],
messageSends: ["position:", "size"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "size",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._streamSize();
}, function($ctx1) {$ctx1.fill(self,"size",{},$globals.Stream)});
},
args: [],
source: "size\x0a\x09^ self streamSize",
referencedClasses: [],
messageSends: ["streamSize"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "skip:",
protocol: 'positioning',
fn: function (anInteger){
var self=this;
return $core.withContext(function($ctx1) {
self._position_($recv($recv(self._position()).__plus(anInteger))._min_max_(self._size(),(0)));
return self;
}, function($ctx1) {$ctx1.fill(self,"skip:",{anInteger:anInteger},$globals.Stream)});
},
args: ["anInteger"],
source: "skip: anInteger\x0a\x09self position: ((self position + anInteger) min: self size max: 0)",
referencedClasses: [],
messageSends: ["position:", "min:max:", "+", "position", "size"]
}),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "streamSize",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@streamSize"];

},
args: [],
source: "streamSize\x0a\x09^ streamSize",
referencedClasses: [],
messageSends: []
}),
$globals.Stream);


$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._setCollection_(aCollection);
$recv($1)._setStreamSize_($recv(aCollection)._size());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aCollection:aCollection},$globals.Stream.klass)});
},
args: ["aCollection"],
source: "on: aCollection\x0a\x09\x09^ self new\x0a\x09\x09setCollection: aCollection;\x0a\x09\x09setStreamSize: aCollection size;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["setCollection:", "new", "setStreamSize:", "size", "yourself"]
}),
$globals.Stream.klass);


$core.addClass('StringStream', $globals.Stream, [], 'Kernel-Collections');
$globals.StringStream.comment="I am a Stream specific to `String` objects.";
$core.addMethod(
$core.method({
selector: "cr",
protocol: 'writing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._nextPutAll_($recv($globals.String)._cr());
}, function($ctx1) {$ctx1.fill(self,"cr",{},$globals.StringStream)});
},
args: [],
source: "cr\x0a\x09^ self nextPutAll: String cr",
referencedClasses: ["String"],
messageSends: ["nextPutAll:", "cr"]
}),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "crlf",
protocol: 'writing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._nextPutAll_($recv($globals.String)._crlf());
}, function($ctx1) {$ctx1.fill(self,"crlf",{},$globals.StringStream)});
},
args: [],
source: "crlf\x0a\x09^ self nextPutAll: String crlf",
referencedClasses: ["String"],
messageSends: ["nextPutAll:", "crlf"]
}),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "lf",
protocol: 'writing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._nextPutAll_($recv($globals.String)._lf());
}, function($ctx1) {$ctx1.fill(self,"lf",{},$globals.StringStream)});
},
args: [],
source: "lf\x0a\x09^ self nextPutAll: String lf",
referencedClasses: ["String"],
messageSends: ["nextPutAll:", "lf"]
}),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "next:",
protocol: 'reading',
fn: function (anInteger){
var self=this;
var tempCollection;
return $core.withContext(function($ctx1) {
var $1;
tempCollection=$recv($recv(self._collection())._class())._new();
$recv(anInteger)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
$1=self._atEnd();
if(!$core.assert($1)){
tempCollection=$recv(tempCollection).__comma(self._next());
return tempCollection;
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return tempCollection;
}, function($ctx1) {$ctx1.fill(self,"next:",{anInteger:anInteger,tempCollection:tempCollection},$globals.StringStream)});
},
args: ["anInteger"],
source: "next: anInteger\x0a\x09| tempCollection |\x0a\x09tempCollection := self collection class new.\x0a\x09anInteger timesRepeat: [\x0a\x09\x09self atEnd ifFalse: [\x0a\x09\x09tempCollection := tempCollection, self next ]].\x0a\x09^ tempCollection",
referencedClasses: [],
messageSends: ["new", "class", "collection", "timesRepeat:", "ifFalse:", "atEnd", ",", "next"]
}),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "nextPut:",
protocol: 'writing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._nextPutAll_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPut:",{aString:aString},$globals.StringStream)});
},
args: ["aString"],
source: "nextPut: aString\x0a\x09self nextPutAll: aString",
referencedClasses: [],
messageSends: ["nextPutAll:"]
}),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "nextPutAll:",
protocol: 'writing',
fn: function (aString){
var self=this;
var pre,post;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$4,$5,$6,$9,$8,$10,$7,$11,$12,$14,$13;
$1=self._atEnd();
if($core.assert($1)){
$3=self._collection();
$ctx1.sendIdx["collection"]=1;
$2=$recv($3).__comma(aString);
$ctx1.sendIdx[","]=1;
self._setCollection_($2);
$ctx1.sendIdx["setCollection:"]=1;
} else {
$4=self._collection();
$ctx1.sendIdx["collection"]=2;
$5=self._position();
$ctx1.sendIdx["position"]=1;
pre=$recv($4)._copyFrom_to_((1),$5);
$ctx1.sendIdx["copyFrom:to:"]=1;
pre;
$6=self._collection();
$ctx1.sendIdx["collection"]=3;
$9=self._position();
$ctx1.sendIdx["position"]=2;
$8=$recv($9).__plus((1));
$ctx1.sendIdx["+"]=2;
$10=$recv(aString)._size();
$ctx1.sendIdx["size"]=1;
$7=$recv($8).__plus($10);
$ctx1.sendIdx["+"]=1;
$11=$recv(self._collection())._size();
$ctx1.sendIdx["size"]=2;
post=$recv($6)._copyFrom_to_($7,$11);
post;
$12=$recv($recv(pre).__comma(aString)).__comma(post);
$ctx1.sendIdx[","]=2;
self._setCollection_($12);
};
$14=self._position();
$ctx1.sendIdx["position"]=3;
$13=$recv($14).__plus($recv(aString)._size());
self._position_($13);
self._setStreamSize_($recv(self._streamSize())._max_(self._position()));
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutAll:",{aString:aString,pre:pre,post:post},$globals.StringStream)});
},
args: ["aString"],
source: "nextPutAll: aString\x0a\x09| pre post |\x0a\x09self atEnd ifTrue: [ self setCollection: self collection, aString ] ifFalse: [\x0a\x09\x09pre := self collection copyFrom: 1 to: self position.\x0a\x09\x09post := self collection copyFrom: (self position + 1 + aString size) to: self collection size.\x0a\x09\x09self setCollection: pre, aString, post\x0a\x09].\x0a\x09self position: self position + aString size.\x0a\x09self setStreamSize: (self streamSize max: self position)",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "atEnd", "setCollection:", ",", "collection", "copyFrom:to:", "position", "+", "size", "position:", "setStreamSize:", "max:", "streamSize"]
}),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "nextPutString:",
protocol: 'writing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._nextPutAll_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutString:",{aString:aString},$globals.StringStream)});
},
args: ["aString"],
source: "nextPutString: aString\x0a\x09self nextPutAll: aString",
referencedClasses: [],
messageSends: ["nextPutAll:"]
}),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "space",
protocol: 'writing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._nextPut_(" ");
return self;
}, function($ctx1) {$ctx1.fill(self,"space",{},$globals.StringStream)});
},
args: [],
source: "space\x0a\x09self nextPut: ' '",
referencedClasses: [],
messageSends: ["nextPut:"]
}),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "tab",
protocol: 'writing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._nextPutAll_($recv($globals.String)._tab());
}, function($ctx1) {$ctx1.fill(self,"tab",{},$globals.StringStream)});
},
args: [],
source: "tab\x0a\x09^ self nextPutAll: String tab",
referencedClasses: ["String"],
messageSends: ["nextPutAll:", "tab"]
}),
$globals.StringStream);



$core.addClass('Queue', $globals.Object, ['read', 'readIndex', 'write'], 'Kernel-Collections');
$globals.Queue.comment="I am a one-sided queue.\x0a\x0a## Usage\x0a\x0aUse `#nextPut:` to add items to the queue.\x0aUse `#next` or `#nextIfAbsent:` to get (and remove) the next item in the queue.\x0a\x0a## Implementation notes\x0a\x0aA Queue uses two OrderedCollections inside,\x0a`read` is at the front, is not modified and only read using `readIndex`.\x0a`write` is at the back and is appended new items.\x0aWhen `read` is exhausted, `write` is promoted to `read` and new `write` is created.\x0a\x0aAs a consequence, no data moving is done by me, write appending may do data moving\x0awhen growing `write`, but this is left to engine to implement as good as it chooses to.";
$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Queue.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@read"]=$recv($globals.OrderedCollection)._new();
$ctx1.sendIdx["new"]=1;
self["@write"]=$recv($globals.OrderedCollection)._new();
self["@readIndex"]=(1);
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.Queue)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09read := OrderedCollection new.\x0a\x09write := OrderedCollection new.\x0a\x09readIndex := 1",
referencedClasses: ["OrderedCollection"],
messageSends: ["initialize", "new"]
}),
$globals.Queue);

$core.addMethod(
$core.method({
selector: "next",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._nextIfAbsent_((function(){
return $core.withContext(function($ctx2) {
return self._error_("Cannot read from empty Queue.");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"next",{},$globals.Queue)});
},
args: [],
source: "next\x0a\x09^ self nextIfAbsent: [ self error: 'Cannot read from empty Queue.' ]",
referencedClasses: [],
messageSends: ["nextIfAbsent:", "error:"]
}),
$globals.Queue);

$core.addMethod(
$core.method({
selector: "nextIfAbsent:",
protocol: 'accessing',
fn: function (aBlock){
var self=this;
var result;
return $core.withContext(function($ctx1) {
var $1,$2;
var $early={};
try {
result=$recv(self["@read"])._at_ifAbsent_(self["@readIndex"],(function(){
return $core.withContext(function($ctx2) {
$1=$recv(self["@write"])._isEmpty();
if($core.assert($1)){
$2=$recv(self["@readIndex"]).__gt((1));
if($core.assert($2)){
self["@read"]=[];
self["@read"];
self["@readIndex"]=(1);
self["@readIndex"];
};
throw $early=[$recv(aBlock)._value()];
};
self["@read"]=self["@write"];
self["@read"];
self["@readIndex"]=(1);
self["@readIndex"];
self["@write"]=$recv($globals.OrderedCollection)._new();
self["@write"];
return $recv(self["@read"])._first();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(self["@read"])._at_put_(self["@readIndex"],nil);
self["@readIndex"]=$recv(self["@readIndex"]).__plus((1));
return result;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"nextIfAbsent:",{aBlock:aBlock,result:result},$globals.Queue)});
},
args: ["aBlock"],
source: "nextIfAbsent: aBlock\x0a\x09| result |\x0a\x09result := read at: readIndex ifAbsent: [\x0a\x09\x09write isEmpty ifTrue: [\x0a\x09\x09\x09readIndex > 1 ifTrue: [ read := #(). readIndex := 1 ].\x0a\x09\x09\x09^ aBlock value ].\x0a\x09\x09read := write.\x0a\x09\x09readIndex := 1.\x0a\x09\x09write := OrderedCollection new.\x0a\x09\x09read first ].\x0a\x09read at: readIndex put: nil.\x0a\x09readIndex := readIndex + 1.\x0a\x09^ result",
referencedClasses: ["OrderedCollection"],
messageSends: ["at:ifAbsent:", "ifTrue:", "isEmpty", ">", "value", "new", "first", "at:put:", "+"]
}),
$globals.Queue);

$core.addMethod(
$core.method({
selector: "nextPut:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@write"])._add_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPut:",{anObject:anObject},$globals.Queue)});
},
args: ["anObject"],
source: "nextPut: anObject\x0a\x09write add: anObject",
referencedClasses: [],
messageSends: ["add:"]
}),
$globals.Queue);



$core.addClass('RegularExpression', $globals.Object, [], 'Kernel-Collections');
$globals.RegularExpression.comment="I represent a regular expression object. My instances are JavaScript `RegExp` object.";
$core.addMethod(
$core.method({
selector: "compile:",
protocol: 'evaluating',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self.compile(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"compile:",{aString:aString},$globals.RegularExpression)});
},
args: ["aString"],
source: "compile: aString\x0a\x09<return self.compile(aString)>",
referencedClasses: [],
messageSends: []
}),
$globals.RegularExpression);

$core.addMethod(
$core.method({
selector: "exec:",
protocol: 'evaluating',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self.exec(aString) || nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"exec:",{aString:aString},$globals.RegularExpression)});
},
args: ["aString"],
source: "exec: aString\x0a\x09<return self.exec(aString) || nil>",
referencedClasses: [],
messageSends: []
}),
$globals.RegularExpression);

$core.addMethod(
$core.method({
selector: "test:",
protocol: 'evaluating',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self.test(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"test:",{aString:aString},$globals.RegularExpression)});
},
args: ["aString"],
source: "test: aString\x0a\x09<return self.test(aString)>",
referencedClasses: [],
messageSends: []
}),
$globals.RegularExpression);


$core.addMethod(
$core.method({
selector: "fromString:",
protocol: 'instance creation',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self._fromString_flag_(aString,"");
}, function($ctx1) {$ctx1.fill(self,"fromString:",{aString:aString},$globals.RegularExpression.klass)});
},
args: ["aString"],
source: "fromString: aString\x0a\x09\x09^ self fromString: aString flag: ''",
referencedClasses: [],
messageSends: ["fromString:flag:"]
}),
$globals.RegularExpression.klass);

$core.addMethod(
$core.method({
selector: "fromString:flag:",
protocol: 'instance creation',
fn: function (aString,anotherString){
var self=this;
return $core.withContext(function($ctx1) {
return new RegExp(aString, anotherString);
return self;
}, function($ctx1) {$ctx1.fill(self,"fromString:flag:",{aString:aString,anotherString:anotherString},$globals.RegularExpression.klass)});
},
args: ["aString", "anotherString"],
source: "fromString: aString flag: anotherString\x0a\x09<return new RegExp(aString, anotherString)>",
referencedClasses: [],
messageSends: []
}),
$globals.RegularExpression.klass);

});

define("amber_core/Kernel-Exceptions", ["amber/boot", "amber_core/Kernel-Objects"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Kernel-Exceptions');
$core.packages["Kernel-Exceptions"].innerEval = function (expr) { return eval(expr); };
$core.packages["Kernel-Exceptions"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('Error', $globals.Object, ['messageText'], 'Kernel-Exceptions');
$globals.Error.comment="From the ANSI standard:\x0a\x0aThis protocol describes the behavior of instances of class `Error`.\x0aThese are used to represent error conditions that prevent the normal continuation of processing.\x0aActual error exceptions used by an application may be subclasses of this class.\x0aAs `Error` is explicitly specified to be subclassable, conforming implementations must implement its behavior in a non-fragile manner.";
$core.addMethod(
$core.method({
selector: "beHandled",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self.amberHandled = true;
return self;
}, function($ctx1) {$ctx1.fill(self,"beHandled",{},$globals.Error)});
},
args: [],
source: "beHandled\x0a\x09<self.amberHandled = true>",
referencedClasses: [],
messageSends: []
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "beUnhandled",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self.amberHandled = false;
return self;
}, function($ctx1) {$ctx1.fill(self,"beUnhandled",{},$globals.Error)});
},
args: [],
source: "beUnhandled\x0a\x09<self.amberHandled = false>",
referencedClasses: [],
messageSends: []
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "context",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.context;
return self;
}, function($ctx1) {$ctx1.fill(self,"context",{},$globals.Error)});
},
args: [],
source: "context\x0a\x09<return self.context>",
referencedClasses: [],
messageSends: []
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._messageText_("Errorclass: ".__comma($recv(self._class())._name()));
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.Error)});
},
args: [],
source: "initialize\x0a\x09self messageText: 'Errorclass: ', (self class name).",
referencedClasses: [],
messageSends: ["messageText:", ",", "name", "class"]
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "isSmalltalkError",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.smalltalkError === true;
return self;
}, function($ctx1) {$ctx1.fill(self,"isSmalltalkError",{},$globals.Error)});
},
args: [],
source: "isSmalltalkError\x0a\x09<return self.smalltalkError === true>",
referencedClasses: [],
messageSends: []
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "jsStack",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.stack;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsStack",{},$globals.Error)});
},
args: [],
source: "jsStack\x0a\x09<return self.stack>",
referencedClasses: [],
messageSends: []
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "messageText",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@messageText"];

},
args: [],
source: "messageText\x0a\x09^ messageText",
referencedClasses: [],
messageSends: []
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "messageText:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@messageText"]=aString;
return self;

},
args: ["aString"],
source: "messageText: aString\x0a\x09messageText := aString",
referencedClasses: [],
messageSends: []
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "resignal",
protocol: 'signaling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		self.amberHandled = false;
		throw(self);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"resignal",{},$globals.Error)});
},
args: [],
source: "resignal\x0a\x09\x22Resignal the receiver without changing its exception context\x22\x0a\x09\x0a\x09<\x0a\x09\x09self.amberHandled = false;\x0a\x09\x09throw(self);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "signal",
protocol: 'signaling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		self.amberHandled = false;
		self.context = $core.getThisContext(); 
		self.smalltalkError = true;
		throw self;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"signal",{},$globals.Error)});
},
args: [],
source: "signal\x0a\x09<\x0a\x09\x09self.amberHandled = false;\x0a\x09\x09self.context = $core.getThisContext(); \x0a\x09\x09self.smalltalkError = true;\x0a\x09\x09throw self;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "signal:",
protocol: 'signaling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._messageText_(aString);
self._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"signal:",{aString:aString},$globals.Error)});
},
args: ["aString"],
source: "signal: aString\x0a\x09self messageText: aString.\x0a\x09self signal",
referencedClasses: [],
messageSends: ["messageText:", "signal"]
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "signalerContext",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._signalerContextFrom_(self._context());
}, function($ctx1) {$ctx1.fill(self,"signalerContext",{},$globals.Error)});
},
args: [],
source: "signalerContext\x0a\x09^ self signalerContextFrom: self context",
referencedClasses: [],
messageSends: ["signalerContextFrom:", "context"]
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "signalerContextFrom:",
protocol: 'accessing',
fn: function (aContext){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
return $recv(aContext)._findContextSuchThat_((function(context){
return $core.withContext(function($ctx2) {
$3=$recv(context)._receiver();
$ctx2.sendIdx["receiver"]=1;
$2=$recv($3).__eq_eq(self);
$ctx2.sendIdx["=="]=1;
$1=$recv($2)._or_((function(){
return $core.withContext(function($ctx3) {
return $recv($recv(context)._receiver()).__eq_eq(self._class());
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
return $recv($1)._not();
}, function($ctx2) {$ctx2.fillBlock({context:context},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"signalerContextFrom:",{aContext:aContext},$globals.Error)});
},
args: ["aContext"],
source: "signalerContextFrom: aContext\x0a\x09\x22Find the first sender of signal(:), the first context which is neither \x0a\x09for an instance method nor for a class side method of Exception (or subclass).\x0a\x09This will make sure that the same context is found for both, `Error signal` \x0a\x09and `Error new signal`\x22\x0a\x0a\x09^ aContext findContextSuchThat: [ :context |\x0a\x09\x09(context receiver == self \x0a\x09\x09or: [ context receiver == self class ]) not ]",
referencedClasses: [],
messageSends: ["findContextSuchThat:", "not", "or:", "==", "receiver", "class"]
}),
$globals.Error);

$core.addMethod(
$core.method({
selector: "wasHandled",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.amberHandled || false;
return self;
}, function($ctx1) {$ctx1.fill(self,"wasHandled",{},$globals.Error)});
},
args: [],
source: "wasHandled\x0a\x09<return self.amberHandled || false>",
referencedClasses: [],
messageSends: []
}),
$globals.Error);


$core.addMethod(
$core.method({
selector: "classTag",
protocol: 'accessing',
fn: function (){
var self=this;
return "exception";

},
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'exception'",
referencedClasses: [],
messageSends: []
}),
$globals.Error.klass);

$core.addMethod(
$core.method({
selector: "signal",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._new())._signal();
}, function($ctx1) {$ctx1.fill(self,"signal",{},$globals.Error.klass)});
},
args: [],
source: "signal\x0a\x09^ self new signal",
referencedClasses: [],
messageSends: ["signal", "new"]
}),
$globals.Error.klass);

$core.addMethod(
$core.method({
selector: "signal:",
protocol: 'instance creation',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._new())._signal_(aString);
}, function($ctx1) {$ctx1.fill(self,"signal:",{aString:aString},$globals.Error.klass)});
},
args: ["aString"],
source: "signal: aString\x0a\x09^ self new\x0a\x09\x09signal: aString",
referencedClasses: [],
messageSends: ["signal:", "new"]
}),
$globals.Error.klass);


$core.addClass('Halt', $globals.Error, [], 'Kernel-Exceptions');
$globals.Halt.comment="I am provided to support `Object>>#halt`.";
$core.addMethod(
$core.method({
selector: "messageText",
protocol: 'accessing',
fn: function (){
var self=this;
return "Halt encountered";

},
args: [],
source: "messageText\x0a\x09^ 'Halt encountered'",
referencedClasses: [],
messageSends: []
}),
$globals.Halt);

$core.addMethod(
$core.method({
selector: "signalerContextFrom:",
protocol: 'accessing',
fn: function (aContext){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
return $recv(aContext)._findContextSuchThat_((function(context){
return $core.withContext(function($ctx2) {
$3=$recv(context)._receiver();
$ctx2.sendIdx["receiver"]=1;
$2=$recv($3).__eq_eq(self);
$ctx2.sendIdx["=="]=1;
$1=$recv($2)._or_((function(){
return $core.withContext(function($ctx3) {
return $recv($recv($recv(context)._receiver()).__eq_eq(self._class()))._or_((function(){
return $core.withContext(function($ctx4) {
return $recv($recv($recv(context)._method())._selector()).__eq("halt");
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,3)});
}));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
$ctx2.sendIdx["or:"]=1;
return $recv($1)._not();
}, function($ctx2) {$ctx2.fillBlock({context:context},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"signalerContextFrom:",{aContext:aContext},$globals.Halt)});
},
args: ["aContext"],
source: "signalerContextFrom: aContext\x0a\x09\x22specialized version to find the proper context to open the debugger on.\x0a\x09This will find the first context whose method is no longer on `Halt` or \x0a\x09`Halt class` nor is `#halt` method itself.\x22\x0a\x09\x0a\x09^ aContext findContextSuchThat: [ :context |\x0a\x09\x09(context receiver == self \x0a\x09\x09or: [ (context receiver == self class) \x0a\x09\x09or: [ context method selector = #halt ]]) not ]",
referencedClasses: [],
messageSends: ["findContextSuchThat:", "not", "or:", "==", "receiver", "class", "=", "selector", "method"]
}),
$globals.Halt);



$core.addClass('JavaScriptException', $globals.Error, ['exception'], 'Kernel-Exceptions');
$globals.JavaScriptException.comment="A JavaScriptException is thrown when a non-Smalltalk exception occurs while in the Smalltalk stack.\x0aSee `boot.js` `inContext()` and `BlockClosure >> on:do:`";
$core.addMethod(
$core.method({
selector: "context:",
protocol: 'accessing',
fn: function (aMethodContext){
var self=this;
return $core.withContext(function($ctx1) {
self.context = aMethodContext;
return self;
}, function($ctx1) {$ctx1.fill(self,"context:",{aMethodContext:aMethodContext},$globals.JavaScriptException)});
},
args: ["aMethodContext"],
source: "context: aMethodContext\x0a\x09\x22Set the context from the outside.\x0a\x09See boot.js `inContext()` exception handling\x22\x0a\x09\x0a\x09<self.context = aMethodContext>",
referencedClasses: [],
messageSends: []
}),
$globals.JavaScriptException);

$core.addMethod(
$core.method({
selector: "exception",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@exception"];

},
args: [],
source: "exception\x0a\x09^ exception",
referencedClasses: [],
messageSends: []
}),
$globals.JavaScriptException);

$core.addMethod(
$core.method({
selector: "exception:",
protocol: 'accessing',
fn: function (anException){
var self=this;
self["@exception"]=anException;
return self;

},
args: ["anException"],
source: "exception: anException\x0a\x09exception := anException",
referencedClasses: [],
messageSends: []
}),
$globals.JavaScriptException);

$core.addMethod(
$core.method({
selector: "messageText",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return 'JavaScript exception: ' + self["@exception"].toString();
return self;
}, function($ctx1) {$ctx1.fill(self,"messageText",{},$globals.JavaScriptException)});
},
args: [],
source: "messageText\x0a\x09<return 'JavaScript exception: ' + self[\x22@exception\x22].toString()>",
referencedClasses: [],
messageSends: []
}),
$globals.JavaScriptException);


$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (anException){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._exception_(anException);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{anException:anException},$globals.JavaScriptException.klass)});
},
args: ["anException"],
source: "on: anException\x0a\x09^ self new\x0a\x09\x09exception: anException;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["exception:", "new", "yourself"]
}),
$globals.JavaScriptException.klass);

$core.addMethod(
$core.method({
selector: "on:context:",
protocol: 'instance creation',
fn: function (anException,aMethodContext){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._exception_(anException);
$recv($1)._context_(aMethodContext);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:context:",{anException:anException,aMethodContext:aMethodContext},$globals.JavaScriptException.klass)});
},
args: ["anException", "aMethodContext"],
source: "on: anException context: aMethodContext\x0a\x09^ self new\x0a\x09\x09exception: anException;\x0a\x09\x09context: aMethodContext;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["exception:", "new", "context:", "yourself"]
}),
$globals.JavaScriptException.klass);


$core.addClass('MessageNotUnderstood', $globals.Error, ['message', 'receiver'], 'Kernel-Exceptions');
$globals.MessageNotUnderstood.comment="This exception is provided to support `Object>>doesNotUnderstand:`.";
$core.addMethod(
$core.method({
selector: "message",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@message"];

},
args: [],
source: "message\x0a\x09^ message",
referencedClasses: [],
messageSends: []
}),
$globals.MessageNotUnderstood);

$core.addMethod(
$core.method({
selector: "message:",
protocol: 'accessing',
fn: function (aMessage){
var self=this;
self["@message"]=aMessage;
return self;

},
args: ["aMessage"],
source: "message: aMessage\x0a\x09message := aMessage",
referencedClasses: [],
messageSends: []
}),
$globals.MessageNotUnderstood);

$core.addMethod(
$core.method({
selector: "messageText",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv($recv(self._receiver())._asString()).__comma(" does not understand #")).__comma($recv(self._message())._selector());
$ctx1.sendIdx[","]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"messageText",{},$globals.MessageNotUnderstood)});
},
args: [],
source: "messageText\x0a\x09^ self receiver asString, ' does not understand #', self message selector",
referencedClasses: [],
messageSends: [",", "asString", "receiver", "selector", "message"]
}),
$globals.MessageNotUnderstood);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@receiver"];

},
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
messageSends: []
}),
$globals.MessageNotUnderstood);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@receiver"]=anObject;
return self;

},
args: ["anObject"],
source: "receiver: anObject\x0a\x09receiver := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.MessageNotUnderstood);



$core.addClass('NonBooleanReceiver', $globals.Error, ['object'], 'Kernel-Exceptions');
$globals.NonBooleanReceiver.comment="NonBooleanReceiver exceptions may be thrown when executing inlined methods such as `#ifTrue:` with a non boolean receiver.";
$core.addMethod(
$core.method({
selector: "object",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@object"];

},
args: [],
source: "object\x0a\x09^ object",
referencedClasses: [],
messageSends: []
}),
$globals.NonBooleanReceiver);

$core.addMethod(
$core.method({
selector: "object:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@object"]=anObject;
return self;

},
args: ["anObject"],
source: "object: anObject\x0a\x09object := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.NonBooleanReceiver);


});

define("amber_core/Kernel-Infrastructure", ["amber/boot", "amber_core/Kernel-Objects", "amber_core/Kernel-Exceptions", "amber_core/Kernel-Collections"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Kernel-Infrastructure');
$core.packages["Kernel-Infrastructure"].innerEval = function (expr) { return eval(expr); };
$core.packages["Kernel-Infrastructure"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('JSObjectProxy', $globals.ProtoObject, ['jsObject'], 'Kernel-Infrastructure');
$globals.JSObjectProxy.comment="I handle sending messages to JavaScript objects, making  JavaScript object accessing from Amber fully transparent.\x0aMy instances make intensive use of `#doesNotUnderstand:`.\x0a\x0aMy instances are automatically created by Amber whenever a message is sent to a JavaScript object.\x0a\x0a## Usage examples\x0a\x0aJSObjectProxy objects are instanciated by Amber when a Smalltalk message is sent to a JavaScript object.\x0a\x0a\x09window alert: 'hello world'.\x0a\x09window inspect.\x0a\x09(window jQuery: 'body') append: 'hello world'\x0a\x0aAmber messages sends are converted to JavaScript function calls or object property access _(in this order)_. If n one of them match, a `MessageNotUnderstood` error will be thrown.\x0a\x0a## Message conversion rules\x0a\x0a- `someUser name` becomes `someUser.name`\x0a- `someUser name: 'John'` becomes `someUser name = \x22John\x22`\x0a- `console log: 'hello world'` becomes `console.log('hello world')`\x0a- `(window jQuery: 'foo') css: 'background' color: 'red'` becomes `window.jQuery('foo').css('background', 'red')`\x0a\x0a__Note:__ For keyword-based messages, only the first keyword is kept: `window foo: 1 bar: 2` is equivalent to `window foo: 1 baz: 2`.";
$core.addMethod(
$core.method({
selector: "=",
protocol: 'comparing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=$recv(anObject)._class();
$ctx1.sendIdx["class"]=1;
$1=$recv($2).__eq_eq(self._class());
if(!$core.assert($1)){
return false;
};
return $recv($globals.JSObjectProxy)._compareJSObjectOfProxy_withProxy_(self,anObject);
}, function($ctx1) {$ctx1.fill(self,"=",{anObject:anObject},$globals.JSObjectProxy)});
},
args: ["anObject"],
source: "= anObject\x0a\x09anObject class == self class ifFalse: [ ^ false ].\x0a\x09^ JSObjectProxy compareJSObjectOfProxy: self withProxy: anObject",
referencedClasses: ["JSObjectProxy"],
messageSends: ["ifFalse:", "==", "class", "compareJSObjectOfProxy:withProxy:"]
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "asJSON",
protocol: 'enumerating',
fn: function (){
var self=this;
return self["@jsObject"];

},
args: [],
source: "asJSON\x0a\x09\x22Answers the receiver in a stringyfy-friendly fashion\x22\x0a\x0a\x09^ jsObject",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "at:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self['@jsObject'][aString];
return self;
}, function($ctx1) {$ctx1.fill(self,"at:",{aString:aString},$globals.JSObjectProxy)});
},
args: ["aString"],
source: "at: aString\x0a\x09<return self['@jsObject'][aString]>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: 'accessing',
fn: function (aString,aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		var obj = self['@jsObject'];
		return aString in obj ? obj[aString] : aBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{aString:aString,aBlock:aBlock},$globals.JSObjectProxy)});
},
args: ["aString", "aBlock"],
source: "at: aString ifAbsent: aBlock\x0a\x09\x22return the aString property or evaluate aBlock if the property is not defined on the object\x22\x0a\x09<\x0a\x09\x09var obj = self['@jsObject'];\x0a\x09\x09return aString in obj ? obj[aString] : aBlock._value();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "at:ifPresent:",
protocol: 'accessing',
fn: function (aString,aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		var obj = self['@jsObject'];
		return aString in obj ? aBlock._value_(obj[aString]) : nil;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:",{aString:aString,aBlock:aBlock},$globals.JSObjectProxy)});
},
args: ["aString", "aBlock"],
source: "at: aString ifPresent: aBlock\x0a\x09\x22return the evaluation of aBlock with the value if the property is defined or return nil\x22\x0a\x09<\x0a\x09\x09var obj = self['@jsObject'];\x0a\x09\x09return aString in obj ? aBlock._value_(obj[aString]) : nil;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "at:ifPresent:ifAbsent:",
protocol: 'accessing',
fn: function (aString,aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {

		var obj = self['@jsObject'];
		return aString in obj ? aBlock._value_(obj[aString]) : anotherBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:ifAbsent:",{aString:aString,aBlock:aBlock,anotherBlock:anotherBlock},$globals.JSObjectProxy)});
},
args: ["aString", "aBlock", "anotherBlock"],
source: "at: aString ifPresent: aBlock ifAbsent: anotherBlock\x0a\x09\x22return the evaluation of aBlock with the value if the property is defined\x0a\x09or return value of anotherBlock\x22\x0a\x09<\x0a\x09\x09var obj = self['@jsObject'];\x0a\x09\x09return aString in obj ? aBlock._value_(obj[aString]) : anotherBlock._value();\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: 'accessing',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self['@jsObject'][aString] = anObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:put:",{aString:aString,anObject:anObject},$globals.JSObjectProxy)});
},
args: ["aString", "anObject"],
source: "at: aString put: anObject\x0a\x09<return self['@jsObject'][aString] = anObject>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "doesNotUnderstand:",
protocol: 'proxy',
fn: function (aMessage){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv($globals.JSObjectProxy)._lookupProperty_ofProxy_($recv($recv(aMessage)._selector())._asJavaScriptPropertyName(),self);
if(($receiver = $1) == null || $receiver.isNil){
return (
$ctx1.supercall = true,
($globals.JSObjectProxy.superclass||$boot.dnu).fn.prototype._doesNotUnderstand_.apply($recv(self), [aMessage]));
$ctx1.supercall = false;
} else {
var jsSelector;
jsSelector=$receiver;
return $recv($globals.JSObjectProxy)._forwardMessage_withArguments_ofProxy_(jsSelector,$recv(aMessage)._arguments(),self);
};
}, function($ctx1) {$ctx1.fill(self,"doesNotUnderstand:",{aMessage:aMessage},$globals.JSObjectProxy)});
},
args: ["aMessage"],
source: "doesNotUnderstand: aMessage\x0a\x09^ (JSObjectProxy lookupProperty: aMessage selector asJavaScriptPropertyName ofProxy: self)\x0a\x09\x09ifNil: [ super doesNotUnderstand: aMessage ]\x0a\x09\x09ifNotNil: [ :jsSelector | \x0a\x09\x09\x09JSObjectProxy \x0a\x09\x09\x09\x09forwardMessage: jsSelector \x0a\x09\x09\x09\x09withArguments: aMessage arguments\x0a\x09\x09\x09\x09ofProxy: self ]",
referencedClasses: ["JSObjectProxy"],
messageSends: ["ifNil:ifNotNil:", "lookupProperty:ofProxy:", "asJavaScriptPropertyName", "selector", "doesNotUnderstand:", "forwardMessage:withArguments:ofProxy:", "arguments"]
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "in:",
protocol: 'accessing',
fn: function (aValuable){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aValuable)._value_(self["@jsObject"]);
}, function($ctx1) {$ctx1.fill(self,"in:",{aValuable:aValuable},$globals.JSObjectProxy)});
},
args: ["aValuable"],
source: "in: aValuable\x0a\x09^ aValuable value: jsObject",
referencedClasses: [],
messageSends: ["value:"]
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "jsObject",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@jsObject"];

},
args: [],
source: "jsObject\x0a\x09^ jsObject",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "keysAndValuesDo:",
protocol: 'enumerating',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {

		var o = self['@jsObject'];
		for(var i in o) {
			aBlock._value_value_(i, o[i]);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"keysAndValuesDo:",{aBlock:aBlock},$globals.JSObjectProxy)});
},
args: ["aBlock"],
source: "keysAndValuesDo: aBlock\x0a\x09<\x0a\x09\x09var o = self['@jsObject'];\x0a\x09\x09for(var i in o) {\x0a\x09\x09\x09aBlock._value_value_(i, o[i]);\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_(self._printString());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.JSObjectProxy)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: self printString",
referencedClasses: [],
messageSends: ["nextPutAll:", "printString"]
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "printString",
protocol: 'printing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		var js = self['@jsObject'];
		return js.toString
			? js.toString()
			: Object.prototype.toString.call(js)
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"printString",{},$globals.JSObjectProxy)});
},
args: [],
source: "printString\x0a\x09<\x0a\x09\x09var js = self['@jsObject'];\x0a\x09\x09return js.toString\x0a\x09\x09\x09? js.toString()\x0a\x09\x09\x09: Object.prototype.toString.call(js)\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "putOn:",
protocol: 'streaming',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutJSObject_(self["@jsObject"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"putOn:",{aStream:aStream},$globals.JSObjectProxy)});
},
args: ["aStream"],
source: "putOn: aStream\x0a\x09aStream nextPutJSObject: jsObject",
referencedClasses: [],
messageSends: ["nextPutJSObject:"]
}),
$globals.JSObjectProxy);


$core.addMethod(
$core.method({
selector: "addObjectVariablesTo:ofProxy:",
protocol: 'proxy',
fn: function (aDictionary,aProxy){
var self=this;
return $core.withContext(function($ctx1) {

		var jsObject = aProxy['@jsObject'];
		for(var i in jsObject) {
			aDictionary._at_put_(i, jsObject[i]);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"addObjectVariablesTo:ofProxy:",{aDictionary:aDictionary,aProxy:aProxy},$globals.JSObjectProxy.klass)});
},
args: ["aDictionary", "aProxy"],
source: "addObjectVariablesTo: aDictionary ofProxy: aProxy\x0a\x09<\x0a\x09\x09var jsObject = aProxy['@jsObject'];\x0a\x09\x09for(var i in jsObject) {\x0a\x09\x09\x09aDictionary._at_put_(i, jsObject[i]);\x0a\x09\x09}\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy.klass);

$core.addMethod(
$core.method({
selector: "compareJSObjectOfProxy:withProxy:",
protocol: 'proxy',
fn: function (aProxy,anotherProxy){
var self=this;
return $core.withContext(function($ctx1) {

	var anotherJSObject = anotherProxy.klass ? anotherProxy["@jsObject"] : anotherProxy;
	return aProxy["@jsObject"] === anotherJSObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"compareJSObjectOfProxy:withProxy:",{aProxy:aProxy,anotherProxy:anotherProxy},$globals.JSObjectProxy.klass)});
},
args: ["aProxy", "anotherProxy"],
source: "compareJSObjectOfProxy: aProxy withProxy: anotherProxy\x0a<\x0a\x09var anotherJSObject = anotherProxy.klass ? anotherProxy[\x22@jsObject\x22] : anotherProxy;\x0a\x09return aProxy[\x22@jsObject\x22] === anotherJSObject\x0a>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy.klass);

$core.addMethod(
$core.method({
selector: "forwardMessage:withArguments:ofProxy:",
protocol: 'proxy',
fn: function (aString,anArray,aProxy){
var self=this;
return $core.withContext(function($ctx1) {

		return $core.accessJavaScript(aProxy._jsObject(), aString, anArray);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"forwardMessage:withArguments:ofProxy:",{aString:aString,anArray:anArray,aProxy:aProxy},$globals.JSObjectProxy.klass)});
},
args: ["aString", "anArray", "aProxy"],
source: "forwardMessage: aString withArguments: anArray ofProxy: aProxy\x0a\x09<\x0a\x09\x09return $core.accessJavaScript(aProxy._jsObject(), aString, anArray);\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy.klass);

$core.addMethod(
$core.method({
selector: "jsObject:ofProxy:",
protocol: 'proxy',
fn: function (aJSObject,aProxy){
var self=this;
return $core.withContext(function($ctx1) {
aProxy['@jsObject'] = aJSObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsObject:ofProxy:",{aJSObject:aJSObject,aProxy:aProxy},$globals.JSObjectProxy.klass)});
},
args: ["aJSObject", "aProxy"],
source: "jsObject: aJSObject ofProxy: aProxy\x0a\x09<aProxy['@jsObject'] = aJSObject>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy.klass);

$core.addMethod(
$core.method({
selector: "lookupProperty:ofProxy:",
protocol: 'proxy',
fn: function (aString,aProxy){
var self=this;
return $core.withContext(function($ctx1) {
return aString in aProxy._jsObject() ? aString : nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"lookupProperty:ofProxy:",{aString:aString,aProxy:aProxy},$globals.JSObjectProxy.klass)});
},
args: ["aString", "aProxy"],
source: "lookupProperty: aString ofProxy: aProxy\x0a\x09\x22Looks up a property in JS object.\x0a\x09Answer the property if it is present, or nil if it is not present.\x22\x0a\x09\x0a\x09<return aString in aProxy._jsObject() ? aString : nil>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxy.klass);

$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (aJSObject){
var self=this;
var instance;
return $core.withContext(function($ctx1) {
instance=self._new();
self._jsObject_ofProxy_(aJSObject,instance);
return instance;
}, function($ctx1) {$ctx1.fill(self,"on:",{aJSObject:aJSObject,instance:instance},$globals.JSObjectProxy.klass)});
},
args: ["aJSObject"],
source: "on: aJSObject\x0a\x09| instance |\x0a\x09instance := self new.\x0a\x09self jsObject: aJSObject ofProxy: instance.\x0a\x09^ instance",
referencedClasses: [],
messageSends: ["new", "jsObject:ofProxy:"]
}),
$globals.JSObjectProxy.klass);


$core.addClass('Organizer', $globals.Object, [], 'Kernel-Infrastructure');
$globals.Organizer.comment="I represent categorization information. \x0a\x0a## API\x0a\x0aUse `#addElement:` and `#removeElement:` to manipulate instances.";
$core.addMethod(
$core.method({
selector: "addElement:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self.elements.addElement(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"addElement:",{anObject:anObject},$globals.Organizer)});
},
args: ["anObject"],
source: "addElement: anObject\x0a\x09<self.elements.addElement(anObject)>",
referencedClasses: [],
messageSends: []
}),
$globals.Organizer);

$core.addMethod(
$core.method({
selector: "elements",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._basicAt_("elements"))._copy();
}, function($ctx1) {$ctx1.fill(self,"elements",{},$globals.Organizer)});
},
args: [],
source: "elements\x0a\x09^ (self basicAt: 'elements') copy",
referencedClasses: [],
messageSends: ["copy", "basicAt:"]
}),
$globals.Organizer);

$core.addMethod(
$core.method({
selector: "removeElement:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self.elements.removeElement(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeElement:",{anObject:anObject},$globals.Organizer)});
},
args: ["anObject"],
source: "removeElement: anObject\x0a\x09<self.elements.removeElement(anObject)>",
referencedClasses: [],
messageSends: []
}),
$globals.Organizer);



$core.addClass('ClassOrganizer', $globals.Organizer, [], 'Kernel-Infrastructure');
$globals.ClassOrganizer.comment="I am an organizer specific to classes. I hold method categorization information for classes.";
$core.addMethod(
$core.method({
selector: "addElement:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
(
$ctx1.supercall = true,
($globals.ClassOrganizer.superclass||$boot.dnu).fn.prototype._addElement_.apply($recv(self), [aString]));
$ctx1.supercall = false;
$1=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.ProtocolAdded)._new();
$recv($3)._protocol_(aString);
$recv($3)._theClass_(self._theClass());
$2=$recv($3)._yourself();
$recv($1)._announce_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"addElement:",{aString:aString},$globals.ClassOrganizer)});
},
args: ["aString"],
source: "addElement: aString\x0a\x09super addElement: aString.\x0a\x0a\x09SystemAnnouncer current announce: (ProtocolAdded new\x0a\x09\x09protocol: aString;\x0a\x09\x09theClass: self theClass;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ProtocolAdded"],
messageSends: ["addElement:", "announce:", "current", "protocol:", "new", "theClass:", "theClass", "yourself"]
}),
$globals.ClassOrganizer);

$core.addMethod(
$core.method({
selector: "removeElement:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
(
$ctx1.supercall = true,
($globals.ClassOrganizer.superclass||$boot.dnu).fn.prototype._removeElement_.apply($recv(self), [aString]));
$ctx1.supercall = false;
$1=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.ProtocolRemoved)._new();
$recv($3)._protocol_(aString);
$recv($3)._theClass_(self._theClass());
$2=$recv($3)._yourself();
$recv($1)._announce_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeElement:",{aString:aString},$globals.ClassOrganizer)});
},
args: ["aString"],
source: "removeElement: aString\x0a\x09super removeElement: aString.\x0a\x0a\x09SystemAnnouncer current announce: (ProtocolRemoved new\x0a\x09\x09protocol: aString;\x0a\x09\x09theClass: self theClass;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ProtocolRemoved"],
messageSends: ["removeElement:", "announce:", "current", "protocol:", "new", "theClass:", "theClass", "yourself"]
}),
$globals.ClassOrganizer);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
 return self.theClass ;
return self;
}, function($ctx1) {$ctx1.fill(self,"theClass",{},$globals.ClassOrganizer)});
},
args: [],
source: "theClass\x0a\x09< return self.theClass >",
referencedClasses: [],
messageSends: []
}),
$globals.ClassOrganizer);



$core.addClass('PackageOrganizer', $globals.Organizer, [], 'Kernel-Infrastructure');
$globals.PackageOrganizer.comment="I am an organizer specific to packages. I hold classes categorization information.";


$core.addClass('Package', $globals.Object, ['transport', 'imports', 'dirty'], 'Kernel-Infrastructure');
$globals.Package.comment="I am similar to a \x22class category\x22 typically found in other Smalltalks like Pharo or Squeak. Amber does not have class categories anymore, it had in the beginning but now each class in the system knows which package it belongs to.\x0a\x0aEach package has a name and can be queried for its classes, but it will then resort to a reverse scan of all classes to find them.\x0a\x0a## API\x0a\x0aPackages are manipulated through \x22Smalltalk current\x22, like for example finding one based on a name or with `Package class >> #name` directly:\x0a\x0a    Smalltalk current packageAt: 'Kernel'\x0a    Package named: 'Kernel'\x0a\x0aA package differs slightly from a Monticello package which can span multiple class categories using a naming convention based on hyphenation. But just as in Monticello a package supports \x22class extensions\x22 so a package can define behaviors in foreign classes using a naming convention for method categories where the category starts with an asterisk and then the name of the owning package follows.\x0a\x0aYou can fetch a package from the server:\x0a\x0a\x09Package load: 'Additional-Examples'";
$core.addMethod(
$core.method({
selector: "basicImports",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.imports || [];
return self;
}, function($ctx1) {$ctx1.fill(self,"basicImports",{},$globals.Package)});
},
args: [],
source: "basicImports\x0a\x09\x22Answer the imports literal JavaScript object as setup in the JavaScript file, if any\x22\x0a\x09\x0a\x09<return self.imports || []>",
referencedClasses: [],
messageSends: []
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "basicName:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self.pkgName = aString;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicName:",{aString:aString},$globals.Package)});
},
args: ["aString"],
source: "basicName: aString\x0a\x09<self.pkgName = aString>",
referencedClasses: [],
messageSends: []
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "basicTransport",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.transport;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicTransport",{},$globals.Package)});
},
args: [],
source: "basicTransport\x0a\x09\x22Answer the transport literal JavaScript object as setup in the JavaScript file, if any\x22\x0a\x09\x0a\x09<return self.transport>",
referencedClasses: [],
messageSends: []
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "beClean",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
self["@dirty"]=false;
$1=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.PackageClean)._new();
$recv($3)._package_(self);
$2=$recv($3)._yourself();
$recv($1)._announce_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"beClean",{},$globals.Package)});
},
args: [],
source: "beClean\x0a\x09dirty := false.\x0a\x09\x0a\x09SystemAnnouncer current announce: (PackageClean new\x0a\x09\x09package: self;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "PackageClean"],
messageSends: ["announce:", "current", "package:", "new", "yourself"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "beDirty",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
self["@dirty"]=true;
$1=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.PackageDirty)._new();
$recv($3)._package_(self);
$2=$recv($3)._yourself();
$recv($1)._announce_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"beDirty",{},$globals.Package)});
},
args: [],
source: "beDirty\x0a\x09dirty := true.\x0a\x09\x0a\x09SystemAnnouncer current announce: (PackageDirty new\x0a\x09\x09package: self;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "PackageDirty"],
messageSends: ["announce:", "current", "package:", "new", "yourself"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "classTemplate",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$4,$5;
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
$recv(stream)._nextPutAll_("Object");
$ctx2.sendIdx["nextPutAll:"]=1;
$recv(stream)._nextPutAll_(" subclass: #NameOfSubclass");
$ctx2.sendIdx["nextPutAll:"]=2;
$2=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=1;
$3=$recv($globals.String)._tab();
$ctx2.sendIdx["tab"]=1;
$1=$recv($2).__comma($3);
$ctx2.sendIdx[","]=1;
$recv(stream)._nextPutAll_($1);
$ctx2.sendIdx["nextPutAll:"]=3;
$4=$recv(stream)._nextPutAll_("instanceVariableNames: ''");
$ctx2.sendIdx["nextPutAll:"]=4;
$4;
$5=$recv("'".__comma($recv($globals.String)._lf())).__comma($recv($globals.String)._tab());
$ctx2.sendIdx[","]=2;
$recv(stream)._nextPutAll_($5);
$ctx2.sendIdx["nextPutAll:"]=5;
$recv(stream)._nextPutAll_("package: '");
$ctx2.sendIdx["nextPutAll:"]=6;
$recv(stream)._nextPutAll_(self._name());
$ctx2.sendIdx["nextPutAll:"]=7;
return $recv(stream)._nextPutAll_("'");
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"classTemplate",{},$globals.Package)});
},
args: [],
source: "classTemplate\x0a\x09^ String streamContents: [ :stream |\x0a\x09\x09stream\x0a\x09\x09\x09nextPutAll: 'Object';\x0a\x09\x09\x09nextPutAll: ' subclass: #NameOfSubclass';\x0a\x09\x09\x09nextPutAll: String lf, String tab;\x0a\x09\x09\x09nextPutAll: 'instanceVariableNames: '''''.\x0a\x09\x09stream\x0a\x09\x09\x09nextPutAll: '''', String lf, String tab;\x0a\x09\x09\x09nextPutAll: 'package: ''';\x0a\x09\x09\x09nextPutAll: self name;\x0a\x09\x09\x09nextPutAll: '''' ]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "nextPutAll:", ",", "lf", "tab", "name"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "classes",
protocol: 'classes',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._organization())._elements();
}, function($ctx1) {$ctx1.fill(self,"classes",{},$globals.Package)});
},
args: [],
source: "classes\x0a\x09^ self organization elements",
referencedClasses: [],
messageSends: ["elements", "organization"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "definition",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$4,$2,$6,$5,$8,$9,$7,$10;
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
$1=$recv(self._class())._name();
$ctx2.sendIdx["name"]=1;
$recv(stream)._nextPutAll_($1);
$ctx2.sendIdx["nextPutAll:"]=1;
$3=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=1;
$4=$recv($globals.String)._tab();
$ctx2.sendIdx["tab"]=1;
$2=$recv($3).__comma($4);
$ctx2.sendIdx[","]=1;
$recv(stream)._nextPutAll_($2);
$ctx2.sendIdx["nextPutAll:"]=2;
$recv(stream)._nextPutAll_("named: ");
$ctx2.sendIdx["nextPutAll:"]=3;
$6="'".__comma(self._name());
$ctx2.sendIdx[","]=3;
$5=$recv($6).__comma("'");
$ctx2.sendIdx[","]=2;
$recv(stream)._nextPutAll_($5);
$ctx2.sendIdx["nextPutAll:"]=4;
$8=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=2;
$9=$recv($globals.String)._tab();
$ctx2.sendIdx["tab"]=2;
$7=$recv($8).__comma($9);
$ctx2.sendIdx[","]=4;
$recv(stream)._nextPutAll_($7);
$ctx2.sendIdx["nextPutAll:"]=5;
$recv(stream)._nextPutAll_("imports: ");
$ctx2.sendIdx["nextPutAll:"]=6;
$recv(stream)._nextPutAll_(self._importsDefinition());
$ctx2.sendIdx["nextPutAll:"]=7;
$10=$recv($recv($globals.String)._lf()).__comma($recv($globals.String)._tab());
$ctx2.sendIdx[","]=5;
$recv(stream)._nextPutAll_($10);
$ctx2.sendIdx["nextPutAll:"]=8;
$recv(stream)._nextPutAll_("transport: (");
$ctx2.sendIdx["nextPutAll:"]=9;
return $recv(stream)._nextPutAll_($recv($recv(self._transport())._definition()).__comma(")"));
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"definition",{},$globals.Package)});
},
args: [],
source: "definition\x0a\x09^ String streamContents: [ :stream |\x0a\x09\x09stream \x0a\x09\x09\x09nextPutAll: self class name;\x0a\x09\x09\x09nextPutAll: String lf, String tab;\x0a\x09\x09\x09nextPutAll: 'named: ';\x0a\x09\x09\x09nextPutAll: '''', self name, '''';\x0a\x09\x09\x09nextPutAll: String lf, String tab;\x0a\x09\x09\x09nextPutAll: 'imports: ';\x0a\x09\x09\x09nextPutAll: self importsDefinition;\x0a\x09\x09\x09nextPutAll: String lf, String tab;\x0a\x09\x09\x09nextPutAll: 'transport: (';\x0a\x09\x09\x09nextPutAll: self transport definition, ')' ]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "nextPutAll:", "name", "class", ",", "lf", "tab", "importsDefinition", "definition", "transport"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "imports",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@imports"];
if(($receiver = $1) == null || $receiver.isNil){
var parsed;
parsed=self._importsFromJson_(self._basicImports());
parsed;
self._imports_(parsed);
return self["@imports"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"imports",{},$globals.Package)});
},
args: [],
source: "imports\x0a\x09^ imports ifNil: [\x0a\x09\x09| parsed |\x0a\x09\x09parsed := self importsFromJson: self basicImports.\x0a\x09\x09self imports: parsed.\x0a\x09\x09imports ]",
referencedClasses: [],
messageSends: ["ifNil:", "importsFromJson:", "basicImports", "imports:"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "imports:",
protocol: 'accessing',
fn: function (anArray){
var self=this;
return $core.withContext(function($ctx1) {
self._validateImports_(anArray);
self["@imports"]=$recv(anArray)._asSet();
return self;
}, function($ctx1) {$ctx1.fill(self,"imports:",{anArray:anArray},$globals.Package)});
},
args: ["anArray"],
source: "imports: anArray\x0a\x09self validateImports: anArray.\x0a\x09imports := anArray asSet",
referencedClasses: [],
messageSends: ["validateImports:", "asSet"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "importsAsJson",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv(self._sortedImportsAsArray())._collect_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(each)._isString();
if($core.assert($1)){
return each;
} else {
return $recv($recv($recv(each)._key()).__comma("=")).__comma($recv(each)._value());
$ctx2.sendIdx[","]=1;
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"importsAsJson",{},$globals.Package)});
},
args: [],
source: "importsAsJson\x0a\x0a\x09^ self sortedImportsAsArray collect: [ :each |\x0a\x09\x09each isString\x0a\x09\x09\x09ifTrue: [ each ]\x0a\x09\x09\x09ifFalse: [ each key, '=', each value ]]",
referencedClasses: [],
messageSends: ["collect:", "sortedImportsAsArray", "ifTrue:ifFalse:", "isString", ",", "key", "value"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "importsDefinition",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
$recv(stream)._nextPutAll_("{");
$ctx2.sendIdx["nextPutAll:"]=1;
$recv(self._sortedImportsAsArray())._do_separatedBy_((function(each){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPutAll_($recv(each)._importsString());
$ctx3.sendIdx["nextPutAll:"]=2;
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPutAll_(". ");
$ctx3.sendIdx["nextPutAll:"]=3;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
return $recv(stream)._nextPutAll_("}");
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"importsDefinition",{},$globals.Package)});
},
args: [],
source: "importsDefinition\x0a\x09^ String streamContents: [ :stream |\x0a\x09\x09stream nextPutAll: '{'.\x0a\x09\x09self sortedImportsAsArray\x0a\x09\x09\x09do: [ :each | stream nextPutAll: each importsString ]\x0a\x09\x09\x09separatedBy: [ stream nextPutAll: '. ' ].\x0a\x09\x09stream nextPutAll: '}' ]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "nextPutAll:", "do:separatedBy:", "sortedImportsAsArray", "importsString"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "importsFromJson:",
protocol: 'converting',
fn: function (anArray){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv(anArray)._collect_((function(each){
var split;
return $core.withContext(function($ctx2) {
split=$recv(each)._tokenize_("=");
split;
$1=$recv($recv(split)._size()).__eq((1));
if($core.assert($1)){
return $recv(split)._first();
$ctx2.sendIdx["first"]=1;
} else {
return $recv($recv(split)._first()).__minus_gt($recv(split)._second());
};
}, function($ctx2) {$ctx2.fillBlock({each:each,split:split},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"importsFromJson:",{anArray:anArray},$globals.Package)});
},
args: ["anArray"],
source: "importsFromJson: anArray\x0a\x09\x22Parses array of string, eg. #('asdf' 'qwer=tyuo')\x0a\x09into array of Strings and Associations,\x0a\x09eg. {'asdf'. 'qwer'->'tyuo'}\x22\x0a\x0a\x09^ anArray collect: [ :each |\x0a\x09\x09| split |\x0a\x09\x09split := each tokenize: '='.\x0a\x09\x09split size = 1\x0a\x09\x09\x09ifTrue: [ split first ]\x0a\x09\x09\x09ifFalse: [ split first -> split second ]]",
referencedClasses: [],
messageSends: ["collect:", "tokenize:", "ifTrue:ifFalse:", "=", "size", "first", "->", "second"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "isDirty",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@dirty"];
if(($receiver = $1) == null || $receiver.isNil){
return false;
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"isDirty",{},$globals.Package)});
},
args: [],
source: "isDirty\x0a\x09^ dirty ifNil: [ false ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "isPackage",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isPackage\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "loadDependencies",
protocol: 'dependencies',
fn: function (){
var self=this;
var classes,packages;
return $core.withContext(function($ctx1) {
var $1;
classes=self._loadDependencyClasses();
$1=$recv($recv(classes)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._package();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._asSet();
$recv($1)._remove_ifAbsent_(self,(function(){

}));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"loadDependencies",{classes:classes,packages:packages},$globals.Package)});
},
args: [],
source: "loadDependencies\x0a\x09\x22Returns list of packages that need to be loaded\x0a\x09before loading this package.\x22\x0a\x09\x0a\x09| classes packages |\x0a\x09classes := self loadDependencyClasses.\x0a\x09^ (classes collect: [ :each | each package ]) asSet\x0a\x09\x09remove: self ifAbsent: [];\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["loadDependencyClasses", "remove:ifAbsent:", "asSet", "collect:", "package", "yourself"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "loadDependencyClasses",
protocol: 'dependencies',
fn: function (){
var self=this;
var starCategoryName;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$5,$4;
starCategoryName="*".__comma(self._name());
$ctx1.sendIdx[","]=1;
$3=self._classes();
$ctx1.sendIdx["classes"]=1;
$2=$recv($3)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._superclass();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$1=$recv($2)._asSet();
$recv($1)._remove_ifAbsent_(nil,(function(){

}));
$recv($1)._addAll_($recv($recv($globals.Smalltalk)._classes())._select_((function(each){
return $core.withContext(function($ctx2) {
$5=$recv(each)._protocols();
$ctx2.sendIdx["protocols"]=1;
$4=$recv($5).__comma($recv($recv(each)._class())._protocols());
return $recv($4)._includes_(starCategoryName);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
})));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"loadDependencyClasses",{starCategoryName:starCategoryName},$globals.Package)});
},
args: [],
source: "loadDependencyClasses\x0a\x09\x22Returns classes needed at the time of loading a package.\x0a\x09These are all that are used to subclass\x0a\x09and to define an extension method\x22\x0a\x09\x0a\x09| starCategoryName |\x0a\x09starCategoryName := '*', self name.\x0a\x09^ (self classes collect: [ :each | each superclass ]) asSet\x0a\x09\x09remove: nil ifAbsent: [];\x0a\x09\x09addAll: (Smalltalk classes select: [ :each | each protocols, each class protocols includes: starCategoryName ]);\x0a\x09\x09yourself",
referencedClasses: ["Smalltalk"],
messageSends: [",", "name", "remove:ifAbsent:", "asSet", "collect:", "classes", "superclass", "addAll:", "select:", "includes:", "protocols", "class", "yourself"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "name",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.pkgName;
return self;
}, function($ctx1) {$ctx1.fill(self,"name",{},$globals.Package)});
},
args: [],
source: "name\x0a\x09<return self.pkgName>",
referencedClasses: [],
messageSends: []
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "name:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._basicName_(aString);
self._beDirty();
return self;
}, function($ctx1) {$ctx1.fill(self,"name:",{aString:aString},$globals.Package)});
},
args: ["aString"],
source: "name: aString\x0a\x09self basicName: aString.\x0a\x09self beDirty",
referencedClasses: [],
messageSends: ["basicName:", "beDirty"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "organization",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._basicAt_("organization");
}, function($ctx1) {$ctx1.fill(self,"organization",{},$globals.Package)});
},
args: [],
source: "organization\x0a\x09^ self basicAt: 'organization'",
referencedClasses: [],
messageSends: ["basicAt:"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Package.superclass||$boot.dnu).fn.prototype._printOn_.apply($recv(self), [aStream]));
$ctx1.supercall = false;
$recv(aStream)._nextPutAll_(" (");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_(self._name());
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.Package)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09aStream \x0a\x09\x09nextPutAll: ' (';\x0a\x09\x09nextPutAll: self name;\x0a\x09\x09nextPutAll: ')'",
referencedClasses: [],
messageSends: ["printOn:", "nextPutAll:", "name"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "setupClasses",
protocol: 'classes',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._classes();
$recv($1)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.ClassBuilder)._new())._setupClass_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["do:"]=1;
$recv($1)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._initialize();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"setupClasses",{},$globals.Package)});
},
args: [],
source: "setupClasses\x0a\x09self classes\x0a\x09\x09do: [ :each | ClassBuilder new setupClass: each ];\x0a\x09\x09do: [ :each | each initialize ]",
referencedClasses: ["ClassBuilder"],
messageSends: ["do:", "classes", "setupClass:", "new", "initialize"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "sortedClasses",
protocol: 'classes',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._class())._sortedClasses_(self._classes());
}, function($ctx1) {$ctx1.fill(self,"sortedClasses",{},$globals.Package)});
},
args: [],
source: "sortedClasses\x0a\x09\x22Answer all classes in the receiver, sorted by superclass/subclasses and by class name for common subclasses (Issue #143).\x22\x0a\x0a\x09^ self class sortedClasses: self classes",
referencedClasses: [],
messageSends: ["sortedClasses:", "class", "classes"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "sortedImportsAsArray",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$4,$1,$6,$5,$7;
return $recv($recv(self._imports())._asArray())._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
$3=$recv(a)._isString();
$ctx2.sendIdx["isString"]=1;
$2=$recv($3)._not();
$4=$recv(b)._isString();
$ctx2.sendIdx["isString"]=2;
$1=$recv($2).__and($4);
return $recv($1)._or_((function(){
return $core.withContext(function($ctx3) {
$6=$recv(a)._isString();
$ctx3.sendIdx["isString"]=3;
$5=$recv($6).__eq($recv(b)._isString());
return $recv($5)._and_((function(){
return $core.withContext(function($ctx4) {
$7=$recv(a)._value();
$ctx4.sendIdx["value"]=1;
return $recv($7).__lt_eq($recv(b)._value());
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,3)});
}));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"sortedImportsAsArray",{},$globals.Package)});
},
args: [],
source: "sortedImportsAsArray\x0a\x09\x22Answer imports sorted first by type (associations first),\x0a\x09then by value\x22\x0a\x0a\x09^ self imports asArray\x0a\x09\x09sorted: [ :a :b |\x0a\x09\x09\x09a isString not & b isString or: [\x0a\x09\x09\x09\x09a isString = b isString and: [\x0a\x09\x09\x09\x09\x09a value <= b value ]]]",
referencedClasses: [],
messageSends: ["sorted:", "asArray", "imports", "or:", "&", "not", "isString", "and:", "=", "<=", "value"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "transport",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
$1=self["@transport"];
if(($receiver = $1) == null || $receiver.isNil){
$2=$recv($globals.PackageTransport)._fromJson_(self._basicTransport());
$recv($2)._package_(self);
self["@transport"]=$recv($2)._yourself();
return self["@transport"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"transport",{},$globals.Package)});
},
args: [],
source: "transport\x0a\x09^ transport ifNil: [ \x0a\x09\x09transport := (PackageTransport fromJson: self basicTransport)\x0a\x09\x09\x09package: self;\x0a\x09\x09\x09yourself ]",
referencedClasses: ["PackageTransport"],
messageSends: ["ifNil:", "package:", "fromJson:", "basicTransport", "yourself"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "transport:",
protocol: 'accessing',
fn: function (aPackageTransport){
var self=this;
return $core.withContext(function($ctx1) {
self["@transport"]=aPackageTransport;
$recv(aPackageTransport)._package_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"transport:",{aPackageTransport:aPackageTransport},$globals.Package)});
},
args: ["aPackageTransport"],
source: "transport: aPackageTransport\x0a\x09transport := aPackageTransport.\x0a\x09aPackageTransport package: self",
referencedClasses: [],
messageSends: ["package:"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "validateImports:",
protocol: 'validation',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$5,$4,$3,$6;
$recv(aCollection)._do_((function(import_){
return $core.withContext(function($ctx2) {
$1=$recv(import_)._isString();
$ctx2.sendIdx["isString"]=1;
if(!$core.assert($1)){
$2=$recv(import_)._respondsTo_("key");
if(!$core.assert($2)){
self._error_("Imports must be Strings or Associations");
$ctx2.sendIdx["error:"]=1;
};
$5=$recv(import_)._key();
$ctx2.sendIdx["key"]=1;
$4=$recv($5)._isString();
$ctx2.sendIdx["isString"]=2;
$3=$recv($4).__and($recv($recv(import_)._value())._isString());
if(!$core.assert($3)){
self._error_("Key and value must be Strings");
$ctx2.sendIdx["error:"]=2;
};
$6=$recv($recv(import_)._key())._match_("^[a-zA-Z][a-zA-Z0-9]*$");
if(!$core.assert($6)){
return self._error_("Keys must be identifiers");
};
};
}, function($ctx2) {$ctx2.fillBlock({import_:import_},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"validateImports:",{aCollection:aCollection},$globals.Package)});
},
args: ["aCollection"],
source: "validateImports: aCollection\x0a\x0a\x09aCollection do: [ :import |\x0a\x09\x09import isString ifFalse: [\x0a\x09\x09\x09(import respondsTo: #key) ifFalse: [\x0a\x09\x09\x09\x09self error: 'Imports must be Strings or Associations' ].\x0a\x09\x09\x09import key isString & import value isString ifFalse: [\x0a\x09\x09\x09\x09self error: 'Key and value must be Strings' ].\x0a\x09\x09\x09(import key match: '^[a-zA-Z][a-zA-Z0-9]*$') ifFalse: [\x0a\x09\x09\x09\x09self error: 'Keys must be identifiers' ]]]",
referencedClasses: [],
messageSends: ["do:", "ifFalse:", "isString", "respondsTo:", "error:", "&", "key", "value", "match:"]
}),
$globals.Package);


$globals.Package.klass.iVarNames = ['defaultCommitPathJs','defaultCommitPathSt'];
$core.addMethod(
$core.method({
selector: "named:",
protocol: 'accessing',
fn: function (aPackageName){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._packageAt_ifAbsent_(aPackageName,(function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Smalltalk)._createPackage_(aPackageName);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"named:",{aPackageName:aPackageName},$globals.Package.klass)});
},
args: ["aPackageName"],
source: "named: aPackageName\x0a\x09^ Smalltalk \x0a\x09\x09packageAt: aPackageName\x0a\x09\x09ifAbsent: [ \x0a\x09\x09\x09Smalltalk createPackage: aPackageName ]",
referencedClasses: ["Smalltalk"],
messageSends: ["packageAt:ifAbsent:", "createPackage:"]
}),
$globals.Package.klass);

$core.addMethod(
$core.method({
selector: "named:ifAbsent:",
protocol: 'accessing',
fn: function (aPackageName,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._packageAt_ifAbsent_(aPackageName,aBlock);
}, function($ctx1) {$ctx1.fill(self,"named:ifAbsent:",{aPackageName:aPackageName,aBlock:aBlock},$globals.Package.klass)});
},
args: ["aPackageName", "aBlock"],
source: "named: aPackageName ifAbsent: aBlock\x0a\x09^ Smalltalk packageAt: aPackageName ifAbsent: aBlock",
referencedClasses: ["Smalltalk"],
messageSends: ["packageAt:ifAbsent:"]
}),
$globals.Package.klass);

$core.addMethod(
$core.method({
selector: "named:imports:transport:",
protocol: 'accessing',
fn: function (aPackageName,anArray,aTransport){
var self=this;
var package_;
return $core.withContext(function($ctx1) {
package_=self._named_(aPackageName);
$recv(package_)._imports_(anArray);
$recv(package_)._transport_(aTransport);
return package_;
}, function($ctx1) {$ctx1.fill(self,"named:imports:transport:",{aPackageName:aPackageName,anArray:anArray,aTransport:aTransport,package_:package_},$globals.Package.klass)});
},
args: ["aPackageName", "anArray", "aTransport"],
source: "named: aPackageName imports: anArray transport: aTransport\x0a\x09| package |\x0a\x09\x0a\x09package := self named: aPackageName.\x0a\x09package imports: anArray.\x0a\x09package transport: aTransport.\x0a\x09\x0a\x09^ package",
referencedClasses: [],
messageSends: ["named:", "imports:", "transport:"]
}),
$globals.Package.klass);

$core.addMethod(
$core.method({
selector: "named:transport:",
protocol: 'accessing',
fn: function (aPackageName,aTransport){
var self=this;
var package_;
return $core.withContext(function($ctx1) {
package_=self._named_(aPackageName);
$recv(package_)._transport_(aTransport);
return package_;
}, function($ctx1) {$ctx1.fill(self,"named:transport:",{aPackageName:aPackageName,aTransport:aTransport,package_:package_},$globals.Package.klass)});
},
args: ["aPackageName", "aTransport"],
source: "named: aPackageName transport: aTransport\x0a\x09| package |\x0a\x09\x0a\x09package := self named: aPackageName.\x0a\x09package transport: aTransport.\x0a\x09\x0a\x09^ package",
referencedClasses: [],
messageSends: ["named:", "transport:"]
}),
$globals.Package.klass);

$core.addMethod(
$core.method({
selector: "sortedClasses:",
protocol: 'sorting',
fn: function (classes){
var self=this;
var children,others,nodes,expandedClasses;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
children=[];
others=[];
$recv(classes)._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(classes)._includes_($recv(each)._superclass());
if($core.assert($1)){
return $recv(others)._add_(each);
} else {
return $recv(children)._add_(each);
$ctx2.sendIdx["add:"]=1;
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["do:"]=1;
nodes=$recv(children)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($globals.ClassSorterNode)._on_classes_level_(each,others,(0));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}));
nodes=$recv(nodes)._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
$3=$recv(a)._theClass();
$ctx2.sendIdx["theClass"]=1;
$2=$recv($3)._name();
$ctx2.sendIdx["name"]=1;
return $recv($2).__lt_eq($recv($recv(b)._theClass())._name());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,5)});
}));
expandedClasses=$recv($globals.Array)._new();
$recv(nodes)._do_((function(aNode){
return $core.withContext(function($ctx2) {
return $recv(aNode)._traverseClassesWith_(expandedClasses);
}, function($ctx2) {$ctx2.fillBlock({aNode:aNode},$ctx1,6)});
}));
return expandedClasses;
}, function($ctx1) {$ctx1.fill(self,"sortedClasses:",{classes:classes,children:children,others:others,nodes:nodes,expandedClasses:expandedClasses},$globals.Package.klass)});
},
args: ["classes"],
source: "sortedClasses: classes\x0a\x09\x22Answer classes, sorted by superclass/subclasses and by class name for common subclasses (Issue #143)\x22\x0a\x0a\x09| children others nodes expandedClasses |\x0a\x09children := #().\x0a\x09others := #().\x0a\x09classes do: [ :each |\x0a\x09\x09(classes includes: each superclass)\x0a\x09\x09\x09ifFalse: [ children add: each ]\x0a\x09\x09\x09ifTrue: [ others add: each ]].\x0a\x09nodes := children collect: [ :each |\x0a\x09\x09ClassSorterNode on: each classes: others level: 0 ].\x0a\x09nodes := nodes sorted: [ :a :b | a theClass name <= b theClass name ].\x0a\x09expandedClasses := Array new.\x0a\x09nodes do: [ :aNode |\x0a\x09\x09aNode traverseClassesWith: expandedClasses ].\x0a\x09^ expandedClasses",
referencedClasses: ["ClassSorterNode", "Array"],
messageSends: ["do:", "ifFalse:ifTrue:", "includes:", "superclass", "add:", "collect:", "on:classes:level:", "sorted:", "<=", "name", "theClass", "new", "traverseClassesWith:"]
}),
$globals.Package.klass);


$core.addClass('PackageStateObserver', $globals.Object, [], 'Kernel-Infrastructure');
$globals.PackageStateObserver.comment="My current instance listens for any changes in the system that might affect the state of a package (being dirty).";
$core.addMethod(
$core.method({
selector: "announcer",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.SystemAnnouncer)._current();
}, function($ctx1) {$ctx1.fill(self,"announcer",{},$globals.PackageStateObserver)});
},
args: [],
source: "announcer\x0a\x09^ SystemAnnouncer current",
referencedClasses: ["SystemAnnouncer"],
messageSends: ["current"]
}),
$globals.PackageStateObserver);

$core.addMethod(
$core.method({
selector: "observeSystem",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._announcer();
$recv($1)._on_send_to_($globals.PackageAdded,"onPackageAdded:",self);
$ctx1.sendIdx["on:send:to:"]=1;
$recv($1)._on_send_to_($globals.ClassAnnouncement,"onClassModification:",self);
$ctx1.sendIdx["on:send:to:"]=2;
$recv($1)._on_send_to_($globals.MethodAnnouncement,"onMethodModification:",self);
$ctx1.sendIdx["on:send:to:"]=3;
$recv($1)._on_send_to_($globals.ProtocolAnnouncement,"onProtocolModification:",self);
return self;
}, function($ctx1) {$ctx1.fill(self,"observeSystem",{},$globals.PackageStateObserver)});
},
args: [],
source: "observeSystem\x0a\x09self announcer\x0a\x09\x09on: PackageAdded\x0a\x09\x09send: #onPackageAdded:\x0a\x09\x09to: self;\x0a\x09\x09\x0a\x09\x09on: ClassAnnouncement\x0a\x09\x09send: #onClassModification:\x0a\x09\x09to: self;\x0a\x09\x09\x0a\x09\x09on: MethodAnnouncement\x0a\x09\x09send: #onMethodModification:\x0a\x09\x09to: self;\x0a\x09\x09\x0a\x09\x09on: ProtocolAnnouncement\x0a\x09\x09send: #onProtocolModification:\x0a\x09\x09to: self",
referencedClasses: ["PackageAdded", "ClassAnnouncement", "MethodAnnouncement", "ProtocolAnnouncement"],
messageSends: ["on:send:to:", "announcer"]
}),
$globals.PackageStateObserver);

$core.addMethod(
$core.method({
selector: "onClassModification:",
protocol: 'reactions',
fn: function (anAnnouncement){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv(anAnnouncement)._theClass();
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
var theClass;
theClass=$receiver;
$recv($recv(theClass)._package())._beDirty();
};
return self;
}, function($ctx1) {$ctx1.fill(self,"onClassModification:",{anAnnouncement:anAnnouncement},$globals.PackageStateObserver)});
},
args: ["anAnnouncement"],
source: "onClassModification: anAnnouncement\x0a\x09anAnnouncement theClass ifNotNil: [ :theClass | theClass package beDirty ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "theClass", "beDirty", "package"]
}),
$globals.PackageStateObserver);

$core.addMethod(
$core.method({
selector: "onMethodModification:",
protocol: 'reactions',
fn: function (anAnnouncement){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv($recv(anAnnouncement)._method())._package();
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
var package_;
package_=$receiver;
$recv(package_)._beDirty();
};
return self;
}, function($ctx1) {$ctx1.fill(self,"onMethodModification:",{anAnnouncement:anAnnouncement},$globals.PackageStateObserver)});
},
args: ["anAnnouncement"],
source: "onMethodModification: anAnnouncement\x0a\x09anAnnouncement method package ifNotNil: [ :package | package beDirty ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "package", "method", "beDirty"]
}),
$globals.PackageStateObserver);

$core.addMethod(
$core.method({
selector: "onPackageAdded:",
protocol: 'reactions',
fn: function (anAnnouncement){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(anAnnouncement)._package())._beDirty();
return self;
}, function($ctx1) {$ctx1.fill(self,"onPackageAdded:",{anAnnouncement:anAnnouncement},$globals.PackageStateObserver)});
},
args: ["anAnnouncement"],
source: "onPackageAdded: anAnnouncement\x0a\x09anAnnouncement package beDirty",
referencedClasses: [],
messageSends: ["beDirty", "package"]
}),
$globals.PackageStateObserver);

$core.addMethod(
$core.method({
selector: "onProtocolModification:",
protocol: 'reactions',
fn: function (anAnnouncement){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv(anAnnouncement)._package();
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
var package_;
package_=$receiver;
$recv(package_)._beDirty();
};
return self;
}, function($ctx1) {$ctx1.fill(self,"onProtocolModification:",{anAnnouncement:anAnnouncement},$globals.PackageStateObserver)});
},
args: ["anAnnouncement"],
source: "onProtocolModification: anAnnouncement\x0a\x09anAnnouncement package ifNotNil: [ :package | package beDirty ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "package", "beDirty"]
}),
$globals.PackageStateObserver);


$globals.PackageStateObserver.klass.iVarNames = ['current'];
$core.addMethod(
$core.method({
selector: "current",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@current"];
if(($receiver = $1) == null || $receiver.isNil){
self["@current"]=self._new();
return self["@current"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"current",{},$globals.PackageStateObserver.klass)});
},
args: [],
source: "current\x0a\x09^ current ifNil: [ current := self new ]",
referencedClasses: [],
messageSends: ["ifNil:", "new"]
}),
$globals.PackageStateObserver.klass);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._current())._observeSystem();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.PackageStateObserver.klass)});
},
args: [],
source: "initialize\x0a\x09self current observeSystem",
referencedClasses: [],
messageSends: ["observeSystem", "current"]
}),
$globals.PackageStateObserver.klass);


$core.addClass('ParseError', $globals.Error, [], 'Kernel-Infrastructure');
$globals.ParseError.comment="Instance of ParseError are signaled on any parsing error.\x0aSee `Smalltalk >> #parse:`";


$core.addClass('RethrowErrorHandler', $globals.Object, [], 'Kernel-Infrastructure');
$globals.RethrowErrorHandler.comment="This class is used in the commandline version of the compiler.\x0aIt uses the handleError: message of ErrorHandler for printing the stacktrace and throws the error again as JS exception.\x0aAs a result Smalltalk errors are not swallowd by the Amber runtime and compilation can be aborted.";
$core.addMethod(
$core.method({
selector: "basicSignal:",
protocol: 'error handling',
fn: function (anError){
var self=this;
return $core.withContext(function($ctx1) {
throw anError;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicSignal:",{anError:anError},$globals.RethrowErrorHandler)});
},
args: ["anError"],
source: "basicSignal: anError\x0a        <throw anError>",
referencedClasses: [],
messageSends: []
}),
$globals.RethrowErrorHandler);

$core.addMethod(
$core.method({
selector: "handleError:",
protocol: 'error handling',
fn: function (anError){
var self=this;
return $core.withContext(function($ctx1) {
self._basicSignal_(anError);
return self;
}, function($ctx1) {$ctx1.fill(self,"handleError:",{anError:anError},$globals.RethrowErrorHandler)});
},
args: ["anError"],
source: "handleError: anError\x0a        self basicSignal: anError",
referencedClasses: [],
messageSends: ["basicSignal:"]
}),
$globals.RethrowErrorHandler);



$core.addClass('Setting', $globals.Object, ['key', 'value', 'defaultValue'], 'Kernel-Infrastructure');
$globals.Setting.comment="I represent a setting **stored** at `Smalltalk settings`. \x0aIn the current implementation, `Smalltalk settings` is an object persisted in the localStorage.\x0a\x0a## API\x0a\x0aA `Setting` value can be read using `value` and set using `value:`.\x0a\x0aSettings are accessed with `'key' asSetting` or `'key' asSettingIfAbsent: aDefaultValue`.\x0a\x0aTo read the value of a setting you can also use the convenience:\x0a\x0a`theValueSet :=  'any.characteristic' settingValue` \x0a\x0aor with a default using:\x0a\x0a `theEnsuredValueSet := 'any.characteristic' settingValueIfAbsent: true`";
$core.addMethod(
$core.method({
selector: "defaultValue",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@defaultValue"];

},
args: [],
source: "defaultValue\x0a\x09^ defaultValue",
referencedClasses: [],
messageSends: []
}),
$globals.Setting);

$core.addMethod(
$core.method({
selector: "defaultValue:",
protocol: 'accessing',
fn: function (aStringifiableObject){
var self=this;
self["@defaultValue"]=aStringifiableObject;
return self;

},
args: ["aStringifiableObject"],
source: "defaultValue: aStringifiableObject\x0a\x09defaultValue := aStringifiableObject",
referencedClasses: [],
messageSends: []
}),
$globals.Setting);

$core.addMethod(
$core.method({
selector: "key",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@key"];

},
args: [],
source: "key\x0a\x09^ key",
referencedClasses: [],
messageSends: []
}),
$globals.Setting);

$core.addMethod(
$core.method({
selector: "key:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@key"]=aString;
return self;

},
args: ["aString"],
source: "key: aString\x0a\x09key := aString",
referencedClasses: [],
messageSends: []
}),
$globals.Setting);

$core.addMethod(
$core.method({
selector: "value",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._settings())._at_ifAbsent_(self._key(),(function(){
return $core.withContext(function($ctx2) {
return self._defaultValue();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"value",{},$globals.Setting)});
},
args: [],
source: "value\x0a\x09^ Smalltalk settings at: self key ifAbsent: [ self defaultValue ]",
referencedClasses: ["Smalltalk"],
messageSends: ["at:ifAbsent:", "settings", "key", "defaultValue"]
}),
$globals.Setting);

$core.addMethod(
$core.method({
selector: "value:",
protocol: 'accessing',
fn: function (aStringifiableObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._settings())._at_put_(self._key(),aStringifiableObject);
}, function($ctx1) {$ctx1.fill(self,"value:",{aStringifiableObject:aStringifiableObject},$globals.Setting)});
},
args: ["aStringifiableObject"],
source: "value: aStringifiableObject\x0a\x09^ Smalltalk settings at: self key put: aStringifiableObject",
referencedClasses: ["Smalltalk"],
messageSends: ["at:put:", "settings", "key"]
}),
$globals.Setting);


$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: 'instance creation',
fn: function (aString,aDefaultValue){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=(
$ctx1.supercall = true,
($globals.Setting.klass.superclass||$boot.dnu).fn.prototype._new.apply($recv(self), []));
$ctx1.supercall = false;
$recv($1)._key_(aString);
$recv($1)._defaultValue_(aDefaultValue);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{aString:aString,aDefaultValue:aDefaultValue},$globals.Setting.klass)});
},
args: ["aString", "aDefaultValue"],
source: "at: aString ifAbsent: aDefaultValue\x0a\x09\x0a\x09^ super new\x0a\x09\x09key: aString;\x0a\x09\x09defaultValue: aDefaultValue;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["key:", "new", "defaultValue:", "yourself"]
}),
$globals.Setting.klass);

$core.addMethod(
$core.method({
selector: "new",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._shouldNotImplement();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{},$globals.Setting.klass)});
},
args: [],
source: "new\x0a\x09self shouldNotImplement",
referencedClasses: [],
messageSends: ["shouldNotImplement"]
}),
$globals.Setting.klass);


$core.addClass('SmalltalkImage', $globals.Object, [], 'Kernel-Infrastructure');
$globals.SmalltalkImage.comment="I represent the Smalltalk system, wrapping\x0aoperations of variable `$core` declared in `support/boot.js`.\x0a\x0a## API\x0a\x0aI have only one instance, accessed with global variable `Smalltalk`.\x0a\x0a## Classes\x0a\x0aClasses can be accessed using the following methods:\x0a\x0a- `#classes` answers the full list of Smalltalk classes in the system\x0a- `#globals #at:` answers a specific global (usually, a class) or `nil`\x0a\x0a## Packages\x0a\x0aPackages can be accessed using the following methods:\x0a\x0a- `#packages` answers the full list of packages\x0a- `#packageAt:` answers a specific package or `nil`\x0a\x0a## Parsing\x0a\x0aThe `#parse:` method is used to parse Amber source code.\x0aIt requires the `Compiler` package and the `support/parser.js` parser file in order to work.";
$core.addMethod(
$core.method({
selector: "addGlobalJsVariable:",
protocol: 'globals',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._globalJsVariables())._add_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"addGlobalJsVariable:",{aString:aString},$globals.SmalltalkImage)});
},
args: ["aString"],
source: "addGlobalJsVariable: aString\x0a\x09self globalJsVariables add: aString",
referencedClasses: [],
messageSends: ["add:", "globalJsVariables"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "amdRequire",
protocol: 'accessing amd',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._core())._at_("amdRequire");
}, function($ctx1) {$ctx1.fill(self,"amdRequire",{},$globals.SmalltalkImage)});
},
args: [],
source: "amdRequire\x0a\x09^ self core at: 'amdRequire'",
referencedClasses: [],
messageSends: ["at:", "core"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "asSmalltalkException:",
protocol: 'error handling',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self._isSmalltalkObject_(anObject))._and_((function(){
return $core.withContext(function($ctx2) {
return $recv(anObject)._isKindOf_($globals.Error);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
if($core.assert($1)){
return anObject;
} else {
return $recv($globals.JavaScriptException)._on_(anObject);
};
}, function($ctx1) {$ctx1.fill(self,"asSmalltalkException:",{anObject:anObject},$globals.SmalltalkImage)});
},
args: ["anObject"],
source: "asSmalltalkException: anObject\x0a\x09\x22A JavaScript exception may be thrown.\x0a\x09We then need to convert it back to a Smalltalk object\x22\x0a\x09\x0a\x09^ ((self isSmalltalkObject: anObject) and: [ anObject isKindOf: Error ])\x0a\x09\x09ifTrue: [ anObject ]\x0a\x09\x09ifFalse: [ JavaScriptException on: anObject ]",
referencedClasses: ["Error", "JavaScriptException"],
messageSends: ["ifTrue:ifFalse:", "and:", "isSmalltalkObject:", "isKindOf:", "on:"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "basicCreatePackage:",
protocol: 'private',
fn: function (packageName){
var self=this;
return $core.withContext(function($ctx1) {
return $core.addPackage(packageName);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicCreatePackage:",{packageName:packageName},$globals.SmalltalkImage)});
},
args: ["packageName"],
source: "basicCreatePackage: packageName\x0a\x09\x22Create and bind a new bare package with given name and return it.\x22\x0a\x09<return $core.addPackage(packageName)>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "basicParse:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.SmalltalkParser)._parse_(aString);
}, function($ctx1) {$ctx1.fill(self,"basicParse:",{aString:aString},$globals.SmalltalkImage)});
},
args: ["aString"],
source: "basicParse: aString\x0a\x09^ SmalltalkParser parse: aString",
referencedClasses: ["SmalltalkParser"],
messageSends: ["parse:"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "basicRegisterPackage:",
protocol: 'private',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
$core.packages[aPackage.pkgName]=aPackage;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicRegisterPackage:",{aPackage:aPackage},$globals.SmalltalkImage)});
},
args: ["aPackage"],
source: "basicRegisterPackage: aPackage\x0a\x09\x22Put aPackage in $core.packages object.\x22\x0a\x09<$core.packages[aPackage.pkgName]=aPackage>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "cancelOptOut:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
delete anObject.klass;
return self;
}, function($ctx1) {$ctx1.fill(self,"cancelOptOut:",{anObject:anObject},$globals.SmalltalkImage)});
},
args: ["anObject"],
source: "cancelOptOut: anObject\x0a\x09\x22A Smalltalk object has a 'klass' property.\x0a\x09If this property is shadowed for anObject by optOut:,\x0a\x09the object is treated as plain JS object.\x0a\x09This removes the shadow and anObject is Smalltalk object\x0a\x09again if it was before.\x22\x0a\x09\x0a\x09<delete anObject.klass>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "classes",
protocol: 'classes',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $core.classes();
return self;
}, function($ctx1) {$ctx1.fill(self,"classes",{},$globals.SmalltalkImage)});
},
args: [],
source: "classes\x0a\x09<return $core.classes()>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "core",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $core;
return self;
}, function($ctx1) {$ctx1.fill(self,"core",{},$globals.SmalltalkImage)});
},
args: [],
source: "core\x0a\x09<return $core>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "createPackage:",
protocol: 'packages',
fn: function (packageName){
var self=this;
var package_,announcement;
return $core.withContext(function($ctx1) {
var $1;
package_=self._basicCreatePackage_(packageName);
$1=$recv($globals.PackageAdded)._new();
$recv($1)._package_(package_);
announcement=$recv($1)._yourself();
$recv($recv($globals.SystemAnnouncer)._current())._announce_(announcement);
return package_;
}, function($ctx1) {$ctx1.fill(self,"createPackage:",{packageName:packageName,package_:package_,announcement:announcement},$globals.SmalltalkImage)});
},
args: ["packageName"],
source: "createPackage: packageName\x0a\x09| package announcement |\x0a\x09\x0a\x09package := self basicCreatePackage: packageName.\x0a\x09\x0a\x09announcement := PackageAdded new\x0a\x09\x09package: package;\x0a\x09\x09yourself.\x0a\x09\x09\x0a\x09SystemAnnouncer current announce: announcement.\x0a\x09\x0a\x09^ package",
referencedClasses: ["PackageAdded", "SystemAnnouncer"],
messageSends: ["basicCreatePackage:", "package:", "new", "yourself", "announce:", "current"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "defaultAmdNamespace",
protocol: 'accessing amd',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return "transport.defaultAmdNamespace"._settingValue();
}, function($ctx1) {$ctx1.fill(self,"defaultAmdNamespace",{},$globals.SmalltalkImage)});
},
args: [],
source: "defaultAmdNamespace\x0a\x09^ 'transport.defaultAmdNamespace' settingValue",
referencedClasses: [],
messageSends: ["settingValue"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "defaultAmdNamespace:",
protocol: 'accessing amd',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
"transport.defaultAmdNamespace"._settingValue_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"defaultAmdNamespace:",{aString:aString},$globals.SmalltalkImage)});
},
args: ["aString"],
source: "defaultAmdNamespace: aString\x0a\x09'transport.defaultAmdNamespace' settingValue: aString",
referencedClasses: [],
messageSends: ["settingValue:"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "deleteClass:",
protocol: 'private',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
$core.removeClass(aClass);
return self;
}, function($ctx1) {$ctx1.fill(self,"deleteClass:",{aClass:aClass},$globals.SmalltalkImage)});
},
args: ["aClass"],
source: "deleteClass: aClass\x0a\x09\x22Deletes a class by deleting its binding only. Use #removeClass instead\x22\x0a\x09\x0a\x09<$core.removeClass(aClass)>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "deleteGlobalJsVariable:",
protocol: 'globals',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._globalJsVariables())._remove_ifAbsent_(aString,(function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"deleteGlobalJsVariable:",{aString:aString},$globals.SmalltalkImage)});
},
args: ["aString"],
source: "deleteGlobalJsVariable: aString\x0a\x09self globalJsVariables remove: aString ifAbsent:[]",
referencedClasses: [],
messageSends: ["remove:ifAbsent:", "globalJsVariables"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "deletePackage:",
protocol: 'private',
fn: function (packageName){
var self=this;
return $core.withContext(function($ctx1) {
delete $core.packages[packageName];
return self;
}, function($ctx1) {$ctx1.fill(self,"deletePackage:",{packageName:packageName},$globals.SmalltalkImage)});
},
args: ["packageName"],
source: "deletePackage: packageName\x0a\x09\x22Deletes a package by deleting its binding, but does not check if it contains classes etc.\x0a\x09To remove a package, use #removePackage instead.\x22\x0a\x0a\x09<delete $core.packages[packageName]>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "existsJsGlobal:",
protocol: 'testing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Platform)._globals())._at_ifPresent_ifAbsent_(aString,(function(){
return true;

}),(function(){
return false;

}));
}, function($ctx1) {$ctx1.fill(self,"existsJsGlobal:",{aString:aString},$globals.SmalltalkImage)});
},
args: ["aString"],
source: "existsJsGlobal: aString\x0a\x09^ Platform globals \x0a\x09\x09at: aString \x0a\x09\x09ifPresent: [ true ] \x0a\x09\x09ifAbsent: [ false ]",
referencedClasses: ["Platform"],
messageSends: ["at:ifPresent:ifAbsent:", "globals"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "globalJsVariables",
protocol: 'globals',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $core.globalJsVariables;
return self;
}, function($ctx1) {$ctx1.fill(self,"globalJsVariables",{},$globals.SmalltalkImage)});
},
args: [],
source: "globalJsVariables\x0a\x09\x22Array of global JavaScript variables\x22\x0a\x09<return $core.globalJsVariables>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "globals",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $globals;
return self;
}, function($ctx1) {$ctx1.fill(self,"globals",{},$globals.SmalltalkImage)});
},
args: [],
source: "globals\x0a\x09<return $globals>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "includesKey:",
protocol: 'accessing',
fn: function (aKey){
var self=this;
return $core.withContext(function($ctx1) {
return $core.hasOwnProperty(aKey);
return self;
}, function($ctx1) {$ctx1.fill(self,"includesKey:",{aKey:aKey},$globals.SmalltalkImage)});
},
args: ["aKey"],
source: "includesKey: aKey\x0a\x09<return $core.hasOwnProperty(aKey)>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "isSmalltalkObject:",
protocol: 'testing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return anObject.klass != null;
return self;
}, function($ctx1) {$ctx1.fill(self,"isSmalltalkObject:",{anObject:anObject},$globals.SmalltalkImage)});
},
args: ["anObject"],
source: "isSmalltalkObject: anObject\x0a\x09\x22Consider anObject a Smalltalk object if it has a 'klass' property.\x0a\x09Note that this may be unaccurate\x22\x0a\x09\x0a\x09<return anObject.klass != null>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "optOut:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
anObject.klass = null;
return self;
}, function($ctx1) {$ctx1.fill(self,"optOut:",{anObject:anObject},$globals.SmalltalkImage)});
},
args: ["anObject"],
source: "optOut: anObject\x0a\x09\x22A Smalltalk object has a 'klass' property.\x0a\x09This shadows the property for anObject.\x0a\x09The object is treated as plain JS object following this.\x22\x0a\x09\x0a\x09<anObject.klass = null>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "packageAt:",
protocol: 'packages',
fn: function (packageName){
var self=this;
return $core.withContext(function($ctx1) {
return $core.packages[packageName];
return self;
}, function($ctx1) {$ctx1.fill(self,"packageAt:",{packageName:packageName},$globals.SmalltalkImage)});
},
args: ["packageName"],
source: "packageAt: packageName\x0a\x09<return $core.packages[packageName]>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "packageAt:ifAbsent:",
protocol: 'packages',
fn: function (packageName,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._packageAt_(packageName);
return $recv($1)._ifNil_(aBlock);
}, function($ctx1) {$ctx1.fill(self,"packageAt:ifAbsent:",{packageName:packageName,aBlock:aBlock},$globals.SmalltalkImage)});
},
args: ["packageName", "aBlock"],
source: "packageAt: packageName ifAbsent: aBlock\x0a\x09^ (self packageAt: packageName) ifNil: aBlock",
referencedClasses: [],
messageSends: ["ifNil:", "packageAt:"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "packages",
protocol: 'packages',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		return Object.keys($core.packages).map(function(k) {
			return $core.packages[k];
		})
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"packages",{},$globals.SmalltalkImage)});
},
args: [],
source: "packages\x0a\x09\x22Return all Package instances in the system.\x22\x0a\x0a\x09<\x0a\x09\x09return Object.keys($core.packages).map(function(k) {\x0a\x09\x09\x09return $core.packages[k];\x0a\x09\x09})\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "parse:",
protocol: 'accessing',
fn: function (aString){
var self=this;
var result;
return $core.withContext(function($ctx1) {
var $1;
$recv((function(){
return $core.withContext(function($ctx2) {
result=self._basicParse_(aString);
return result;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._tryCatch_((function(ex){
return $core.withContext(function($ctx2) {
return $recv(self._parseError_parsing_(ex,aString))._signal();
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,2)});
}));
$1=result;
$recv($1)._source_(aString);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"parse:",{aString:aString,result:result},$globals.SmalltalkImage)});
},
args: ["aString"],
source: "parse: aString\x0a\x09| result |\x0a\x09\x0a\x09[ result := self basicParse: aString ] \x0a\x09\x09tryCatch: [ :ex | (self parseError: ex parsing: aString) signal ].\x0a\x09\x09\x0a\x09^ result\x0a\x09\x09source: aString;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["tryCatch:", "basicParse:", "signal", "parseError:parsing:", "source:", "yourself"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "parseError:parsing:",
protocol: 'error handling',
fn: function (anException,aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$7,$6,$5,$8,$4,$3,$2;
$1=$recv($globals.ParseError)._new();
$7=$recv(anException)._basicAt_("line");
$ctx1.sendIdx["basicAt:"]=1;
$6="Parse error on line ".__comma($7);
$5=$recv($6).__comma(" column ");
$ctx1.sendIdx[","]=4;
$8=$recv(anException)._basicAt_("column");
$ctx1.sendIdx["basicAt:"]=2;
$4=$recv($5).__comma($8);
$ctx1.sendIdx[","]=3;
$3=$recv($4).__comma(" : Unexpected character ");
$ctx1.sendIdx[","]=2;
$2=$recv($3).__comma($recv(anException)._basicAt_("found"));
$ctx1.sendIdx[","]=1;
return $recv($1)._messageText_($2);
}, function($ctx1) {$ctx1.fill(self,"parseError:parsing:",{anException:anException,aString:aString},$globals.SmalltalkImage)});
},
args: ["anException", "aString"],
source: "parseError: anException parsing: aString\x0a\x09^ ParseError new messageText: 'Parse error on line ', (anException basicAt: 'line') ,' column ' , (anException basicAt: 'column') ,' : Unexpected character ', (anException basicAt: 'found')",
referencedClasses: ["ParseError"],
messageSends: ["messageText:", "new", ",", "basicAt:"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "pseudoVariableNames",
protocol: 'accessing',
fn: function (){
var self=this;
return ["self", "super", "nil", "true", "false", "thisContext"];

},
args: [],
source: "pseudoVariableNames\x0a\x09^ #('self' 'super' 'nil' 'true' 'false' 'thisContext')",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "readJSObject:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $core.readJSObject(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"readJSObject:",{anObject:anObject},$globals.SmalltalkImage)});
},
args: ["anObject"],
source: "readJSObject: anObject\x0a\x09<return $core.readJSObject(anObject)>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "removeClass:",
protocol: 'classes',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3;
$1=$recv(aClass)._isMetaclass();
if($core.assert($1)){
self._error_($recv($recv(aClass)._asString()).__comma(" is a Metaclass and cannot be removed!"));
};
self._deleteClass_(aClass);
$2=$recv($globals.SystemAnnouncer)._current();
$4=$recv($globals.ClassRemoved)._new();
$recv($4)._theClass_(aClass);
$3=$recv($4)._yourself();
$recv($2)._announce_($3);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeClass:",{aClass:aClass},$globals.SmalltalkImage)});
},
args: ["aClass"],
source: "removeClass: aClass\x0a\x09aClass isMetaclass ifTrue: [ self error: aClass asString, ' is a Metaclass and cannot be removed!' ].\x0a\x09\x0a\x09self deleteClass: aClass.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassRemoved new\x0a\x09\x09\x09theClass: aClass;\x0a\x09\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ClassRemoved"],
messageSends: ["ifTrue:", "isMetaclass", "error:", ",", "asString", "deleteClass:", "announce:", "current", "theClass:", "new", "yourself"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "removePackage:",
protocol: 'packages',
fn: function (packageName){
var self=this;
var pkg;
return $core.withContext(function($ctx1) {
pkg=self._packageAt_ifAbsent_(packageName,(function(){
return $core.withContext(function($ctx2) {
return self._error_("Missing package: ".__comma(packageName));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv($recv(pkg)._classes())._do_((function(each){
return $core.withContext(function($ctx2) {
return self._removeClass_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
self._deletePackage_(packageName);
return self;
}, function($ctx1) {$ctx1.fill(self,"removePackage:",{packageName:packageName,pkg:pkg},$globals.SmalltalkImage)});
},
args: ["packageName"],
source: "removePackage: packageName\x0a\x09\x22Removes a package and all its classes.\x22\x0a\x0a\x09| pkg |\x0a\x09pkg := self packageAt: packageName ifAbsent: [ self error: 'Missing package: ', packageName ].\x0a\x09pkg classes do: [ :each |\x0a\x09\x09\x09self removeClass: each ].\x0a\x09self deletePackage: packageName",
referencedClasses: [],
messageSends: ["packageAt:ifAbsent:", "error:", ",", "do:", "classes", "removeClass:", "deletePackage:"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "renamePackage:to:",
protocol: 'packages',
fn: function (packageName,newName){
var self=this;
var pkg;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
pkg=self._packageAt_ifAbsent_(packageName,(function(){
return $core.withContext(function($ctx2) {
$1="Missing package: ".__comma(packageName);
$ctx2.sendIdx[","]=1;
return self._error_($1);
$ctx2.sendIdx["error:"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$2=self._packageAt_(newName);
if(($receiver = $2) == null || $receiver.isNil){
$2;
} else {
self._error_("Already exists a package called: ".__comma(newName));
};
$recv(pkg)._name_(newName);
self._basicRegisterPackage_(pkg);
self._deletePackage_(packageName);
return self;
}, function($ctx1) {$ctx1.fill(self,"renamePackage:to:",{packageName:packageName,newName:newName,pkg:pkg},$globals.SmalltalkImage)});
},
args: ["packageName", "newName"],
source: "renamePackage: packageName to: newName\x0a\x09\x22Rename a package.\x22\x0a\x0a\x09| pkg |\x0a\x09pkg := self packageAt: packageName ifAbsent: [ self error: 'Missing package: ', packageName ].\x0a\x09(self packageAt: newName) ifNotNil: [ self error: 'Already exists a package called: ', newName ].\x0a\x09pkg name: newName.\x0a\x09self basicRegisterPackage: pkg.\x0a\x09self deletePackage: packageName.",
referencedClasses: [],
messageSends: ["packageAt:ifAbsent:", "error:", ",", "ifNotNil:", "packageAt:", "name:", "basicRegisterPackage:", "deletePackage:"]
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "reservedWords",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $core.reservedWords;
return self;
}, function($ctx1) {$ctx1.fill(self,"reservedWords",{},$globals.SmalltalkImage)});
},
args: [],
source: "reservedWords\x0a\x09\x22JavaScript reserved words\x22\x0a\x09<return $core.reservedWords>",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "settings",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.SmalltalkSettings;

},
args: [],
source: "settings\x0a\x09^ SmalltalkSettings",
referencedClasses: ["SmalltalkSettings"],
messageSends: []
}),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "version",
protocol: 'accessing',
fn: function (){
var self=this;
return "0.15.0-pre";

},
args: [],
source: "version\x0a\x09\x22Answer the version string of Amber\x22\x0a\x09\x0a\x09^ '0.15.0-pre'",
referencedClasses: [],
messageSends: []
}),
$globals.SmalltalkImage);


$globals.SmalltalkImage.klass.iVarNames = ['current'];
$core.addMethod(
$core.method({
selector: "current",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@current"];
if(($receiver = $1) == null || $receiver.isNil){
self["@current"]=(
$ctx1.supercall = true,
($globals.SmalltalkImage.klass.superclass||$boot.dnu).fn.prototype._new.apply($recv(self), []));
$ctx1.supercall = false;
return self["@current"];
} else {
self._deprecatedAPI();
return self["@current"];
};
}, function($ctx1) {$ctx1.fill(self,"current",{},$globals.SmalltalkImage.klass)});
},
args: [],
source: "current\x0a\x09^ current ifNil: [ current := super new ] ifNotNil: [ self deprecatedAPI. current ]",
referencedClasses: [],
messageSends: ["ifNil:ifNotNil:", "new", "deprecatedAPI"]
}),
$globals.SmalltalkImage.klass);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
var st;
return $core.withContext(function($ctx1) {
st=self._current();
$recv($recv(st)._globals())._at_put_("Smalltalk",st);
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{st:st},$globals.SmalltalkImage.klass)});
},
args: [],
source: "initialize\x0a\x09| st |\x0a\x09st := self current.\x0a\x09st globals at: 'Smalltalk' put: st",
referencedClasses: [],
messageSends: ["current", "at:put:", "globals"]
}),
$globals.SmalltalkImage.klass);

$core.addMethod(
$core.method({
selector: "new",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._shouldNotImplement();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{},$globals.SmalltalkImage.klass)});
},
args: [],
source: "new\x0a\x09self shouldNotImplement",
referencedClasses: [],
messageSends: ["shouldNotImplement"]
}),
$globals.SmalltalkImage.klass);

$core.addMethod(
$core.method({
selector: "importsString",
protocol: '*Kernel-Infrastructure',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
$3=$recv(self._key())._importsString();
$ctx1.sendIdx["importsString"]=1;
$2=$recv($3).__comma(" -> ");
$1=$recv($2).__comma($recv(self._value())._importsString());
$ctx1.sendIdx[","]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"importsString",{},$globals.Association)});
},
args: [],
source: "importsString\x0a\x09\x22This is for use by package exporter.\x0a\x09It can fail for non-string keys and values.\x22\x0a\x0a\x09^ self key importsString, ' -> ', self value importsString",
referencedClasses: [],
messageSends: [",", "importsString", "key", "value"]
}),
$globals.Association);

$core.addMethod(
$core.method({
selector: "asJavaScriptPropertyName",
protocol: '*Kernel-Infrastructure',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $core.st2prop(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptPropertyName",{},$globals.String)});
},
args: [],
source: "asJavaScriptPropertyName\x0a<return $core.st2prop(self)>",
referencedClasses: [],
messageSends: []
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asSetting",
protocol: '*Kernel-Infrastructure',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Setting)._at_ifAbsent_(self,nil);
}, function($ctx1) {$ctx1.fill(self,"asSetting",{},$globals.String)});
},
args: [],
source: "asSetting\x0a\x09\x22Answer aSetting dedicated to locally store a value using this string as key.\x0a\x09Nil will be the default value.\x22\x0a\x09^ Setting at: self ifAbsent: nil",
referencedClasses: ["Setting"],
messageSends: ["at:ifAbsent:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "asSettingIfAbsent:",
protocol: '*Kernel-Infrastructure',
fn: function (aDefaultValue){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Setting)._at_ifAbsent_(self,aDefaultValue);
}, function($ctx1) {$ctx1.fill(self,"asSettingIfAbsent:",{aDefaultValue:aDefaultValue},$globals.String)});
},
args: ["aDefaultValue"],
source: "asSettingIfAbsent: aDefaultValue\x0a\x09\x22Answer aSetting dedicated to locally store a value using this string as key.\x0a\x09Make this setting to have aDefaultValue.\x22\x0a\x09^ Setting at: self ifAbsent: aDefaultValue",
referencedClasses: ["Setting"],
messageSends: ["at:ifAbsent:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "importsString",
protocol: '*Kernel-Infrastructure',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv("'".__comma(self._replace_with_("'","''"))).__comma("'");
$ctx1.sendIdx[","]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"importsString",{},$globals.String)});
},
args: [],
source: "importsString\x0a\x09\x22Answer receiver as Smalltalk expression\x22\x0a\x09^ '''', (self replace: '''' with: ''''''), ''''",
referencedClasses: [],
messageSends: [",", "replace:with:"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "settingValue",
protocol: '*Kernel-Infrastructure',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._asSetting())._value();
}, function($ctx1) {$ctx1.fill(self,"settingValue",{},$globals.String)});
},
args: [],
source: "settingValue\x0a\x09^ self asSetting value",
referencedClasses: [],
messageSends: ["value", "asSetting"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "settingValue:",
protocol: '*Kernel-Infrastructure',
fn: function (aValue){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._asSetting())._value_(aValue);
}, function($ctx1) {$ctx1.fill(self,"settingValue:",{aValue:aValue},$globals.String)});
},
args: ["aValue"],
source: "settingValue: aValue\x0a\x09\x22Sets the value of the setting that will be locally stored using this string as key.\x0a\x09Note that aValue can be any object that can be stringifyed\x22\x0a\x09^ self asSetting value: aValue",
referencedClasses: [],
messageSends: ["value:", "asSetting"]
}),
$globals.String);

$core.addMethod(
$core.method({
selector: "settingValueIfAbsent:",
protocol: '*Kernel-Infrastructure',
fn: function (aDefaultValue){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._asSettingIfAbsent_(aDefaultValue))._value();
}, function($ctx1) {$ctx1.fill(self,"settingValueIfAbsent:",{aDefaultValue:aDefaultValue},$globals.String)});
},
args: ["aDefaultValue"],
source: "settingValueIfAbsent: aDefaultValue\x0a\x09\x22Answer the value of the locally stored setting using this string as key.\x0a\x09Use aDefaultValue in case no setting is found\x22\x0a\x09^ (self asSettingIfAbsent: aDefaultValue) value",
referencedClasses: [],
messageSends: ["value", "asSettingIfAbsent:"]
}),
$globals.String);

});

define("amber_core/Kernel-Announcements", ["amber/boot", "amber_core/Kernel-Objects"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Kernel-Announcements');
$core.packages["Kernel-Announcements"].innerEval = function (expr) { return eval(expr); };
$core.packages["Kernel-Announcements"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('AnnouncementSubscription', $globals.Object, ['valuable', 'announcementClass'], 'Kernel-Announcements');
$globals.AnnouncementSubscription.comment="I am a single entry in a subscription registry of an `Announcer`.\x0aSeveral subscriptions by the same object is possible.";
$core.addMethod(
$core.method({
selector: "announcementClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@announcementClass"];

},
args: [],
source: "announcementClass\x0a\x09^ announcementClass",
referencedClasses: [],
messageSends: []
}),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "announcementClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@announcementClass"]=aClass;
return self;

},
args: ["aClass"],
source: "announcementClass: aClass\x0a\x09announcementClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "deliver:",
protocol: 'announcing',
fn: function (anAnnouncement){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._handlesAnnouncement_(anAnnouncement);
if($core.assert($1)){
$recv(self._valuable())._value_(anAnnouncement);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"deliver:",{anAnnouncement:anAnnouncement},$globals.AnnouncementSubscription)});
},
args: ["anAnnouncement"],
source: "deliver: anAnnouncement\x0a\x09(self handlesAnnouncement: anAnnouncement)\x0a\x09\x09ifTrue: [ self valuable value: anAnnouncement ]",
referencedClasses: [],
messageSends: ["ifTrue:", "handlesAnnouncement:", "value:", "valuable"]
}),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "handlesAnnouncement:",
protocol: 'announcing',
fn: function (anAnnouncement){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$receiver;
$2=$recv($globals.Smalltalk)._globals();
$ctx1.sendIdx["globals"]=1;
$3=$recv(self._announcementClass())._name();
$ctx1.sendIdx["name"]=1;
$1=$recv($2)._at_($3);
$ctx1.sendIdx["at:"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return false;
} else {
var class_;
class_=$receiver;
return $recv($recv($recv($globals.Smalltalk)._globals())._at_($recv($recv($recv(anAnnouncement)._class())._theNonMetaClass())._name()))._includesBehavior_(class_);
};
}, function($ctx1) {$ctx1.fill(self,"handlesAnnouncement:",{anAnnouncement:anAnnouncement},$globals.AnnouncementSubscription)});
},
args: ["anAnnouncement"],
source: "handlesAnnouncement: anAnnouncement\x0a\x09\x22anAnnouncement might be announced from within another Amber environment\x22\x0a\x09\x0a\x09^ (Smalltalk globals at: self announcementClass name)\x0a\x09\x09ifNil: [ ^ false ]\x0a\x09\x09ifNotNil: [ :class |\x0a\x09\x09(Smalltalk globals at: anAnnouncement class theNonMetaClass name) includesBehavior: class ]",
referencedClasses: ["Smalltalk"],
messageSends: ["ifNil:ifNotNil:", "at:", "globals", "name", "announcementClass", "includesBehavior:", "theNonMetaClass", "class"]
}),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._valuable())._receiver();
}, function($ctx1) {$ctx1.fill(self,"receiver",{},$globals.AnnouncementSubscription)});
},
args: [],
source: "receiver\x0a\x09^ self valuable receiver",
referencedClasses: [],
messageSends: ["receiver", "valuable"]
}),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "valuable",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@valuable"];

},
args: [],
source: "valuable\x0a\x09^ valuable",
referencedClasses: [],
messageSends: []
}),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "valuable:",
protocol: 'accessing',
fn: function (aValuable){
var self=this;
self["@valuable"]=aValuable;
return self;

},
args: ["aValuable"],
source: "valuable: aValuable\x0a\x09valuable := aValuable",
referencedClasses: [],
messageSends: []
}),
$globals.AnnouncementSubscription);



$core.addClass('AnnouncementValuable', $globals.Object, ['valuable', 'receiver'], 'Kernel-Announcements');
$globals.AnnouncementValuable.comment="I wrap `valuable` objects (typically instances of `BlockClosure`) with a `receiver` to be able to unregister subscriptions based on a `receiver`.";
$core.addMethod(
$core.method({
selector: "receiver",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@receiver"];

},
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
messageSends: []
}),
$globals.AnnouncementValuable);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@receiver"]=anObject;
return self;

},
args: ["anObject"],
source: "receiver: anObject\x0a\x09receiver := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.AnnouncementValuable);

$core.addMethod(
$core.method({
selector: "valuable",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@valuable"];

},
args: [],
source: "valuable\x0a\x09^ valuable",
referencedClasses: [],
messageSends: []
}),
$globals.AnnouncementValuable);

$core.addMethod(
$core.method({
selector: "valuable:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@valuable"]=anObject;
return self;

},
args: ["anObject"],
source: "valuable: anObject\x0a\x09valuable := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.AnnouncementValuable);

$core.addMethod(
$core.method({
selector: "value",
protocol: 'evaluating',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._valuable())._value();
}, function($ctx1) {$ctx1.fill(self,"value",{},$globals.AnnouncementValuable)});
},
args: [],
source: "value\x0a\x09^ self valuable value",
referencedClasses: [],
messageSends: ["value", "valuable"]
}),
$globals.AnnouncementValuable);

$core.addMethod(
$core.method({
selector: "value:",
protocol: 'evaluating',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._valuable())._value_(anObject);
}, function($ctx1) {$ctx1.fill(self,"value:",{anObject:anObject},$globals.AnnouncementValuable)});
},
args: ["anObject"],
source: "value: anObject\x0a\x09^ self valuable value: anObject",
referencedClasses: [],
messageSends: ["value:", "valuable"]
}),
$globals.AnnouncementValuable);



$core.addClass('Announcer', $globals.Object, ['registry', 'subscriptions'], 'Kernel-Announcements');
$globals.Announcer.comment="I hold annoncement subscriptions (instances of `AnnouncementSubscription`) in a private registry.\x0aI announce (trigger) announces, which are then dispatched to all subscriptions.\x0a\x0aThe code is based on the announcements as [described by Vassili Bykov](http://www.cincomsmalltalk.com/userblogs/vbykov/blogView?searchCategory=Announcements%20Framework).\x0a\x0a## API\x0a\x0aUse `#announce:` to trigger an announcement.\x0a\x0aUse `#on:do:` or `#on:send:to:` to register subscriptions.\x0a\x0aWhen using `#on:send:to:`, unregistration can be done with `#unregister:`.\x0a\x0a## Usage example:\x0a\x0a    SystemAnnouncer current\x0a        on: ClassAdded\x0a        do: [ :ann | window alert: ann theClass name, ' added' ].";
$core.addMethod(
$core.method({
selector: "announce:",
protocol: 'announcing',
fn: function (anAnnouncement){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@subscriptions"])._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._deliver_(anAnnouncement);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"announce:",{anAnnouncement:anAnnouncement},$globals.Announcer)});
},
args: ["anAnnouncement"],
source: "announce: anAnnouncement\x0a\x09subscriptions do: [ :each |\x0a\x09\x09each deliver: anAnnouncement ]",
referencedClasses: [],
messageSends: ["do:", "deliver:"]
}),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Announcer.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@subscriptions"]=$recv($globals.OrderedCollection)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.Announcer)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09subscriptions := OrderedCollection new",
referencedClasses: ["OrderedCollection"],
messageSends: ["initialize", "new"]
}),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "on:do:",
protocol: 'subscribing',
fn: function (aClass,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._on_do_for_(aClass,aBlock,nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"on:do:",{aClass:aClass,aBlock:aBlock},$globals.Announcer)});
},
args: ["aClass", "aBlock"],
source: "on: aClass do: aBlock\x0a\x09self on: aClass do: aBlock for: nil",
referencedClasses: [],
messageSends: ["on:do:for:"]
}),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "on:do:for:",
protocol: 'subscribing',
fn: function (aClass,aBlock,aReceiver){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$5,$6,$4,$2;
$1=self["@subscriptions"];
$3=$recv($globals.AnnouncementSubscription)._new();
$ctx1.sendIdx["new"]=1;
$5=$recv($globals.AnnouncementValuable)._new();
$recv($5)._valuable_(aBlock);
$recv($5)._receiver_(aReceiver);
$6=$recv($5)._yourself();
$ctx1.sendIdx["yourself"]=1;
$4=$6;
$recv($3)._valuable_($4);
$ctx1.sendIdx["valuable:"]=1;
$recv($3)._announcementClass_(aClass);
$2=$recv($3)._yourself();
$recv($1)._add_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"on:do:for:",{aClass:aClass,aBlock:aBlock,aReceiver:aReceiver},$globals.Announcer)});
},
args: ["aClass", "aBlock", "aReceiver"],
source: "on: aClass do: aBlock for: aReceiver\x0a\x09subscriptions add: (AnnouncementSubscription new\x0a\x09\x09valuable: (AnnouncementValuable new\x0a\x09\x09\x09valuable: aBlock;\x0a\x09\x09\x09receiver: aReceiver;\x0a\x09\x09\x09yourself);\x0a\x09\x09announcementClass: aClass;\x0a\x09\x09yourself)",
referencedClasses: ["AnnouncementSubscription", "AnnouncementValuable"],
messageSends: ["add:", "valuable:", "new", "receiver:", "yourself", "announcementClass:"]
}),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "on:doOnce:",
protocol: 'subscribing',
fn: function (aClass,aBlock){
var self=this;
var subscription;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.AnnouncementSubscription)._new();
$recv($1)._announcementClass_(aClass);
subscription=$recv($1)._yourself();
$recv(subscription)._valuable_((function(ann){
return $core.withContext(function($ctx2) {
$recv(self["@subscriptions"])._remove_(subscription);
return $recv(aBlock)._value_(ann);
}, function($ctx2) {$ctx2.fillBlock({ann:ann},$ctx1,1)});
}));
$recv(self["@subscriptions"])._add_(subscription);
return self;
}, function($ctx1) {$ctx1.fill(self,"on:doOnce:",{aClass:aClass,aBlock:aBlock,subscription:subscription},$globals.Announcer)});
},
args: ["aClass", "aBlock"],
source: "on: aClass doOnce: aBlock\x0a\x09| subscription |\x0a\x09\x0a\x09subscription := AnnouncementSubscription new\x0a\x09\x09announcementClass: aClass;\x0a\x09\x09yourself.\x0a\x09subscription valuable: [ :ann |\x0a\x09\x09subscriptions remove: subscription.\x0a\x09\x09aBlock value: ann ].\x0a\x0a\x09subscriptions add: subscription",
referencedClasses: ["AnnouncementSubscription"],
messageSends: ["announcementClass:", "new", "yourself", "valuable:", "remove:", "value:", "add:"]
}),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "on:send:to:",
protocol: 'subscribing',
fn: function (aClass,aSelector,anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$5,$6,$4,$2;
$1=self["@subscriptions"];
$3=$recv($globals.AnnouncementSubscription)._new();
$ctx1.sendIdx["new"]=1;
$5=$recv($globals.MessageSend)._new();
$recv($5)._receiver_(anObject);
$recv($5)._selector_(aSelector);
$6=$recv($5)._yourself();
$ctx1.sendIdx["yourself"]=1;
$4=$6;
$recv($3)._valuable_($4);
$recv($3)._announcementClass_(aClass);
$2=$recv($3)._yourself();
$recv($1)._add_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"on:send:to:",{aClass:aClass,aSelector:aSelector,anObject:anObject},$globals.Announcer)});
},
args: ["aClass", "aSelector", "anObject"],
source: "on: aClass send: aSelector to: anObject\x0a\x09subscriptions add: (AnnouncementSubscription new\x0a\x09\x09valuable: (MessageSend new\x0a\x09\x09\x09receiver: anObject;\x0a\x09\x09\x09selector: aSelector;\x0a\x09\x09\x09yourself);\x0a\x09\x09announcementClass: aClass;\x0a\x09\x09yourself)",
referencedClasses: ["AnnouncementSubscription", "MessageSend"],
messageSends: ["add:", "valuable:", "new", "receiver:", "selector:", "yourself", "announcementClass:"]
}),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "unsubscribe:",
protocol: 'subscribing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self["@subscriptions"]=$recv(self["@subscriptions"])._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._receiver()).__eq(anObject);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"unsubscribe:",{anObject:anObject},$globals.Announcer)});
},
args: ["anObject"],
source: "unsubscribe: anObject\x0a\x09subscriptions := subscriptions reject: [ :each |\x0a\x09\x09each receiver = anObject ]",
referencedClasses: [],
messageSends: ["reject:", "=", "receiver"]
}),
$globals.Announcer);



$core.addClass('SystemAnnouncer', $globals.Announcer, [], 'Kernel-Announcements');
$globals.SystemAnnouncer.comment="My unique instance is the global announcer handling all Amber system-related announces.\x0a\x0a## API\x0a\x0aAccess to the unique instance is done via `#current`";

$globals.SystemAnnouncer.klass.iVarNames = ['current'];
$core.addMethod(
$core.method({
selector: "current",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@current"];
if(($receiver = $1) == null || $receiver.isNil){
self["@current"]=(
$ctx1.supercall = true,
($globals.SystemAnnouncer.klass.superclass||$boot.dnu).fn.prototype._new.apply($recv(self), []));
$ctx1.supercall = false;
return self["@current"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"current",{},$globals.SystemAnnouncer.klass)});
},
args: [],
source: "current\x0a\x09^ current ifNil: [ current := super new ]",
referencedClasses: [],
messageSends: ["ifNil:", "new"]
}),
$globals.SystemAnnouncer.klass);

$core.addMethod(
$core.method({
selector: "new",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._shouldNotImplement();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{},$globals.SystemAnnouncer.klass)});
},
args: [],
source: "new\x0a\x09self shouldNotImplement",
referencedClasses: [],
messageSends: ["shouldNotImplement"]
}),
$globals.SystemAnnouncer.klass);


$core.addClass('SystemAnnouncement', $globals.Object, [], 'Kernel-Announcements');
$globals.SystemAnnouncement.comment="I am the superclass of all system announcements";

$core.addMethod(
$core.method({
selector: "classTag",
protocol: 'accessing',
fn: function (){
var self=this;
return "announcement";

},
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'announcement'",
referencedClasses: [],
messageSends: []
}),
$globals.SystemAnnouncement.klass);


$core.addClass('ClassAnnouncement', $globals.SystemAnnouncement, ['theClass'], 'Kernel-Announcements');
$globals.ClassAnnouncement.comment="I am the abstract superclass of class-related announcements.";
$core.addMethod(
$core.method({
selector: "theClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@theClass"];

},
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
messageSends: []
}),
$globals.ClassAnnouncement);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@theClass"]=aClass;
return self;

},
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.ClassAnnouncement);



$core.addClass('ClassAdded', $globals.ClassAnnouncement, [], 'Kernel-Announcements');
$globals.ClassAdded.comment="I am emitted when a class is added to the system.\x0aSee ClassBuilder >> #addSubclassOf:... methods";


$core.addClass('ClassCommentChanged', $globals.ClassAnnouncement, [], 'Kernel-Announcements');
$globals.ClassCommentChanged.comment="I am emitted when the comment of a class changes. (Behavior >> #comment)";


$core.addClass('ClassDefinitionChanged', $globals.ClassAnnouncement, [], 'Kernel-Announcements');
$globals.ClassDefinitionChanged.comment="I am emitted when the definition of a class changes.\x0aSee ClassBuilder >> #class:instanceVariableNames:";


$core.addClass('ClassMigrated', $globals.ClassAnnouncement, ['oldClass'], 'Kernel-Announcements');
$globals.ClassMigrated.comment="I am emitted when a class is migrated.";
$core.addMethod(
$core.method({
selector: "oldClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@oldClass"];

},
args: [],
source: "oldClass\x0a\x09^ oldClass",
referencedClasses: [],
messageSends: []
}),
$globals.ClassMigrated);

$core.addMethod(
$core.method({
selector: "oldClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@oldClass"]=aClass;
return self;

},
args: ["aClass"],
source: "oldClass: aClass\x0a\x09oldClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.ClassMigrated);



$core.addClass('ClassMoved', $globals.ClassAnnouncement, ['oldPackage'], 'Kernel-Announcements');
$globals.ClassMoved.comment="I am emitted when a class is moved from one package to another.";
$core.addMethod(
$core.method({
selector: "oldPackage",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@oldPackage"];

},
args: [],
source: "oldPackage\x0a\x09^ oldPackage",
referencedClasses: [],
messageSends: []
}),
$globals.ClassMoved);

$core.addMethod(
$core.method({
selector: "oldPackage:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
self["@oldPackage"]=aPackage;
return self;

},
args: ["aPackage"],
source: "oldPackage: aPackage\x0a\x09oldPackage := aPackage",
referencedClasses: [],
messageSends: []
}),
$globals.ClassMoved);



$core.addClass('ClassRemoved', $globals.ClassAnnouncement, [], 'Kernel-Announcements');
$globals.ClassRemoved.comment="I am emitted when a class is removed.\x0aSee Smalltalk >> #removeClass:";


$core.addClass('ClassRenamed', $globals.ClassAnnouncement, [], 'Kernel-Announcements');
$globals.ClassRenamed.comment="I am emitted when a class is renamed.\x0aSee ClassBuilder >> #renameClass:to:";


$core.addClass('MethodAnnouncement', $globals.SystemAnnouncement, ['method'], 'Kernel-Announcements');
$globals.MethodAnnouncement.comment="I am the abstract superclass of method-related announcements.";
$core.addMethod(
$core.method({
selector: "method",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@method"];

},
args: [],
source: "method\x0a\x09^ method",
referencedClasses: [],
messageSends: []
}),
$globals.MethodAnnouncement);

$core.addMethod(
$core.method({
selector: "method:",
protocol: 'accessing',
fn: function (aCompiledMethod){
var self=this;
self["@method"]=aCompiledMethod;
return self;

},
args: ["aCompiledMethod"],
source: "method: aCompiledMethod\x0a\x09method := aCompiledMethod",
referencedClasses: [],
messageSends: []
}),
$globals.MethodAnnouncement);



$core.addClass('MethodAdded', $globals.MethodAnnouncement, [], 'Kernel-Announcements');
$globals.MethodAdded.comment="I am emitted when a `CompiledMethod` is added to a class.";


$core.addClass('MethodModified', $globals.MethodAnnouncement, ['oldMethod'], 'Kernel-Announcements');
$globals.MethodModified.comment="I am emitted when a `CompiledMethod` is modified (a new method is installed). I hold a reference to the old method being replaced.";
$core.addMethod(
$core.method({
selector: "oldMethod",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@oldMethod"];

},
args: [],
source: "oldMethod\x0a\x09^ oldMethod",
referencedClasses: [],
messageSends: []
}),
$globals.MethodModified);

$core.addMethod(
$core.method({
selector: "oldMethod:",
protocol: 'accessing',
fn: function (aMethod){
var self=this;
self["@oldMethod"]=aMethod;
return self;

},
args: ["aMethod"],
source: "oldMethod: aMethod\x0a\x09oldMethod := aMethod",
referencedClasses: [],
messageSends: []
}),
$globals.MethodModified);



$core.addClass('MethodMoved', $globals.MethodAnnouncement, ['oldProtocol'], 'Kernel-Announcements');
$globals.MethodMoved.comment="I am emitted when a `CompiledMethod` is moved to another protocol. I hold a refernce to the old protocol of the method.";
$core.addMethod(
$core.method({
selector: "oldProtocol",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@oldProtocol"];

},
args: [],
source: "oldProtocol\x0a\x09^ oldProtocol",
referencedClasses: [],
messageSends: []
}),
$globals.MethodMoved);

$core.addMethod(
$core.method({
selector: "oldProtocol:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@oldProtocol"]=aString;
return self;

},
args: ["aString"],
source: "oldProtocol: aString\x0a\x09oldProtocol := aString",
referencedClasses: [],
messageSends: []
}),
$globals.MethodMoved);



$core.addClass('MethodRemoved', $globals.MethodAnnouncement, [], 'Kernel-Announcements');
$globals.MethodRemoved.comment="I am emitted when a `CompiledMethod` is removed from a class.";


$core.addClass('PackageAnnouncement', $globals.SystemAnnouncement, ['package'], 'Kernel-Announcements');
$globals.PackageAnnouncement.comment="I am the abstract superclass of package-related announcements.";
$core.addMethod(
$core.method({
selector: "package",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@package"];

},
args: [],
source: "package\x0a\x09^ package",
referencedClasses: [],
messageSends: []
}),
$globals.PackageAnnouncement);

$core.addMethod(
$core.method({
selector: "package:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
self["@package"]=aPackage;
return self;

},
args: ["aPackage"],
source: "package: aPackage\x0a\x09package := aPackage",
referencedClasses: [],
messageSends: []
}),
$globals.PackageAnnouncement);



$core.addClass('PackageAdded', $globals.PackageAnnouncement, [], 'Kernel-Announcements');
$globals.PackageAdded.comment="I am emitted when a `Package` is added to the system.";


$core.addClass('PackageClean', $globals.PackageAnnouncement, [], 'Kernel-Announcements');
$globals.PackageClean.comment="I am emitted when a package is committed and becomes clean.";


$core.addClass('PackageDirty', $globals.PackageAnnouncement, [], 'Kernel-Announcements');
$globals.PackageDirty.comment="I am emitted when a package becomes dirty.";


$core.addClass('PackageRemoved', $globals.PackageAnnouncement, [], 'Kernel-Announcements');
$globals.PackageRemoved.comment="I am emitted when a `Package` is removed from the system.";


$core.addClass('ProtocolAnnouncement', $globals.SystemAnnouncement, ['theClass', 'protocol'], 'Kernel-Announcements');
$globals.ProtocolAnnouncement.comment="I am the abstract superclass of protocol-related announcements.";
$core.addMethod(
$core.method({
selector: "package",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._theClass();
if(($receiver = $1) == null || $receiver.isNil){
return $1;
} else {
var class_;
class_=$receiver;
return $recv(class_)._packageOfProtocol_(self._protocol());
};
}, function($ctx1) {$ctx1.fill(self,"package",{},$globals.ProtocolAnnouncement)});
},
args: [],
source: "package\x0a\x09\x0a\x09^ self theClass ifNotNil: [ :class | class packageOfProtocol: self protocol ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "theClass", "packageOfProtocol:", "protocol"]
}),
$globals.ProtocolAnnouncement);

$core.addMethod(
$core.method({
selector: "protocol",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@protocol"];

},
args: [],
source: "protocol\x0a\x09^ protocol",
referencedClasses: [],
messageSends: []
}),
$globals.ProtocolAnnouncement);

$core.addMethod(
$core.method({
selector: "protocol:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@protocol"]=aString;
return self;

},
args: ["aString"],
source: "protocol: aString\x0a\x09protocol := aString",
referencedClasses: [],
messageSends: []
}),
$globals.ProtocolAnnouncement);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@theClass"];

},
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
messageSends: []
}),
$globals.ProtocolAnnouncement);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@theClass"]=aClass;
return self;

},
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.ProtocolAnnouncement);



$core.addClass('ProtocolAdded', $globals.ProtocolAnnouncement, [], 'Kernel-Announcements');
$globals.ProtocolAdded.comment="I am emitted when a protocol is added to a class.";


$core.addClass('ProtocolRemoved', $globals.ProtocolAnnouncement, [], 'Kernel-Announcements');
$globals.ProtocolRemoved.comment="I am emitted when a protocol is removed from a class.";

});

define("amber_core/Platform-Services", ["amber/boot", "amber_core/Kernel-Objects", "amber_core/Kernel-Collections", "amber_core/Kernel-Methods", "amber_core/Kernel-Infrastructure"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Platform-Services');
$core.packages["Platform-Services"].innerEval = function (expr) { return eval(expr); };
$core.packages["Platform-Services"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('ConsoleErrorHandler', $globals.Object, [], 'Platform-Services');
$globals.ConsoleErrorHandler.comment="I am manage Smalltalk errors, displaying the stack in the console.";
$core.addMethod(
$core.method({
selector: "handleError:",
protocol: 'error handling',
fn: function (anError){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv(anError)._context();
$ctx1.sendIdx["context"]=1;
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
self._logErrorContext_($recv(anError)._context());
};
self._logError_(anError);
return self;
}, function($ctx1) {$ctx1.fill(self,"handleError:",{anError:anError},$globals.ConsoleErrorHandler)});
},
args: ["anError"],
source: "handleError: anError\x0a\x09anError context ifNotNil: [ self logErrorContext: anError context ].\x0a\x09self logError: anError",
referencedClasses: [],
messageSends: ["ifNotNil:", "context", "logErrorContext:", "logError:"]
}),
$globals.ConsoleErrorHandler);

$core.addMethod(
$core.method({
selector: "log:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(console)._log_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"log:",{aString:aString},$globals.ConsoleErrorHandler)});
},
args: ["aString"],
source: "log: aString\x0a\x09console log: aString",
referencedClasses: [],
messageSends: ["log:"]
}),
$globals.ConsoleErrorHandler);

$core.addMethod(
$core.method({
selector: "logContext:",
protocol: 'private',
fn: function (aContext){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv(aContext)._home();
$ctx1.sendIdx["home"]=1;
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
self._logContext_($recv(aContext)._home());
};
self._log_($recv(aContext)._asString());
return self;
}, function($ctx1) {$ctx1.fill(self,"logContext:",{aContext:aContext},$globals.ConsoleErrorHandler)});
},
args: ["aContext"],
source: "logContext: aContext\x0a\x09aContext home ifNotNil: [\x0a\x09\x09self logContext: aContext home ].\x0a\x09self log: aContext asString",
referencedClasses: [],
messageSends: ["ifNotNil:", "home", "logContext:", "log:", "asString"]
}),
$globals.ConsoleErrorHandler);

$core.addMethod(
$core.method({
selector: "logError:",
protocol: 'private',
fn: function (anError){
var self=this;
return $core.withContext(function($ctx1) {
self._log_($recv(anError)._messageText());
return self;
}, function($ctx1) {$ctx1.fill(self,"logError:",{anError:anError},$globals.ConsoleErrorHandler)});
},
args: ["anError"],
source: "logError: anError\x0a\x09self log: anError messageText",
referencedClasses: [],
messageSends: ["log:", "messageText"]
}),
$globals.ConsoleErrorHandler);

$core.addMethod(
$core.method({
selector: "logErrorContext:",
protocol: 'private',
fn: function (aContext){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
if(($receiver = aContext) == null || $receiver.isNil){
aContext;
} else {
$1=$recv(aContext)._home();
$ctx1.sendIdx["home"]=1;
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
self._logContext_($recv(aContext)._home());
};
};
return self;
}, function($ctx1) {$ctx1.fill(self,"logErrorContext:",{aContext:aContext},$globals.ConsoleErrorHandler)});
},
args: ["aContext"],
source: "logErrorContext: aContext\x0a\x09aContext ifNotNil: [\x0a\x09\x09aContext home ifNotNil: [\x0a\x09\x09\x09self logContext: aContext home ]]",
referencedClasses: [],
messageSends: ["ifNotNil:", "home", "logContext:"]
}),
$globals.ConsoleErrorHandler);


$globals.ConsoleErrorHandler.klass.iVarNames = ['current'];
$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ErrorHandler)._registerIfNone_(self._new());
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.ConsoleErrorHandler.klass)});
},
args: [],
source: "initialize\x0a\x09ErrorHandler registerIfNone: self new",
referencedClasses: ["ErrorHandler"],
messageSends: ["registerIfNone:", "new"]
}),
$globals.ConsoleErrorHandler.klass);


$core.addClass('ConsoleTranscript', $globals.Object, ['textarea'], 'Platform-Services');
$globals.ConsoleTranscript.comment="I am a specific transcript emitting to the JavaScript console.\x0a\x0aIf no other transcript is registered, I am the default.";
$core.addMethod(
$core.method({
selector: "clear",
protocol: 'printing',
fn: function (){
var self=this;
return self;

},
args: [],
source: "clear\x0a\x09\x22no op\x22",
referencedClasses: [],
messageSends: []
}),
$globals.ConsoleTranscript);

$core.addMethod(
$core.method({
selector: "cr",
protocol: 'printing',
fn: function (){
var self=this;
return self;

},
args: [],
source: "cr\x0a\x09\x22no op\x22",
referencedClasses: [],
messageSends: []
}),
$globals.ConsoleTranscript);

$core.addMethod(
$core.method({
selector: "open",
protocol: 'actions',
fn: function (){
var self=this;
return self;

},
args: [],
source: "open",
referencedClasses: [],
messageSends: []
}),
$globals.ConsoleTranscript);

$core.addMethod(
$core.method({
selector: "show:",
protocol: 'printing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
console.log(String($recv(anObject)._asString()));
return self;
}, function($ctx1) {$ctx1.fill(self,"show:",{anObject:anObject},$globals.ConsoleTranscript)});
},
args: ["anObject"],
source: "show: anObject\x0a\x22Smalltalk objects should have no trouble displaying themselves on the Transcript; Javascript objects don't know how, so must be wrapped in a JSObectProxy.\x22\x0a<console.log(String($recv(anObject)._asString()))>",
referencedClasses: [],
messageSends: []
}),
$globals.ConsoleTranscript);


$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Transcript)._registerIfNone_(self._new());
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.ConsoleTranscript.klass)});
},
args: [],
source: "initialize\x0a\x09Transcript registerIfNone: self new",
referencedClasses: ["Transcript"],
messageSends: ["registerIfNone:", "new"]
}),
$globals.ConsoleTranscript.klass);


$core.addClass('InterfacingObject', $globals.Object, [], 'Platform-Services');
$globals.InterfacingObject.comment="I am superclass of all object that interface with user or environment. `Widget` and a few other classes are subclasses of me. I delegate all of the above APIs to `PlatformInterface`.\x0a\x0a## API\x0a\x0a    self alert: 'Hey, there is a problem'.\x0a    self confirm: 'Affirmative?'.\x0a    self prompt: 'Your name:'.\x0a\x0a    self ajax: #{\x0a        'url' -> '/patch.js'. 'type' -> 'GET'. dataType->'script'\x0a    }.";
$core.addMethod(
$core.method({
selector: "ajax:",
protocol: 'actions',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._deprecatedAPI();
return $recv($globals.PlatformInterface)._ajax_(anObject);
}, function($ctx1) {$ctx1.fill(self,"ajax:",{anObject:anObject},$globals.InterfacingObject)});
},
args: ["anObject"],
source: "ajax: anObject\x0a\x09self deprecatedAPI.\x0a\x09^ PlatformInterface ajax: anObject",
referencedClasses: ["PlatformInterface"],
messageSends: ["deprecatedAPI", "ajax:"]
}),
$globals.InterfacingObject);

$core.addMethod(
$core.method({
selector: "alert:",
protocol: 'actions',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Terminal)._alert_(aString);
}, function($ctx1) {$ctx1.fill(self,"alert:",{aString:aString},$globals.InterfacingObject)});
},
args: ["aString"],
source: "alert: aString\x0a\x09^ Terminal alert: aString",
referencedClasses: ["Terminal"],
messageSends: ["alert:"]
}),
$globals.InterfacingObject);

$core.addMethod(
$core.method({
selector: "confirm:",
protocol: 'actions',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Terminal)._confirm_(aString);
}, function($ctx1) {$ctx1.fill(self,"confirm:",{aString:aString},$globals.InterfacingObject)});
},
args: ["aString"],
source: "confirm: aString\x0a\x09^ Terminal confirm: aString",
referencedClasses: ["Terminal"],
messageSends: ["confirm:"]
}),
$globals.InterfacingObject);

$core.addMethod(
$core.method({
selector: "prompt:",
protocol: 'actions',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Terminal)._prompt_(aString);
}, function($ctx1) {$ctx1.fill(self,"prompt:",{aString:aString},$globals.InterfacingObject)});
},
args: ["aString"],
source: "prompt: aString\x0a\x09^ Terminal prompt: aString",
referencedClasses: ["Terminal"],
messageSends: ["prompt:"]
}),
$globals.InterfacingObject);

$core.addMethod(
$core.method({
selector: "prompt:default:",
protocol: 'actions',
fn: function (aString,defaultString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Terminal)._prompt_default_(aString,defaultString);
}, function($ctx1) {$ctx1.fill(self,"prompt:default:",{aString:aString,defaultString:defaultString},$globals.InterfacingObject)});
},
args: ["aString", "defaultString"],
source: "prompt: aString default: defaultString\x0a\x09^ Terminal prompt: aString default: defaultString",
referencedClasses: ["Terminal"],
messageSends: ["prompt:default:"]
}),
$globals.InterfacingObject);



$core.addClass('Environment', $globals.InterfacingObject, [], 'Platform-Services');
$globals.Environment.comment="I provide an unified entry point to manipulate Amber packages, classes and methods.\x0a\x0aTypical use cases include IDEs, remote access and restricting browsing.";
$core.addMethod(
$core.method({
selector: "addInstVarNamed:to:",
protocol: 'compiling',
fn: function (aString,aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$4;
$1=self._classBuilder();
$2=$recv(aClass)._superclass();
$3=$recv(aClass)._name();
$ctx1.sendIdx["name"]=1;
$5=$recv($recv(aClass)._instanceVariableNames())._copy();
$recv($5)._add_(aString);
$4=$recv($5)._yourself();
$recv($1)._addSubclassOf_named_instanceVariableNames_package_($2,$3,$4,$recv($recv(aClass)._package())._name());
return self;
}, function($ctx1) {$ctx1.fill(self,"addInstVarNamed:to:",{aString:aString,aClass:aClass},$globals.Environment)});
},
args: ["aString", "aClass"],
source: "addInstVarNamed: aString to: aClass\x0a\x09self classBuilder\x0a\x09\x09addSubclassOf: aClass superclass \x0a\x09\x09named: aClass name \x0a\x09\x09instanceVariableNames: (aClass instanceVariableNames copy add: aString; yourself)\x0a\x09\x09package: aClass package name",
referencedClasses: [],
messageSends: ["addSubclassOf:named:instanceVariableNames:package:", "classBuilder", "superclass", "name", "add:", "copy", "instanceVariableNames", "yourself", "package"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "allSelectors",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._core())._allSelectors();
}, function($ctx1) {$ctx1.fill(self,"allSelectors",{},$globals.Environment)});
},
args: [],
source: "allSelectors\x0a\x09^ Smalltalk core allSelectors",
referencedClasses: ["Smalltalk"],
messageSends: ["allSelectors", "core"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "availableClassNames",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._classes())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._name();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"availableClassNames",{},$globals.Environment)});
},
args: [],
source: "availableClassNames\x0a\x09^ Smalltalk classes \x0a\x09\x09collect: [ :each | each name ]",
referencedClasses: ["Smalltalk"],
messageSends: ["collect:", "classes", "name"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "availablePackageNames",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._packages())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._name();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"availablePackageNames",{},$globals.Environment)});
},
args: [],
source: "availablePackageNames\x0a\x09^ Smalltalk packages \x0a\x09\x09collect: [ :each | each name ]",
referencedClasses: ["Smalltalk"],
messageSends: ["collect:", "packages", "name"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "availableProtocolsFor:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
var protocols;
return $core.withContext(function($ctx1) {
var $1,$receiver;
protocols=$recv(aClass)._protocols();
$1=$recv(aClass)._superclass();
$ctx1.sendIdx["superclass"]=1;
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
$recv(protocols)._addAll_(self._availableProtocolsFor_($recv(aClass)._superclass()));
};
return $recv($recv($recv(protocols)._asSet())._asArray())._sort();
}, function($ctx1) {$ctx1.fill(self,"availableProtocolsFor:",{aClass:aClass,protocols:protocols},$globals.Environment)});
},
args: ["aClass"],
source: "availableProtocolsFor: aClass\x0a\x09| protocols |\x0a\x09\x0a\x09protocols := aClass protocols.\x0a\x09aClass superclass ifNotNil: [ protocols addAll: (self availableProtocolsFor: aClass superclass) ].\x0a\x09^ protocols asSet asArray sort",
referencedClasses: [],
messageSends: ["protocols", "ifNotNil:", "superclass", "addAll:", "availableProtocolsFor:", "sort", "asArray", "asSet"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "classBuilder",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.ClassBuilder)._new();
}, function($ctx1) {$ctx1.fill(self,"classBuilder",{},$globals.Environment)});
},
args: [],
source: "classBuilder\x0a\x09^ ClassBuilder new",
referencedClasses: ["ClassBuilder"],
messageSends: ["new"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "classNamed:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv($recv($globals.Smalltalk)._globals())._at_($recv(aString)._asSymbol());
if(($receiver = $1) == null || $receiver.isNil){
return self._error_("Invalid class name");
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"classNamed:",{aString:aString},$globals.Environment)});
},
args: ["aString"],
source: "classNamed: aString\x0a\x09^ (Smalltalk globals at: aString asSymbol)\x0a\x09\x09ifNil: [ self error: 'Invalid class name' ]",
referencedClasses: ["Smalltalk"],
messageSends: ["ifNil:", "at:", "globals", "asSymbol", "error:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "classes",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._classes();
}, function($ctx1) {$ctx1.fill(self,"classes",{},$globals.Environment)});
},
args: [],
source: "classes\x0a\x09^ Smalltalk classes",
referencedClasses: ["Smalltalk"],
messageSends: ["classes"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "commitPackage:onSuccess:onError:",
protocol: 'actions',
fn: function (aPackage,aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aPackage)._transport())._commitOnSuccess_onError_(aBlock,anotherBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"commitPackage:onSuccess:onError:",{aPackage:aPackage,aBlock:aBlock,anotherBlock:anotherBlock},$globals.Environment)});
},
args: ["aPackage", "aBlock", "anotherBlock"],
source: "commitPackage: aPackage onSuccess: aBlock onError: anotherBlock\x0a\x09aPackage transport\x0a\x09\x09commitOnSuccess: aBlock\x0a\x09\x09onError: anotherBlock",
referencedClasses: [],
messageSends: ["commitOnSuccess:onError:", "transport"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "compileClassComment:for:",
protocol: 'compiling',
fn: function (aString,aClass){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aClass)._comment_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"compileClassComment:for:",{aString:aString,aClass:aClass},$globals.Environment)});
},
args: ["aString", "aClass"],
source: "compileClassComment: aString for: aClass\x0a\x09aClass comment: aString",
referencedClasses: [],
messageSends: ["comment:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "compileClassDefinition:",
protocol: 'compiling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return self._evaluate_for_(aString,$recv($globals.DoIt)._new());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(error){
return $core.withContext(function($ctx2) {
return self._alert_($recv(error)._messageText());
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"compileClassDefinition:",{aString:aString},$globals.Environment)});
},
args: ["aString"],
source: "compileClassDefinition: aString\x0a\x09[ self evaluate: aString for: DoIt new ]\x0a\x09\x09on: Error\x0a\x09\x09do: [ :error | self alert: error messageText ]",
referencedClasses: ["DoIt", "Error"],
messageSends: ["on:do:", "evaluate:for:", "new", "alert:", "messageText"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "compileMethod:for:protocol:",
protocol: 'compiling',
fn: function (sourceCode,class_,protocol){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(class_)._compile_protocol_(sourceCode,protocol);
}, function($ctx1) {$ctx1.fill(self,"compileMethod:for:protocol:",{sourceCode:sourceCode,class_:class_,protocol:protocol},$globals.Environment)});
},
args: ["sourceCode", "class", "protocol"],
source: "compileMethod: sourceCode for: class protocol: protocol\x0a\x09^ class\x0a\x09\x09compile: sourceCode\x0a\x09\x09protocol: protocol",
referencedClasses: [],
messageSends: ["compile:protocol:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "copyClass:to:",
protocol: 'actions',
fn: function (aClass,aClassName){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
$1=$recv($recv($globals.Smalltalk)._globals())._at_(aClassName);
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
$2=$recv("A class named ".__comma(aClassName)).__comma(" already exists");
$ctx1.sendIdx[","]=1;
self._error_($2);
};
$recv($recv($globals.ClassBuilder)._new())._copyClass_named_(aClass,aClassName);
return self;
}, function($ctx1) {$ctx1.fill(self,"copyClass:to:",{aClass:aClass,aClassName:aClassName},$globals.Environment)});
},
args: ["aClass", "aClassName"],
source: "copyClass: aClass to: aClassName\x0a\x09(Smalltalk globals at: aClassName)\x0a\x09\x09ifNotNil: [ self error: 'A class named ', aClassName, ' already exists' ].\x0a\x09\x09\x0a\x09ClassBuilder new copyClass: aClass named: aClassName",
referencedClasses: ["Smalltalk", "ClassBuilder"],
messageSends: ["ifNotNil:", "at:", "globals", "error:", ",", "copyClass:named:", "new"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "doItReceiver",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.DoIt)._new();
}, function($ctx1) {$ctx1.fill(self,"doItReceiver",{},$globals.Environment)});
},
args: [],
source: "doItReceiver\x0a\x09^ DoIt new",
referencedClasses: ["DoIt"],
messageSends: ["new"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "evaluate:for:",
protocol: 'evaluating',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Evaluator)._evaluate_for_(aString,anObject);
}, function($ctx1) {$ctx1.fill(self,"evaluate:for:",{aString:aString,anObject:anObject},$globals.Environment)});
},
args: ["aString", "anObject"],
source: "evaluate: aString for: anObject\x0a\x09^ Evaluator evaluate: aString for: anObject",
referencedClasses: ["Evaluator"],
messageSends: ["evaluate:for:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "evaluate:on:do:",
protocol: 'error handling',
fn: function (aBlock,anErrorClass,exceptionBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(aBlock)._tryCatch_((function(exception){
return $core.withContext(function($ctx2) {
$1=$recv(exception)._isKindOf_(self._classNamed_($recv(anErrorClass)._name()));
if($core.assert($1)){
return $recv(exceptionBlock)._value_(exception);
} else {
return $recv(exception)._resignal();
};
}, function($ctx2) {$ctx2.fillBlock({exception:exception},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"evaluate:on:do:",{aBlock:aBlock,anErrorClass:anErrorClass,exceptionBlock:exceptionBlock},$globals.Environment)});
},
args: ["aBlock", "anErrorClass", "exceptionBlock"],
source: "evaluate: aBlock on: anErrorClass do: exceptionBlock\x0a\x09\x22Evaluate a block and catch exceptions happening on the environment stack\x22\x0a\x09\x0a\x09aBlock tryCatch: [ :exception | \x0a\x09\x09(exception isKindOf: (self classNamed: anErrorClass name))\x0a\x09\x09\x09ifTrue: [ exceptionBlock value: exception ]\x0a \x09\x09\x09ifFalse: [ exception resignal ] ]",
referencedClasses: [],
messageSends: ["tryCatch:", "ifTrue:ifFalse:", "isKindOf:", "classNamed:", "name", "value:", "resignal"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "inspect:",
protocol: 'actions',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Inspector)._inspect_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspect:",{anObject:anObject},$globals.Environment)});
},
args: ["anObject"],
source: "inspect: anObject\x0a\x09Inspector inspect: anObject",
referencedClasses: ["Inspector"],
messageSends: ["inspect:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "moveClass:toPackage:",
protocol: 'actions',
fn: function (aClass,aPackageName){
var self=this;
var package_;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
package_=$recv($globals.Package)._named_(aPackageName);
$1=package_;
if(($receiver = $1) == null || $receiver.isNil){
self._error_("Invalid package name");
} else {
$1;
};
$2=$recv(package_).__eq_eq($recv(aClass)._package());
if($core.assert($2)){
return self;
};
$recv(aClass)._package_(package_);
return self;
}, function($ctx1) {$ctx1.fill(self,"moveClass:toPackage:",{aClass:aClass,aPackageName:aPackageName,package_:package_},$globals.Environment)});
},
args: ["aClass", "aPackageName"],
source: "moveClass: aClass toPackage: aPackageName\x0a\x09| package |\x0a\x09\x0a\x09package := Package named: aPackageName.\x0a\x09package ifNil: [ self error: 'Invalid package name' ].\x0a\x09package == aClass package ifTrue: [ ^ self ].\x0a\x09\x0a\x09aClass package: package",
referencedClasses: ["Package"],
messageSends: ["named:", "ifNil:", "error:", "ifTrue:", "==", "package", "package:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "moveMethod:toClass:",
protocol: 'actions',
fn: function (aMethod,aClassName){
var self=this;
var destinationClass;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$5,$4;
destinationClass=self._classNamed_(aClassName);
$2=destinationClass;
$3=$recv(aMethod)._methodClass();
$ctx1.sendIdx["methodClass"]=1;
$1=$recv($2).__eq_eq($3);
if($core.assert($1)){
return self;
};
$5=$recv(aMethod)._methodClass();
$ctx1.sendIdx["methodClass"]=2;
$4=$recv($5)._isMetaclass();
if($core.assert($4)){
destinationClass=$recv(destinationClass)._class();
destinationClass;
};
$recv(destinationClass)._compile_protocol_($recv(aMethod)._source(),$recv(aMethod)._protocol());
$recv($recv(aMethod)._methodClass())._removeCompiledMethod_(aMethod);
return self;
}, function($ctx1) {$ctx1.fill(self,"moveMethod:toClass:",{aMethod:aMethod,aClassName:aClassName,destinationClass:destinationClass},$globals.Environment)});
},
args: ["aMethod", "aClassName"],
source: "moveMethod: aMethod toClass: aClassName\x0a\x09| destinationClass |\x0a\x09\x0a\x09destinationClass := self classNamed: aClassName.\x0a\x09destinationClass == aMethod methodClass ifTrue: [ ^ self ].\x0a\x09\x0a\x09aMethod methodClass isMetaclass ifTrue: [ \x0a\x09\x09destinationClass := destinationClass class ].\x0a\x09\x0a\x09destinationClass \x0a\x09\x09compile: aMethod source\x0a\x09\x09protocol: aMethod protocol.\x0a\x09aMethod methodClass \x0a\x09\x09removeCompiledMethod: aMethod",
referencedClasses: [],
messageSends: ["classNamed:", "ifTrue:", "==", "methodClass", "isMetaclass", "class", "compile:protocol:", "source", "protocol", "removeCompiledMethod:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "moveMethod:toProtocol:",
protocol: 'actions',
fn: function (aMethod,aProtocol){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aMethod)._protocol_(aProtocol);
return self;
}, function($ctx1) {$ctx1.fill(self,"moveMethod:toProtocol:",{aMethod:aMethod,aProtocol:aProtocol},$globals.Environment)});
},
args: ["aMethod", "aProtocol"],
source: "moveMethod: aMethod toProtocol: aProtocol\x0a\x09aMethod protocol: aProtocol",
referencedClasses: [],
messageSends: ["protocol:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "packages",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._packages();
}, function($ctx1) {$ctx1.fill(self,"packages",{},$globals.Environment)});
},
args: [],
source: "packages\x0a\x09^ Smalltalk packages",
referencedClasses: ["Smalltalk"],
messageSends: ["packages"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "registerErrorHandler:",
protocol: 'services',
fn: function (anErrorHandler){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ErrorHandler)._register_(anErrorHandler);
return self;
}, function($ctx1) {$ctx1.fill(self,"registerErrorHandler:",{anErrorHandler:anErrorHandler},$globals.Environment)});
},
args: ["anErrorHandler"],
source: "registerErrorHandler: anErrorHandler\x0a\x09ErrorHandler register: anErrorHandler",
referencedClasses: ["ErrorHandler"],
messageSends: ["register:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "registerFinder:",
protocol: 'services',
fn: function (aFinder){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Finder)._register_(aFinder);
return self;
}, function($ctx1) {$ctx1.fill(self,"registerFinder:",{aFinder:aFinder},$globals.Environment)});
},
args: ["aFinder"],
source: "registerFinder: aFinder\x0a\x09Finder register: aFinder",
referencedClasses: ["Finder"],
messageSends: ["register:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "registerInspector:",
protocol: 'services',
fn: function (anInspector){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Inspector)._register_(anInspector);
return self;
}, function($ctx1) {$ctx1.fill(self,"registerInspector:",{anInspector:anInspector},$globals.Environment)});
},
args: ["anInspector"],
source: "registerInspector: anInspector\x0a\x09Inspector register: anInspector",
referencedClasses: ["Inspector"],
messageSends: ["register:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "registerProgressHandler:",
protocol: 'services',
fn: function (aProgressHandler){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ProgressHandler)._register_(aProgressHandler);
return self;
}, function($ctx1) {$ctx1.fill(self,"registerProgressHandler:",{aProgressHandler:aProgressHandler},$globals.Environment)});
},
args: ["aProgressHandler"],
source: "registerProgressHandler: aProgressHandler\x0a\x09ProgressHandler register: aProgressHandler",
referencedClasses: ["ProgressHandler"],
messageSends: ["register:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "registerTranscript:",
protocol: 'services',
fn: function (aTranscript){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Transcript)._register_(aTranscript);
return self;
}, function($ctx1) {$ctx1.fill(self,"registerTranscript:",{aTranscript:aTranscript},$globals.Environment)});
},
args: ["aTranscript"],
source: "registerTranscript: aTranscript\x0a\x09Transcript register: aTranscript",
referencedClasses: ["Transcript"],
messageSends: ["register:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "removeClass:",
protocol: 'actions',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Smalltalk)._removeClass_(aClass);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeClass:",{aClass:aClass},$globals.Environment)});
},
args: ["aClass"],
source: "removeClass: aClass\x0a\x09Smalltalk removeClass: aClass",
referencedClasses: ["Smalltalk"],
messageSends: ["removeClass:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "removeMethod:",
protocol: 'actions',
fn: function (aMethod){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aMethod)._methodClass())._removeCompiledMethod_(aMethod);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeMethod:",{aMethod:aMethod},$globals.Environment)});
},
args: ["aMethod"],
source: "removeMethod: aMethod\x0a\x09aMethod methodClass removeCompiledMethod: aMethod",
referencedClasses: [],
messageSends: ["removeCompiledMethod:", "methodClass"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "removeProtocol:from:",
protocol: 'actions',
fn: function (aString,aClass){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aClass)._methodsInProtocol_(aString))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(aClass)._removeCompiledMethod_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"removeProtocol:from:",{aString:aString,aClass:aClass},$globals.Environment)});
},
args: ["aString", "aClass"],
source: "removeProtocol: aString from: aClass\x0a\x09(aClass methodsInProtocol: aString)\x0a\x09\x09do: [ :each | aClass removeCompiledMethod: each ]",
referencedClasses: [],
messageSends: ["do:", "methodsInProtocol:", "removeCompiledMethod:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "renameClass:to:",
protocol: 'actions',
fn: function (aClass,aClassName){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
$1=$recv($recv($globals.Smalltalk)._globals())._at_(aClassName);
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
$2=$recv("A class named ".__comma(aClassName)).__comma(" already exists");
$ctx1.sendIdx[","]=1;
self._error_($2);
};
$recv($recv($globals.ClassBuilder)._new())._renameClass_to_(aClass,aClassName);
return self;
}, function($ctx1) {$ctx1.fill(self,"renameClass:to:",{aClass:aClass,aClassName:aClassName},$globals.Environment)});
},
args: ["aClass", "aClassName"],
source: "renameClass: aClass to: aClassName\x0a\x09(Smalltalk globals at: aClassName)\x0a\x09\x09ifNotNil: [ self error: 'A class named ', aClassName, ' already exists' ].\x0a\x09\x09\x0a\x09ClassBuilder new renameClass: aClass to: aClassName",
referencedClasses: ["Smalltalk", "ClassBuilder"],
messageSends: ["ifNotNil:", "at:", "globals", "error:", ",", "renameClass:to:", "new"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "renamePackage:to:",
protocol: 'actions',
fn: function (aPackageName,aNewPackageName){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
$1=$recv($recv($globals.Smalltalk)._globals())._at_(aNewPackageName);
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
$2=$recv("A package named ".__comma(aNewPackageName)).__comma(" already exists");
$ctx1.sendIdx[","]=1;
self._error_($2);
};
$recv($globals.Smalltalk)._renamePackage_to_(aPackageName,aNewPackageName);
return self;
}, function($ctx1) {$ctx1.fill(self,"renamePackage:to:",{aPackageName:aPackageName,aNewPackageName:aNewPackageName},$globals.Environment)});
},
args: ["aPackageName", "aNewPackageName"],
source: "renamePackage: aPackageName to: aNewPackageName\x0a        (Smalltalk globals at: aNewPackageName)\x0a                ifNotNil: [ self error: 'A package named ', aNewPackageName, ' already exists' ].\x0a\x0a        Smalltalk renamePackage: aPackageName to: aNewPackageName",
referencedClasses: ["Smalltalk"],
messageSends: ["ifNotNil:", "at:", "globals", "error:", ",", "renamePackage:to:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "renameProtocol:to:in:",
protocol: 'actions',
fn: function (aString,anotherString,aClass){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aClass)._methodsInProtocol_(aString))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._protocol_(anotherString);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"renameProtocol:to:in:",{aString:aString,anotherString:anotherString,aClass:aClass},$globals.Environment)});
},
args: ["aString", "anotherString", "aClass"],
source: "renameProtocol: aString to: anotherString in: aClass\x0a\x09(aClass methodsInProtocol: aString)\x0a\x09\x09do: [ :each | each protocol: anotherString ]",
referencedClasses: [],
messageSends: ["do:", "methodsInProtocol:", "protocol:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "setClassCommentOf:to:",
protocol: 'actions',
fn: function (aClass,aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aClass)._comment_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"setClassCommentOf:to:",{aClass:aClass,aString:aString},$globals.Environment)});
},
args: ["aClass", "aString"],
source: "setClassCommentOf: aClass to: aString\x0a\x09aClass comment: aString",
referencedClasses: [],
messageSends: ["comment:"]
}),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "systemAnnouncer",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv($globals.Smalltalk)._globals())._at_("SystemAnnouncer"))._current();
}, function($ctx1) {$ctx1.fill(self,"systemAnnouncer",{},$globals.Environment)});
},
args: [],
source: "systemAnnouncer\x0a\x09^ (Smalltalk globals at: #SystemAnnouncer) current",
referencedClasses: ["Smalltalk"],
messageSends: ["current", "at:", "globals"]
}),
$globals.Environment);



$core.addClass('NullProgressHandler', $globals.Object, [], 'Platform-Services');
$globals.NullProgressHandler.comment="I am the default progress handler. I do not display any progress, and simply iterate over the collection.";
$core.addMethod(
$core.method({
selector: "do:on:displaying:",
protocol: 'progress handling',
fn: function (aBlock,aCollection,aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._do_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"do:on:displaying:",{aBlock:aBlock,aCollection:aCollection,aString:aString},$globals.NullProgressHandler)});
},
args: ["aBlock", "aCollection", "aString"],
source: "do: aBlock on: aCollection displaying: aString\x0a\x09aCollection do: aBlock",
referencedClasses: [],
messageSends: ["do:"]
}),
$globals.NullProgressHandler);


$globals.NullProgressHandler.klass.iVarNames = ['current'];
$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ProgressHandler)._registerIfNone_(self._new());
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.NullProgressHandler.klass)});
},
args: [],
source: "initialize\x0a\x09ProgressHandler registerIfNone: self new",
referencedClasses: ["ProgressHandler"],
messageSends: ["registerIfNone:", "new"]
}),
$globals.NullProgressHandler.klass);


$core.addClass('PlatformInterface', $globals.Object, [], 'Platform-Services');
$globals.PlatformInterface.comment="Deprecated. Use `Platform` or `Terminal`.";

$core.addMethod(
$core.method({
selector: "ajax:",
protocol: 'actions',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $receiver;
self._deprecatedAPI_("Use Platform newXhr or dedicated library.");
if(($receiver = $globals.JQuery) == null || $receiver.isNil){
return self._error_("JQuery wrapper not loaded, cannot do AJAX.");
} else {
return $recv($recv($globals.JQuery)._current())._ajax_(anObject);
};
}, function($ctx1) {$ctx1.fill(self,"ajax:",{anObject:anObject},$globals.PlatformInterface.klass)});
},
args: ["anObject"],
source: "ajax: anObject\x0a\x09self deprecatedAPI: 'Use Platform newXhr or dedicated library.'.\x0a\x09^ JQuery\x0a\x09\x09ifNotNil: [ JQuery current ajax: anObject ]\x0a\x09\x09ifNil: [ self error: 'JQuery wrapper not loaded, cannot do AJAX.' ]",
referencedClasses: ["JQuery"],
messageSends: ["deprecatedAPI:", "ifNotNil:ifNil:", "ajax:", "current", "error:"]
}),
$globals.PlatformInterface.klass);

$core.addMethod(
$core.method({
selector: "alert:",
protocol: 'actions',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._deprecatedAPI_("Use Terminal alert:");
return $recv($globals.Terminal)._alert_(aString);
}, function($ctx1) {$ctx1.fill(self,"alert:",{aString:aString},$globals.PlatformInterface.klass)});
},
args: ["aString"],
source: "alert: aString\x0a\x09self deprecatedAPI: 'Use Terminal alert:'.\x0a\x09^ Terminal alert: aString",
referencedClasses: ["Terminal"],
messageSends: ["deprecatedAPI:", "alert:"]
}),
$globals.PlatformInterface.klass);

$core.addMethod(
$core.method({
selector: "confirm:",
protocol: 'actions',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._deprecatedAPI_("Use Terminal confirm:");
return $recv($globals.Terminal)._confirm_(aString);
}, function($ctx1) {$ctx1.fill(self,"confirm:",{aString:aString},$globals.PlatformInterface.klass)});
},
args: ["aString"],
source: "confirm: aString\x0a\x09self deprecatedAPI: 'Use Terminal confirm:'.\x0a\x09^ Terminal confirm: aString",
referencedClasses: ["Terminal"],
messageSends: ["deprecatedAPI:", "confirm:"]
}),
$globals.PlatformInterface.klass);

$core.addMethod(
$core.method({
selector: "existsGlobal:",
protocol: 'actions',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._deprecatedAPI_("Use Smalltalk existsJsGlobal:");
return $recv($recv($globals.PlatformInterface)._globals())._at_ifPresent_ifAbsent_(aString,(function(){
return true;

}),(function(){
return false;

}));
}, function($ctx1) {$ctx1.fill(self,"existsGlobal:",{aString:aString},$globals.PlatformInterface.klass)});
},
args: ["aString"],
source: "existsGlobal: aString\x0a\x09self deprecatedAPI: 'Use Smalltalk existsJsGlobal:'.\x0a\x09^ PlatformInterface globals \x0a\x09\x09at: aString \x0a\x09\x09ifPresent: [ true ] \x0a\x09\x09ifAbsent: [ false ]",
referencedClasses: ["PlatformInterface"],
messageSends: ["deprecatedAPI:", "at:ifPresent:ifAbsent:", "globals"]
}),
$globals.PlatformInterface.klass);

$core.addMethod(
$core.method({
selector: "globals",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._deprecatedAPI_("Use Platform globals");
return $recv($globals.Platform)._globals();
}, function($ctx1) {$ctx1.fill(self,"globals",{},$globals.PlatformInterface.klass)});
},
args: [],
source: "globals\x0a\x09self deprecatedAPI: 'Use Platform globals'.\x0a\x09^ Platform globals",
referencedClasses: ["Platform"],
messageSends: ["deprecatedAPI:", "globals"]
}),
$globals.PlatformInterface.klass);

$core.addMethod(
$core.method({
selector: "newXhr",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._deprecatedAPI_("Use Platform newXhr");
return $recv($globals.Platform)._newXhr();
}, function($ctx1) {$ctx1.fill(self,"newXhr",{},$globals.PlatformInterface.klass)});
},
args: [],
source: "newXhr\x0a\x09self deprecatedAPI: 'Use Platform newXhr'.\x0a\x09^ Platform newXhr",
referencedClasses: ["Platform"],
messageSends: ["deprecatedAPI:", "newXhr"]
}),
$globals.PlatformInterface.klass);

$core.addMethod(
$core.method({
selector: "prompt:",
protocol: 'actions',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self._deprecatedAPI_("Use Terminal prompt:");
return $recv($globals.Terminal)._prompt_(aString);
}, function($ctx1) {$ctx1.fill(self,"prompt:",{aString:aString},$globals.PlatformInterface.klass)});
},
args: ["aString"],
source: "prompt: aString\x0a\x09self deprecatedAPI: 'Use Terminal prompt:'.\x0a\x09^ Terminal prompt: aString",
referencedClasses: ["Terminal"],
messageSends: ["deprecatedAPI:", "prompt:"]
}),
$globals.PlatformInterface.klass);

$core.addMethod(
$core.method({
selector: "prompt:default:",
protocol: 'actions',
fn: function (aString,defaultString){
var self=this;
return $core.withContext(function($ctx1) {
self._deprecatedAPI_("Use Terminal prompt:default:");
return $recv($globals.Terminal)._prompt_default_(aString,defaultString);
}, function($ctx1) {$ctx1.fill(self,"prompt:default:",{aString:aString,defaultString:defaultString},$globals.PlatformInterface.klass)});
},
args: ["aString", "defaultString"],
source: "prompt: aString default: defaultString\x0a\x09self deprecatedAPI: 'Use Terminal prompt:default:'.\x0a\x09^ Terminal prompt: aString default: defaultString",
referencedClasses: ["Terminal"],
messageSends: ["deprecatedAPI:", "prompt:default:"]
}),
$globals.PlatformInterface.klass);


$core.addClass('Service', $globals.Object, [], 'Platform-Services');
$globals.Service.comment="I implement the basic behavior for class registration to a service.\x0a\x0aSee the `Transcript` class for a concrete service.\x0a\x0a## API\x0a\x0aUse class-side methods `#register:` and `#registerIfNone:` to register classes to a specific service.";

$globals.Service.klass.iVarNames = ['current'];
$core.addMethod(
$core.method({
selector: "current",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@current"];

},
args: [],
source: "current\x0a\x09^ current",
referencedClasses: [],
messageSends: []
}),
$globals.Service.klass);

$core.addMethod(
$core.method({
selector: "new",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._shouldNotImplement();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{},$globals.Service.klass)});
},
args: [],
source: "new\x0a\x09self shouldNotImplement",
referencedClasses: [],
messageSends: ["shouldNotImplement"]
}),
$globals.Service.klass);

$core.addMethod(
$core.method({
selector: "register:",
protocol: 'registration',
fn: function (anObject){
var self=this;
self["@current"]=anObject;
return self;

},
args: ["anObject"],
source: "register: anObject\x0a\x09current := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.Service.klass);

$core.addMethod(
$core.method({
selector: "registerIfNone:",
protocol: 'registration',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._current();
if(($receiver = $1) == null || $receiver.isNil){
self._register_(anObject);
} else {
$1;
};
return self;
}, function($ctx1) {$ctx1.fill(self,"registerIfNone:",{anObject:anObject},$globals.Service.klass)});
},
args: ["anObject"],
source: "registerIfNone: anObject\x0a\x09self current ifNil: [ self register: anObject ]",
referencedClasses: [],
messageSends: ["ifNil:", "current", "register:"]
}),
$globals.Service.klass);


$core.addClass('ErrorHandler', $globals.Service, [], 'Platform-Services');
$globals.ErrorHandler.comment="I am the service used to handle Smalltalk errors.\x0aSee `boot.js` `handleError()` function.\x0a\x0aRegistered service instances must implement `#handleError:` to perform an action on the thrown exception.";

$core.addMethod(
$core.method({
selector: "handleError:",
protocol: 'error handling',
fn: function (anError){
var self=this;
return $core.withContext(function($ctx1) {
self._handleUnhandledError_(anError);
return self;
}, function($ctx1) {$ctx1.fill(self,"handleError:",{anError:anError},$globals.ErrorHandler.klass)});
},
args: ["anError"],
source: "handleError: anError\x0a\x09self handleUnhandledError: anError",
referencedClasses: [],
messageSends: ["handleUnhandledError:"]
}),
$globals.ErrorHandler.klass);

$core.addMethod(
$core.method({
selector: "handleUnhandledError:",
protocol: 'error handling',
fn: function (anError){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(anError)._wasHandled();
if($core.assert($1)){
return self;
};
return $recv(self._current())._handleError_(anError);
}, function($ctx1) {$ctx1.fill(self,"handleUnhandledError:",{anError:anError},$globals.ErrorHandler.klass)});
},
args: ["anError"],
source: "handleUnhandledError: anError\x0a\x09anError wasHandled ifTrue: [ ^ self ].\x0a\x09\x0a\x09^ self current handleError: anError",
referencedClasses: [],
messageSends: ["ifTrue:", "wasHandled", "handleError:", "current"]
}),
$globals.ErrorHandler.klass);


$core.addClass('Finder', $globals.Service, [], 'Platform-Services');
$globals.Finder.comment="I am the service responsible for finding classes/methods.\x0a__There is no default finder.__\x0a\x0a## API\x0a\x0aUse `#browse` on an object to find it.";

$core.addMethod(
$core.method({
selector: "findClass:",
protocol: 'finding',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._current())._findClass_(aClass);
}, function($ctx1) {$ctx1.fill(self,"findClass:",{aClass:aClass},$globals.Finder.klass)});
},
args: ["aClass"],
source: "findClass: aClass\x0a\x09^ self current findClass: aClass",
referencedClasses: [],
messageSends: ["findClass:", "current"]
}),
$globals.Finder.klass);

$core.addMethod(
$core.method({
selector: "findMethod:",
protocol: 'finding',
fn: function (aCompiledMethod){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._current())._findMethod_(aCompiledMethod);
}, function($ctx1) {$ctx1.fill(self,"findMethod:",{aCompiledMethod:aCompiledMethod},$globals.Finder.klass)});
},
args: ["aCompiledMethod"],
source: "findMethod: aCompiledMethod\x0a\x09^ self current findMethod: aCompiledMethod",
referencedClasses: [],
messageSends: ["findMethod:", "current"]
}),
$globals.Finder.klass);

$core.addMethod(
$core.method({
selector: "findString:",
protocol: 'finding',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._current())._findString_(aString);
}, function($ctx1) {$ctx1.fill(self,"findString:",{aString:aString},$globals.Finder.klass)});
},
args: ["aString"],
source: "findString: aString\x0a\x09^ self current findString: aString",
referencedClasses: [],
messageSends: ["findString:", "current"]
}),
$globals.Finder.klass);


$core.addClass('Inspector', $globals.Service, [], 'Platform-Services');
$globals.Inspector.comment="I am the service responsible for inspecting objects.\x0a\x0aThe default inspector object is the transcript.";

$core.addMethod(
$core.method({
selector: "inspect:",
protocol: 'inspecting',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._current())._inspect_(anObject);
}, function($ctx1) {$ctx1.fill(self,"inspect:",{anObject:anObject},$globals.Inspector.klass)});
},
args: ["anObject"],
source: "inspect: anObject\x0a\x09^ self current inspect: anObject",
referencedClasses: [],
messageSends: ["inspect:", "current"]
}),
$globals.Inspector.klass);


$core.addClass('Platform', $globals.Service, [], 'Platform-Services');
$globals.Platform.comment="I am bridge to JS environment.\x0a\x0a## API\x0a\x0a    Platform globals. \x22JS global object\x22\x0a    Platform newXHR \x22new XMLHttpRequest() or its shim\x22";

$core.addMethod(
$core.method({
selector: "globals",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._current())._globals();
}, function($ctx1) {$ctx1.fill(self,"globals",{},$globals.Platform.klass)});
},
args: [],
source: "globals\x0a\x09^ self current globals",
referencedClasses: [],
messageSends: ["globals", "current"]
}),
$globals.Platform.klass);

$core.addMethod(
$core.method({
selector: "newXhr",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._current())._newXhr();
}, function($ctx1) {$ctx1.fill(self,"newXhr",{},$globals.Platform.klass)});
},
args: [],
source: "newXhr\x0a\x09^ self current newXhr",
referencedClasses: [],
messageSends: ["newXhr", "current"]
}),
$globals.Platform.klass);


$core.addClass('ProgressHandler', $globals.Service, [], 'Platform-Services');
$globals.ProgressHandler.comment="I am used to manage progress in collection iterations, see `SequenceableCollection >> #do:displayingProgress:`.\x0a\x0aRegistered instances must implement `#do:on:displaying:`.\x0a\x0aThe default behavior is to simply iterate over the collection, using `NullProgressHandler`.";

$core.addMethod(
$core.method({
selector: "do:on:displaying:",
protocol: 'progress handling',
fn: function (aBlock,aCollection,aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._current())._do_on_displaying_(aBlock,aCollection,aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"do:on:displaying:",{aBlock:aBlock,aCollection:aCollection,aString:aString},$globals.ProgressHandler.klass)});
},
args: ["aBlock", "aCollection", "aString"],
source: "do: aBlock on: aCollection displaying: aString\x0a\x09self current do: aBlock on: aCollection displaying: aString",
referencedClasses: [],
messageSends: ["do:on:displaying:", "current"]
}),
$globals.ProgressHandler.klass);


$core.addClass('Terminal', $globals.Service, [], 'Platform-Services');
$globals.Terminal.comment="I am UI interface service.\x0a\x0a## API\x0a\x0a    Terminal alert: 'Hey, there is a problem'.\x0a    Terminal confirm: 'Affirmative?'.\x0a    Terminal prompt: 'Your name:'.";

$core.addMethod(
$core.method({
selector: "alert:",
protocol: 'dialogs',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._current())._alert_(aString);
}, function($ctx1) {$ctx1.fill(self,"alert:",{aString:aString},$globals.Terminal.klass)});
},
args: ["aString"],
source: "alert: aString\x0a\x09^ self current alert: aString",
referencedClasses: [],
messageSends: ["alert:", "current"]
}),
$globals.Terminal.klass);

$core.addMethod(
$core.method({
selector: "confirm:",
protocol: 'dialogs',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._current())._confirm_(aString);
}, function($ctx1) {$ctx1.fill(self,"confirm:",{aString:aString},$globals.Terminal.klass)});
},
args: ["aString"],
source: "confirm: aString\x0a\x09^ self current confirm: aString",
referencedClasses: [],
messageSends: ["confirm:", "current"]
}),
$globals.Terminal.klass);

$core.addMethod(
$core.method({
selector: "prompt:",
protocol: 'dialogs',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._current())._prompt_(aString);
}, function($ctx1) {$ctx1.fill(self,"prompt:",{aString:aString},$globals.Terminal.klass)});
},
args: ["aString"],
source: "prompt: aString\x0a\x09^ self current prompt: aString",
referencedClasses: [],
messageSends: ["prompt:", "current"]
}),
$globals.Terminal.klass);

$core.addMethod(
$core.method({
selector: "prompt:default:",
protocol: 'dialogs',
fn: function (aString,defaultString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._current())._prompt_default_(aString,defaultString);
}, function($ctx1) {$ctx1.fill(self,"prompt:default:",{aString:aString,defaultString:defaultString},$globals.Terminal.klass)});
},
args: ["aString", "defaultString"],
source: "prompt: aString default: defaultString\x0a\x09^ self current prompt: aString default: defaultString",
referencedClasses: [],
messageSends: ["prompt:default:", "current"]
}),
$globals.Terminal.klass);


$core.addClass('Transcript', $globals.Service, [], 'Platform-Services');
$globals.Transcript.comment="I am a facade for Transcript actions.\x0a\x0aI delegate actions to the currently registered transcript.\x0a\x0a## API\x0a\x0a    Transcript \x0a        show: 'hello world';\x0a        cr;\x0a        show: anObject.";

$core.addMethod(
$core.method({
selector: "clear",
protocol: 'printing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._current())._clear();
return self;
}, function($ctx1) {$ctx1.fill(self,"clear",{},$globals.Transcript.klass)});
},
args: [],
source: "clear\x0a\x09self current clear",
referencedClasses: [],
messageSends: ["clear", "current"]
}),
$globals.Transcript.klass);

$core.addMethod(
$core.method({
selector: "cr",
protocol: 'printing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._current())._show_($recv($globals.String)._cr());
return self;
}, function($ctx1) {$ctx1.fill(self,"cr",{},$globals.Transcript.klass)});
},
args: [],
source: "cr\x0a\x09self current show: String cr",
referencedClasses: ["String"],
messageSends: ["show:", "current", "cr"]
}),
$globals.Transcript.klass);

$core.addMethod(
$core.method({
selector: "inspect:",
protocol: 'printing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._show_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspect:",{anObject:anObject},$globals.Transcript.klass)});
},
args: ["anObject"],
source: "inspect: anObject\x0a\x09self show: anObject",
referencedClasses: [],
messageSends: ["show:"]
}),
$globals.Transcript.klass);

$core.addMethod(
$core.method({
selector: "open",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._current())._open();
return self;
}, function($ctx1) {$ctx1.fill(self,"open",{},$globals.Transcript.klass)});
},
args: [],
source: "open\x0a\x09self current open",
referencedClasses: [],
messageSends: ["open", "current"]
}),
$globals.Transcript.klass);

$core.addMethod(
$core.method({
selector: "show:",
protocol: 'printing',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._current())._show_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"show:",{anObject:anObject},$globals.Transcript.klass)});
},
args: ["anObject"],
source: "show: anObject\x0a\x09self current show: anObject",
referencedClasses: [],
messageSends: ["show:", "current"]
}),
$globals.Transcript.klass);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: '*Platform-Services',
fn: function (anInspector){
var self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Dictionary)._new();
$recv(variables)._at_put_("#self",self);
$ctx1.sendIdx["at:put:"]=1;
$recv(variables)._at_put_("#keys",self._keys());
$ctx1.sendIdx["at:put:"]=2;
self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(variables)._at_put_(key,value);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
$recv(anInspector)._setLabel_(self._printString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables},$globals.AssociativeCollection)});
},
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Dictionary new.\x0a\x09variables at: '#self' put: self.\x0a\x09variables at: '#keys' put: self keys.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09variables at: key put: value ].\x0a\x09anInspector\x0a\x09\x09setLabel: self printString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Dictionary"],
messageSends: ["new", "at:put:", "keys", "keysAndValuesDo:", "setLabel:", "printString", "setVariables:"]
}),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: '*Platform-Services',
fn: function (anInspector){
var self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Dictionary)._new();
$recv(variables)._at_put_("#self",self);
$ctx1.sendIdx["at:put:"]=1;
self._withIndexDo_((function(each,i){
return $core.withContext(function($ctx2) {
return $recv(variables)._at_put_(i,each);
}, function($ctx2) {$ctx2.fillBlock({each:each,i:i},$ctx1,1)});
}));
$recv(anInspector)._setLabel_(self._printString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables},$globals.Collection)});
},
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Dictionary new.\x0a\x09variables at: '#self' put: self.\x0a\x09self withIndexDo: [ :each :i |\x0a\x09\x09variables at: i put: each ].\x0a\x09anInspector\x0a\x09\x09setLabel: self printString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Dictionary"],
messageSends: ["new", "at:put:", "withIndexDo:", "setLabel:", "printString", "setVariables:"]
}),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: '*Platform-Services',
fn: function (anInspector){
var self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Dictionary)._new();
$recv(variables)._at_put_("#self",self);
$ctx1.sendIdx["at:put:"]=1;
$recv(variables)._at_put_("#year",self._year());
$ctx1.sendIdx["at:put:"]=2;
$recv(variables)._at_put_("#month",self._month());
$ctx1.sendIdx["at:put:"]=3;
$recv(variables)._at_put_("#day",self._day());
$ctx1.sendIdx["at:put:"]=4;
$recv(variables)._at_put_("#hours",self._hours());
$ctx1.sendIdx["at:put:"]=5;
$recv(variables)._at_put_("#minutes",self._minutes());
$ctx1.sendIdx["at:put:"]=6;
$recv(variables)._at_put_("#seconds",self._seconds());
$ctx1.sendIdx["at:put:"]=7;
$recv(variables)._at_put_("#milliseconds",self._milliseconds());
$recv(anInspector)._setLabel_(self._printString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables},$globals.Date)});
},
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Dictionary new.\x0a\x09variables at: '#self' put: self.\x0a\x09variables at: '#year' put: self year.\x0a\x09variables at: '#month' put: self month.\x0a\x09variables at: '#day' put: self day.\x0a\x09variables at: '#hours' put: self hours.\x0a\x09variables at: '#minutes' put: self minutes.\x0a\x09variables at: '#seconds' put: self seconds.\x0a\x09variables at: '#milliseconds' put: self milliseconds.\x0a\x09anInspector\x0a\x09\x09setLabel: self printString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Dictionary"],
messageSends: ["new", "at:put:", "year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "setLabel:", "printString", "setVariables:"]
}),
$globals.Date);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: '*Platform-Services',
fn: function (anInspector){
var self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Dictionary)._new();
$recv(variables)._at_put_("#self",self._jsObject());
$recv(anInspector)._setLabel_(self._printString());
$recv($globals.JSObjectProxy)._addObjectVariablesTo_ofProxy_(variables,self);
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables},$globals.JSObjectProxy)});
},
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Dictionary new.\x0a\x09variables at: '#self' put: self jsObject.\x0a\x09anInspector setLabel: self printString.\x0a\x09JSObjectProxy addObjectVariablesTo: variables ofProxy: self.\x0a\x09anInspector setVariables: variables",
referencedClasses: ["Dictionary", "JSObjectProxy"],
messageSends: ["new", "at:put:", "jsObject", "setLabel:", "printString", "addObjectVariablesTo:ofProxy:", "setVariables:"]
}),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: '*Platform-Services',
fn: function (anInspector){
var self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Dictionary)._new();
$recv(variables)._at_put_("#self",self);
$ctx1.sendIdx["at:put:"]=1;
$recv(variables)._at_put_("#home",self._home());
$ctx1.sendIdx["at:put:"]=2;
$recv(variables)._at_put_("#receiver",self._receiver());
$ctx1.sendIdx["at:put:"]=3;
$recv(variables)._at_put_("#selector",self._selector());
$ctx1.sendIdx["at:put:"]=4;
$recv(variables)._at_put_("#locals",self._locals());
$ctx1.sendIdx["at:put:"]=5;
$recv($recv(self._class())._instanceVariableNames())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(variables)._at_put_(each,self._instVarAt_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$recv(anInspector)._setLabel_(self._printString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables},$globals.MethodContext)});
},
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Dictionary new.\x0a\x09variables at: '#self' put: self.\x0a\x09variables at: '#home' put: self home.\x0a\x09variables at: '#receiver' put: self receiver.\x0a\x09variables at: '#selector' put: self selector.\x0a\x09variables at: '#locals' put: self locals.\x0a\x09self class instanceVariableNames do: [ :each |\x0a\x09\x09variables at: each put: (self instVarAt: each) ].\x0a\x09anInspector\x0a\x09\x09setLabel: self printString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Dictionary"],
messageSends: ["new", "at:put:", "home", "receiver", "selector", "locals", "do:", "instanceVariableNames", "class", "instVarAt:", "setLabel:", "printString", "setVariables:"]
}),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: '*Platform-Services',
fn: function (anInspector){
var self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Dictionary)._new();
$recv(variables)._at_put_("#self",self);
$ctx1.sendIdx["at:put:"]=1;
$recv($recv(self._class())._allInstanceVariableNames())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(variables)._at_put_(each,self._instVarAt_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$recv(anInspector)._setLabel_(self._printString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables},$globals.Object)});
},
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Dictionary new.\x0a\x09variables at: '#self' put: self.\x0a\x09self class allInstanceVariableNames do: [ :each |\x0a\x09\x09variables at: each put: (self instVarAt: each) ].\x0a\x09anInspector\x0a\x09\x09setLabel: self printString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Dictionary"],
messageSends: ["new", "at:put:", "do:", "allInstanceVariableNames", "class", "instVarAt:", "setLabel:", "printString", "setVariables:"]
}),
$globals.Object);

$core.addMethod(
$core.method({
selector: "do:displayingProgress:",
protocol: '*Platform-Services',
fn: function (aBlock,aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ProgressHandler)._do_on_displaying_(aBlock,self,aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"do:displayingProgress:",{aBlock:aBlock,aString:aString},$globals.SequenceableCollection)});
},
args: ["aBlock", "aString"],
source: "do: aBlock displayingProgress: aString\x0a\x09ProgressHandler \x0a\x09\x09do: aBlock \x0a\x09\x09on: self \x0a\x09\x09displaying: aString",
referencedClasses: ["ProgressHandler"],
messageSends: ["do:on:displaying:"]
}),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: '*Platform-Services',
fn: function (anInspector){
var self=this;
var variables,i;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Dictionary)._new();
$recv(variables)._at_put_("#self",self);
$ctx1.sendIdx["at:put:"]=1;
i=(1);
self._do_((function(each){
return $core.withContext(function($ctx2) {
$recv(variables)._at_put_(i,each);
i=$recv(i).__plus((1));
return i;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$recv(anInspector)._setLabel_(self._printString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables,i:i},$globals.Set)});
},
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables i |\x0a\x09variables := Dictionary new.\x0a\x09variables at: '#self' put: self.\x0a\x09i := 1.\x0a\x09self do: [ :each |\x0a\x09\x09variables at: i put: each.\x0a\x09\x09i := i + 1 ].\x0a\x09anInspector\x0a\x09\x09setLabel: self printString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Dictionary"],
messageSends: ["new", "at:put:", "do:", "+", "setLabel:", "printString", "setVariables:"]
}),
$globals.Set);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: '*Platform-Services',
fn: function (anInspector){
var self=this;
var label;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$5,$4;
(
$ctx1.supercall = true,
($globals.String.superclass||$boot.dnu).fn.prototype._inspectOn_.apply($recv(self), [anInspector]));
$ctx1.supercall = false;
$3=self._printString();
$ctx1.sendIdx["printString"]=1;
$2=$recv($3)._size();
$1=$recv($2).__gt((30));
if($core.assert($1)){
$5=self._printString();
$ctx1.sendIdx["printString"]=2;
$4=$recv($5)._copyFrom_to_((1),(30));
label=$recv($4).__comma("...'");
label;
} else {
label=self._printString();
label;
};
$recv(anInspector)._setLabel_(label);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,label:label},$globals.String)});
},
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| label |\x0a\x09super inspectOn: anInspector.\x0a\x09self printString size > 30\x0a\x09\x09ifTrue: [ label := (self printString copyFrom: 1 to: 30), '...''' ]\x0a\x09\x09ifFalse: [ label := self printString ].\x0a\x09anInspector setLabel: label",
referencedClasses: [],
messageSends: ["inspectOn:", "ifTrue:ifFalse:", ">", "size", "printString", ",", "copyFrom:to:", "setLabel:"]
}),
$globals.String);

});

define("amber_core/Platform-Node", ["amber/boot", "amber_core/Kernel-Objects"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Platform-Node');
$core.packages["Platform-Node"].innerEval = function (expr) { return eval(expr); };
$core.packages["Platform-Node"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('NodePlatform', $globals.Object, [], 'Platform-Node');
$globals.NodePlatform.comment="I am `Platform` service implementation for node-like environment.";
$core.addMethod(
$core.method({
selector: "globals",
protocol: 'accessing',
fn: function (){
var self=this;
return global;

},
args: [],
source: "globals\x0a\x09^ global",
referencedClasses: [],
messageSends: []
}),
$globals.NodePlatform);

$core.addMethod(
$core.method({
selector: "newXhr",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $receiver;
if(($receiver = $globals.XMLHttpRequest) == null || $receiver.isNil){
self._error_("XMLHttpRequest not available.");
} else {
return $recv($globals.XMLHttpRequest)._new();
};
return self;
}, function($ctx1) {$ctx1.fill(self,"newXhr",{},$globals.NodePlatform)});
},
args: [],
source: "newXhr\x0a\x09XMLHttpRequest\x0a\x09\x09ifNotNil: [ ^ XMLHttpRequest new ]\x0a\x09\x09ifNil: [ self error: 'XMLHttpRequest not available.' ]",
referencedClasses: ["XMLHttpRequest"],
messageSends: ["ifNotNil:ifNil:", "new", "error:"]
}),
$globals.NodePlatform);


$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._isFeasible();
if($core.assert($1)){
$recv($globals.Platform)._registerIfNone_(self._new());
};
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.NodePlatform.klass)});
},
args: [],
source: "initialize\x0a\x09self isFeasible ifTrue: [ Platform registerIfNone: self new ]",
referencedClasses: ["Platform"],
messageSends: ["ifTrue:", "isFeasible", "registerIfNone:", "new"]
}),
$globals.NodePlatform.klass);

$core.addMethod(
$core.method({
selector: "isFeasible",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return typeof global !== "undefined";
return self;
}, function($ctx1) {$ctx1.fill(self,"isFeasible",{},$globals.NodePlatform.klass)});
},
args: [],
source: "isFeasible\x0a<return typeof global !== \x22undefined\x22>",
referencedClasses: [],
messageSends: []
}),
$globals.NodePlatform.klass);

});

define('amber/deploy',[
    './helpers',
    // --- packages of the core Amber begin here ---
    'amber_core/Kernel-Objects',
    'amber_core/Kernel-Classes',
    'amber_core/Kernel-Methods',
    'amber_core/Kernel-Collections',
    'amber_core/Kernel-Infrastructure',
    'amber_core/Kernel-Exceptions',
    'amber_core/Kernel-Announcements',
    'amber_core/Platform-Services',
    'amber/Platform'
    // --- packages of the core Amber end here ---
], function (amber) { return amber; });

define('amber/parser',['./boot'], function($boot) {
var $globals = $boot.globals, nil = $boot.nil;
$globals.SmalltalkParser = (function() {
  "use strict";

  /*
   * Generated by PEG.js 0.9.0.
   *
   * http://pegjs.org/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  function peg$parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},
        parser  = this,

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = /^[ \t\x0B\f\xA0\uFEFF\n\r\u2028\u2029]/,
        peg$c1 = { type: "class", value: "[ \\t\\v\\f\\u00A0\\uFEFF\\n\\r\\u2028\\u2029]", description: "[ \\t\\v\\f\\u00A0\\uFEFF\\n\\r\\u2028\\u2029]" },
        peg$c2 = "\"",
        peg$c3 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c4 = /^[^"]/,
        peg$c5 = { type: "class", value: "[^\"]", description: "[^\"]" },
        peg$c6 = ".",
        peg$c7 = { type: "literal", value: ".", description: "\".\"" },
        peg$c8 = /^[a-zA-Z]/,
        peg$c9 = { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
        peg$c10 = /^[a-zA-Z0-9]/,
        peg$c11 = { type: "class", value: "[a-zA-Z0-9]", description: "[a-zA-Z0-9]" },
        peg$c12 = function(first, others) {return first + others.join("");},
        peg$c13 = ":",
        peg$c14 = { type: "literal", value: ":", description: "\":\"" },
        peg$c15 = function(first, last) {return first + last;},
        peg$c16 = /^[a-zA-Z0-9:]/,
        peg$c17 = { type: "class", value: "[a-zA-Z0-9\\:]", description: "[a-zA-Z0-9\\:]" },
        peg$c18 = /^[A-Z]/,
        peg$c19 = { type: "class", value: "[A-Z]", description: "[A-Z]" },
        peg$c20 = "'",
        peg$c21 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c22 = "''",
        peg$c23 = { type: "literal", value: "''", description: "\"''\"" },
        peg$c24 = function() {return "'";},
        peg$c25 = /^[^']/,
        peg$c26 = { type: "class", value: "[^']", description: "[^']" },
        peg$c27 = function(val) {
                             return $globals.ValueNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._value_(val.join(""));
                         },
        peg$c28 = "$",
        peg$c29 = { type: "literal", value: "$", description: "\"$\"" },
        peg$c30 = { type: "any", description: "any character" },
        peg$c31 = function(char) {
                              return $globals.ValueNode._new()
                                     ._location_(location())
                                     ._source_(text())
                                     ._value_(char);
                          },
        peg$c32 = "#",
        peg$c33 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c34 = function(rest) {return rest;},
        peg$c35 = function(node) {return node._value();},
        peg$c36 = function(val) {
                              return $globals.ValueNode._new()
                                     ._location_(location())
                                     ._source_(text())
                                     ._value_(val);
                          },
        peg$c37 = function(n) {
                             return $globals.ValueNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._value_(n);
                         },
        peg$c38 = "e",
        peg$c39 = { type: "literal", value: "e", description: "\"e\"" },
        peg$c40 = function(n) {return parseFloat(n.join(""));},
        peg$c41 = "-",
        peg$c42 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c43 = "16r",
        peg$c44 = { type: "literal", value: "16r", description: "\"16r\"" },
        peg$c45 = /^[0-9a-fA-F]/,
        peg$c46 = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
        peg$c47 = function(neg, num) {return parseInt(((neg || '') + num.join("")), 16);},
        peg$c48 = /^[0-9]/,
        peg$c49 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c50 = function(neg, digits, dec) {return parseFloat(((neg || '') + digits.join("") + "." + dec.join("")), 10);},
        peg$c51 = function(neg, digits) {return (parseInt((neg || '') + digits.join(""), 10));},
        peg$c52 = "#(",
        peg$c53 = { type: "literal", value: "#(", description: "\"#(\"" },
        peg$c54 = ")",
        peg$c55 = { type: "literal", value: ")", description: "\")\"" },
        peg$c56 = function(rest) {
            return rest
                ._location_(location())
                ._source_(text());
        },
        peg$c57 = "(",
        peg$c58 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c59 = function(lit) {return lit._value();},
        peg$c60 = function(lits) {
                             return $globals.ValueNode._new()
                                    ._value_(lits);
                         },
        peg$c61 = "{",
        peg$c62 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c63 = "}",
        peg$c64 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c65 = function(expressions) {
                             return $globals.DynamicArrayNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._nodes_(expressions || []);
                         },
        peg$c66 = "#{",
        peg$c67 = { type: "literal", value: "#{", description: "\"#{\"" },
        peg$c68 = function(expressions) {
                                return $globals.DynamicDictionaryNode._new()
                                       ._location_(location())
                                       ._source_(text())
                                       ._nodes_(expressions || []);
                            },
        peg$c69 = "true",
        peg$c70 = { type: "literal", value: "true", description: "\"true\"" },
        peg$c71 = function() {return true;},
        peg$c72 = "false",
        peg$c73 = { type: "literal", value: "false", description: "\"false\"" },
        peg$c74 = function() {return false;},
        peg$c75 = "nil",
        peg$c76 = { type: "literal", value: "nil", description: "\"nil\"" },
        peg$c77 = function() {return nil;},
        peg$c78 = function(val) {
                               return $globals.ValueNode._new()
                                      ._location_(location())
                                      ._source_(text())
                                      ._value_(val);
                           },
        peg$c79 = function(identifier) {
                             return $globals.VariableNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._value_(identifier);
                         },
        peg$c80 = /^[\\+*\/=><,@%~|&\-]/,
        peg$c81 = { type: "class", value: "[\\\\+*/=><,@%~|&-]", description: "[\\\\+*/=><,@%~|&-]" },
        peg$c82 = function(bin) {return bin.join("");},
        peg$c83 = function(key, arg) {return {key:key, arg:arg};},
        peg$c84 = function(pairs) {
                             var selector = "";
                             var params = [];
                             for(var i = 0; i < pairs.length; i++){
                                 selector += pairs[i].key;
                                 params.push(pairs[i].arg);
                             }
                             return [selector, params];
                         },
        peg$c85 = function(selector, arg) {return [selector, [arg]];},
        peg$c86 = function(selector) {return [selector, []];},
        peg$c87 = function(expression) {return expression;},
        peg$c88 = function(first, others) { return [first].concat(others); },
        peg$c89 = ":=",
        peg$c90 = { type: "literal", value: ":=", description: "\":=\"" },
        peg$c91 = function(variable, expression) {
                             return $globals.AssignmentNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._left_(variable)
                                    ._right_(expression);
                         },
        peg$c92 = "^",
        peg$c93 = { type: "literal", value: "^", description: "\"^\"" },
        peg$c94 = function(expression) {
                             return $globals.ReturnNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._nodes_([expression]);
                         },
        peg$c95 = "|",
        peg$c96 = { type: "literal", value: "|", description: "\"|\"" },
        peg$c97 = function(variable) {return variable;},
        peg$c98 = function(vars) {return vars;},
        peg$c99 = function(param) {return param;},
        peg$c100 = function(params) {return params;},
        peg$c101 = function(ret) {return [ret];},
        peg$c102 = function(exps, ret) {
                               var expressions = exps;
                               expressions.push(ret);
                               return expressions;
                           },
        peg$c103 = function(expressions) {
                               return expressions || [];
                           },
        peg$c104 = function(js) { return js; },
        peg$c105 = function(temps, statements) {
                             return $globals.SequenceNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._temps_(temps || [])
                                    ._nodes_(statements || []);
                         },
        peg$c106 = "[",
        peg$c107 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c108 = "]",
        peg$c109 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c110 = function(params, sequence) {
                             return $globals.BlockNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._parameters_(params || [])
                                    ._nodes_([sequence._asBlockSequenceNode()]);
                         },
        peg$c111 = function(selector) {
                             return $globals.SendNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._selector_(selector);
                         },
        peg$c112 = function(message, tail) {
                             if(tail) {
                                 return tail._valueForReceiver_(message);
                             }
                             else {
                                 return message;
                             }
                         },
        peg$c113 = function(receiver, tail) {
                             if(tail) {
                                 return tail._valueForReceiver_(receiver);
                             }
                             else {
                                 return receiver;
                             }
                         },
        peg$c114 = function(selector, arg) {
                             return $globals.SendNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._selector_(selector)
                                    ._arguments_([arg]);
                         },
        peg$c115 = function(message, tail) {
                             if(tail) {
                                 return tail._valueForReceiver_(message);
                              }
                             else {
                                 return message;
                             }
                         },
        peg$c116 = function(pairs) {
                             var selector = "";
                             var args = [];
                              for(var i = 0; i < pairs.length; i++) {
                                  selector += pairs[i].key;
                                  args.push(pairs[i].arg);
                              }
                              return $globals.SendNode._new()
                                     ._location_(location())
                                     ._source_(text())
                                     ._selector_(selector)
                                     ._arguments_(args);
                         },
        peg$c117 = function(send) { return send._isSendNode(); },
        peg$c118 = ";",
        peg$c119 = { type: "literal", value: ";", description: "\";\"" },
        peg$c120 = function(send, mess) {return mess;},
        peg$c121 = function(send, messages) {
                             messages.unshift(send);
                             return $globals.CascadeNode._new()
                                    ._location_(location())
                                    ._source_(text())
                                    ._nodes_(messages);
                         },
        peg$c122 = "<",
        peg$c123 = { type: "literal", value: "<", description: "\"<\"" },
        peg$c124 = ">>",
        peg$c125 = { type: "literal", value: ">>", description: "\">>\"" },
        peg$c126 = function() {return ">";},
        peg$c127 = /^[^>]/,
        peg$c128 = { type: "class", value: "[^>]", description: "[^>]" },
        peg$c129 = ">",
        peg$c130 = { type: "literal", value: ">", description: "\">\"" },
        peg$c131 = function(val) {
                             return $globals.JSStatementNode._new()
                                    ._location_(location())
                                    ._source_(val.join(""))
                         },
        peg$c132 = function(pattern, sequence) {
                              return $globals.MethodNode._new()
                                     ._location_(location())
                                     ._source_(text())
                                     ._selector_(pattern[0])
                                     ._arguments_(pattern[1])
                                     ._nodes_([sequence]);
                         },
        peg$c133 = function(send) { return send._isSendNode() && send._selector() === "->" },
        peg$c134 = function(send) { return [send._receiver(), send._arguments()[0]]; },
        peg$c135 = function(first, others) { return first.concat.apply(first, others); },

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$resultsCache = {},

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function error(message) {
      throw peg$buildException(
        message,
        null,
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos],
          p, ch;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column,
          seenCR: details.seenCR
        };

        while (p < pos) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, found, location) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new peg$SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parsestart() {
      var s0;

      var key    = peg$currPos * 61 + 0,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsemethod();

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseseparator() {
      var s0, s1;

      var key    = peg$currPos * 61 + 1,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      if (peg$c0.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c0.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c1); }
          }
        }
      } else {
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecomments() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 2,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c2;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c4.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c5); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c4.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c5); }
          }
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s4 = peg$c2;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c3); }
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c2;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c3); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$c4.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c5); }
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c4.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c5); }
              }
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s4 = peg$c2;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c3); }
              }
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
      } else {
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsews() {
      var s0, s1;

      var key    = peg$currPos * 61 + 3,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      s1 = peg$parseseparator();
      if (s1 === peg$FAILED) {
        s1 = peg$parsecomments();
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parseseparator();
        if (s1 === peg$FAILED) {
          s1 = peg$parsecomments();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsemaybeDotsWs() {
      var s0, s1;

      var key    = peg$currPos * 61 + 4,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c6;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c7); }
      }
      if (s1 === peg$FAILED) {
        s1 = peg$parseseparator();
        if (s1 === peg$FAILED) {
          s1 = peg$parsecomments();
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$parseseparator();
          if (s1 === peg$FAILED) {
            s1 = peg$parsecomments();
          }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseidentifier() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 61 + 5,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (peg$c8.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c10.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c11); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c10.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c11); }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c12(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsekeyword() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 6,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s2 = peg$c13;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c14); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c15(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseselector() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 61 + 7,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (peg$c8.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c16.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c17); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c16.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c17); }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c12(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseclassName() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 61 + 8,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (peg$c18.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c19); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c10.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c11); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c10.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c11); }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c12(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsestring() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 9,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c20;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c21); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c22) {
          s4 = peg$c22;
          peg$currPos += 2;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c23); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c24();
        }
        s3 = s4;
        if (s3 === peg$FAILED) {
          if (peg$c25.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c26); }
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c22) {
            s4 = peg$c22;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c23); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c24();
          }
          s3 = s4;
          if (s3 === peg$FAILED) {
            if (peg$c25.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c26); }
            }
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c20;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c21); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c27(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecharacter() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 10,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 36) {
        s1 = peg$c28;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c29); }
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c30); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesymbol() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 11,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c32;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c33); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebareSymbol();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c34(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebareSymbol() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 12,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseselector();
      if (s1 === peg$FAILED) {
        s1 = peg$parsebinarySelector();
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s2 = peg$parsestring();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c35(s2);
          }
          s1 = s2;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c36(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenumber() {
      var s0, s1;

      var key    = peg$currPos * 61 + 13,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsenumberExp();
      if (s1 === peg$FAILED) {
        s1 = peg$parsehex();
        if (s1 === peg$FAILED) {
          s1 = peg$parsefloat();
          if (s1 === peg$FAILED) {
            s1 = peg$parseinteger();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c37(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenumberExp() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 14,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parsefloat();
      if (s2 === peg$FAILED) {
        s2 = peg$parseinteger();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 101) {
          s3 = peg$c38;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c39); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseinteger();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c40(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsehex() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 15,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c41;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c43) {
          s2 = peg$c43;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c44); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c46); }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c45.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c46); }
              }
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c47(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsefloat() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 61 + 16,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c41;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c48.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c49); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c48.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c49); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c6;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c7); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            if (peg$c48.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c49); }
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$c48.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c49); }
                }
              }
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c50(s1, s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseinteger() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 61 + 17,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c41;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c48.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c49); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c48.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c49); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c51(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteralArray() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 18,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c52) {
        s1 = peg$c52;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsLiteralArrayContents();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s4 = peg$c54;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c55); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c56(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebareLiteralArray() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 19,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c57;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c58); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsLiteralArrayContents();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s4 = peg$c54;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c55); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c56(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteralArrayElement() {
      var s0;

      var key    = peg$currPos * 61 + 20,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parseparseTimeLiteral();
      if (s0 === peg$FAILED) {
        s0 = peg$parsebareLiteralArray();
        if (s0 === peg$FAILED) {
          s0 = peg$parsebareSymbol();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsLiteralArrayContents() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 21,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parsews();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseliteralArrayElement();
        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c59(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$parsews();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseliteralArrayElement();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c59(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c60(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedynamicArray() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 61 + 22,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c61;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c62); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexpressions();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsemaybeDotsWs();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s5 = peg$c63;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c64); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedynamicDictionary() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 61 + 23,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c66) {
        s1 = peg$c66;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseassociations();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsemaybeDotsWs();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s5 = peg$c63;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c64); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c68(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepseudoVariable() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 24,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c69) {
        s2 = peg$c69;
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c70); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c71();
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c72) {
          s2 = peg$c72;
          peg$currPos += 5;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c73); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c74();
        }
        s1 = s2;
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c75) {
            s2 = peg$c75;
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c76); }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c77();
          }
          s1 = s2;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c78(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseparseTimeLiteral() {
      var s0;

      var key    = peg$currPos * 61 + 25,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsepseudoVariable();
      if (s0 === peg$FAILED) {
        s0 = peg$parsenumber();
        if (s0 === peg$FAILED) {
          s0 = peg$parseliteralArray();
          if (s0 === peg$FAILED) {
            s0 = peg$parsestring();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesymbol();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecharacter();
              }
            }
          }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseruntimeLiteral() {
      var s0;

      var key    = peg$currPos * 61 + 26,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsedynamicDictionary();
      if (s0 === peg$FAILED) {
        s0 = peg$parsedynamicArray();
        if (s0 === peg$FAILED) {
          s0 = peg$parseblock();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteral() {
      var s0;

      var key    = peg$currPos * 61 + 27,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parseruntimeLiteral();
      if (s0 === peg$FAILED) {
        s0 = peg$parseparseTimeLiteral();
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsevariable() {
      var s0, s1;

      var key    = peg$currPos * 61 + 28,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c79(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebinarySelector() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 29,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      if (peg$c80.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c81); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c80.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c81); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c82(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsKeywordPattern() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 61 + 30,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parsews();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekeyword();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsews();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseidentifier();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c83(s4, s6);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsekeyword();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsews();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseidentifier();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c83(s4, s6);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c84(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsBinaryPattern() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 31,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebinarySelector();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifier();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c85(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsUnaryPattern() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 32,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifier();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c86(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseexpression() {
      var s0;

      var key    = peg$currPos * 61 + 33,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parseassignment();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecascade();
        if (s0 === peg$FAILED) {
          s0 = peg$parsekeywordSend();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsExpressionsRest() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 34,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemaybeDotsWs();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseexpression();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseexpressions() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 61 + 35,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseexpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsExpressionsRest();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsExpressionsRest();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c88(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseassignment() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 61 + 36,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsevariable();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c89) {
            s3 = peg$c89;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c90); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsews();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseexpression();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c91(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseret() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 61 + 37,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 94) {
        s1 = peg$c92;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c93); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexpression();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c94(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetemps() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 61 + 38,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 124) {
        s1 = peg$c95;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c96); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parsews();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseidentifier();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c97(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parsews();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseidentifier();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c97(s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 124) {
              s4 = peg$c95;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c96); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c98(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsBlockParamList() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 61 + 39,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parsews();
      if (s3 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s4 = peg$c13;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c14); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsews();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseidentifier();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c99(s6);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c13;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c14); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsews();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseidentifier();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c99(s6);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 124) {
            s3 = peg$c95;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c96); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c100(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesubexpression() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 61 + 40,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c57;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c58); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexpression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsews();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c54;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c55); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c87(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsestatementsWs() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 61 + 41,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseret();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsemaybeDotsWs();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c101(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseexpressions();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsews();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c6;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsemaybeDotsWs();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseret();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsemaybeDotsWs();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c102(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseexpressions();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsemaybeDotsWs();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c103(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsSequenceWs() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 61 + 42,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsejsStatement();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c104(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsewsStSequenceWs();
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsStSequenceWs() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 43,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsetemps();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemaybeDotsWs();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsestatementsWs();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c105(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseblock() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 44,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c106;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c107); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsBlockParamList();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsewsSequenceWs();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s4 = peg$c108;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c109); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c110(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseoperand() {
      var s0;

      var key    = peg$currPos * 61 + 45,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parseliteral();
      if (s0 === peg$FAILED) {
        s0 = peg$parsevariable();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesubexpression();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsUnaryMessage() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 46,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifier();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c13;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c111(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsUnaryTail() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 47,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsewsUnaryMessage();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsUnaryTail();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c112(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseunarySend() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 48,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseoperand();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsUnaryTail();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c113(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsBinaryMessage() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 49,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebinarySelector();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseunarySend();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c114(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsBinaryTail() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 50,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsewsBinaryMessage();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsBinaryTail();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c115(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebinarySend() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 51,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseunarySend();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsBinaryTail();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c113(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsKeywordMessage() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 61 + 52,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parsews();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekeyword();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsews();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsebinarySend();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c83(s4, s6);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsekeyword();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsews();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsebinarySend();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c83(s4, s6);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c116(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsekeywordSend() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 53,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsebinarySend();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsKeywordMessage();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c113(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsMessage() {
      var s0;

      var key    = peg$currPos * 61 + 54,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsewsBinaryMessage();
      if (s0 === peg$FAILED) {
        s0 = peg$parsewsUnaryMessage();
        if (s0 === peg$FAILED) {
          s0 = peg$parsewsKeywordMessage();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecascade() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 61 + 55,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsekeywordSend();
      if (s1 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s2 = peg$c117(s1);
        if (s2) {
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parsews();
          if (s5 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 59) {
              s6 = peg$c118;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c119); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsewsMessage();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s4;
                s5 = peg$c120(s1, s7);
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              s5 = peg$parsews();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 59) {
                  s6 = peg$c118;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c119); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsewsMessage();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c120(s1, s7);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsejsStatement() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 56,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 60) {
        s1 = peg$c122;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c123); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c124) {
          s4 = peg$c124;
          peg$currPos += 2;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c125); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c126();
        }
        s3 = s4;
        if (s3 === peg$FAILED) {
          if (peg$c127.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c128); }
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c124) {
            s4 = peg$c124;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c125); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c126();
          }
          s3 = s4;
          if (s3 === peg$FAILED) {
            if (peg$c127.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c128); }
            }
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 62) {
            s3 = peg$c129;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c130); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c131(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsemethod() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 57,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsewsKeywordPattern();
      if (s1 === peg$FAILED) {
        s1 = peg$parsewsBinaryPattern();
        if (s1 === peg$FAILED) {
          s1 = peg$parsewsUnaryPattern();
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsSequenceWs();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c132(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseassociationSend() {
      var s0, s1, s2;

      var key    = peg$currPos * 61 + 58,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsebinarySend();
      if (s1 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s2 = peg$c133(s1);
        if (s2) {
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c134(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsAssociationsRest() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 61 + 59,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemaybeDotsWs();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseassociationSend();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseassociations() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 61 + 60,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseassociationSend();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsAssociationsRest();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsAssociationsRest();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c135(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(
        null,
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})();
});
define("amber_core/Platform-ImportExport", ["amber/boot", "amber_core/Kernel-Objects", "amber_core/Kernel-Exceptions", "amber_core/Platform-Services", "amber_core/Kernel-Infrastructure", "amber_core/Kernel-Classes"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Platform-ImportExport');
$core.packages["Platform-ImportExport"].innerEval = function (expr) { return eval(expr); };
$core.packages["Platform-ImportExport"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('AbstractExporter', $globals.Object, [], 'Platform-ImportExport');
$globals.AbstractExporter.comment="I am an abstract exporter for Amber source code.\x0a\x0a## API\x0a\x0aUse `#exportPackage:on:` to export a given package on a Stream.";
$core.addMethod(
$core.method({
selector: "classNameFor:",
protocol: 'convenience',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$4,$1;
$2=$recv(aClass)._isMetaclass();
if($core.assert($2)){
$3=$recv($recv(aClass)._instanceClass())._name();
$ctx1.sendIdx["name"]=1;
$1=$recv($3).__comma(" class");
} else {
$4=$recv(aClass)._isNil();
if($core.assert($4)){
$1="nil";
} else {
$1=$recv(aClass)._name();
};
};
return $1;
}, function($ctx1) {$ctx1.fill(self,"classNameFor:",{aClass:aClass},$globals.AbstractExporter)});
},
args: ["aClass"],
source: "classNameFor: aClass\x0a\x09^ aClass isMetaclass\x0a\x09\x09ifTrue: [ aClass instanceClass name, ' class' ]\x0a\x09\x09ifFalse: [\x0a\x09\x09\x09aClass isNil\x0a\x09\x09\x09\x09ifTrue: [ 'nil' ]\x0a\x09\x09\x09\x09ifFalse: [ aClass name ] ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "isMetaclass", ",", "name", "instanceClass", "isNil"]
}),
$globals.AbstractExporter);

$core.addMethod(
$core.method({
selector: "exportPackage:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackage:on:",{aPackage:aPackage,aStream:aStream},$globals.AbstractExporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackage: aPackage on: aStream\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.AbstractExporter);

$core.addMethod(
$core.method({
selector: "extensionMethodsOfPackage:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
var result;
return $core.withContext(function($ctx1) {
result=$recv($globals.OrderedCollection)._new();
$recv(self._extensionProtocolsOfPackage_(aPackage))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(result)._addAll_($recv(each)._methods());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return result;
}, function($ctx1) {$ctx1.fill(self,"extensionMethodsOfPackage:",{aPackage:aPackage,result:result},$globals.AbstractExporter)});
},
args: ["aPackage"],
source: "extensionMethodsOfPackage: aPackage\x0a\x09| result |\x0a\x09\x0a\x09result := OrderedCollection new.\x0a\x09\x0a\x09(self extensionProtocolsOfPackage: aPackage) do: [ :each |\x0a\x09\x09result addAll: each methods ].\x0a\x09\x09\x0a\x09^ result",
referencedClasses: ["OrderedCollection"],
messageSends: ["new", "do:", "extensionProtocolsOfPackage:", "addAll:", "methods"]
}),
$globals.AbstractExporter);

$core.addMethod(
$core.method({
selector: "extensionProtocolsOfPackage:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
var extensionName,result;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$1=$recv(aPackage)._name();
$ctx1.sendIdx["name"]=1;
extensionName="*".__comma($1);
result=$recv($globals.OrderedCollection)._new();
$recv($recv($recv($recv($globals.Smalltalk)._classes())._asArray())._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
$2=$recv(a)._name();
$ctx2.sendIdx["name"]=2;
return $recv($2).__lt($recv(b)._name());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
})))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv([each,$recv(each)._class()])._do_((function(behavior){
return $core.withContext(function($ctx3) {
$3=$recv($recv(behavior)._protocols())._includes_(extensionName);
if($core.assert($3)){
return $recv(result)._add_($recv($globals.ExportMethodProtocol)._name_theClass_(extensionName,behavior));
};
}, function($ctx3) {$ctx3.fillBlock({behavior:behavior},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
$ctx1.sendIdx["do:"]=1;
return result;
}, function($ctx1) {$ctx1.fill(self,"extensionProtocolsOfPackage:",{aPackage:aPackage,extensionName:extensionName,result:result},$globals.AbstractExporter)});
},
args: ["aPackage"],
source: "extensionProtocolsOfPackage: aPackage\x0a\x09| extensionName result |\x0a\x09\x0a\x09extensionName := '*', aPackage name.\x0a\x09result := OrderedCollection new.\x0a\x09\x0a\x09\x22The classes must be loaded since it is extensions only.\x0a\x09Therefore topological sorting (dependency resolution) does not matter here.\x0a\x09Not sorting topologically improves the speed by a number of magnitude.\x0a\x09\x0a\x09Not to shuffle diffs, classes are sorted by their name.\x22\x0a\x09\x0a\x09(Smalltalk classes asArray sorted: [ :a :b | a name < b name ]) do: [ :each |\x0a\x09\x09{each. each class} do: [ :behavior |\x0a\x09\x09\x09(behavior protocols includes: extensionName) ifTrue: [\x0a\x09\x09\x09\x09result add: (ExportMethodProtocol name: extensionName theClass: behavior) ] ] ].\x0a\x0a\x09^ result",
referencedClasses: ["OrderedCollection", "Smalltalk", "ExportMethodProtocol"],
messageSends: [",", "name", "new", "do:", "sorted:", "asArray", "classes", "<", "class", "ifTrue:", "includes:", "protocols", "add:", "name:theClass:"]
}),
$globals.AbstractExporter);



$core.addClass('ChunkExporter', $globals.AbstractExporter, [], 'Platform-ImportExport');
$globals.ChunkExporter.comment="I am an exporter dedicated to outputting Amber source code in the classic Smalltalk chunk format.\x0a\x0aI do not output any compiled code.";
$core.addMethod(
$core.method({
selector: "chunkEscape:",
protocol: 'convenience',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aString)._replace_with_("!","!!"))._trimBoth();
}, function($ctx1) {$ctx1.fill(self,"chunkEscape:",{aString:aString},$globals.ChunkExporter)});
},
args: ["aString"],
source: "chunkEscape: aString\x0a\x09\x22Replace all occurrences of ! with !! and trim at both ends.\x22\x0a\x0a\x09^ (aString replace: '!' with: '!!') trimBoth",
referencedClasses: [],
messageSends: ["trimBoth", "replace:with:"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportCategoryEpilogueOf:on:",
protocol: 'output',
fn: function (aCategory,aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_(" !");
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=1;
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportCategoryEpilogueOf:on:",{aCategory:aCategory,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aCategory", "aStream"],
source: "exportCategoryEpilogueOf: aCategory on: aStream\x0a\x09aStream nextPutAll: ' !'; lf; lf",
referencedClasses: [],
messageSends: ["nextPutAll:", "lf"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportCategoryPrologueOf:on:",
protocol: 'output',
fn: function (aCategory,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1="!".__comma(self._classNameFor_($recv(aCategory)._theClass()));
$ctx1.sendIdx[","]=1;
$recv(aStream)._nextPutAll_($1);
$ctx1.sendIdx["nextPutAll:"]=1;
$2=$recv(" methodsFor: '".__comma($recv(aCategory)._name())).__comma("'!");
$ctx1.sendIdx[","]=2;
$recv(aStream)._nextPutAll_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportCategoryPrologueOf:on:",{aCategory:aCategory,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aCategory", "aStream"],
source: "exportCategoryPrologueOf: aCategory on: aStream\x0a\x09aStream\x0a\x09\x09nextPutAll: '!', (self classNameFor: aCategory theClass);\x0a\x09\x09nextPutAll: ' methodsFor: ''', aCategory name, '''!'",
referencedClasses: [],
messageSends: ["nextPutAll:", ",", "classNameFor:", "theClass", "name"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportDefinitionOf:on:",
protocol: 'output',
fn: function (aClass,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$4,$6,$5,$7,$9,$8,$11,$10,$12;
$1=self._classNameFor_($recv(aClass)._superclass());
$ctx1.sendIdx["classNameFor:"]=1;
$recv(aStream)._nextPutAll_($1);
$ctx1.sendIdx["nextPutAll:"]=1;
$3=self._classNameFor_(aClass);
$ctx1.sendIdx["classNameFor:"]=2;
$2=" subclass: #".__comma($3);
$ctx1.sendIdx[","]=1;
$recv(aStream)._nextPutAll_($2);
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=1;
$recv(aStream)._tab();
$ctx1.sendIdx["tab"]=1;
$4=$recv(aStream)._nextPutAll_("instanceVariableNames: '");
$ctx1.sendIdx["nextPutAll:"]=3;
$recv($recv(aClass)._instanceVariableNames())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(aStream)._nextPutAll_(each);
$ctx2.sendIdx["nextPutAll:"]=4;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(aStream)._nextPutAll_(" ");
$ctx2.sendIdx["nextPutAll:"]=5;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv(aStream)._nextPutAll_("'");
$ctx1.sendIdx["nextPutAll:"]=6;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=2;
$recv(aStream)._tab();
$6="package: '".__comma($recv(aClass)._category());
$ctx1.sendIdx[","]=3;
$5=$recv($6).__comma("'!");
$ctx1.sendIdx[","]=2;
$recv(aStream)._nextPutAll_($5);
$ctx1.sendIdx["nextPutAll:"]=7;
$7=$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=3;
$9=$recv(aClass)._comment();
$ctx1.sendIdx["comment"]=1;
$8=$recv($9)._notEmpty();
if($core.assert($8)){
$11="!".__comma(self._classNameFor_(aClass));
$ctx1.sendIdx[","]=5;
$10=$recv($11).__comma(" commentStamp!");
$ctx1.sendIdx[","]=4;
$recv(aStream)._nextPutAll_($10);
$ctx1.sendIdx["nextPutAll:"]=8;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=4;
$recv(aStream)._nextPutAll_($recv(self._chunkEscape_($recv(aClass)._comment())).__comma("!"));
$12=$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=5;
$12;
};
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportDefinitionOf:on:",{aClass:aClass,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aClass", "aStream"],
source: "exportDefinitionOf: aClass on: aStream\x0a\x09\x22Chunk format.\x22\x0a\x0a\x09aStream\x0a\x09\x09nextPutAll: (self classNameFor: aClass superclass);\x0a\x09\x09nextPutAll: ' subclass: #', (self classNameFor: aClass); lf;\x0a\x09\x09tab; nextPutAll: 'instanceVariableNames: '''.\x0a\x09aClass instanceVariableNames\x0a\x09\x09do: [ :each | aStream nextPutAll: each ]\x0a\x09\x09separatedBy: [ aStream nextPutAll: ' ' ].\x0a\x09aStream\x0a\x09\x09nextPutAll: ''''; lf;\x0a\x09\x09tab; nextPutAll: 'package: ''', aClass category, '''!'; lf.\x0a\x09aClass comment notEmpty ifTrue: [\x0a\x09\x09aStream\x0a\x09\x09nextPutAll: '!', (self classNameFor: aClass), ' commentStamp!';lf;\x0a\x09\x09nextPutAll: (self chunkEscape: aClass comment), '!';lf ].\x0a\x09aStream lf",
referencedClasses: [],
messageSends: ["nextPutAll:", "classNameFor:", "superclass", ",", "lf", "tab", "do:separatedBy:", "instanceVariableNames", "category", "ifTrue:", "notEmpty", "comment", "chunkEscape:"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportMetaDefinitionOf:on:",
protocol: 'output',
fn: function (aClass,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$5,$4,$6;
$3=$recv(aClass)._class();
$ctx1.sendIdx["class"]=1;
$2=$recv($3)._instanceVariableNames();
$ctx1.sendIdx["instanceVariableNames"]=1;
$1=$recv($2)._isEmpty();
if(!$core.assert($1)){
$5=$recv(aClass)._class();
$ctx1.sendIdx["class"]=2;
$4=self._classNameFor_($5);
$recv(aStream)._nextPutAll_($4);
$ctx1.sendIdx["nextPutAll:"]=1;
$6=$recv(aStream)._nextPutAll_(" instanceVariableNames: '");
$ctx1.sendIdx["nextPutAll:"]=2;
$6;
$recv($recv($recv(aClass)._class())._instanceVariableNames())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(aStream)._nextPutAll_(each);
$ctx2.sendIdx["nextPutAll:"]=3;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(aStream)._nextPutAll_(" ");
$ctx2.sendIdx["nextPutAll:"]=4;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
$recv(aStream)._nextPutAll_("'!");
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=1;
$recv(aStream)._lf();
};
return self;
}, function($ctx1) {$ctx1.fill(self,"exportMetaDefinitionOf:on:",{aClass:aClass,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aClass", "aStream"],
source: "exportMetaDefinitionOf: aClass on: aStream\x0a\x0a\x09aClass class instanceVariableNames isEmpty ifFalse: [\x0a\x09\x09aStream\x0a\x09\x09\x09nextPutAll: (self classNameFor: aClass class);\x0a\x09\x09\x09nextPutAll: ' instanceVariableNames: '''.\x0a\x09\x09aClass class instanceVariableNames\x0a\x09\x09\x09do: [ :each | aStream nextPutAll: each ]\x0a\x09\x09\x09separatedBy: [ aStream nextPutAll: ' ' ].\x0a\x09\x09aStream\x0a\x09\x09\x09nextPutAll: '''!'; lf; lf ]",
referencedClasses: [],
messageSends: ["ifFalse:", "isEmpty", "instanceVariableNames", "class", "nextPutAll:", "classNameFor:", "do:separatedBy:", "lf"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportMethod:on:",
protocol: 'output',
fn: function (aMethod,aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=1;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=2;
$recv(aStream)._nextPutAll_(self._chunkEscape_($recv(aMethod)._source()));
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._lf();
$recv(aStream)._nextPutAll_("!");
return self;
}, function($ctx1) {$ctx1.fill(self,"exportMethod:on:",{aMethod:aMethod,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aMethod", "aStream"],
source: "exportMethod: aMethod on: aStream\x0a\x09aStream\x0a\x09\x09lf; lf; nextPutAll: (self chunkEscape: aMethod source); lf;\x0a\x09\x09nextPutAll: '!'",
referencedClasses: [],
messageSends: ["lf", "nextPutAll:", "chunkEscape:", "source"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportPackage:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
self._exportPackageDefinitionOf_on_(aPackage,aStream);
self._exportPackageImportsOf_on_(aPackage,aStream);
$recv($recv(aPackage)._sortedClasses())._do_((function(each){
return $core.withContext(function($ctx2) {
self._exportDefinitionOf_on_(each,aStream);
$1=self._ownMethodProtocolsOfClass_(each);
$ctx2.sendIdx["ownMethodProtocolsOfClass:"]=1;
self._exportProtocols_on_($1,aStream);
$ctx2.sendIdx["exportProtocols:on:"]=1;
self._exportMetaDefinitionOf_on_(each,aStream);
return self._exportProtocols_on_(self._ownMethodProtocolsOfClass_($recv(each)._class()),aStream);
$ctx2.sendIdx["exportProtocols:on:"]=2;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
self._exportProtocols_on_(self._extensionProtocolsOfPackage_(aPackage),aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackage:on:",{aPackage:aPackage,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackage: aPackage on: aStream\x0a\x0a\x09self\x0a\x09\x09exportPackageDefinitionOf: aPackage on: aStream;\x0a\x09\x09exportPackageImportsOf: aPackage on: aStream.\x0a\x09\x0a\x09aPackage sortedClasses do: [ :each |\x0a\x09\x09self exportDefinitionOf: each on: aStream.\x0a\x09\x09\x0a\x09\x09self \x0a\x09\x09\x09exportProtocols: (self ownMethodProtocolsOfClass: each)\x0a\x09\x09\x09on: aStream.\x0a\x09\x09\x09\x0a\x09\x09self exportMetaDefinitionOf: each on: aStream.\x0a\x09\x09\x0a\x09\x09self \x0a\x09\x09\x09exportProtocols: (self ownMethodProtocolsOfClass: each class)\x0a\x09\x09\x09on: aStream ].\x0a\x09\x09\x09\x0a\x09self \x0a\x09\x09exportProtocols: (self extensionProtocolsOfPackage: aPackage)\x0a\x09\x09on: aStream",
referencedClasses: [],
messageSends: ["exportPackageDefinitionOf:on:", "exportPackageImportsOf:on:", "do:", "sortedClasses", "exportDefinitionOf:on:", "exportProtocols:on:", "ownMethodProtocolsOfClass:", "exportMetaDefinitionOf:on:", "class", "extensionProtocolsOfPackage:"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportPackageDefinitionOf:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv("Smalltalk createPackage: '".__comma($recv(aPackage)._name())).__comma("'!");
$ctx1.sendIdx[","]=1;
$recv(aStream)._nextPutAll_($1);
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageDefinitionOf:on:",{aPackage:aPackage,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackageDefinitionOf: aPackage on: aStream\x0a\x09aStream\x0a\x09\x09nextPutAll: 'Smalltalk createPackage: ''', aPackage name, '''!';\x0a\x09\x09lf",
referencedClasses: [],
messageSends: ["nextPutAll:", ",", "name", "lf"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportPackageImportsOf:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aPackage)._imports())._ifNotEmpty_((function(imports){
return $core.withContext(function($ctx2) {
$recv(aStream)._nextPutAll_("(Smalltalk packageAt: '");
$ctx2.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_($recv(aPackage)._name());
$ctx2.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_("') imports: ");
$ctx2.sendIdx["nextPutAll:"]=3;
$recv(aStream)._nextPutAll_(self._chunkEscape_($recv(aPackage)._importsDefinition()));
$ctx2.sendIdx["nextPutAll:"]=4;
$recv(aStream)._nextPutAll_("!");
return $recv(aStream)._lf();
}, function($ctx2) {$ctx2.fillBlock({imports:imports},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageImportsOf:on:",{aPackage:aPackage,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackageImportsOf: aPackage on: aStream\x0a\x09aPackage imports ifNotEmpty: [ :imports |\x0a\x09\x09aStream\x0a\x09\x09\x09nextPutAll: '(Smalltalk packageAt: ''';\x0a\x09\x09\x09nextPutAll: aPackage name;\x0a\x09\x09\x09nextPutAll: ''') imports: ';\x0a\x09\x09\x09nextPutAll: (self chunkEscape: aPackage importsDefinition);\x0a\x09\x09\x09nextPutAll: '!';\x0a\x09\x09\x09lf ]",
referencedClasses: [],
messageSends: ["ifNotEmpty:", "imports", "nextPutAll:", "name", "chunkEscape:", "importsDefinition", "lf"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportProtocol:on:",
protocol: 'output',
fn: function (aProtocol,aStream){
var self=this;
return $core.withContext(function($ctx1) {
self._exportProtocolPrologueOf_on_(aProtocol,aStream);
$recv($recv(aProtocol)._methods())._do_((function(method){
return $core.withContext(function($ctx2) {
return self._exportMethod_on_(method,aStream);
}, function($ctx2) {$ctx2.fillBlock({method:method},$ctx1,1)});
}));
self._exportProtocolEpilogueOf_on_(aProtocol,aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportProtocol:on:",{aProtocol:aProtocol,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aProtocol", "aStream"],
source: "exportProtocol: aProtocol on: aStream\x0a\x09self exportProtocolPrologueOf: aProtocol on: aStream.\x0a\x09aProtocol methods do: [ :method | \x0a\x09\x09self exportMethod: method on: aStream ].\x0a\x09self exportProtocolEpilogueOf: aProtocol on: aStream",
referencedClasses: [],
messageSends: ["exportProtocolPrologueOf:on:", "do:", "methods", "exportMethod:on:", "exportProtocolEpilogueOf:on:"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportProtocolEpilogueOf:on:",
protocol: 'output',
fn: function (aProtocol,aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_(" !");
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=1;
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportProtocolEpilogueOf:on:",{aProtocol:aProtocol,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aProtocol", "aStream"],
source: "exportProtocolEpilogueOf: aProtocol on: aStream\x0a\x09aStream nextPutAll: ' !'; lf; lf",
referencedClasses: [],
messageSends: ["nextPutAll:", "lf"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportProtocolPrologueOf:on:",
protocol: 'output',
fn: function (aProtocol,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1="!".__comma(self._classNameFor_($recv(aProtocol)._theClass()));
$ctx1.sendIdx[","]=1;
$recv(aStream)._nextPutAll_($1);
$ctx1.sendIdx["nextPutAll:"]=1;
$2=$recv(" methodsFor: '".__comma($recv(aProtocol)._name())).__comma("'!");
$ctx1.sendIdx[","]=2;
$recv(aStream)._nextPutAll_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportProtocolPrologueOf:on:",{aProtocol:aProtocol,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aProtocol", "aStream"],
source: "exportProtocolPrologueOf: aProtocol on: aStream\x0a\x09aStream\x0a\x09\x09nextPutAll: '!', (self classNameFor: aProtocol theClass);\x0a\x09\x09nextPutAll: ' methodsFor: ''', aProtocol name, '''!'",
referencedClasses: [],
messageSends: ["nextPutAll:", ",", "classNameFor:", "theClass", "name"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportProtocols:on:",
protocol: 'output',
fn: function (aCollection,aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return self._exportProtocol_on_(each,aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportProtocols:on:",{aCollection:aCollection,aStream:aStream},$globals.ChunkExporter)});
},
args: ["aCollection", "aStream"],
source: "exportProtocols: aCollection on: aStream\x0a\x09aCollection do: [ :each |\x0a\x09\x09self exportProtocol: each on: aStream ]",
referencedClasses: [],
messageSends: ["do:", "exportProtocol:on:"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "extensionCategoriesOfPackage:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
var name,map,result;
return $core.withContext(function($ctx1) {
var $1;
name=$recv(aPackage)._name();
result=$recv($globals.OrderedCollection)._new();
$ctx1.sendIdx["new"]=1;
$recv($recv($globals.Package)._sortedClasses_($recv($globals.Smalltalk)._classes()))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv([each,$recv(each)._class()])._do_((function(aClass){
return $core.withContext(function($ctx3) {
map=$recv($globals.Dictionary)._new();
map;
$recv(aClass)._protocolsDo_((function(category,methods){
return $core.withContext(function($ctx4) {
$1=$recv(category).__eq("*".__comma(name));
if($core.assert($1)){
return $recv(map)._at_put_(category,methods);
};
}, function($ctx4) {$ctx4.fillBlock({category:category,methods:methods},$ctx3,3)});
}));
return $recv(result)._addAll_($recv($recv($recv(map)._keys())._sorted_((function(a,b){
return $core.withContext(function($ctx4) {
return $recv(a).__lt_eq(b);
}, function($ctx4) {$ctx4.fillBlock({a:a,b:b},$ctx3,5)});
})))._collect_((function(category){
return $core.withContext(function($ctx4) {
return $recv($globals.MethodCategory)._name_theClass_methods_(category,aClass,$recv(map)._at_(category));
}, function($ctx4) {$ctx4.fillBlock({category:category},$ctx3,6)});
})));
}, function($ctx3) {$ctx3.fillBlock({aClass:aClass},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["do:"]=1;
return result;
}, function($ctx1) {$ctx1.fill(self,"extensionCategoriesOfPackage:",{aPackage:aPackage,name:name,map:map,result:result},$globals.ChunkExporter)});
},
args: ["aPackage"],
source: "extensionCategoriesOfPackage: aPackage\x0a\x09\x22Issue #143: sort protocol alphabetically\x22\x0a\x0a\x09| name map result |\x0a\x09name := aPackage name.\x0a\x09result := OrderedCollection new.\x0a\x09(Package sortedClasses: Smalltalk classes) do: [ :each |\x0a\x09\x09{each. each class} do: [ :aClass |\x0a\x09\x09\x09map := Dictionary new.\x0a\x09\x09\x09aClass protocolsDo: [ :category :methods |\x0a\x09\x09\x09\x09category = ('*', name) ifTrue: [ map at: category put: methods ] ].\x0a\x09\x09\x09result addAll: ((map keys sorted: [ :a :b | a <= b ]) collect: [ :category |\x0a\x09\x09\x09\x09MethodCategory name: category theClass: aClass methods: (map at: category) ]) ] ].\x0a\x09^ result",
referencedClasses: ["OrderedCollection", "Package", "Smalltalk", "Dictionary", "MethodCategory"],
messageSends: ["name", "new", "do:", "sortedClasses:", "classes", "class", "protocolsDo:", "ifTrue:", "=", ",", "at:put:", "addAll:", "collect:", "sorted:", "keys", "<=", "name:theClass:methods:", "at:"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "ownCategoriesOfClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
var map;
return $core.withContext(function($ctx1) {
var $1;
map=$recv($globals.Dictionary)._new();
$recv(aClass)._protocolsDo_((function(each,methods){
return $core.withContext(function($ctx2) {
$1=$recv(each)._match_("^\x5c*");
if(!$core.assert($1)){
return $recv(map)._at_put_(each,methods);
};
}, function($ctx2) {$ctx2.fillBlock({each:each,methods:methods},$ctx1,1)});
}));
return $recv($recv($recv(map)._keys())._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv(a).__lt_eq(b);
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,3)});
})))._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($globals.MethodCategory)._name_theClass_methods_(each,aClass,$recv(map)._at_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownCategoriesOfClass:",{aClass:aClass,map:map},$globals.ChunkExporter)});
},
args: ["aClass"],
source: "ownCategoriesOfClass: aClass\x0a\x09\x22Answer the protocols of aClass that are not package extensions\x22\x0a\x09\x0a\x09\x22Issue #143: sort protocol alphabetically\x22\x0a\x0a\x09| map |\x0a\x09map := Dictionary new.\x0a\x09aClass protocolsDo: [ :each :methods |\x0a\x09\x09(each match: '^\x5c*') ifFalse: [ map at: each put: methods ] ].\x0a\x09^ (map keys sorted: [ :a :b | a <= b ]) collect: [ :each |\x0a\x09\x09MethodCategory name: each theClass: aClass methods: (map at: each) ]",
referencedClasses: ["Dictionary", "MethodCategory"],
messageSends: ["new", "protocolsDo:", "ifFalse:", "match:", "at:put:", "collect:", "sorted:", "keys", "<=", "name:theClass:methods:", "at:"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "ownCategoriesOfMetaClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
return self._ownCategoriesOfClass_($recv(aClass)._class());
}, function($ctx1) {$ctx1.fill(self,"ownCategoriesOfMetaClass:",{aClass:aClass},$globals.ChunkExporter)});
},
args: ["aClass"],
source: "ownCategoriesOfMetaClass: aClass\x0a\x09\x22Issue #143: sort protocol alphabetically\x22\x0a\x0a\x09^ self ownCategoriesOfClass: aClass class",
referencedClasses: [],
messageSends: ["ownCategoriesOfClass:", "class"]
}),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "ownMethodProtocolsOfClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aClass)._ownProtocols())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($globals.ExportMethodProtocol)._name_theClass_(each,aClass);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownMethodProtocolsOfClass:",{aClass:aClass},$globals.ChunkExporter)});
},
args: ["aClass"],
source: "ownMethodProtocolsOfClass: aClass\x0a\x09\x22Answer a collection of ExportMethodProtocol object of aClass that are not package extensions\x22\x0a\x09\x0a\x09^ aClass ownProtocols collect: [ :each |\x0a\x09\x09ExportMethodProtocol name: each theClass: aClass ]",
referencedClasses: ["ExportMethodProtocol"],
messageSends: ["collect:", "ownProtocols", "name:theClass:"]
}),
$globals.ChunkExporter);



$core.addClass('Exporter', $globals.AbstractExporter, [], 'Platform-ImportExport');
$globals.Exporter.comment="I am responsible for outputting Amber code into a JavaScript string.\x0a\x0aThe generated output is enough to reconstruct the exported data, including Smalltalk source code and other metadata.\x0a\x0a## Use case\x0a\x0aI am typically used to save code outside of the Amber runtime (committing to disk, etc.).";
$core.addMethod(
$core.method({
selector: "exportDefinitionOf:on:",
protocol: 'output',
fn: function (aClass,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$4,$6,$5,$7,$9,$8;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=1;
$recv(aStream)._nextPutAll_("$core.addClass(");
$ctx1.sendIdx["nextPutAll:"]=1;
$2="'".__comma(self._classNameFor_(aClass));
$ctx1.sendIdx[","]=2;
$1=$recv($2).__comma("', ");
$ctx1.sendIdx[","]=1;
$recv(aStream)._nextPutAll_($1);
$ctx1.sendIdx["nextPutAll:"]=2;
$3=self._jsClassNameFor_($recv(aClass)._superclass());
$ctx1.sendIdx["jsClassNameFor:"]=1;
$recv(aStream)._nextPutAll_($3);
$ctx1.sendIdx["nextPutAll:"]=3;
$4=$recv(aStream)._nextPutAll_(", [");
$ctx1.sendIdx["nextPutAll:"]=4;
$recv($recv(aClass)._instanceVariableNames())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
$6="'".__comma(each);
$ctx2.sendIdx[","]=4;
$5=$recv($6).__comma("'");
$ctx2.sendIdx[","]=3;
return $recv(aStream)._nextPutAll_($5);
$ctx2.sendIdx["nextPutAll:"]=5;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(aStream)._nextPutAll_(", ");
$ctx2.sendIdx["nextPutAll:"]=6;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv(aStream)._nextPutAll_("], '");
$ctx1.sendIdx["nextPutAll:"]=7;
$recv(aStream)._nextPutAll_($recv($recv(aClass)._category()).__comma("'"));
$ctx1.sendIdx["nextPutAll:"]=8;
$7=$recv(aStream)._nextPutAll_(");");
$ctx1.sendIdx["nextPutAll:"]=9;
$9=$recv(aClass)._comment();
$ctx1.sendIdx["comment"]=1;
$8=$recv($9)._notEmpty();
if($core.assert($8)){
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=2;
$recv(aStream)._nextPutAll_("//>>excludeStart(\x22ide\x22, pragmas.excludeIdeData);");
$ctx1.sendIdx["nextPutAll:"]=10;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=3;
$recv(aStream)._nextPutAll_(self._jsClassNameFor_(aClass));
$ctx1.sendIdx["nextPutAll:"]=11;
$recv(aStream)._nextPutAll_(".comment=");
$ctx1.sendIdx["nextPutAll:"]=12;
$recv(aStream)._nextPutAll_($recv($recv($recv(aClass)._comment())._crlfSanitized())._asJavascript());
$ctx1.sendIdx["nextPutAll:"]=13;
$recv(aStream)._nextPutAll_(";");
$ctx1.sendIdx["nextPutAll:"]=14;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=4;
$recv(aStream)._nextPutAll_("//>>excludeEnd(\x22ide\x22);");
};
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportDefinitionOf:on:",{aClass:aClass,aStream:aStream},$globals.Exporter)});
},
args: ["aClass", "aStream"],
source: "exportDefinitionOf: aClass on: aStream\x0a\x09aStream\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '$core.addClass(';\x0a\x09\x09nextPutAll: '''', (self classNameFor: aClass), ''', ';\x0a\x09\x09nextPutAll: (self jsClassNameFor: aClass superclass);\x0a\x09\x09nextPutAll: ', ['.\x0a\x09aClass instanceVariableNames\x0a\x09\x09do: [ :each | aStream nextPutAll: '''', each, '''' ]\x0a\x09\x09separatedBy: [ aStream nextPutAll: ', ' ].\x0a\x09aStream\x0a\x09\x09nextPutAll: '], ''';\x0a\x09\x09nextPutAll: aClass category, '''';\x0a\x09\x09nextPutAll: ');'.\x0a\x09aClass comment notEmpty ifTrue: [\x0a\x09\x09aStream\x0a\x09\x09\x09lf;\x0a\x09\x09\x09nextPutAll: '//>>excludeStart(\x22ide\x22, pragmas.excludeIdeData);';\x0a\x09\x09\x09lf;\x0a\x09\x09\x09nextPutAll: (self jsClassNameFor: aClass);\x0a\x09\x09\x09nextPutAll: '.comment=';\x0a\x09\x09\x09nextPutAll: aClass comment crlfSanitized asJavascript;\x0a\x09\x09\x09nextPutAll: ';';\x0a\x09\x09\x09lf;\x0a\x09\x09\x09nextPutAll: '//>>excludeEnd(\x22ide\x22);' ].\x0a\x09aStream lf",
referencedClasses: [],
messageSends: ["lf", "nextPutAll:", ",", "classNameFor:", "jsClassNameFor:", "superclass", "do:separatedBy:", "instanceVariableNames", "category", "ifTrue:", "notEmpty", "comment", "asJavascript", "crlfSanitized"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportMetaDefinitionOf:on:",
protocol: 'output',
fn: function (aClass,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$5,$4,$6,$8,$7;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=1;
$3=$recv(aClass)._class();
$ctx1.sendIdx["class"]=1;
$2=$recv($3)._instanceVariableNames();
$ctx1.sendIdx["instanceVariableNames"]=1;
$1=$recv($2)._isEmpty();
if(!$core.assert($1)){
$5=$recv(aClass)._class();
$ctx1.sendIdx["class"]=2;
$4=self._jsClassNameFor_($5);
$recv(aStream)._nextPutAll_($4);
$ctx1.sendIdx["nextPutAll:"]=1;
$6=$recv(aStream)._nextPutAll_(".iVarNames = [");
$ctx1.sendIdx["nextPutAll:"]=2;
$6;
$recv($recv($recv(aClass)._class())._instanceVariableNames())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
$8="'".__comma(each);
$ctx2.sendIdx[","]=2;
$7=$recv($8).__comma("'");
$ctx2.sendIdx[","]=1;
return $recv(aStream)._nextPutAll_($7);
$ctx2.sendIdx["nextPutAll:"]=3;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(aStream)._nextPutAll_(",");
$ctx2.sendIdx["nextPutAll:"]=4;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
$recv(aStream)._nextPutAll_("];".__comma($recv($globals.String)._lf()));
};
return self;
}, function($ctx1) {$ctx1.fill(self,"exportMetaDefinitionOf:on:",{aClass:aClass,aStream:aStream},$globals.Exporter)});
},
args: ["aClass", "aStream"],
source: "exportMetaDefinitionOf: aClass on: aStream\x0a\x09aStream lf.\x0a\x09aClass class instanceVariableNames isEmpty ifFalse: [\x0a\x09\x09aStream\x0a\x09\x09nextPutAll: (self jsClassNameFor: aClass class);\x0a\x09\x09nextPutAll: '.iVarNames = ['.\x0a\x09\x09aClass class instanceVariableNames\x0a\x09\x09do: [ :each | aStream nextPutAll: '''', each, '''' ]\x0a\x09\x09separatedBy: [ aStream nextPutAll: ',' ].\x0a\x09\x09aStream nextPutAll: '];', String lf ]",
referencedClasses: ["String"],
messageSends: ["lf", "ifFalse:", "isEmpty", "instanceVariableNames", "class", "nextPutAll:", "jsClassNameFor:", "do:separatedBy:", ","]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportMethod:on:",
protocol: 'output',
fn: function (aMethod,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$5,$4,$7,$6,$10,$9,$8,$13,$12,$11,$16,$15,$14;
$recv(aStream)._nextPutAll_("$core.addMethod(");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=1;
$recv(aStream)._nextPutAll_("$core.method({");
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=2;
$3=$recv($recv(aMethod)._selector())._asJavascript();
$ctx1.sendIdx["asJavascript"]=1;
$2="selector: ".__comma($3);
$ctx1.sendIdx[","]=2;
$1=$recv($2).__comma(",");
$ctx1.sendIdx[","]=1;
$recv(aStream)._nextPutAll_($1);
$ctx1.sendIdx["nextPutAll:"]=3;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=3;
$5="protocol: '".__comma($recv(aMethod)._protocol());
$ctx1.sendIdx[","]=4;
$4=$recv($5).__comma("',");
$ctx1.sendIdx[","]=3;
$recv(aStream)._nextPutAll_($4);
$ctx1.sendIdx["nextPutAll:"]=4;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=4;
$7="fn: ".__comma($recv($recv(aMethod)._fn())._compiledSource());
$ctx1.sendIdx[","]=6;
$6=$recv($7).__comma(",");
$ctx1.sendIdx[","]=5;
$recv(aStream)._nextPutAll_($6);
$ctx1.sendIdx["nextPutAll:"]=5;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=5;
$recv(aStream)._nextPutAll_("//>>excludeStart(\x22ide\x22, pragmas.excludeIdeData);");
$ctx1.sendIdx["nextPutAll:"]=6;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=6;
$10=$recv($recv(aMethod)._arguments())._asJavascript();
$ctx1.sendIdx["asJavascript"]=2;
$9="args: ".__comma($10);
$ctx1.sendIdx[","]=8;
$8=$recv($9).__comma(",");
$ctx1.sendIdx[","]=7;
$recv(aStream)._nextPutAll_($8);
$ctx1.sendIdx["nextPutAll:"]=7;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=7;
$13=$recv($recv(aMethod)._source())._asJavascript();
$ctx1.sendIdx["asJavascript"]=3;
$12="source: ".__comma($13);
$ctx1.sendIdx[","]=10;
$11=$recv($12).__comma(",");
$ctx1.sendIdx[","]=9;
$recv(aStream)._nextPutAll_($11);
$ctx1.sendIdx["nextPutAll:"]=8;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=8;
$16=$recv($recv(aMethod)._referencedClasses())._asJavascript();
$ctx1.sendIdx["asJavascript"]=4;
$15="referencedClasses: ".__comma($16);
$ctx1.sendIdx[","]=12;
$14=$recv($15).__comma(",");
$ctx1.sendIdx[","]=11;
$recv(aStream)._nextPutAll_($14);
$ctx1.sendIdx["nextPutAll:"]=9;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=9;
$recv(aStream)._nextPutAll_("//>>excludeEnd(\x22ide\x22);");
$ctx1.sendIdx["nextPutAll:"]=10;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=10;
$recv(aStream)._nextPutAll_("messageSends: ".__comma($recv($recv(aMethod)._messageSends())._asJavascript()));
$ctx1.sendIdx["nextPutAll:"]=11;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=11;
$recv(aStream)._nextPutAll_("}),");
$ctx1.sendIdx["nextPutAll:"]=12;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=12;
$recv(aStream)._nextPutAll_(self._jsClassNameFor_($recv(aMethod)._methodClass()));
$ctx1.sendIdx["nextPutAll:"]=13;
$recv(aStream)._nextPutAll_(");");
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=13;
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportMethod:on:",{aMethod:aMethod,aStream:aStream},$globals.Exporter)});
},
args: ["aMethod", "aStream"],
source: "exportMethod: aMethod on: aStream\x0a\x09aStream\x0a\x09\x09nextPutAll: '$core.addMethod(';lf;\x0a\x09\x09nextPutAll: '$core.method({';lf;\x0a\x09\x09nextPutAll: 'selector: ', aMethod selector asJavascript, ',';lf;\x0a\x09\x09nextPutAll: 'protocol: ''', aMethod protocol, ''',';lf;\x0a\x09\x09nextPutAll: 'fn: ', aMethod fn compiledSource, ',';lf;\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ide\x22, pragmas.excludeIdeData);';lf;\x0a\x09\x09nextPutAll: 'args: ', aMethod arguments asJavascript, ','; lf;\x0a\x09\x09nextPutAll: 'source: ', aMethod source asJavascript, ',';lf;\x0a\x09\x09nextPutAll: 'referencedClasses: ', aMethod referencedClasses asJavascript, ',';lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ide\x22);';lf;\x0a\x09\x09nextPutAll: 'messageSends: ', aMethod messageSends asJavascript;lf;\x0a\x09\x09nextPutAll: '}),';lf;\x0a\x09\x09nextPutAll: (self jsClassNameFor: aMethod methodClass);\x0a\x09\x09nextPutAll: ');';lf;lf",
referencedClasses: [],
messageSends: ["nextPutAll:", "lf", ",", "asJavascript", "selector", "protocol", "compiledSource", "fn", "arguments", "source", "referencedClasses", "messageSends", "jsClassNameFor:", "methodClass"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackage:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
self._exportPackagePrologueOf_on_(aPackage,aStream);
self._exportPackageDefinitionOf_on_(aPackage,aStream);
self._exportPackageContextOf_on_(aPackage,aStream);
self._exportPackageImportsOf_on_(aPackage,aStream);
self._exportPackageTransportOf_on_(aPackage,aStream);
$recv($recv(aPackage)._sortedClasses())._do_((function(each){
return $core.withContext(function($ctx2) {
self._exportDefinitionOf_on_(each,aStream);
$1=$recv(each)._ownMethods();
$ctx2.sendIdx["ownMethods"]=1;
$recv($1)._do_((function(method){
return $core.withContext(function($ctx3) {
return self._exportMethod_on_(method,aStream);
$ctx3.sendIdx["exportMethod:on:"]=1;
}, function($ctx3) {$ctx3.fillBlock({method:method},$ctx2,2)});
}));
$ctx2.sendIdx["do:"]=2;
self._exportMetaDefinitionOf_on_(each,aStream);
return $recv($recv($recv(each)._class())._ownMethods())._do_((function(method){
return $core.withContext(function($ctx3) {
return self._exportMethod_on_(method,aStream);
$ctx3.sendIdx["exportMethod:on:"]=2;
}, function($ctx3) {$ctx3.fillBlock({method:method},$ctx2,3)});
}));
$ctx2.sendIdx["do:"]=3;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["do:"]=1;
$recv(self._extensionMethodsOfPackage_(aPackage))._do_((function(each){
return $core.withContext(function($ctx2) {
return self._exportMethod_on_(each,aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}));
self._exportPackageEpilogueOf_on_(aPackage,aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackage:on:",{aPackage:aPackage,aStream:aStream},$globals.Exporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackage: aPackage on: aStream\x0a\x09\x0a\x09self \x0a\x09\x09exportPackagePrologueOf: aPackage on: aStream;\x0a\x09\x09exportPackageDefinitionOf: aPackage on: aStream;\x0a\x09\x09exportPackageContextOf: aPackage on: aStream;\x0a\x09\x09exportPackageImportsOf: aPackage on: aStream;\x0a\x09\x09exportPackageTransportOf: aPackage on: aStream.\x0a\x09\x0a\x09aPackage sortedClasses do: [ :each |\x0a\x09\x09self exportDefinitionOf: each on: aStream.\x0a\x09\x09each ownMethods do: [ :method |\x0a\x09\x09\x09self exportMethod: method on: aStream ].\x0a\x09\x09\x09\x0a\x09\x09self exportMetaDefinitionOf: each on: aStream.\x0a\x09\x09each class ownMethods do: [ :method |\x0a\x09\x09\x09self exportMethod: method on: aStream ] ].\x0a\x09\x09\x09\x0a\x09(self extensionMethodsOfPackage: aPackage) do: [ :each |\x0a\x09\x09self exportMethod: each on: aStream ].\x0a\x09\x09\x0a\x09self exportPackageEpilogueOf: aPackage on: aStream",
referencedClasses: [],
messageSends: ["exportPackagePrologueOf:on:", "exportPackageDefinitionOf:on:", "exportPackageContextOf:on:", "exportPackageImportsOf:on:", "exportPackageTransportOf:on:", "do:", "sortedClasses", "exportDefinitionOf:on:", "ownMethods", "exportMethod:on:", "exportMetaDefinitionOf:on:", "class", "extensionMethodsOfPackage:", "exportPackageEpilogueOf:on:"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageContextOf:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_("$core.packages[");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_($recv($recv(aPackage)._name())._asJavascript());
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_("].innerEval = ");
$ctx1.sendIdx["nextPutAll:"]=3;
$recv(aStream)._nextPutAll_("function (expr) { return eval(expr); }");
$ctx1.sendIdx["nextPutAll:"]=4;
$recv(aStream)._nextPutAll_(";");
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageContextOf:on:",{aPackage:aPackage,aStream:aStream},$globals.Exporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackageContextOf: aPackage on: aStream\x0a\x09aStream\x0a\x09\x09nextPutAll: '$core.packages[';\x0a\x09\x09nextPutAll: aPackage name asJavascript;\x0a\x09\x09nextPutAll: '].innerEval = ';\x0a\x09\x09nextPutAll: 'function (expr) { return eval(expr); }';\x0a\x09\x09nextPutAll: ';';\x0a\x09\x09lf",
referencedClasses: [],
messageSends: ["nextPutAll:", "asJavascript", "name", "lf"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageDefinitionOf:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(aStream)._nextPutAll_("$core.addPackage(");
$ctx1.sendIdx["nextPutAll:"]=1;
$1=$recv("'".__comma($recv(aPackage)._name())).__comma("');");
$ctx1.sendIdx[","]=1;
$recv(aStream)._nextPutAll_($1);
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageDefinitionOf:on:",{aPackage:aPackage,aStream:aStream},$globals.Exporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackageDefinitionOf: aPackage on: aStream\x0a\x09aStream\x0a\x09\x09nextPutAll: '$core.addPackage(';\x0a\x09\x09nextPutAll: '''', aPackage name, ''');';\x0a\x09\x09lf",
referencedClasses: [],
messageSends: ["nextPutAll:", ",", "name", "lf"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageEpilogueOf:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageEpilogueOf:on:",{aPackage:aPackage,aStream:aStream},$globals.Exporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackageEpilogueOf: aPackage on: aStream\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageImportsOf:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv($recv(aPackage)._importsAsJson())._ifNotEmpty_((function(imports){
return $core.withContext(function($ctx2) {
$recv(aStream)._nextPutAll_("$core.packages[");
$ctx2.sendIdx["nextPutAll:"]=1;
$1=$recv($recv(aPackage)._name())._asJavascript();
$ctx2.sendIdx["asJavascript"]=1;
$recv(aStream)._nextPutAll_($1);
$ctx2.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_("].imports = ");
$ctx2.sendIdx["nextPutAll:"]=3;
$recv(aStream)._nextPutAll_($recv(imports)._asJavascript());
$ctx2.sendIdx["nextPutAll:"]=4;
$recv(aStream)._nextPutAll_(";");
return $recv(aStream)._lf();
}, function($ctx2) {$ctx2.fillBlock({imports:imports},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageImportsOf:on:",{aPackage:aPackage,aStream:aStream},$globals.Exporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackageImportsOf: aPackage on: aStream\x0a\x09aPackage importsAsJson ifNotEmpty: [ :imports |\x0a\x09\x09aStream\x0a\x09\x09\x09nextPutAll: '$core.packages[';\x0a\x09\x09\x09nextPutAll: aPackage name asJavascript;\x0a\x09\x09\x09nextPutAll: '].imports = ';\x0a\x09\x09\x09nextPutAll: imports asJavascript;\x0a\x09\x09\x09nextPutAll: ';';\x0a\x09\x09\x09lf ]",
referencedClasses: [],
messageSends: ["ifNotEmpty:", "importsAsJson", "nextPutAll:", "asJavascript", "name", "lf"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackagePrologueOf:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackagePrologueOf:on:",{aPackage:aPackage,aStream:aStream},$globals.Exporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackagePrologueOf: aPackage on: aStream\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageTransportOf:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_("$core.packages[");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_($recv($recv(aPackage)._name())._asJavascript());
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_("].transport = ");
$ctx1.sendIdx["nextPutAll:"]=3;
$recv(aStream)._nextPutAll_($recv($recv(aPackage)._transport())._asJSONString());
$ctx1.sendIdx["nextPutAll:"]=4;
$recv(aStream)._nextPutAll_(";");
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageTransportOf:on:",{aPackage:aPackage,aStream:aStream},$globals.Exporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackageTransportOf: aPackage on: aStream\x0a\x09aStream\x0a\x09\x09nextPutAll: '$core.packages[';\x0a\x09\x09nextPutAll: aPackage name asJavascript;\x0a\x09\x09nextPutAll: '].transport = ';\x0a\x09\x09nextPutAll: aPackage transport asJSONString;\x0a\x09\x09nextPutAll: ';';\x0a\x09\x09lf",
referencedClasses: [],
messageSends: ["nextPutAll:", "asJavascript", "name", "asJSONString", "transport", "lf"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "jsClassNameFor:",
protocol: 'convenience',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv(aClass)._isMetaclass();
if($core.assert($1)){
return $recv(self._jsClassNameFor_($recv(aClass)._instanceClass())).__comma(".klass");
$ctx1.sendIdx[","]=1;
} else {
if(($receiver = aClass) == null || $receiver.isNil){
return "null";
} else {
return "$globals.".__comma($recv(aClass)._name());
};
};
}, function($ctx1) {$ctx1.fill(self,"jsClassNameFor:",{aClass:aClass},$globals.Exporter)});
},
args: ["aClass"],
source: "jsClassNameFor: aClass\x0a\x09^ aClass isMetaclass\x0a\x09\x09ifTrue: [ (self jsClassNameFor: aClass instanceClass), '.klass' ]\x0a\x09\x09ifFalse: [\x0a\x09\x09\x09aClass\x0a\x09\x09\x09\x09ifNil: [ 'null' ]\x0a\x09\x09\x09\x09ifNotNil: [ '$globals.', aClass name ] ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "isMetaclass", ",", "jsClassNameFor:", "instanceClass", "ifNil:ifNotNil:", "name"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "ownMethodsOfClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv($recv($recv($recv(aClass)._methodDictionary())._values())._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
$1=$recv(a)._selector();
$ctx2.sendIdx["selector"]=1;
return $recv($1).__lt_eq($recv(b)._selector());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
})))._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._protocol())._match_("^\x5c*");
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownMethodsOfClass:",{aClass:aClass},$globals.Exporter)});
},
args: ["aClass"],
source: "ownMethodsOfClass: aClass\x0a\x09\x22Issue #143: sort methods alphabetically\x22\x0a\x0a\x09^ ((aClass methodDictionary values) sorted: [ :a :b | a selector <= b selector ])\x0a\x09\x09reject: [ :each | (each protocol match: '^\x5c*') ]",
referencedClasses: [],
messageSends: ["reject:", "sorted:", "values", "methodDictionary", "<=", "selector", "match:", "protocol"]
}),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "ownMethodsOfMetaClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
return self._ownMethodsOfClass_($recv(aClass)._class());
}, function($ctx1) {$ctx1.fill(self,"ownMethodsOfMetaClass:",{aClass:aClass},$globals.Exporter)});
},
args: ["aClass"],
source: "ownMethodsOfMetaClass: aClass\x0a\x09\x22Issue #143: sort methods alphabetically\x22\x0a\x0a\x09^ self ownMethodsOfClass: aClass class",
referencedClasses: [],
messageSends: ["ownMethodsOfClass:", "class"]
}),
$globals.Exporter);



$core.addClass('AmdExporter', $globals.Exporter, ['namespace'], 'Platform-ImportExport');
$globals.AmdExporter.comment="I am used to export Packages in an AMD (Asynchronous Module Definition) JavaScript format.";
$core.addMethod(
$core.method({
selector: "amdNamesOfPackages:",
protocol: 'private',
fn: function (anArray){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv($recv(anArray)._select_((function(each){
return $core.withContext(function($ctx2) {
$1=self._amdNamespaceOfPackage_(each);
$ctx2.sendIdx["amdNamespaceOfPackage:"]=1;
return $recv($1)._notNil();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(self._amdNamespaceOfPackage_(each)).__comma("/")).__comma($recv(each)._name());
$ctx2.sendIdx[","]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"amdNamesOfPackages:",{anArray:anArray},$globals.AmdExporter)});
},
args: ["anArray"],
source: "amdNamesOfPackages: anArray\x0a\x09^ (anArray\x0a\x09\x09select: [ :each | (self amdNamespaceOfPackage: each) notNil ])\x0a\x09\x09collect: [ :each | (self amdNamespaceOfPackage: each), '/', each name ]",
referencedClasses: [],
messageSends: ["collect:", "select:", "notNil", "amdNamespaceOfPackage:", ",", "name"]
}),
$globals.AmdExporter);

$core.addMethod(
$core.method({
selector: "amdNamespaceOfPackage:",
protocol: 'private',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
$3=$recv(aPackage)._transport();
$ctx1.sendIdx["transport"]=1;
$2=$recv($3)._type();
$1=$recv($2).__eq("amd");
if($core.assert($1)){
return $recv($recv(aPackage)._transport())._namespace();
} else {
return nil;
};
}, function($ctx1) {$ctx1.fill(self,"amdNamespaceOfPackage:",{aPackage:aPackage},$globals.AmdExporter)});
},
args: ["aPackage"],
source: "amdNamespaceOfPackage: aPackage\x0a\x09^ (aPackage transport type = 'amd')\x0a\x09\x09ifTrue: [ aPackage transport namespace ]\x0a\x09\x09ifFalse: [ nil ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "=", "type", "transport", "namespace"]
}),
$globals.AmdExporter);

$core.addMethod(
$core.method({
selector: "exportPackageEpilogueOf:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_("});");
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageEpilogueOf:on:",{aPackage:aPackage,aStream:aStream},$globals.AmdExporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackageEpilogueOf: aPackage on: aStream\x0a\x09aStream\x0a\x09\x09nextPutAll: '});';\x0a\x09\x09lf",
referencedClasses: [],
messageSends: ["nextPutAll:", "lf"]
}),
$globals.AmdExporter);

$core.addMethod(
$core.method({
selector: "exportPackagePrologueOf:on:",
protocol: 'output',
fn: function (aPackage,aStream){
var self=this;
var importsForOutput,loadDependencies,pragmaStart,pragmaEnd;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$4,$6,$5,$7,$13,$12,$11,$10,$9,$8,$17,$16,$15,$14;
pragmaStart="";
pragmaEnd="";
importsForOutput=self._importsForOutput_(aPackage);
loadDependencies=self._amdNamesOfPackages_($recv(aPackage)._loadDependencies());
$1=$recv(importsForOutput)._value();
$ctx1.sendIdx["value"]=1;
$recv($1)._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
$3=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=1;
$2=$recv($3).__comma("//>>excludeStart(\x22imports\x22, pragmas.excludeImports);");
$ctx2.sendIdx[","]=2;
$4=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=2;
pragmaStart=$recv($2).__comma($4);
$ctx2.sendIdx[","]=1;
pragmaStart;
$6=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=3;
$5=$recv($6).__comma("//>>excludeEnd(\x22imports\x22);");
$ctx2.sendIdx[","]=4;
$7=$recv($globals.String)._lf();
$ctx2.sendIdx["lf"]=4;
pragmaEnd=$recv($5).__comma($7);
$ctx2.sendIdx[","]=3;
return pragmaEnd;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(aStream)._nextPutAll_("define(\x22");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_(self._amdNamespaceOfPackage_(aPackage));
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_("/");
$ctx1.sendIdx["nextPutAll:"]=3;
$recv(aStream)._nextPutAll_($recv(aPackage)._name());
$ctx1.sendIdx["nextPutAll:"]=4;
$recv(aStream)._nextPutAll_("\x22, ");
$ctx1.sendIdx["nextPutAll:"]=5;
$13=["amber/boot", ":1:"].__comma($recv(importsForOutput)._value());
$ctx1.sendIdx[","]=7;
$12=$recv($13).__comma([":2:"]);
$ctx1.sendIdx[","]=6;
$11=$recv($12).__comma(loadDependencies);
$ctx1.sendIdx[","]=5;
$10=$recv($11)._asJavascript();
$9=$recv($10)._replace_with_(",\x5cs*[\x22']:1:[\x22']",pragmaStart);
$ctx1.sendIdx["replace:with:"]=2;
$8=$recv($9)._replace_with_(",\x5cs*[\x22']:2:[\x22']",pragmaEnd);
$ctx1.sendIdx["replace:with:"]=1;
$recv(aStream)._nextPutAll_($8);
$ctx1.sendIdx["nextPutAll:"]=6;
$recv(aStream)._nextPutAll_(", function(");
$ctx1.sendIdx["nextPutAll:"]=7;
$17=$recv(["$boot", ":1:"].__comma($recv(importsForOutput)._key())).__comma([":2:"]);
$ctx1.sendIdx[","]=8;
$16=$recv($17)._join_(",");
$15=$recv($16)._replace_with_(",\x5cs*:1:",pragmaStart);
$14=$recv($15)._replace_with_(",\x5cs*:2:",pragmaEnd);
$ctx1.sendIdx["replace:with:"]=3;
$recv(aStream)._nextPutAll_($14);
$ctx1.sendIdx["nextPutAll:"]=8;
$recv(aStream)._nextPutAll_("){\x22use strict\x22;");
$ctx1.sendIdx["nextPutAll:"]=9;
$recv(aStream)._lf();
$ctx1.sendIdx["lf"]=5;
$recv(aStream)._nextPutAll_("var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;");
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackagePrologueOf:on:",{aPackage:aPackage,aStream:aStream,importsForOutput:importsForOutput,loadDependencies:loadDependencies,pragmaStart:pragmaStart,pragmaEnd:pragmaEnd},$globals.AmdExporter)});
},
args: ["aPackage", "aStream"],
source: "exportPackagePrologueOf: aPackage on: aStream\x0a\x09| importsForOutput loadDependencies pragmaStart pragmaEnd |\x0a\x09pragmaStart := ''.\x0a\x09pragmaEnd := ''.\x0a\x09importsForOutput := self importsForOutput: aPackage.\x0a\x09loadDependencies := self amdNamesOfPackages: aPackage loadDependencies.\x0a\x09importsForOutput value ifNotEmpty: [\x0a\x09\x09pragmaStart := String lf, '//>>excludeStart(\x22imports\x22, pragmas.excludeImports);', String lf.\x0a\x09\x09pragmaEnd := String lf, '//>>excludeEnd(\x22imports\x22);', String lf ].\x0a\x09aStream\x0a\x09\x09nextPutAll: 'define(\x22';\x0a\x09\x09nextPutAll: (self amdNamespaceOfPackage: aPackage);\x0a\x09\x09nextPutAll: '/'; \x0a\x09\x09nextPutAll: aPackage name;\x0a\x09\x09nextPutAll: '\x22, ';\x0a\x09\x09nextPutAll: (((\x0a\x09\x09\x09(#('amber/boot' ':1:'), importsForOutput value, #(':2:'), loadDependencies) asJavascript)\x0a\x09\x09\x09replace: ',\x5cs*[\x22'']:1:[\x22'']' with: pragmaStart) replace: ',\x5cs*[\x22'']:2:[\x22'']' with: pragmaEnd);\x0a\x09\x09nextPutAll: ', function(';\x0a\x09\x09nextPutAll: (((\x0a\x09\x09\x09(#('$boot' ':1:'), importsForOutput key, #(':2:')) join: ',')\x0a\x09\x09\x09replace: ',\x5cs*:1:' with: pragmaStart) replace: ',\x5cs*:2:' with: pragmaEnd);\x0a\x09\x09nextPutAll: '){\x22use strict\x22;';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: 'var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;';\x0a\x09\x09lf",
referencedClasses: ["String"],
messageSends: ["importsForOutput:", "amdNamesOfPackages:", "loadDependencies", "ifNotEmpty:", "value", ",", "lf", "nextPutAll:", "amdNamespaceOfPackage:", "name", "replace:with:", "asJavascript", "join:", "key"]
}),
$globals.AmdExporter);

$core.addMethod(
$core.method({
selector: "importsForOutput:",
protocol: 'private',
fn: function (aPackage){
var self=this;
var namedImports,anonImports,importVarNames;
return $core.withContext(function($ctx1) {
var $1;
namedImports=[];
anonImports=[];
importVarNames=[];
$recv($recv(aPackage)._imports())._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(each)._isString();
if($core.assert($1)){
return $recv(anonImports)._add_(each);
$ctx2.sendIdx["add:"]=1;
} else {
$recv(namedImports)._add_($recv(each)._value());
$ctx2.sendIdx["add:"]=2;
return $recv(importVarNames)._add_($recv(each)._key());
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(importVarNames).__minus_gt($recv(namedImports).__comma(anonImports));
}, function($ctx1) {$ctx1.fill(self,"importsForOutput:",{aPackage:aPackage,namedImports:namedImports,anonImports:anonImports,importVarNames:importVarNames},$globals.AmdExporter)});
},
args: ["aPackage"],
source: "importsForOutput: aPackage\x0a\x09\x22Returns an association where key is list of import variables\x0a\x09and value is list of external dependencies, with ones imported as variables\x0a\x09put at the beginning with same order as is in key.\x0a\x09\x0a\x09For example imports:{'jQuery'->'jquery'. 'bootstrap'} would yield\x0a\x09#('jQuery') -> #('jquery' 'bootstrap')\x22\x0a\x09| namedImports anonImports importVarNames |\x0a\x09namedImports := #().\x0a\x09anonImports := #().\x0a\x09importVarNames := #().\x0a\x09aPackage imports do: [ :each | each isString\x0a\x09\x09ifTrue: [ anonImports add: each ]\x0a\x09\x09ifFalse: [ namedImports add: each value.\x0a\x09\x09\x09importVarNames add: each key ]].\x0a\x09^ importVarNames -> (namedImports, anonImports)",
referencedClasses: [],
messageSends: ["do:", "imports", "ifTrue:ifFalse:", "isString", "add:", "value", "key", "->", ","]
}),
$globals.AmdExporter);



$core.addClass('ChunkParser', $globals.Object, ['stream', 'last'], 'Platform-ImportExport');
$globals.ChunkParser.comment="I am responsible for parsing aStream contents in the chunk format.\x0a\x0a## API\x0a\x0a    ChunkParser new\x0a        stream: aStream;\x0a        nextChunk";
$core.addMethod(
$core.method({
selector: "last",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@last"];

},
args: [],
source: "last\x0a\x09^ last",
referencedClasses: [],
messageSends: []
}),
$globals.ChunkParser);

$core.addMethod(
$core.method({
selector: "nextChunk",
protocol: 'reading',
fn: function (){
var self=this;
var char,result,chunk;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
var $early={};
try {
result=""._writeStream();
$recv((function(){
return $core.withContext(function($ctx2) {
char=$recv(self["@stream"])._next();
$ctx2.sendIdx["next"]=1;
char;
return $recv(char)._notNil();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
$1=$recv(char).__eq("!");
$ctx2.sendIdx["="]=1;
if($core.assert($1)){
$2=$recv($recv(self["@stream"])._peek()).__eq("!");
if($core.assert($2)){
$recv(self["@stream"])._next();
} else {
self["@last"]=$recv($recv(result)._contents())._trimBoth();
$3=self["@last"];
throw $early=[$3];
};
};
return $recv(result)._nextPut_(char);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
self["@last"]=nil;
$4=self["@last"];
return $4;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"nextChunk",{char:char,result:result,chunk:chunk},$globals.ChunkParser)});
},
args: [],
source: "nextChunk\x0a\x09\x22The chunk format (Smalltalk Interchange Format or Fileout format)\x0a\x09is a trivial format but can be a bit tricky to understand:\x0a\x09\x09- Uses the exclamation mark as delimiter of chunks.\x0a\x09\x09- Inside a chunk a normal exclamation mark must be doubled.\x0a\x09\x09- A non empty chunk must be a valid Smalltalk expression.\x0a\x09\x09- A chunk on top level with a preceding empty chunk is an instruction chunk:\x0a\x09\x09\x09- The object created by the expression then takes over reading chunks.\x0a\x0a\x09This method returns next chunk as a String (trimmed), empty String (all whitespace) or nil.\x22\x0a\x0a\x09| char result chunk |\x0a\x09result := '' writeStream.\x0a\x09\x09[ char := stream next.\x0a\x09\x09char notNil ] whileTrue: [\x0a\x09\x09\x09\x09char = '!' ifTrue: [\x0a\x09\x09\x09\x09\x09\x09stream peek = '!'\x0a\x09\x09\x09\x09\x09\x09\x09\x09ifTrue: [ stream next \x22skipping the escape double\x22 ]\x0a\x09\x09\x09\x09\x09\x09\x09\x09ifFalse: [ ^ last := result contents trimBoth \x22chunk end marker found\x22 ]].\x0a\x09\x09\x09\x09result nextPut: char ].\x0a\x09^ last := nil \x22a chunk needs to end with !\x22",
referencedClasses: [],
messageSends: ["writeStream", "whileTrue:", "next", "notNil", "ifTrue:", "=", "ifTrue:ifFalse:", "peek", "trimBoth", "contents", "nextPut:"]
}),
$globals.ChunkParser);

$core.addMethod(
$core.method({
selector: "stream:",
protocol: 'accessing',
fn: function (aStream){
var self=this;
self["@stream"]=aStream;
return self;

},
args: ["aStream"],
source: "stream: aStream\x0a\x09stream := aStream",
referencedClasses: [],
messageSends: []
}),
$globals.ChunkParser);


$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._new())._stream_(aStream);
}, function($ctx1) {$ctx1.fill(self,"on:",{aStream:aStream},$globals.ChunkParser.klass)});
},
args: ["aStream"],
source: "on: aStream\x0a\x09^ self new stream: aStream",
referencedClasses: [],
messageSends: ["stream:", "new"]
}),
$globals.ChunkParser.klass);


$core.addClass('ClassCommentReader', $globals.Object, ['class'], 'Platform-ImportExport');
$globals.ClassCommentReader.comment="I provide a mechanism for retrieving class comments stored on a file.\x0a\x0aSee also `ClassCategoryReader`.";
$core.addMethod(
$core.method({
selector: "class:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@class"]=aClass;
return self;

},
args: ["aClass"],
source: "class: aClass\x0a\x09class := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.ClassCommentReader);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.ClassCommentReader.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.ClassCommentReader)});
},
args: [],
source: "initialize\x0a\x09super initialize.",
referencedClasses: [],
messageSends: ["initialize"]
}),
$globals.ClassCommentReader);

$core.addMethod(
$core.method({
selector: "scanFrom:",
protocol: 'fileIn',
fn: function (aChunkParser){
var self=this;
var chunk;
return $core.withContext(function($ctx1) {
var $1;
chunk=$recv(aChunkParser)._nextChunk();
$1=$recv(chunk)._isEmpty();
if(!$core.assert($1)){
self._setComment_(chunk);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"scanFrom:",{aChunkParser:aChunkParser,chunk:chunk},$globals.ClassCommentReader)});
},
args: ["aChunkParser"],
source: "scanFrom: aChunkParser\x0a\x09| chunk |\x0a\x09chunk := aChunkParser nextChunk.\x0a\x09chunk isEmpty ifFalse: [\x0a\x09\x09self setComment: chunk ].",
referencedClasses: [],
messageSends: ["nextChunk", "ifFalse:", "isEmpty", "setComment:"]
}),
$globals.ClassCommentReader);

$core.addMethod(
$core.method({
selector: "setComment:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@class"])._comment_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"setComment:",{aString:aString},$globals.ClassCommentReader)});
},
args: ["aString"],
source: "setComment: aString\x0a\x09class comment: aString",
referencedClasses: [],
messageSends: ["comment:"]
}),
$globals.ClassCommentReader);



$core.addClass('ClassProtocolReader', $globals.Object, ['class', 'category'], 'Platform-ImportExport');
$globals.ClassProtocolReader.comment="I provide a mechanism for retrieving class descriptions stored on a file in the Smalltalk chunk format.";
$core.addMethod(
$core.method({
selector: "class:category:",
protocol: 'accessing',
fn: function (aClass,aString){
var self=this;
self["@class"]=aClass;
self["@category"]=aString;
return self;

},
args: ["aClass", "aString"],
source: "class: aClass category: aString\x0a\x09class := aClass.\x0a\x09category := aString",
referencedClasses: [],
messageSends: []
}),
$globals.ClassProtocolReader);

$core.addMethod(
$core.method({
selector: "compileMethod:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Compiler)._new())._install_forClass_protocol_(aString,self["@class"],self["@category"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"compileMethod:",{aString:aString},$globals.ClassProtocolReader)});
},
args: ["aString"],
source: "compileMethod: aString\x0a\x09Compiler new install: aString forClass: class protocol: category",
referencedClasses: ["Compiler"],
messageSends: ["install:forClass:protocol:", "new"]
}),
$globals.ClassProtocolReader);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.ClassProtocolReader.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.ClassProtocolReader)});
},
args: [],
source: "initialize\x0a\x09super initialize.",
referencedClasses: [],
messageSends: ["initialize"]
}),
$globals.ClassProtocolReader);

$core.addMethod(
$core.method({
selector: "scanFrom:",
protocol: 'fileIn',
fn: function (aChunkParser){
var self=this;
var chunk;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
chunk=$recv(aChunkParser)._nextChunk();
chunk;
return $recv(chunk)._isEmpty();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
return self._compileMethod_(chunk);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv($recv($globals.ClassBuilder)._new())._setupClass_(self["@class"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"scanFrom:",{aChunkParser:aChunkParser,chunk:chunk},$globals.ClassProtocolReader)});
},
args: ["aChunkParser"],
source: "scanFrom: aChunkParser\x0a\x09| chunk |\x0a\x09[ chunk := aChunkParser nextChunk.\x0a\x09chunk isEmpty ] whileFalse: [\x0a\x09\x09self compileMethod: chunk ].\x0a\x09ClassBuilder new setupClass: class",
referencedClasses: ["ClassBuilder"],
messageSends: ["whileFalse:", "nextChunk", "isEmpty", "compileMethod:", "setupClass:", "new"]
}),
$globals.ClassProtocolReader);



$core.addClass('ExportMethodProtocol', $globals.Object, ['name', 'theClass'], 'Platform-ImportExport');
$globals.ExportMethodProtocol.comment="I am an abstraction for a method protocol in a class / metaclass.\x0a\x0aI know of my class, name and methods.\x0aI am used when exporting a package.";
$core.addMethod(
$core.method({
selector: "methods",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv($recv(self._theClass())._methodsInProtocol_(self._name()))._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
$1=$recv(a)._selector();
$ctx2.sendIdx["selector"]=1;
return $recv($1).__lt_eq($recv(b)._selector());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"methods",{},$globals.ExportMethodProtocol)});
},
args: [],
source: "methods\x0a\x09^ (self theClass methodsInProtocol: self name)\x0a\x09\x09sorted: [ :a :b | a selector <= b selector ]",
referencedClasses: [],
messageSends: ["sorted:", "methodsInProtocol:", "theClass", "name", "<=", "selector"]
}),
$globals.ExportMethodProtocol);

$core.addMethod(
$core.method({
selector: "name",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@name"];

},
args: [],
source: "name\x0a\x09^ name",
referencedClasses: [],
messageSends: []
}),
$globals.ExportMethodProtocol);

$core.addMethod(
$core.method({
selector: "name:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@name"]=aString;
return self;

},
args: ["aString"],
source: "name: aString\x0a\x09name := aString",
referencedClasses: [],
messageSends: []
}),
$globals.ExportMethodProtocol);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@theClass"];

},
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
messageSends: []
}),
$globals.ExportMethodProtocol);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@theClass"]=aClass;
return self;

},
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.ExportMethodProtocol);


$core.addMethod(
$core.method({
selector: "name:theClass:",
protocol: 'instance creation',
fn: function (aString,aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._name_(aString);
$recv($1)._theClass_(aClass);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"name:theClass:",{aString:aString,aClass:aClass},$globals.ExportMethodProtocol.klass)});
},
args: ["aString", "aClass"],
source: "name: aString theClass: aClass\x0a\x09^ self new\x0a\x09\x09name: aString;\x0a\x09\x09theClass: aClass;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["name:", "new", "theClass:", "yourself"]
}),
$globals.ExportMethodProtocol.klass);


$core.addClass('Importer', $globals.Object, ['lastSection', 'lastChunk'], 'Platform-ImportExport');
$globals.Importer.comment="I can import Amber code from a string in the chunk format.\x0a\x0a## API\x0a\x0a    Importer new import: aString";
$core.addMethod(
$core.method({
selector: "import:",
protocol: 'fileIn',
fn: function (aStream){
var self=this;
var chunk,result,parser,lastEmpty;
return $core.withContext(function($ctx1) {
var $1,$2;
parser=$recv($globals.ChunkParser)._on_(aStream);
lastEmpty=false;
self["@lastSection"]="n/a, not started";
self["@lastChunk"]=nil;
$recv((function(){
return $core.withContext(function($ctx2) {
$recv((function(){
return $core.withContext(function($ctx3) {
chunk=$recv(parser)._nextChunk();
chunk;
return $recv(chunk)._isNil();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx3) {
$1=$recv(chunk)._isEmpty();
if($core.assert($1)){
lastEmpty=true;
return lastEmpty;
} else {
self["@lastSection"]=chunk;
self["@lastSection"];
result=$recv($recv($globals.Compiler)._new())._evaluateExpression_(chunk);
result;
$2=lastEmpty;
if($core.assert($2)){
lastEmpty=false;
lastEmpty;
return $recv(result)._scanFrom_(parser);
};
};
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
self["@lastSection"]="n/a, finished";
return self["@lastSection"];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(e){
return $core.withContext(function($ctx2) {
self["@lastChunk"]=$recv(parser)._last();
self["@lastChunk"];
return $recv(e)._resignal();
}, function($ctx2) {$ctx2.fillBlock({e:e},$ctx1,7)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"import:",{aStream:aStream,chunk:chunk,result:result,parser:parser,lastEmpty:lastEmpty},$globals.Importer)});
},
args: ["aStream"],
source: "import: aStream\x0a\x09| chunk result parser lastEmpty |\x0a\x09parser := ChunkParser on: aStream.\x0a\x09lastEmpty := false.\x0a\x09lastSection := 'n/a, not started'.\x0a\x09lastChunk := nil.\x0a\x09[\x0a\x09[ chunk := parser nextChunk.\x0a\x09chunk isNil ] whileFalse: [\x0a\x09\x09chunk isEmpty\x0a\x09\x09\x09ifTrue: [ lastEmpty := true ]\x0a\x09\x09\x09ifFalse: [\x0a\x09\x09\x09\x09lastSection := chunk.\x0a\x09\x09\x09\x09result := Compiler new evaluateExpression: chunk.\x0a\x09\x09\x09\x09lastEmpty\x0a\x09\x09\x09\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09lastEmpty := false.\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09result scanFrom: parser ]] ].\x0a\x09lastSection := 'n/a, finished'\x0a\x09] on: Error do: [:e | lastChunk := parser last. e resignal ].",
referencedClasses: ["ChunkParser", "Compiler", "Error"],
messageSends: ["on:", "on:do:", "whileFalse:", "nextChunk", "isNil", "ifTrue:ifFalse:", "isEmpty", "evaluateExpression:", "new", "ifTrue:", "scanFrom:", "last", "resignal"]
}),
$globals.Importer);

$core.addMethod(
$core.method({
selector: "lastChunk",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@lastChunk"];

},
args: [],
source: "lastChunk\x0a\x09^ lastChunk",
referencedClasses: [],
messageSends: []
}),
$globals.Importer);

$core.addMethod(
$core.method({
selector: "lastSection",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@lastSection"];

},
args: [],
source: "lastSection\x0a\x09^ lastSection",
referencedClasses: [],
messageSends: []
}),
$globals.Importer);



$core.addClass('PackageCommitError', $globals.Error, [], 'Platform-ImportExport');
$globals.PackageCommitError.comment="I get signaled when an attempt to commit a package has failed.";


$core.addClass('PackageHandler', $globals.InterfacingObject, [], 'Platform-ImportExport');
$globals.PackageHandler.comment="I am responsible for handling package loading and committing.\x0a\x0aI should not be used directly. Instead, use the corresponding `Package` methods.";
$core.addMethod(
$core.method({
selector: "ajaxPutAt:data:onSuccess:onError:",
protocol: 'private',
fn: function (aURL,aString,aBlock,anotherBlock){
var self=this;
var xhr;
return $core.withContext(function($ctx1) {
var $1,$4,$3,$2;
xhr=$recv($globals.Platform)._newXhr();
$recv(xhr)._open_url_async_("PUT",aURL,true);
$recv(xhr)._onreadystatechange_((function(){
return $core.withContext(function($ctx2) {
$1=$recv($recv(xhr)._readyState()).__eq((4));
if($core.assert($1)){
$4=$recv(xhr)._status();
$ctx2.sendIdx["status"]=1;
$3=$recv($4).__gt_eq((200));
$2=$recv($3)._and_((function(){
return $core.withContext(function($ctx3) {
return $recv($recv(xhr)._status()).__lt((300));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
return $recv($2)._ifTrue_ifFalse_(aBlock,anotherBlock);
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(xhr)._send_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"ajaxPutAt:data:onSuccess:onError:",{aURL:aURL,aString:aString,aBlock:aBlock,anotherBlock:anotherBlock,xhr:xhr},$globals.PackageHandler)});
},
args: ["aURL", "aString", "aBlock", "anotherBlock"],
source: "ajaxPutAt: aURL data: aString onSuccess: aBlock onError: anotherBlock\x0a\x09| xhr |\x0a\x09xhr := Platform newXhr.\x0a\x09xhr open: 'PUT' url: aURL async: true.\x0a\x09xhr onreadystatechange: [\x0a\x09\x09xhr readyState = 4 ifTrue: [\x0a\x09\x09\x09(xhr status >= 200 and: [ xhr status < 300 ])\x0a\x09\x09\x09\x09ifTrue: aBlock\x0a\x09\x09\x09\x09ifFalse: anotherBlock ]].\x0a\x09xhr send: aString",
referencedClasses: ["Platform"],
messageSends: ["newXhr", "open:url:async:", "onreadystatechange:", "ifTrue:", "=", "readyState", "ifTrue:ifFalse:", "and:", ">=", "status", "<", "send:"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "chunkContentsFor:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
return $recv(self._chunkExporter())._exportPackage_on_(aPackage,str);
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"chunkContentsFor:",{aPackage:aPackage},$globals.PackageHandler)});
},
args: ["aPackage"],
source: "chunkContentsFor: aPackage\x0a\x09^ String streamContents: [ :str |\x0a\x09\x09self chunkExporter exportPackage: aPackage on: str ]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "exportPackage:on:", "chunkExporter"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "chunkExporter",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._chunkExporterClass())._new();
}, function($ctx1) {$ctx1.fill(self,"chunkExporter",{},$globals.PackageHandler)});
},
args: [],
source: "chunkExporter\x0a\x09^ self chunkExporterClass new",
referencedClasses: [],
messageSends: ["new", "chunkExporterClass"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "chunkExporterClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.ChunkExporter;

},
args: [],
source: "chunkExporterClass\x0a\x09^ ChunkExporter",
referencedClasses: ["ChunkExporter"],
messageSends: []
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commit:",
protocol: 'committing',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
self._commit_onSuccess_onError_(aPackage,(function(){

}),(function(error){
return $core.withContext(function($ctx2) {
$1=$recv($globals.PackageCommitError)._new();
$2=$recv("Commiting failed with reason: \x22".__comma($recv(error)._responseText())).__comma("\x22");
$ctx2.sendIdx[","]=1;
$recv($1)._messageText_($2);
return $recv($1)._signal();
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"commit:",{aPackage:aPackage},$globals.PackageHandler)});
},
args: ["aPackage"],
source: "commit: aPackage\x0a\x09self \x0a\x09\x09commit: aPackage\x0a\x09\x09onSuccess: []\x0a\x09\x09onError: [ :error |\x0a\x09\x09\x09PackageCommitError new\x0a\x09\x09\x09\x09messageText: 'Commiting failed with reason: \x22' , (error responseText) , '\x22';\x0a\x09\x09\x09\x09signal ]",
referencedClasses: ["PackageCommitError"],
messageSends: ["commit:onSuccess:onError:", "messageText:", "new", ",", "responseText", "signal"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commit:onSuccess:onError:",
protocol: 'committing',
fn: function (aPackage,aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._commitJsFileFor_onSuccess_onError_(aPackage,(function(){
return $core.withContext(function($ctx2) {
return self._commitStFileFor_onSuccess_onError_(aPackage,(function(){
return $core.withContext(function($ctx3) {
$recv(aPackage)._beClean();
return $recv(aBlock)._value();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),anotherBlock);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),anotherBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"commit:onSuccess:onError:",{aPackage:aPackage,aBlock:aBlock,anotherBlock:anotherBlock},$globals.PackageHandler)});
},
args: ["aPackage", "aBlock", "anotherBlock"],
source: "commit: aPackage onSuccess: aBlock onError: anotherBlock\x0a\x09self \x0a\x09\x09commitJsFileFor: aPackage \x0a\x09\x09onSuccess: [\x0a\x09\x09\x09self \x0a\x09\x09\x09\x09commitStFileFor: aPackage \x0a\x09\x09\x09\x09onSuccess: [ aPackage beClean. aBlock value ]\x0a\x09\x09\x09\x09onError: anotherBlock ] \x0a\x09\x09onError: anotherBlock",
referencedClasses: [],
messageSends: ["commitJsFileFor:onSuccess:onError:", "commitStFileFor:onSuccess:onError:", "beClean", "value"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commitJsFileFor:onSuccess:onError:",
protocol: 'committing',
fn: function (aPackage,aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=$recv($recv(self._commitPathJsFor_(aPackage)).__comma("/")).__comma($recv(aPackage)._name());
$ctx1.sendIdx[","]=2;
$1=$recv($2).__comma(".js");
$ctx1.sendIdx[","]=1;
self._ajaxPutAt_data_onSuccess_onError_($1,self._contentsFor_(aPackage),aBlock,anotherBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"commitJsFileFor:onSuccess:onError:",{aPackage:aPackage,aBlock:aBlock,anotherBlock:anotherBlock},$globals.PackageHandler)});
},
args: ["aPackage", "aBlock", "anotherBlock"],
source: "commitJsFileFor: aPackage onSuccess: aBlock onError: anotherBlock\x0a\x09self \x0a\x09\x09ajaxPutAt: (self commitPathJsFor: aPackage), '/', aPackage name, '.js'\x0a\x09\x09data: (self contentsFor: aPackage)\x0a\x09\x09onSuccess: aBlock\x0a\x09\x09onError: anotherBlock",
referencedClasses: [],
messageSends: ["ajaxPutAt:data:onSuccess:onError:", ",", "commitPathJsFor:", "name", "contentsFor:"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commitPathJsFor:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"commitPathJsFor:",{aPackage:aPackage},$globals.PackageHandler)});
},
args: ["aPackage"],
source: "commitPathJsFor: aPackage\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commitPathStFor:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"commitPathStFor:",{aPackage:aPackage},$globals.PackageHandler)});
},
args: ["aPackage"],
source: "commitPathStFor: aPackage\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commitStFileFor:onSuccess:onError:",
protocol: 'committing',
fn: function (aPackage,aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=$recv($recv(self._commitPathStFor_(aPackage)).__comma("/")).__comma($recv(aPackage)._name());
$ctx1.sendIdx[","]=2;
$1=$recv($2).__comma(".st");
$ctx1.sendIdx[","]=1;
self._ajaxPutAt_data_onSuccess_onError_($1,self._chunkContentsFor_(aPackage),aBlock,anotherBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"commitStFileFor:onSuccess:onError:",{aPackage:aPackage,aBlock:aBlock,anotherBlock:anotherBlock},$globals.PackageHandler)});
},
args: ["aPackage", "aBlock", "anotherBlock"],
source: "commitStFileFor: aPackage onSuccess: aBlock onError: anotherBlock\x0a\x09self \x0a\x09\x09ajaxPutAt: (self commitPathStFor: aPackage), '/', aPackage name, '.st'\x0a\x09\x09data: (self chunkContentsFor: aPackage)\x0a\x09\x09onSuccess: aBlock\x0a\x09\x09onError: anotherBlock",
referencedClasses: [],
messageSends: ["ajaxPutAt:data:onSuccess:onError:", ",", "commitPathStFor:", "name", "chunkContentsFor:"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "contentsFor:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
return $recv(self._exporter())._exportPackage_on_(aPackage,str);
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"contentsFor:",{aPackage:aPackage},$globals.PackageHandler)});
},
args: ["aPackage"],
source: "contentsFor: aPackage\x0a\x09^ String streamContents: [ :str |\x0a\x09\x09self exporter exportPackage: aPackage on: str ]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "exportPackage:on:", "exporter"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "exporter",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._exporterClass())._new();
}, function($ctx1) {$ctx1.fill(self,"exporter",{},$globals.PackageHandler)});
},
args: [],
source: "exporter\x0a\x09^ self exporterClass new",
referencedClasses: [],
messageSends: ["new", "exporterClass"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "exporterClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"exporterClass",{},$globals.PackageHandler)});
},
args: [],
source: "exporterClass\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "load:",
protocol: 'loading',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"load:",{aPackage:aPackage},$globals.PackageHandler)});
},
args: ["aPackage"],
source: "load: aPackage\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "onCommitError:",
protocol: 'error handling',
fn: function (anError){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv($globals.PackageCommitError)._new();
$2=$recv("Commiting failed with reason: \x22".__comma($recv(anError)._responseText())).__comma("\x22");
$ctx1.sendIdx[","]=1;
$recv($1)._messageText_($2);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"onCommitError:",{anError:anError},$globals.PackageHandler)});
},
args: ["anError"],
source: "onCommitError: anError\x0a\x09PackageCommitError new\x0a\x09\x09messageText: 'Commiting failed with reason: \x22' , (anError responseText) , '\x22';\x0a\x09\x09signal",
referencedClasses: ["PackageCommitError"],
messageSends: ["messageText:", "new", ",", "responseText", "signal"]
}),
$globals.PackageHandler);



$core.addClass('AmdPackageHandler', $globals.PackageHandler, [], 'Platform-ImportExport');
$globals.AmdPackageHandler.comment="I am responsible for handling package loading and committing.\x0a\x0aI should not be used directly. Instead, use the corresponding `Package` methods.";
$core.addMethod(
$core.method({
selector: "commitPathJsFor:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
return self._toUrl_(self._namespaceFor_(aPackage));
}, function($ctx1) {$ctx1.fill(self,"commitPathJsFor:",{aPackage:aPackage},$globals.AmdPackageHandler)});
},
args: ["aPackage"],
source: "commitPathJsFor: aPackage\x0a\x09^ self toUrl: (self namespaceFor: aPackage)",
referencedClasses: [],
messageSends: ["toUrl:", "namespaceFor:"]
}),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "commitPathStFor:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
var path,pathWithout;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv(self._namespaceFor_(aPackage)).__comma("/_source");
$ctx1.sendIdx[","]=1;
path=self._toUrl_($1);
pathWithout=self._commitPathJsFor_(aPackage);
$2=$recv(path).__eq($recv(pathWithout).__comma("/_source"));
if($core.assert($2)){
return pathWithout;
} else {
return path;
};
}, function($ctx1) {$ctx1.fill(self,"commitPathStFor:",{aPackage:aPackage,path:path,pathWithout:pathWithout},$globals.AmdPackageHandler)});
},
args: ["aPackage"],
source: "commitPathStFor: aPackage\x0a\x09\x22If _source is not mapped, .st will be committed to .js path.\x0a\x09It is recommended not to use _source as it can be deprecated.\x22\x0a\x09\x0a\x09| path pathWithout |\x0a\x09path := self toUrl: (self namespaceFor: aPackage), '/_source'.\x0a\x09pathWithout := self commitPathJsFor: aPackage.\x0a\x09^ path = (pathWithout, '/_source') ifTrue: [ pathWithout ] ifFalse: [ path ]",
referencedClasses: [],
messageSends: ["toUrl:", ",", "namespaceFor:", "commitPathJsFor:", "ifTrue:ifFalse:", "="]
}),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "exporterClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.AmdExporter;

},
args: [],
source: "exporterClass\x0a\x09^ AmdExporter",
referencedClasses: ["AmdExporter"],
messageSends: []
}),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "load:",
protocol: 'loading',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$receiver;
$1=$recv($globals.Smalltalk)._amdRequire();
if(($receiver = $1) == null || $receiver.isNil){
self._error_("AMD loader not present");
} else {
var require;
require=$receiver;
$3=$recv($recv(self._namespaceFor_(aPackage)).__comma("/")).__comma($recv(aPackage)._name());
$ctx1.sendIdx[","]=1;
$2=$recv($globals.Array)._with_($3);
$recv(require)._value_($2);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"load:",{aPackage:aPackage},$globals.AmdPackageHandler)});
},
args: ["aPackage"],
source: "load: aPackage\x0a\x09Smalltalk amdRequire\x0a\x09\x09ifNil: [ self error: 'AMD loader not present' ]\x0a\x09\x09ifNotNil: [ :require |\x0a\x09\x09\x09require value: (Array with: (self namespaceFor: aPackage), '/', aPackage name ) ]",
referencedClasses: ["Smalltalk", "Array"],
messageSends: ["ifNil:ifNotNil:", "amdRequire", "error:", "value:", "with:", ",", "namespaceFor:", "name"]
}),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "namespaceFor:",
protocol: 'committing',
fn: function (aPackage){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aPackage)._transport())._namespace();
}, function($ctx1) {$ctx1.fill(self,"namespaceFor:",{aPackage:aPackage},$globals.AmdPackageHandler)});
},
args: ["aPackage"],
source: "namespaceFor: aPackage\x0a\x09^ aPackage transport namespace",
referencedClasses: [],
messageSends: ["namespace", "transport"]
}),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "toUrl:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv($globals.Smalltalk)._amdRequire();
if(($receiver = $1) == null || $receiver.isNil){
return self._error_("AMD loader not present");
} else {
var require;
require=$receiver;
return $recv($recv(require)._basicAt_("toUrl"))._value_(aString);
};
}, function($ctx1) {$ctx1.fill(self,"toUrl:",{aString:aString},$globals.AmdPackageHandler)});
},
args: ["aString"],
source: "toUrl: aString\x0a\x09^ Smalltalk amdRequire\x0a\x09\x09ifNil: [ self error: 'AMD loader not present' ]\x0a\x09\x09ifNotNil: [ :require | (require basicAt: 'toUrl') value: aString ]",
referencedClasses: ["Smalltalk"],
messageSends: ["ifNil:ifNotNil:", "amdRequire", "error:", "value:", "basicAt:"]
}),
$globals.AmdPackageHandler);


$core.addMethod(
$core.method({
selector: "defaultNamespace",
protocol: 'commit paths',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._defaultAmdNamespace();
}, function($ctx1) {$ctx1.fill(self,"defaultNamespace",{},$globals.AmdPackageHandler.klass)});
},
args: [],
source: "defaultNamespace\x0a\x09^ Smalltalk defaultAmdNamespace",
referencedClasses: ["Smalltalk"],
messageSends: ["defaultAmdNamespace"]
}),
$globals.AmdPackageHandler.klass);

$core.addMethod(
$core.method({
selector: "defaultNamespace:",
protocol: 'commit paths',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Smalltalk)._defaultAmdNamespace_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"defaultNamespace:",{aString:aString},$globals.AmdPackageHandler.klass)});
},
args: ["aString"],
source: "defaultNamespace: aString\x0a\x09Smalltalk defaultAmdNamespace: aString",
referencedClasses: ["Smalltalk"],
messageSends: ["defaultAmdNamespace:"]
}),
$globals.AmdPackageHandler.klass);


$core.addClass('PackageTransport', $globals.Object, ['package'], 'Platform-ImportExport');
$globals.PackageTransport.comment="I represent the transport mechanism used to commit a package.\x0a\x0aMy concrete subclasses have a `#handler` to which committing is delegated.";
$core.addMethod(
$core.method({
selector: "asJSON",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $globals.HashedCollection._newFromPairs_(["type",self._type()]);
}, function($ctx1) {$ctx1.fill(self,"asJSON",{},$globals.PackageTransport)});
},
args: [],
source: "asJSON\x0a\x09^ #{ 'type' -> self type }",
referencedClasses: [],
messageSends: ["type"]
}),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "commit",
protocol: 'committing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._commitHandler())._commit_(self._package());
return self;
}, function($ctx1) {$ctx1.fill(self,"commit",{},$globals.PackageTransport)});
},
args: [],
source: "commit\x0a\x09self commitHandler commit: self package",
referencedClasses: [],
messageSends: ["commit:", "commitHandler", "package"]
}),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "commitHandler",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._commitHandlerClass())._new();
}, function($ctx1) {$ctx1.fill(self,"commitHandler",{},$globals.PackageTransport)});
},
args: [],
source: "commitHandler\x0a\x09^ self commitHandlerClass new",
referencedClasses: [],
messageSends: ["new", "commitHandlerClass"]
}),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "commitHandlerClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"commitHandlerClass",{},$globals.PackageTransport)});
},
args: [],
source: "commitHandlerClass\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "commitOnSuccess:onError:",
protocol: 'committing',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._commitHandler())._commit_onSuccess_onError_(self._package(),aBlock,anotherBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"commitOnSuccess:onError:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.PackageTransport)});
},
args: ["aBlock", "anotherBlock"],
source: "commitOnSuccess: aBlock onError: anotherBlock\x0a\x09self commitHandler \x0a\x09\x09commit: self package\x0a\x09\x09onSuccess: aBlock\x0a\x09\x09onError: anotherBlock",
referencedClasses: [],
messageSends: ["commit:onSuccess:onError:", "commitHandler", "package"]
}),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "definition",
protocol: 'accessing',
fn: function (){
var self=this;
return "";

},
args: [],
source: "definition\x0a\x09^ ''",
referencedClasses: [],
messageSends: []
}),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "load",
protocol: 'loading',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._commitHandler())._load_(self._package());
return self;
}, function($ctx1) {$ctx1.fill(self,"load",{},$globals.PackageTransport)});
},
args: [],
source: "load\x0a\x09self commitHandler load: self package",
referencedClasses: [],
messageSends: ["load:", "commitHandler", "package"]
}),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "package",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@package"];

},
args: [],
source: "package\x0a\x09^ package",
referencedClasses: [],
messageSends: []
}),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "package:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
self["@package"]=aPackage;
return self;

},
args: ["aPackage"],
source: "package: aPackage\x0a\x09package := aPackage",
referencedClasses: [],
messageSends: []
}),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "setupFromJson:",
protocol: 'initialization',
fn: function (anObject){
var self=this;
return self;

},
args: ["anObject"],
source: "setupFromJson: anObject\x0a\x09\x22no op. override if needed in subclasses\x22",
referencedClasses: [],
messageSends: []
}),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "type",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._class())._type();
}, function($ctx1) {$ctx1.fill(self,"type",{},$globals.PackageTransport)});
},
args: [],
source: "type\x0a\x09^ self class type",
referencedClasses: [],
messageSends: ["type", "class"]
}),
$globals.PackageTransport);


$globals.PackageTransport.klass.iVarNames = ['registry'];
$core.addMethod(
$core.method({
selector: "classRegisteredFor:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@registry"])._at_(aString);
}, function($ctx1) {$ctx1.fill(self,"classRegisteredFor:",{aString:aString},$globals.PackageTransport.klass)});
},
args: ["aString"],
source: "classRegisteredFor: aString\x0a\x09^ registry at: aString",
referencedClasses: [],
messageSends: ["at:"]
}),
$globals.PackageTransport.klass);

$core.addMethod(
$core.method({
selector: "defaultType",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.AmdPackageTransport)._type();
}, function($ctx1) {$ctx1.fill(self,"defaultType",{},$globals.PackageTransport.klass)});
},
args: [],
source: "defaultType\x0a\x09^ AmdPackageTransport type",
referencedClasses: ["AmdPackageTransport"],
messageSends: ["type"]
}),
$globals.PackageTransport.klass);

$core.addMethod(
$core.method({
selector: "for:",
protocol: 'instance creation',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._classRegisteredFor_(aString))._new();
}, function($ctx1) {$ctx1.fill(self,"for:",{aString:aString},$globals.PackageTransport.klass)});
},
args: ["aString"],
source: "for: aString\x0a\x09^ (self classRegisteredFor: aString) new",
referencedClasses: [],
messageSends: ["new", "classRegisteredFor:"]
}),
$globals.PackageTransport.klass);

$core.addMethod(
$core.method({
selector: "fromJson:",
protocol: 'instance creation',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
if(($receiver = anObject) == null || $receiver.isNil){
$1=self._for_(self._defaultType());
$ctx1.sendIdx["for:"]=1;
return $1;
} else {
anObject;
};
$2=self._for_($recv(anObject)._type());
$recv($2)._setupFromJson_(anObject);
return $recv($2)._yourself();
}, function($ctx1) {$ctx1.fill(self,"fromJson:",{anObject:anObject},$globals.PackageTransport.klass)});
},
args: ["anObject"],
source: "fromJson: anObject\x0a\x09anObject ifNil: [ ^ self for: self defaultType ].\x0a\x09\x0a\x09^ (self for: anObject type)\x0a\x09\x09setupFromJson: anObject;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["ifNil:", "for:", "defaultType", "setupFromJson:", "type", "yourself"]
}),
$globals.PackageTransport.klass);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
(
$ctx1.supercall = true,
($globals.PackageTransport.klass.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
$1=self.__eq_eq($globals.PackageTransport);
if($core.assert($1)){
self["@registry"]=$globals.HashedCollection._newFromPairs_([]);
self["@registry"];
} else {
self._register();
};
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.PackageTransport.klass)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09self == PackageTransport\x0a\x09\x09ifTrue: [ registry := #{} ]\x0a\x09\x09ifFalse: [ self register ]",
referencedClasses: ["PackageTransport"],
messageSends: ["initialize", "ifTrue:ifFalse:", "==", "register"]
}),
$globals.PackageTransport.klass);

$core.addMethod(
$core.method({
selector: "register",
protocol: 'registration',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.PackageTransport)._register_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"register",{},$globals.PackageTransport.klass)});
},
args: [],
source: "register\x0a\x09PackageTransport register: self",
referencedClasses: ["PackageTransport"],
messageSends: ["register:"]
}),
$globals.PackageTransport.klass);

$core.addMethod(
$core.method({
selector: "register:",
protocol: 'registration',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv(aClass)._type();
$ctx1.sendIdx["type"]=1;
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
$recv(self["@registry"])._at_put_($recv(aClass)._type(),aClass);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"register:",{aClass:aClass},$globals.PackageTransport.klass)});
},
args: ["aClass"],
source: "register: aClass\x0a\x09aClass type ifNotNil: [\x0a\x09\x09registry at: aClass type put: aClass ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "type", "at:put:"]
}),
$globals.PackageTransport.klass);

$core.addMethod(
$core.method({
selector: "type",
protocol: 'accessing',
fn: function (){
var self=this;
return nil;

},
args: [],
source: "type\x0a\x09\x22Override in subclasses\x22\x0a\x09^ nil",
referencedClasses: [],
messageSends: []
}),
$globals.PackageTransport.klass);


$core.addClass('AmdPackageTransport', $globals.PackageTransport, ['namespace'], 'Platform-ImportExport');
$globals.AmdPackageTransport.comment="I am the default transport for committing packages.\x0a\x0aSee `AmdExporter` and `AmdPackageHandler`.";
$core.addMethod(
$core.method({
selector: "asJSON",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=(
$ctx1.supercall = true,
($globals.AmdPackageTransport.superclass||$boot.dnu).fn.prototype._asJSON.apply($recv(self), []));
$ctx1.supercall = false;
$recv($1)._at_put_("amdNamespace",self._namespace());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"asJSON",{},$globals.AmdPackageTransport)});
},
args: [],
source: "asJSON\x0a\x09^ super asJSON\x0a\x09\x09at: 'amdNamespace' put: self namespace;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["at:put:", "asJSON", "namespace", "yourself"]
}),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "commitHandlerClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.AmdPackageHandler;

},
args: [],
source: "commitHandlerClass\x0a\x09^ AmdPackageHandler",
referencedClasses: ["AmdPackageHandler"],
messageSends: []
}),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "defaultNamespace",
protocol: 'defaults',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._defaultAmdNamespace();
}, function($ctx1) {$ctx1.fill(self,"defaultNamespace",{},$globals.AmdPackageTransport)});
},
args: [],
source: "defaultNamespace\x0a\x09^ Smalltalk defaultAmdNamespace",
referencedClasses: ["Smalltalk"],
messageSends: ["defaultAmdNamespace"]
}),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "definition",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
$recv(stream)._nextPutAll_($recv(self._class())._name());
$ctx2.sendIdx["nextPutAll:"]=1;
$recv(stream)._nextPutAll_(" namespace: ");
$ctx2.sendIdx["nextPutAll:"]=2;
$1=$recv("'".__comma(self._namespace())).__comma("'");
$ctx2.sendIdx[","]=1;
return $recv(stream)._nextPutAll_($1);
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"definition",{},$globals.AmdPackageTransport)});
},
args: [],
source: "definition\x0a\x09^ String streamContents: [ :stream |\x0a\x09\x09stream \x0a\x09\x09\x09nextPutAll: self class name;\x0a\x09\x09\x09nextPutAll: ' namespace: ';\x0a\x09\x09\x09nextPutAll: '''', self namespace, '''' ]",
referencedClasses: ["String"],
messageSends: ["streamContents:", "nextPutAll:", "name", "class", ",", "namespace"]
}),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "namespace",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@namespace"];
if(($receiver = $1) == null || $receiver.isNil){
return self._defaultNamespace();
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"namespace",{},$globals.AmdPackageTransport)});
},
args: [],
source: "namespace\x0a\x09^ namespace ifNil: [ self defaultNamespace ]",
referencedClasses: [],
messageSends: ["ifNil:", "defaultNamespace"]
}),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "namespace:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@namespace"]=aString;
return self;

},
args: ["aString"],
source: "namespace: aString\x0a\x09namespace := aString",
referencedClasses: [],
messageSends: []
}),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: 'printing',
fn: function (aStream){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.AmdPackageTransport.superclass||$boot.dnu).fn.prototype._printOn_.apply($recv(self), [aStream]));
$ctx1.supercall = false;
$recv(aStream)._nextPutAll_(" (AMD Namespace: ");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aStream)._nextPutAll_(self._namespace());
$ctx1.sendIdx["nextPutAll:"]=2;
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream},$globals.AmdPackageTransport)});
},
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09aStream\x0a\x09\x09nextPutAll: ' (AMD Namespace: ';\x0a\x09\x09nextPutAll: self namespace;\x0a\x09\x09nextPutAll: ')'",
referencedClasses: [],
messageSends: ["printOn:", "nextPutAll:", "namespace"]
}),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "setPath:",
protocol: 'actions',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(require)._basicAt_("config"))._value_($globals.HashedCollection._newFromPairs_(["paths",$globals.HashedCollection._newFromPairs_([self._namespace(),aString])]));
return self;
}, function($ctx1) {$ctx1.fill(self,"setPath:",{aString:aString},$globals.AmdPackageTransport)});
},
args: ["aString"],
source: "setPath: aString\x0a\x09\x22Set the path the the receiver's `namespace`\x22\x0a\x09\x0a\x09(require basicAt: 'config') value: #{\x0a\x09\x09'paths' -> #{\x0a\x09\x09\x09self namespace -> aString\x0a\x09\x09}\x0a\x09}.",
referencedClasses: [],
messageSends: ["value:", "basicAt:", "namespace"]
}),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "setupFromJson:",
protocol: 'initialization',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
self._namespace_($recv(anObject)._at_("amdNamespace"));
return self;
}, function($ctx1) {$ctx1.fill(self,"setupFromJson:",{anObject:anObject},$globals.AmdPackageTransport)});
},
args: ["anObject"],
source: "setupFromJson: anObject\x0a\x09self namespace: (anObject at: 'amdNamespace')",
referencedClasses: [],
messageSends: ["namespace:", "at:"]
}),
$globals.AmdPackageTransport);


$core.addMethod(
$core.method({
selector: "namespace:",
protocol: 'instance creation',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._namespace_(aString);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"namespace:",{aString:aString},$globals.AmdPackageTransport.klass)});
},
args: ["aString"],
source: "namespace: aString\x0a\x09^ self new\x0a\x09\x09namespace: aString;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["namespace:", "new", "yourself"]
}),
$globals.AmdPackageTransport.klass);

$core.addMethod(
$core.method({
selector: "type",
protocol: 'accessing',
fn: function (){
var self=this;
return "amd";

},
args: [],
source: "type\x0a\x09^ 'amd'",
referencedClasses: [],
messageSends: []
}),
$globals.AmdPackageTransport.klass);

$core.addMethod(
$core.method({
selector: "commentStamp",
protocol: '*Platform-ImportExport',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ClassCommentReader)._new();
$recv($1)._class_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"commentStamp",{},$globals.Behavior)});
},
args: [],
source: "commentStamp\x0a\x09^ ClassCommentReader new\x0a\x09class: self;\x0a\x09yourself",
referencedClasses: ["ClassCommentReader"],
messageSends: ["class:", "new", "yourself"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "commentStamp:prior:",
protocol: '*Platform-ImportExport',
fn: function (aStamp,prior){
var self=this;
return $core.withContext(function($ctx1) {
return self._commentStamp();
}, function($ctx1) {$ctx1.fill(self,"commentStamp:prior:",{aStamp:aStamp,prior:prior},$globals.Behavior)});
},
args: ["aStamp", "prior"],
source: "commentStamp: aStamp prior: prior\x0a\x09\x09^ self commentStamp",
referencedClasses: [],
messageSends: ["commentStamp"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "methodsFor:",
protocol: '*Platform-ImportExport',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ClassProtocolReader)._new();
$recv($1)._class_category_(self,aString);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"methodsFor:",{aString:aString},$globals.Behavior)});
},
args: ["aString"],
source: "methodsFor: aString\x0a\x09^ ClassProtocolReader new\x0a\x09\x09class: self category: aString;\x0a\x09\x09yourself",
referencedClasses: ["ClassProtocolReader"],
messageSends: ["class:category:", "new", "yourself"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "methodsFor:stamp:",
protocol: '*Platform-ImportExport',
fn: function (aString,aStamp){
var self=this;
return $core.withContext(function($ctx1) {
return self._methodsFor_(aString);
}, function($ctx1) {$ctx1.fill(self,"methodsFor:stamp:",{aString:aString,aStamp:aStamp},$globals.Behavior)});
},
args: ["aString", "aStamp"],
source: "methodsFor: aString stamp: aStamp\x0a\x09\x22Added for file-in compatibility, ignores stamp.\x22\x0a\x09^ self methodsFor: aString",
referencedClasses: [],
messageSends: ["methodsFor:"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "commit",
protocol: '*Platform-ImportExport',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._transport())._commit();
}, function($ctx1) {$ctx1.fill(self,"commit",{},$globals.Package)});
},
args: [],
source: "commit\x0a\x09^ self transport commit",
referencedClasses: [],
messageSends: ["commit", "transport"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "load",
protocol: '*Platform-ImportExport',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._transport())._load();
}, function($ctx1) {$ctx1.fill(self,"load",{},$globals.Package)});
},
args: [],
source: "load\x0a\x09^ self transport load",
referencedClasses: [],
messageSends: ["load", "transport"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "loadFromNamespace:",
protocol: '*Platform-ImportExport',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._transport();
$recv($1)._namespace_(aString);
return $recv($1)._load();
}, function($ctx1) {$ctx1.fill(self,"loadFromNamespace:",{aString:aString},$globals.Package)});
},
args: ["aString"],
source: "loadFromNamespace: aString\x0a\x09^ self transport\x0a\x09\x09namespace: aString;\x0a\x09\x09load",
referencedClasses: [],
messageSends: ["namespace:", "transport", "load"]
}),
$globals.Package);

$core.addMethod(
$core.method({
selector: "load:",
protocol: '*Platform-ImportExport',
fn: function (aPackageName){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._named_(aPackageName))._load();
return self;
}, function($ctx1) {$ctx1.fill(self,"load:",{aPackageName:aPackageName},$globals.Package.klass)});
},
args: ["aPackageName"],
source: "load: aPackageName\x0a\x09(self named: aPackageName) load",
referencedClasses: [],
messageSends: ["load", "named:"]
}),
$globals.Package.klass);

$core.addMethod(
$core.method({
selector: "load:fromNamespace:",
protocol: '*Platform-ImportExport',
fn: function (aPackageName,aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._named_(aPackageName))._loadFromNamespace_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"load:fromNamespace:",{aPackageName:aPackageName,aString:aString},$globals.Package.klass)});
},
args: ["aPackageName", "aString"],
source: "load: aPackageName fromNamespace: aString\x0a\x09(self named: aPackageName) loadFromNamespace: aString",
referencedClasses: [],
messageSends: ["loadFromNamespace:", "named:"]
}),
$globals.Package.klass);

});

define("amber_core/Compiler-Core", ["amber/boot", "amber_core/Kernel-Objects", "amber_core/Kernel-Exceptions", "amber_core/Platform-Services", "amber_core/Kernel-Collections"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Compiler-Core');
$core.packages["Compiler-Core"].innerEval = function (expr) { return eval(expr); };
$core.packages["Compiler-Core"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('AbstractCodeGenerator', $globals.Object, ['currentClass', 'currentPackage', 'source'], 'Compiler-Core');
$globals.AbstractCodeGenerator.comment="I am the abstract super class of all code generators and provide their common API.";
$core.addMethod(
$core.method({
selector: "classNameFor:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$4,$1;
$2=$recv(aClass)._isMetaclass();
if($core.assert($2)){
$3=$recv($recv(aClass)._instanceClass())._name();
$ctx1.sendIdx["name"]=1;
$1=$recv($3).__comma(".klass");
} else {
$4=$recv(aClass)._isNil();
if($core.assert($4)){
$1="nil";
} else {
$1=$recv(aClass)._name();
};
};
return $1;
}, function($ctx1) {$ctx1.fill(self,"classNameFor:",{aClass:aClass},$globals.AbstractCodeGenerator)});
},
args: ["aClass"],
source: "classNameFor: aClass\x0a\x09^ aClass isMetaclass\x0a\x09\x09ifTrue: [ aClass instanceClass name, '.klass' ]\x0a\x09\x09ifFalse: [\x0a\x09\x09aClass isNil\x0a\x09\x09\x09ifTrue: [ 'nil' ]\x0a\x09\x09\x09ifFalse: [ aClass name ]]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "isMetaclass", ",", "name", "instanceClass", "isNil"]
}),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "compileNode:",
protocol: 'compiling',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"compileNode:",{aNode:aNode},$globals.AbstractCodeGenerator)});
},
args: ["aNode"],
source: "compileNode: aNode\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "currentClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@currentClass"];

},
args: [],
source: "currentClass\x0a\x09^ currentClass",
referencedClasses: [],
messageSends: []
}),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "currentClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@currentClass"]=aClass;
return self;

},
args: ["aClass"],
source: "currentClass: aClass\x0a\x09currentClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "currentPackage",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@currentPackage"];

},
args: [],
source: "currentPackage\x0a\x09^ currentPackage",
referencedClasses: [],
messageSends: []
}),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "currentPackage:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@currentPackage"]=anObject;
return self;

},
args: ["anObject"],
source: "currentPackage: anObject\x0a\x09currentPackage := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "pseudoVariables",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._pseudoVariableNames();
}, function($ctx1) {$ctx1.fill(self,"pseudoVariables",{},$globals.AbstractCodeGenerator)});
},
args: [],
source: "pseudoVariables\x0a\x09^ Smalltalk pseudoVariableNames",
referencedClasses: ["Smalltalk"],
messageSends: ["pseudoVariableNames"]
}),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "source",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@source"];
if(($receiver = $1) == null || $receiver.isNil){
return "";
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"source",{},$globals.AbstractCodeGenerator)});
},
args: [],
source: "source\x0a\x09^ source ifNil: [ '' ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "source:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@source"]=aString;
return self;

},
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
messageSends: []
}),
$globals.AbstractCodeGenerator);



$core.addClass('CodeGenerator', $globals.AbstractCodeGenerator, [], 'Compiler-Core');
$globals.CodeGenerator.comment="I am a basic code generator. I generate a valid JavaScript output, but no not perform any inlining.\x0aSee `InliningCodeGenerator` for an optimized JavaScript code generation.";
$core.addMethod(
$core.method({
selector: "compileNode:",
protocol: 'compiling',
fn: function (aNode){
var self=this;
var ir,stream;
return $core.withContext(function($ctx1) {
var $1;
$recv(self._semanticAnalyzer())._visit_(aNode);
$ctx1.sendIdx["visit:"]=1;
ir=$recv(self._translator())._visit_(aNode);
$ctx1.sendIdx["visit:"]=2;
$1=self._irTranslator();
$recv($1)._currentClass_(self._currentClass());
$recv($1)._visit_(ir);
return $recv($1)._contents();
}, function($ctx1) {$ctx1.fill(self,"compileNode:",{aNode:aNode,ir:ir,stream:stream},$globals.CodeGenerator)});
},
args: ["aNode"],
source: "compileNode: aNode\x0a\x09| ir stream |\x0a\x09self semanticAnalyzer visit: aNode.\x0a\x09ir := self translator visit: aNode.\x0a\x09^ self irTranslator\x0a\x09\x09currentClass: self currentClass;\x0a\x09\x09visit: ir;\x0a\x09\x09contents",
referencedClasses: [],
messageSends: ["visit:", "semanticAnalyzer", "translator", "currentClass:", "irTranslator", "currentClass", "contents"]
}),
$globals.CodeGenerator);

$core.addMethod(
$core.method({
selector: "irTranslator",
protocol: 'compiling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.IRJSTranslator)._new();
}, function($ctx1) {$ctx1.fill(self,"irTranslator",{},$globals.CodeGenerator)});
},
args: [],
source: "irTranslator\x0a\x09^ IRJSTranslator new",
referencedClasses: ["IRJSTranslator"],
messageSends: ["new"]
}),
$globals.CodeGenerator);

$core.addMethod(
$core.method({
selector: "semanticAnalyzer",
protocol: 'compiling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.SemanticAnalyzer)._on_(self._currentClass());
$recv($1)._thePackage_(self._currentPackage());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"semanticAnalyzer",{},$globals.CodeGenerator)});
},
args: [],
source: "semanticAnalyzer\x0a\x09^ (SemanticAnalyzer on: self currentClass)\x0a\x09\x09thePackage: self currentPackage;\x0a\x09\x09yourself",
referencedClasses: ["SemanticAnalyzer"],
messageSends: ["thePackage:", "on:", "currentClass", "currentPackage", "yourself"]
}),
$globals.CodeGenerator);

$core.addMethod(
$core.method({
selector: "translator",
protocol: 'compiling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRASTTranslator)._new();
$recv($1)._source_(self._source());
$recv($1)._theClass_(self._currentClass());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"translator",{},$globals.CodeGenerator)});
},
args: [],
source: "translator\x0a\x09^ IRASTTranslator new\x0a\x09\x09source: self source;\x0a\x09\x09theClass: self currentClass;\x0a\x09\x09yourself",
referencedClasses: ["IRASTTranslator"],
messageSends: ["source:", "new", "source", "theClass:", "currentClass", "yourself"]
}),
$globals.CodeGenerator);



$core.addClass('Compiler', $globals.Object, ['currentClass', 'currentPackage', 'source', 'unknownVariables', 'codeGeneratorClass'], 'Compiler-Core');
$globals.Compiler.comment="I provide the public interface for compiling Amber source code into JavaScript.\x0a\x0aThe code generator used to produce JavaScript can be plugged with `#codeGeneratorClass`.\x0aThe default code generator is an instance of `InlinedCodeGenerator`";
$core.addMethod(
$core.method({
selector: "codeGeneratorClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@codeGeneratorClass"];
if(($receiver = $1) == null || $receiver.isNil){
return $globals.InliningCodeGenerator;
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"codeGeneratorClass",{},$globals.Compiler)});
},
args: [],
source: "codeGeneratorClass\x0a\x09^ codeGeneratorClass ifNil: [ InliningCodeGenerator ]",
referencedClasses: ["InliningCodeGenerator"],
messageSends: ["ifNil:"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "codeGeneratorClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@codeGeneratorClass"]=aClass;
return self;

},
args: ["aClass"],
source: "codeGeneratorClass: aClass\x0a\x09codeGeneratorClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "compile:forClass:protocol:",
protocol: 'compiling',
fn: function (aString,aClass,anotherString){
var self=this;
return $core.withContext(function($ctx1) {
self._source_(aString);
return self._compileNode_forClass_package_(self._parse_(aString),aClass,$recv(aClass)._packageOfProtocol_(anotherString));
}, function($ctx1) {$ctx1.fill(self,"compile:forClass:protocol:",{aString:aString,aClass:aClass,anotherString:anotherString},$globals.Compiler)});
},
args: ["aString", "aClass", "anotherString"],
source: "compile: aString forClass: aClass protocol: anotherString\x0a\x09^ self\x0a\x09\x09source: aString;\x0a\x09\x09compileNode: (self parse: aString)\x0a\x09\x09forClass: aClass\x0a\x09\x09package: (aClass packageOfProtocol: anotherString)",
referencedClasses: [],
messageSends: ["source:", "compileNode:forClass:package:", "parse:", "packageOfProtocol:"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "compileExpression:on:",
protocol: 'compiling',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv("xxxDoIt ^ [ ".__comma(aString)).__comma(" ] value");
$ctx1.sendIdx[","]=1;
return self._compile_forClass_protocol_($1,$recv(anObject)._class(),"**xxxDoIt");
}, function($ctx1) {$ctx1.fill(self,"compileExpression:on:",{aString:aString,anObject:anObject},$globals.Compiler)});
},
args: ["aString", "anObject"],
source: "compileExpression: aString on: anObject\x0a\x09^ self\x0a\x09\x09compile: 'xxxDoIt ^ [ ', aString, ' ] value'\x0a\x09\x09forClass: anObject class\x0a\x09\x09protocol: '**xxxDoIt'",
referencedClasses: [],
messageSends: ["compile:forClass:protocol:", ",", "class"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "compileNode:",
protocol: 'compiling',
fn: function (aNode){
var self=this;
var generator,result;
return $core.withContext(function($ctx1) {
var $1;
generator=$recv(self._codeGeneratorClass())._new();
$1=generator;
$recv($1)._source_(self._source());
$recv($1)._currentClass_(self._currentClass());
$recv($1)._currentPackage_(self._currentPackage());
result=$recv(generator)._compileNode_(aNode);
self._unknownVariables_([]);
return result;
}, function($ctx1) {$ctx1.fill(self,"compileNode:",{aNode:aNode,generator:generator,result:result},$globals.Compiler)});
},
args: ["aNode"],
source: "compileNode: aNode\x0a\x09| generator result |\x0a\x09generator := self codeGeneratorClass new.\x0a\x09generator\x0a\x09\x09source: self source;\x0a\x09\x09currentClass: self currentClass;\x0a\x09\x09currentPackage: self currentPackage.\x0a\x09result := generator compileNode: aNode.\x0a\x09self unknownVariables: #().\x0a\x09^ result",
referencedClasses: [],
messageSends: ["new", "codeGeneratorClass", "source:", "source", "currentClass:", "currentClass", "currentPackage:", "currentPackage", "compileNode:", "unknownVariables:"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "compileNode:forClass:package:",
protocol: 'compiling',
fn: function (aNode,aClass,aPackage){
var self=this;
return $core.withContext(function($ctx1) {
self._currentClass_(aClass);
self._currentPackage_(aPackage);
return self._compileNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"compileNode:forClass:package:",{aNode:aNode,aClass:aClass,aPackage:aPackage},$globals.Compiler)});
},
args: ["aNode", "aClass", "aPackage"],
source: "compileNode: aNode forClass: aClass package: aPackage\x0a\x09^ self\x0a\x09\x09currentClass: aClass;\x0a\x09\x09currentPackage: aPackage;\x0a\x09\x09compileNode: aNode",
referencedClasses: [],
messageSends: ["currentClass:", "currentPackage:", "compileNode:"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "currentClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@currentClass"];

},
args: [],
source: "currentClass\x0a\x09^ currentClass",
referencedClasses: [],
messageSends: []
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "currentClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@currentClass"]=aClass;
return self;

},
args: ["aClass"],
source: "currentClass: aClass\x0a\x09currentClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "currentPackage",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@currentPackage"];

},
args: [],
source: "currentPackage\x0a\x09^ currentPackage",
referencedClasses: [],
messageSends: []
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "currentPackage:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@currentPackage"]=anObject;
return self;

},
args: ["anObject"],
source: "currentPackage: anObject\x0a\x09currentPackage := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "eval:",
protocol: 'compiling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return eval(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"eval:",{aString:aString},$globals.Compiler)});
},
args: ["aString"],
source: "eval: aString\x0a\x09<return eval(aString)>",
referencedClasses: [],
messageSends: []
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "eval:forPackage:",
protocol: 'compiling',
fn: function (aString,aPackage){
var self=this;
return $core.withContext(function($ctx1) {
return aPackage && aPackage.innerEval
		? aPackage.innerEval(aString)
		: eval(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"eval:forPackage:",{aString:aString,aPackage:aPackage},$globals.Compiler)});
},
args: ["aString", "aPackage"],
source: "eval: aString forPackage: aPackage\x0a\x09<return aPackage && aPackage.innerEval\x0a\x09\x09? aPackage.innerEval(aString)\x0a\x09\x09: eval(aString)>",
referencedClasses: [],
messageSends: []
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "evaluateExpression:",
protocol: 'compiling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self._evaluateExpression_on_(aString,$recv($globals.DoIt)._new());
}, function($ctx1) {$ctx1.fill(self,"evaluateExpression:",{aString:aString},$globals.Compiler)});
},
args: ["aString"],
source: "evaluateExpression: aString\x0a\x09\x22Unlike #eval: evaluate a Smalltalk expression and answer the returned object\x22\x0a\x09^ self evaluateExpression: aString on: DoIt new",
referencedClasses: ["DoIt"],
messageSends: ["evaluateExpression:on:", "new"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "evaluateExpression:on:",
protocol: 'compiling',
fn: function (aString,anObject){
var self=this;
var result,method;
return $core.withContext(function($ctx1) {
var $1;
method=self._eval_(self._compileExpression_on_(aString,anObject));
$recv(method)._protocol_("**xxxDoIt");
$1=$recv(anObject)._class();
$ctx1.sendIdx["class"]=1;
$recv($1)._addCompiledMethod_(method);
result=$recv(anObject)._xxxDoIt();
$recv($recv(anObject)._class())._removeCompiledMethod_(method);
return result;
}, function($ctx1) {$ctx1.fill(self,"evaluateExpression:on:",{aString:aString,anObject:anObject,result:result,method:method},$globals.Compiler)});
},
args: ["aString", "anObject"],
source: "evaluateExpression: aString on: anObject\x0a\x09\x22Unlike #eval: evaluate a Smalltalk expression with anObject as the receiver and answer the returned object\x22\x0a\x09| result method |\x0a\x09method := self eval: (self compileExpression: aString on: anObject).\x0a\x09method protocol: '**xxxDoIt'.\x0a\x09anObject class addCompiledMethod: method.\x0a\x09result := anObject xxxDoIt.\x0a\x09anObject class removeCompiledMethod: method.\x0a\x09^ result",
referencedClasses: [],
messageSends: ["eval:", "compileExpression:on:", "protocol:", "addCompiledMethod:", "class", "xxxDoIt", "removeCompiledMethod:"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "install:forClass:protocol:",
protocol: 'compiling',
fn: function (aString,aBehavior,anotherString){
var self=this;
var compiledMethod;
return $core.withContext(function($ctx1) {
compiledMethod=self._eval_forPackage_(self._compile_forClass_protocol_(aString,aBehavior,anotherString),$recv(aBehavior)._packageOfProtocol_(anotherString));
return $recv($recv($globals.ClassBuilder)._new())._installMethod_forClass_protocol_(compiledMethod,aBehavior,anotherString);
}, function($ctx1) {$ctx1.fill(self,"install:forClass:protocol:",{aString:aString,aBehavior:aBehavior,anotherString:anotherString,compiledMethod:compiledMethod},$globals.Compiler)});
},
args: ["aString", "aBehavior", "anotherString"],
source: "install: aString forClass: aBehavior protocol: anotherString\x0a\x09| compiledMethod |\x0a\x09compiledMethod := self\x0a\x09\x09eval: (self compile: aString forClass: aBehavior protocol: anotherString)\x0a\x09\x09forPackage: (aBehavior packageOfProtocol: anotherString).\x0a\x09^ ClassBuilder new\x0a\x09\x09installMethod: compiledMethod\x0a\x09\x09forClass: aBehavior\x0a\x09\x09protocol: anotherString",
referencedClasses: ["ClassBuilder"],
messageSends: ["eval:forPackage:", "compile:forClass:protocol:", "packageOfProtocol:", "installMethod:forClass:protocol:", "new"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "parse:",
protocol: 'compiling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._parse_(aString);
}, function($ctx1) {$ctx1.fill(self,"parse:",{aString:aString},$globals.Compiler)});
},
args: ["aString"],
source: "parse: aString\x0a\x09^ Smalltalk parse: aString",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "parseExpression:",
protocol: 'compiling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv("doIt ^ [ ".__comma(aString)).__comma(" ] value");
$ctx1.sendIdx[","]=1;
return self._parse_($1);
}, function($ctx1) {$ctx1.fill(self,"parseExpression:",{aString:aString},$globals.Compiler)});
},
args: ["aString"],
source: "parseExpression: aString\x0a\x09^ self parse: 'doIt ^ [ ', aString, ' ] value'",
referencedClasses: [],
messageSends: ["parse:", ","]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "recompile:",
protocol: 'compiling',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv($recv($recv(aClass)._methodDictionary())._values())._do_displayingProgress_((function(each){
return $core.withContext(function($ctx2) {
return self._install_forClass_protocol_($recv(each)._source(),aClass,$recv(each)._protocol());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),"Recompiling ".__comma($recv(aClass)._name()));
$1=$recv(aClass)._isMetaclass();
if(!$core.assert($1)){
self._recompile_($recv(aClass)._class());
};
return self;
}, function($ctx1) {$ctx1.fill(self,"recompile:",{aClass:aClass},$globals.Compiler)});
},
args: ["aClass"],
source: "recompile: aClass\x0a\x09aClass methodDictionary values\x0a\x09\x09do: [ :each | \x0a\x09\x09\x09self \x0a\x09\x09\x09\x09install: each source \x0a\x09\x09\x09\x09forClass: aClass \x0a\x09\x09\x09\x09protocol: each protocol ]\x0a\x09\x09displayingProgress: 'Recompiling ', aClass name.\x0a\x09aClass isMetaclass ifFalse: [ self recompile: aClass class ]",
referencedClasses: [],
messageSends: ["do:displayingProgress:", "values", "methodDictionary", "install:forClass:protocol:", "source", "protocol", ",", "name", "ifFalse:", "isMetaclass", "recompile:", "class"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "recompileAll",
protocol: 'compiling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Smalltalk)._classes())._do_displayingProgress_((function(each){
return $core.withContext(function($ctx2) {
return self._recompile_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),"Compiling all classes...");
return self;
}, function($ctx1) {$ctx1.fill(self,"recompileAll",{},$globals.Compiler)});
},
args: [],
source: "recompileAll\x0a\x09Smalltalk classes \x0a\x09\x09do: [ :each | self recompile: each ]\x0a\x09\x09displayingProgress: 'Compiling all classes...'",
referencedClasses: ["Smalltalk"],
messageSends: ["do:displayingProgress:", "classes", "recompile:"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "source",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@source"];
if(($receiver = $1) == null || $receiver.isNil){
return "";
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"source",{},$globals.Compiler)});
},
args: [],
source: "source\x0a\x09^ source ifNil: [ '' ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "source:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@source"]=aString;
return self;

},
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
messageSends: []
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "unknownVariables",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@unknownVariables"];

},
args: [],
source: "unknownVariables\x0a\x09^ unknownVariables",
referencedClasses: [],
messageSends: []
}),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "unknownVariables:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
self["@unknownVariables"]=aCollection;
return self;

},
args: ["aCollection"],
source: "unknownVariables: aCollection\x0a\x09unknownVariables := aCollection",
referencedClasses: [],
messageSends: []
}),
$globals.Compiler);


$core.addMethod(
$core.method({
selector: "recompile:",
protocol: 'compiling',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._new())._recompile_(aClass);
return self;
}, function($ctx1) {$ctx1.fill(self,"recompile:",{aClass:aClass},$globals.Compiler.klass)});
},
args: ["aClass"],
source: "recompile: aClass\x0a\x09self new recompile: aClass",
referencedClasses: [],
messageSends: ["recompile:", "new"]
}),
$globals.Compiler.klass);

$core.addMethod(
$core.method({
selector: "recompileAll",
protocol: 'compiling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Smalltalk)._classes())._do_((function(each){
return $core.withContext(function($ctx2) {
return self._recompile_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"recompileAll",{},$globals.Compiler.klass)});
},
args: [],
source: "recompileAll\x0a\x09Smalltalk classes do: [ :each |\x0a\x09\x09self recompile: each ]",
referencedClasses: ["Smalltalk"],
messageSends: ["do:", "classes", "recompile:"]
}),
$globals.Compiler.klass);


$core.addClass('CompilerError', $globals.Error, [], 'Compiler-Core');
$globals.CompilerError.comment="I am the common superclass of all compiling errors.";


$core.addClass('DoIt', $globals.Object, [], 'Compiler-Core');
$globals.DoIt.comment="`DoIt` is the class used to compile and evaluate expressions. See `Compiler >> evaluateExpression:`.";


$core.addClass('Evaluator', $globals.InterfacingObject, [], 'Compiler-Core');
$globals.Evaluator.comment="I evaluate code against a receiver, dispatching #evaluate:on: to the receiver.";
$core.addMethod(
$core.method({
selector: "evaluate:context:",
protocol: 'evaluating',
fn: function (aString,aContext){
var self=this;
var compiler,ast;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
compiler=$recv($globals.Compiler)._new();
$recv((function(){
return $core.withContext(function($ctx2) {
ast=$recv(compiler)._parseExpression_(aString);
return ast;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx2) {
throw $early=[self._alert_($recv(ex)._messageText())];
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,2)});
}));
$1=$recv($globals.AISemanticAnalyzer)._on_($recv($recv(aContext)._receiver())._class());
$recv($1)._context_(aContext);
$recv($1)._visit_(ast);
return $recv(aContext)._evaluateNode_(ast);
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"evaluate:context:",{aString:aString,aContext:aContext,compiler:compiler,ast:ast},$globals.Evaluator)});
},
args: ["aString", "aContext"],
source: "evaluate: aString context: aContext\x0a\x09\x22Similar to #evaluate:for:, with the following differences:\x0a\x09- instead of compiling and running `aString`, `aString` is interpreted using an `ASTInterpreter`\x0a\x09- instead of evaluating against a receiver, evaluate in the context of `aContext`\x22\x0a\x0a\x09| compiler ast |\x0a\x09\x0a\x09compiler := Compiler new.\x0a\x09[ ast := compiler parseExpression: aString ] \x0a\x09\x09on: Error \x0a\x09\x09do: [ :ex | ^ self alert: ex messageText ].\x0a\x09\x09\x0a\x09(AISemanticAnalyzer on: aContext receiver class)\x0a\x09\x09context: aContext;\x0a\x09\x09visit: ast.\x0a\x0a\x09^ aContext evaluateNode: ast",
referencedClasses: ["Compiler", "Error", "AISemanticAnalyzer"],
messageSends: ["new", "on:do:", "parseExpression:", "alert:", "messageText", "context:", "on:", "class", "receiver", "visit:", "evaluateNode:"]
}),
$globals.Evaluator);

$core.addMethod(
$core.method({
selector: "evaluate:for:",
protocol: 'evaluating',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(anObject)._evaluate_on_(aString,self);
}, function($ctx1) {$ctx1.fill(self,"evaluate:for:",{aString:aString,anObject:anObject},$globals.Evaluator)});
},
args: ["aString", "anObject"],
source: "evaluate: aString for: anObject\x0a\x09^ anObject evaluate: aString on: self",
referencedClasses: [],
messageSends: ["evaluate:on:"]
}),
$globals.Evaluator);

$core.addMethod(
$core.method({
selector: "evaluate:receiver:",
protocol: 'evaluating',
fn: function (aString,anObject){
var self=this;
var compiler;
return $core.withContext(function($ctx1) {
var $early={};
try {
compiler=$recv($globals.Compiler)._new();
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(compiler)._parseExpression_(aString);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx2) {
throw $early=[self._alert_($recv(ex)._messageText())];
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,2)});
}));
return $recv(compiler)._evaluateExpression_on_(aString,anObject);
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"evaluate:receiver:",{aString:aString,anObject:anObject,compiler:compiler},$globals.Evaluator)});
},
args: ["aString", "anObject"],
source: "evaluate: aString receiver: anObject\x0a\x09| compiler |\x0a\x09\x0a\x09compiler := Compiler new.\x0a\x09[ compiler parseExpression: aString ] \x0a\x09\x09on: Error \x0a\x09\x09do: [ :ex | ^ self alert: ex messageText ].\x0a\x0a\x09^ compiler evaluateExpression: aString on: anObject",
referencedClasses: ["Compiler", "Error"],
messageSends: ["new", "on:do:", "parseExpression:", "alert:", "messageText", "evaluateExpression:on:"]
}),
$globals.Evaluator);


$core.addMethod(
$core.method({
selector: "evaluate:for:",
protocol: 'instance creation',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._new())._evaluate_for_(aString,anObject);
}, function($ctx1) {$ctx1.fill(self,"evaluate:for:",{aString:aString,anObject:anObject},$globals.Evaluator.klass)});
},
args: ["aString", "anObject"],
source: "evaluate: aString for: anObject\x0a\x09^ self new evaluate: aString for: anObject",
referencedClasses: [],
messageSends: ["evaluate:for:", "new"]
}),
$globals.Evaluator.klass);

$core.addMethod(
$core.method({
selector: "asVariableName",
protocol: '*Compiler-Core',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv($globals.Smalltalk)._reservedWords())._includes_(self);
if($core.assert($1)){
return self.__comma("_");
} else {
return self;
};
}, function($ctx1) {$ctx1.fill(self,"asVariableName",{},$globals.String)});
},
args: [],
source: "asVariableName\x0a\x09^ (Smalltalk reservedWords includes: self)\x0a\x09\x09ifTrue: [ self, '_' ]\x0a\x09\x09ifFalse: [ self ]",
referencedClasses: ["Smalltalk"],
messageSends: ["ifTrue:ifFalse:", "includes:", "reservedWords", ","]
}),
$globals.String);

});

define("amber_core/Compiler-AST", ["amber/boot", "amber_core/Kernel-Objects", "amber_core/Kernel-Methods"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Compiler-AST');
$core.packages["Compiler-AST"].innerEval = function (expr) { return eval(expr); };
$core.packages["Compiler-AST"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('Node', $globals.Object, ['parent', 'position', 'source', 'nodes', 'shouldBeInlined', 'shouldBeAliased'], 'Compiler-AST');
$globals.Node.comment="I am the abstract root class of the abstract syntax tree.\x0a\x0aConcrete classes should implement `#accept:` to allow visiting.\x0a\x0a`position` holds a point containing line and column number of the symbol location in the original source file.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.Node)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitNode: self",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "addNode:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._nodes())._add_(aNode);
$recv(aNode)._parent_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"addNode:",{aNode:aNode},$globals.Node)});
},
args: ["aNode"],
source: "addNode: aNode\x0a\x09self nodes add: aNode.\x0a\x09aNode parent: self",
referencedClasses: [],
messageSends: ["add:", "nodes", "parent:"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "allNodes",
protocol: 'accessing',
fn: function (){
var self=this;
var allNodes;
return $core.withContext(function($ctx1) {
var $1;
$1=self._nodes();
$ctx1.sendIdx["nodes"]=1;
allNodes=$recv($1)._asSet();
$recv(self._nodes())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(allNodes)._addAll_($recv(each)._allNodes());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return allNodes;
}, function($ctx1) {$ctx1.fill(self,"allNodes",{allNodes:allNodes},$globals.Node)});
},
args: [],
source: "allNodes\x0a\x09| allNodes |\x0a\x09\x0a\x09allNodes := self nodes asSet.\x0a\x09self nodes do: [ :each | \x0a\x09\x09allNodes addAll: each allNodes ].\x0a\x09\x0a\x09^ allNodes",
referencedClasses: [],
messageSends: ["asSet", "nodes", "do:", "addAll:", "allNodes"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "inPosition:",
protocol: 'testing',
fn: function (aPoint){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._positionStart()).__lt_eq(aPoint))._and_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._positionEnd()).__gt_eq(aPoint);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"inPosition:",{aPoint:aPoint},$globals.Node)});
},
args: ["aPoint"],
source: "inPosition: aPoint\x0a\x09^ (self positionStart <= aPoint and: [\x0a\x09\x09self positionEnd >= aPoint ])",
referencedClasses: [],
messageSends: ["and:", "<=", "positionStart", ">=", "positionEnd"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isAssignmentNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isAssignmentNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isBlockNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isBlockNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isBlockSequenceNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isBlockSequenceNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isCascadeNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isCascadeNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isImmutable\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isJSStatementNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isJSStatementNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isLastChild",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv(self._parent())._nodes())._last()).__eq(self);
}, function($ctx1) {$ctx1.fill(self,"isLastChild",{},$globals.Node)});
},
args: [],
source: "isLastChild\x0a\x09^ self parent nodes last = self",
referencedClasses: [],
messageSends: ["=", "last", "nodes", "parent"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isNavigationNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isNavigationNode\x0a\x09\x22Answer true if the node can be navigated to\x22\x0a\x09\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isReferenced",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
$3=self._parent();
$ctx1.sendIdx["parent"]=1;
$2=$recv($3)._isSequenceNode();
$1=$recv($2)._or_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._parent())._isAssignmentNode();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return $recv($1)._not();
}, function($ctx1) {$ctx1.fill(self,"isReferenced",{},$globals.Node)});
},
args: [],
source: "isReferenced\x0a\x09\x22Answer true if the receiver is referenced by other nodes.\x0a\x09Do not take sequences or assignments into account\x22\x0a\x09\x0a\x09^ (self parent isSequenceNode or: [\x0a\x09\x09self parent isAssignmentNode ]) not",
referencedClasses: [],
messageSends: ["not", "or:", "isSequenceNode", "parent", "isAssignmentNode"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isReturnNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isReturnNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isSendNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isSendNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isSequenceNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isSequenceNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isValueNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isValueNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isVariableNode",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isVariableNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "location:",
protocol: 'accessing',
fn: function (aLocation){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
$3=$recv(aLocation)._start();
$ctx1.sendIdx["start"]=1;
$2=$recv($3)._line();
$1=$recv($2).__at($recv($recv(aLocation)._start())._column());
self._position_($1);
return self;
}, function($ctx1) {$ctx1.fill(self,"location:",{aLocation:aLocation},$globals.Node)});
},
args: ["aLocation"],
source: "location: aLocation\x0a\x09self position: aLocation start line @ aLocation start column",
referencedClasses: [],
messageSends: ["position:", "@", "line", "start", "column"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "method",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._parent();
if(($receiver = $1) == null || $receiver.isNil){
return $1;
} else {
var node;
node=$receiver;
return $recv(node)._method();
};
}, function($ctx1) {$ctx1.fill(self,"method",{},$globals.Node)});
},
args: [],
source: "method\x0a\x09^ self parent ifNotNil: [ :node | node method ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "parent", "method"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "navigationNodeAt:ifAbsent:",
protocol: 'accessing',
fn: function (aPoint,aBlock){
var self=this;
var children;
return $core.withContext(function($ctx1) {
var $2,$1;
var $early={};
try {
children=$recv(self._allNodes())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._isNavigationNode())._and_((function(){
return $core.withContext(function($ctx3) {
return $recv(each)._inPosition_(aPoint);
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$recv(children)._ifEmpty_((function(){
return $core.withContext(function($ctx2) {
throw $early=[$recv(aBlock)._value()];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return $recv($recv($recv(children)._asArray())._sort_((function(a,b){
return $core.withContext(function($ctx2) {
$2=$recv(a)._positionStart();
$ctx2.sendIdx["positionStart"]=1;
$1=$recv($2)._dist_(aPoint);
$ctx2.sendIdx["dist:"]=1;
return $recv($1).__lt_eq($recv($recv(b)._positionStart())._dist_(aPoint));
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,4)});
})))._first();
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"navigationNodeAt:ifAbsent:",{aPoint:aPoint,aBlock:aBlock,children:children},$globals.Node)});
},
args: ["aPoint", "aBlock"],
source: "navigationNodeAt: aPoint ifAbsent: aBlock\x0a\x09\x22Answer the navigation node in the receiver's tree at aPoint \x0a\x09or nil if no navigation node was found.\x0a\x09\x0a\x09See `node >> isNaviationNode`\x22\x0a\x09\x0a\x09| children |\x0a\x09\x0a\x09children := self allNodes select: [ :each | \x0a\x09\x09each isNavigationNode and: [ each inPosition: aPoint ] ].\x0a\x09\x0a\x09children ifEmpty: [ ^ aBlock value ].\x0a\x09\x0a\x09^ (children asArray sort: [ :a :b | \x0a\x09\x09(a positionStart dist: aPoint) <= \x0a\x09\x09(b positionStart dist: aPoint) ]) first",
referencedClasses: [],
messageSends: ["select:", "allNodes", "and:", "isNavigationNode", "inPosition:", "ifEmpty:", "value", "first", "sort:", "asArray", "<=", "dist:", "positionStart"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "nodes",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@nodes"];
if(($receiver = $1) == null || $receiver.isNil){
self["@nodes"]=$recv($globals.Array)._new();
return self["@nodes"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"nodes",{},$globals.Node)});
},
args: [],
source: "nodes\x0a\x09^ nodes ifNil: [ nodes := Array new ]",
referencedClasses: ["Array"],
messageSends: ["ifNil:", "new"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "nodes:",
protocol: 'building',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
self["@nodes"]=aCollection;
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._parent_(self);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"nodes:",{aCollection:aCollection},$globals.Node)});
},
args: ["aCollection"],
source: "nodes: aCollection\x0a\x09nodes := aCollection.\x0a\x09aCollection do: [ :each | each parent: self ]",
referencedClasses: [],
messageSends: ["do:", "parent:"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "parent",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@parent"];

},
args: [],
source: "parent\x0a\x09^ parent",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "parent:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
self["@parent"]=aNode;
return self;

},
args: ["aNode"],
source: "parent: aNode\x0a\x09parent := aNode",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "position",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
$1=self["@position"];
if(($receiver = $1) == null || $receiver.isNil){
$2=self._parent();
if(($receiver = $2) == null || $receiver.isNil){
return $2;
} else {
var node;
node=$receiver;
return $recv(node)._position();
};
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"position",{},$globals.Node)});
},
args: [],
source: "position\x0a\x09\x22answer the line and column of the receiver in the source code\x22\x0a\x09\x0a\x09^ position ifNil: [ \x0a\x09\x09self parent ifNotNil: [ :node | node position ] ]",
referencedClasses: [],
messageSends: ["ifNil:", "ifNotNil:", "parent", "position"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "position:",
protocol: 'accessing',
fn: function (aPosition){
var self=this;
self["@position"]=aPosition;
return self;

},
args: ["aPosition"],
source: "position: aPosition\x0a\x09position := aPosition",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "positionEnd",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$6,$5,$4,$3,$2;
$1=self._positionStart();
$6=self._source();
$ctx1.sendIdx["source"]=1;
$5=$recv($6)._lines();
$ctx1.sendIdx["lines"]=1;
$4=$recv($5)._size();
$ctx1.sendIdx["size"]=1;
$3=$recv($4).__minus((1));
$ctx1.sendIdx["-"]=1;
$2=$recv($3).__at($recv($recv($recv($recv(self._source())._lines())._last())._size()).__minus((1)));
return $recv($1).__plus($2);
}, function($ctx1) {$ctx1.fill(self,"positionEnd",{},$globals.Node)});
},
args: [],
source: "positionEnd\x0a\x09^ self positionStart + ((self source lines size - 1) @ (self source lines last size - 1))",
referencedClasses: [],
messageSends: ["+", "positionStart", "@", "-", "size", "lines", "source", "last"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "positionStart",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._position();
}, function($ctx1) {$ctx1.fill(self,"positionStart",{},$globals.Node)});
},
args: [],
source: "positionStart\x0a\x09^ self position",
referencedClasses: [],
messageSends: ["position"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "postCopy",
protocol: 'copying',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Node.superclass||$boot.dnu).fn.prototype._postCopy.apply($recv(self), []));
$ctx1.supercall = false;
$recv(self._nodes())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._parent_(self);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"postCopy",{},$globals.Node)});
},
args: [],
source: "postCopy\x0a\x09super postCopy.\x0a\x09self nodes do: [ :each | each parent: self ]",
referencedClasses: [],
messageSends: ["postCopy", "do:", "nodes", "parent:"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "requiresSmalltalkContext",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._nodes())._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._requiresSmalltalkContext();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return nil;

})))._notNil();
}, function($ctx1) {$ctx1.fill(self,"requiresSmalltalkContext",{},$globals.Node)});
},
args: [],
source: "requiresSmalltalkContext\x0a\x09\x22Answer true if the receiver requires a smalltalk context.\x0a\x09Only send nodes require a context.\x0a\x09\x0a\x09If no node requires a context, the method will be compiled without one.\x0a\x09See `IRJSTranslator` and `JSStream` for context creation\x22\x0a\x09\x0a\x09^ (self nodes \x0a\x09\x09detect: [ :each | each requiresSmalltalkContext ]\x0a\x09\x09ifNone: [ nil ]) notNil",
referencedClasses: [],
messageSends: ["notNil", "detect:ifNone:", "nodes", "requiresSmalltalkContext"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "shouldBeAliased",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@shouldBeAliased"];
if(($receiver = $1) == null || $receiver.isNil){
return false;
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"shouldBeAliased",{},$globals.Node)});
},
args: [],
source: "shouldBeAliased\x0a\x09^ shouldBeAliased ifNil: [ false ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "shouldBeAliased:",
protocol: 'accessing',
fn: function (aBoolean){
var self=this;
self["@shouldBeAliased"]=aBoolean;
return self;

},
args: ["aBoolean"],
source: "shouldBeAliased: aBoolean\x0a\x09shouldBeAliased := aBoolean",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "shouldBeInlined",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@shouldBeInlined"];
if(($receiver = $1) == null || $receiver.isNil){
return false;
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"shouldBeInlined",{},$globals.Node)});
},
args: [],
source: "shouldBeInlined\x0a\x09^ shouldBeInlined ifNil: [ false ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "shouldBeInlined:",
protocol: 'accessing',
fn: function (aBoolean){
var self=this;
self["@shouldBeInlined"]=aBoolean;
return self;

},
args: ["aBoolean"],
source: "shouldBeInlined: aBoolean\x0a\x09shouldBeInlined := aBoolean",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "size",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._source())._size();
}, function($ctx1) {$ctx1.fill(self,"size",{},$globals.Node)});
},
args: [],
source: "size\x0a\x09^ self source size",
referencedClasses: [],
messageSends: ["size", "source"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "source",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@source"];
if(($receiver = $1) == null || $receiver.isNil){
return "";
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"source",{},$globals.Node)});
},
args: [],
source: "source\x0a\x09^ source ifNil: [ '' ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "source:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@source"]=aString;
return self;

},
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "subtreeNeedsAliasing",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv(self._shouldBeAliased())._or_((function(){
return $core.withContext(function($ctx2) {
return self._shouldBeInlined();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._or_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._nodes())._anySatisfy_((function(each){
return $core.withContext(function($ctx3) {
return $recv(each)._subtreeNeedsAliasing();
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$ctx1.sendIdx["or:"]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"subtreeNeedsAliasing",{},$globals.Node)});
},
args: [],
source: "subtreeNeedsAliasing\x0a\x09^ (self shouldBeAliased or: [ self shouldBeInlined ]) or: [\x0a\x09\x09self nodes anySatisfy: [ :each | each subtreeNeedsAliasing ] ]",
referencedClasses: [],
messageSends: ["or:", "shouldBeAliased", "shouldBeInlined", "anySatisfy:", "nodes", "subtreeNeedsAliasing"]
}),
$globals.Node);



$core.addClass('AssignmentNode', $globals.Node, ['left', 'right'], 'Compiler-AST');
$globals.AssignmentNode.comment="I represent an assignment node.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitAssignmentNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.AssignmentNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitAssignmentNode: self",
referencedClasses: [],
messageSends: ["visitAssignmentNode:"]
}),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "isAssignmentNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isAssignmentNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "left",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@left"];

},
args: [],
source: "left\x0a\x09^ left",
referencedClasses: [],
messageSends: []
}),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "left:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
self["@left"]=aNode;
$recv(aNode)._parent_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"left:",{aNode:aNode},$globals.AssignmentNode)});
},
args: ["aNode"],
source: "left: aNode\x0a\x09left := aNode.\x0a\x09aNode parent: self",
referencedClasses: [],
messageSends: ["parent:"]
}),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "nodes",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Array)._with_with_(self._left(),self._right());
}, function($ctx1) {$ctx1.fill(self,"nodes",{},$globals.AssignmentNode)});
},
args: [],
source: "nodes\x0a\x09^ Array with: self left with: self right",
referencedClasses: ["Array"],
messageSends: ["with:with:", "left", "right"]
}),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "right",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@right"];

},
args: [],
source: "right\x0a\x09^ right",
referencedClasses: [],
messageSends: []
}),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "right:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
self["@right"]=aNode;
$recv(aNode)._parent_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"right:",{aNode:aNode},$globals.AssignmentNode)});
},
args: ["aNode"],
source: "right: aNode\x0a\x09right := aNode.\x0a\x09aNode parent: self",
referencedClasses: [],
messageSends: ["parent:"]
}),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "shouldBeAliased",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=(
$ctx1.supercall = true,
($globals.AssignmentNode.superclass||$boot.dnu).fn.prototype._shouldBeAliased.apply($recv(self), []));
$ctx1.supercall = false;
return $recv($1)._or_((function(){
return $core.withContext(function($ctx2) {
return self._isReferenced();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"shouldBeAliased",{},$globals.AssignmentNode)});
},
args: [],
source: "shouldBeAliased\x0a\x09^ super shouldBeAliased or: [ self isReferenced ]",
referencedClasses: [],
messageSends: ["or:", "shouldBeAliased", "isReferenced"]
}),
$globals.AssignmentNode);



$core.addClass('BlockNode', $globals.Node, ['parameters', 'scope'], 'Compiler-AST');
$globals.BlockNode.comment="I represent an block closure node.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitBlockNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.BlockNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitBlockNode: self",
referencedClasses: [],
messageSends: ["visitBlockNode:"]
}),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "isBlockNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isBlockNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "parameters",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@parameters"];
if(($receiver = $1) == null || $receiver.isNil){
self["@parameters"]=$recv($globals.Array)._new();
return self["@parameters"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"parameters",{},$globals.BlockNode)});
},
args: [],
source: "parameters\x0a\x09^ parameters ifNil: [ parameters := Array new ]",
referencedClasses: ["Array"],
messageSends: ["ifNil:", "new"]
}),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "parameters:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
self["@parameters"]=aCollection;
return self;

},
args: ["aCollection"],
source: "parameters: aCollection\x0a\x09parameters := aCollection",
referencedClasses: [],
messageSends: []
}),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "scope",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@scope"];

},
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
messageSends: []
}),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: 'accessing',
fn: function (aLexicalScope){
var self=this;
self["@scope"]=aLexicalScope;
return self;

},
args: ["aLexicalScope"],
source: "scope: aLexicalScope\x0a\x09scope := aLexicalScope",
referencedClasses: [],
messageSends: []
}),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "subtreeNeedsAliasing",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._shouldBeAliased())._or_((function(){
return $core.withContext(function($ctx2) {
return self._shouldBeInlined();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"subtreeNeedsAliasing",{},$globals.BlockNode)});
},
args: [],
source: "subtreeNeedsAliasing\x0a\x09^ self shouldBeAliased or: [ self shouldBeInlined ]",
referencedClasses: [],
messageSends: ["or:", "shouldBeAliased", "shouldBeInlined"]
}),
$globals.BlockNode);



$core.addClass('CascadeNode', $globals.Node, ['receiver'], 'Compiler-AST');
$globals.CascadeNode.comment="I represent an cascade node.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitCascadeNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.CascadeNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitCascadeNode: self",
referencedClasses: [],
messageSends: ["visitCascadeNode:"]
}),
$globals.CascadeNode);

$core.addMethod(
$core.method({
selector: "isCascadeNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isCascadeNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.CascadeNode);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@receiver"];

},
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
messageSends: []
}),
$globals.CascadeNode);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
self["@receiver"]=aNode;
return self;

},
args: ["aNode"],
source: "receiver: aNode\x0a\x09receiver := aNode",
referencedClasses: [],
messageSends: []
}),
$globals.CascadeNode);

$core.addMethod(
$core.method({
selector: "subtreeNeedsAliasing",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._parent())._isSequenceNode())._not();
}, function($ctx1) {$ctx1.fill(self,"subtreeNeedsAliasing",{},$globals.CascadeNode)});
},
args: [],
source: "subtreeNeedsAliasing\x0a\x09^ self parent isSequenceNode not",
referencedClasses: [],
messageSends: ["not", "isSequenceNode", "parent"]
}),
$globals.CascadeNode);



$core.addClass('DynamicArrayNode', $globals.Node, [], 'Compiler-AST');
$globals.DynamicArrayNode.comment="I represent an dynamic array node.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitDynamicArrayNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.DynamicArrayNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitDynamicArrayNode: self",
referencedClasses: [],
messageSends: ["visitDynamicArrayNode:"]
}),
$globals.DynamicArrayNode);



$core.addClass('DynamicDictionaryNode', $globals.Node, [], 'Compiler-AST');
$globals.DynamicDictionaryNode.comment="I represent an dynamic dictionary node.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitDynamicDictionaryNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.DynamicDictionaryNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitDynamicDictionaryNode: self",
referencedClasses: [],
messageSends: ["visitDynamicDictionaryNode:"]
}),
$globals.DynamicDictionaryNode);



$core.addClass('JSStatementNode', $globals.Node, [], 'Compiler-AST');
$globals.JSStatementNode.comment="I represent an JavaScript statement node.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitJSStatementNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.JSStatementNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitJSStatementNode: self",
referencedClasses: [],
messageSends: ["visitJSStatementNode:"]
}),
$globals.JSStatementNode);

$core.addMethod(
$core.method({
selector: "isJSStatementNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isJSStatementNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.JSStatementNode);

$core.addMethod(
$core.method({
selector: "requiresSmalltalkContext",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "requiresSmalltalkContext\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.JSStatementNode);



$core.addClass('MethodNode', $globals.Node, ['selector', 'arguments', 'source', 'scope', 'classReferences', 'sendIndexes'], 'Compiler-AST');
$globals.MethodNode.comment="I represent an method node.\x0a\x0aA method node must be the root and only method node of a valid AST.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitMethodNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.MethodNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitMethodNode: self",
referencedClasses: [],
messageSends: ["visitMethodNode:"]
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "arguments",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@arguments"];
if(($receiver = $1) == null || $receiver.isNil){
return [];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"arguments",{},$globals.MethodNode)});
},
args: [],
source: "arguments\x0a\x09^ arguments ifNil: [ #() ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
self["@arguments"]=aCollection;
return self;

},
args: ["aCollection"],
source: "arguments: aCollection\x0a\x09arguments := aCollection",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "classReferences",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@classReferences"];

},
args: [],
source: "classReferences\x0a\x09^ classReferences",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "classReferences:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
self["@classReferences"]=aCollection;
return self;

},
args: ["aCollection"],
source: "classReferences: aCollection\x0a\x09classReferences := aCollection",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "messageSends",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._sendIndexes())._keys();
}, function($ctx1) {$ctx1.fill(self,"messageSends",{},$globals.MethodNode)});
},
args: [],
source: "messageSends\x0a\x09^ self sendIndexes keys",
referencedClasses: [],
messageSends: ["keys", "sendIndexes"]
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "method",
protocol: 'accessing',
fn: function (){
var self=this;
return self;

},
args: [],
source: "method\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "scope",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@scope"];

},
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: 'accessing',
fn: function (aMethodScope){
var self=this;
self["@scope"]=aMethodScope;
return self;

},
args: ["aMethodScope"],
source: "scope: aMethodScope\x0a\x09scope := aMethodScope",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@selector"];

},
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@selector"]=aString;
return self;

},
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "sendIndexes",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@sendIndexes"];

},
args: [],
source: "sendIndexes\x0a\x09^ sendIndexes",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "sendIndexes:",
protocol: 'accessing',
fn: function (aDictionary){
var self=this;
self["@sendIndexes"]=aDictionary;
return self;

},
args: ["aDictionary"],
source: "sendIndexes: aDictionary\x0a\x09sendIndexes := aDictionary",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "sequenceNode",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
$recv(self._nodes())._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(each)._isSequenceNode();
if($core.assert($1)){
throw $early=[each];
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return nil;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"sequenceNode",{},$globals.MethodNode)});
},
args: [],
source: "sequenceNode\x0a\x09self nodes do: [ :each |\x0a\x09\x09each isSequenceNode ifTrue: [ ^ each ] ].\x0a\x09\x09\x0a\x09^ nil",
referencedClasses: [],
messageSends: ["do:", "nodes", "ifTrue:", "isSequenceNode"]
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "source",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@source"];

},
args: [],
source: "source\x0a\x09^ source",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "source:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@source"]=aString;
return self;

},
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
messageSends: []
}),
$globals.MethodNode);



$core.addClass('ReturnNode', $globals.Node, ['scope'], 'Compiler-AST');
$globals.ReturnNode.comment="I represent an return node. At the AST level, there is not difference between a local return or non-local return.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitReturnNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.ReturnNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitReturnNode: self",
referencedClasses: [],
messageSends: ["visitReturnNode:"]
}),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "isReturnNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isReturnNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "nonLocalReturn",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._scope())._isMethodScope())._not();
}, function($ctx1) {$ctx1.fill(self,"nonLocalReturn",{},$globals.ReturnNode)});
},
args: [],
source: "nonLocalReturn\x0a\x09^ self scope isMethodScope not",
referencedClasses: [],
messageSends: ["not", "isMethodScope", "scope"]
}),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "scope",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@scope"];

},
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
messageSends: []
}),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: 'accessing',
fn: function (aLexicalScope){
var self=this;
self["@scope"]=aLexicalScope;
return self;

},
args: ["aLexicalScope"],
source: "scope: aLexicalScope\x0a\x09scope := aLexicalScope",
referencedClasses: [],
messageSends: []
}),
$globals.ReturnNode);



$core.addClass('SendNode', $globals.Node, ['selector', 'arguments', 'receiver', 'index'], 'Compiler-AST');
$globals.SendNode.comment="I represent an message send node.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitSendNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.SendNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitSendNode: self",
referencedClasses: [],
messageSends: ["visitSendNode:"]
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "arguments",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@arguments"];
if(($receiver = $1) == null || $receiver.isNil){
self["@arguments"]=[];
return self["@arguments"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"arguments",{},$globals.SendNode)});
},
args: [],
source: "arguments\x0a\x09^ arguments ifNil: [ arguments := #() ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
self["@arguments"]=aCollection;
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._parent_(self);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"arguments:",{aCollection:aCollection},$globals.SendNode)});
},
args: ["aCollection"],
source: "arguments: aCollection\x0a\x09arguments := aCollection.\x0a\x09aCollection do: [ :each | each parent: self ]",
referencedClasses: [],
messageSends: ["do:", "parent:"]
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "cascadeNodeWithMessages:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
var first;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$1=$recv($globals.SendNode)._new();
$ctx1.sendIdx["new"]=1;
$recv($1)._selector_(self._selector());
$recv($1)._arguments_(self._arguments());
$2=$recv($1)._yourself();
$ctx1.sendIdx["yourself"]=1;
first=$2;
$3=$recv($globals.CascadeNode)._new();
$recv($3)._receiver_(self._receiver());
$recv($3)._nodes_($recv($recv($globals.Array)._with_(first)).__comma(aCollection));
return $recv($3)._yourself();
}, function($ctx1) {$ctx1.fill(self,"cascadeNodeWithMessages:",{aCollection:aCollection,first:first},$globals.SendNode)});
},
args: ["aCollection"],
source: "cascadeNodeWithMessages: aCollection\x0a\x09| first |\x0a\x09first := SendNode new\x0a\x09\x09selector: self selector;\x0a\x09\x09arguments: self arguments;\x0a\x09\x09yourself.\x0a\x09^ CascadeNode new\x0a\x09\x09receiver: self receiver;\x0a\x09\x09nodes: (Array with: first), aCollection;\x0a\x09\x09yourself",
referencedClasses: ["SendNode", "CascadeNode", "Array"],
messageSends: ["selector:", "new", "selector", "arguments:", "arguments", "yourself", "receiver:", "receiver", "nodes:", ",", "with:"]
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "index",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@index"];

},
args: [],
source: "index\x0a\x09^ index",
referencedClasses: [],
messageSends: []
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "index:",
protocol: 'accessing',
fn: function (anInteger){
var self=this;
self["@index"]=anInteger;
return self;

},
args: ["anInteger"],
source: "index: anInteger\x0a\x09index := anInteger",
referencedClasses: [],
messageSends: []
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "isCascadeSendNode",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._parent())._isCascadeNode();
}, function($ctx1) {$ctx1.fill(self,"isCascadeSendNode",{},$globals.SendNode)});
},
args: [],
source: "isCascadeSendNode\x0a\x09^ self parent isCascadeNode",
referencedClasses: [],
messageSends: ["isCascadeNode", "parent"]
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "isNavigationNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isNavigationNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "isSendNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isSendNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "navigationLink",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._selector();
}, function($ctx1) {$ctx1.fill(self,"navigationLink",{},$globals.SendNode)});
},
args: [],
source: "navigationLink\x0a\x09^ self selector",
referencedClasses: [],
messageSends: ["selector"]
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "nodes",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$receiver;
$1=self._receiver();
$ctx1.sendIdx["receiver"]=1;
if(($receiver = $1) == null || $receiver.isNil){
$2=self._arguments();
$ctx1.sendIdx["arguments"]=1;
return $recv($2)._copy();
} else {
$1;
};
$3=$recv($globals.Array)._with_(self._receiver());
$recv($3)._addAll_(self._arguments());
return $recv($3)._yourself();
}, function($ctx1) {$ctx1.fill(self,"nodes",{},$globals.SendNode)});
},
args: [],
source: "nodes\x0a\x09self receiver ifNil: [ ^ self arguments copy ].\x0a\x09\x0a\x09^ (Array with: self receiver)\x0a\x09\x09addAll: self arguments;\x0a\x09\x09yourself",
referencedClasses: ["Array"],
messageSends: ["ifNil:", "receiver", "copy", "arguments", "addAll:", "with:", "yourself"]
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@receiver"];

},
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
messageSends: []
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
self["@receiver"]=aNode;
$1=$recv(aNode)._isNode();
if($core.assert($1)){
$recv(aNode)._parent_(self);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"receiver:",{aNode:aNode},$globals.SendNode)});
},
args: ["aNode"],
source: "receiver: aNode\x0a\x09receiver := aNode.\x0a\x09aNode isNode ifTrue: [\x0a\x09\x09aNode parent: self ]",
referencedClasses: [],
messageSends: ["ifTrue:", "isNode", "parent:"]
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "requiresSmalltalkContext",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "requiresSmalltalkContext\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@selector"];

},
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
messageSends: []
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@selector"]=aString;
return self;

},
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
messageSends: []
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "shouldBeAliased",
protocol: 'testing',
fn: function (){
var self=this;
var sends;
return $core.withContext(function($ctx1) {
var $2,$1;
sends=$recv($recv($recv(self._method())._sendIndexes())._at_(self._selector()))._size();
$2=(
$ctx1.supercall = true,
($globals.SendNode.superclass||$boot.dnu).fn.prototype._shouldBeAliased.apply($recv(self), []));
$ctx1.supercall = false;
$1=$recv($2)._or_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._isReferenced())._and_((function(){
return $core.withContext(function($ctx3) {
return $recv($recv($recv(sends).__gt((1)))._and_((function(){
return $core.withContext(function($ctx4) {
return $recv(self._index()).__lt(sends);
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,3)});
})))._or_((function(){
return $core.withContext(function($ctx4) {
return self._superSend();
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,4)});
}));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
$ctx2.sendIdx["and:"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["or:"]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"shouldBeAliased",{sends:sends},$globals.SendNode)});
},
args: [],
source: "shouldBeAliased\x0a\x09\x22Because we keep track of send indexes, some send nodes need additional care for aliasing. \x0a\x09See IRJSVisitor >> visitIRSend:\x22\x0a\x09\x0a\x09| sends |\x0a\x09\x0a\x09sends := (self method sendIndexes at: self selector) size.\x0a\x09\x0a\x09^ (super shouldBeAliased or: [\x0a\x09\x09self isReferenced and: [\x0a\x09\x09\x09(sends > 1 and: [ self index < sends ])\x0a\x09\x09\x09\x09or: [ self superSend ] ] ])",
referencedClasses: [],
messageSends: ["size", "at:", "sendIndexes", "method", "selector", "or:", "shouldBeAliased", "and:", "isReferenced", ">", "<", "index", "superSend"]
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "superSend",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._receiver())._value()).__eq("super");
}, function($ctx1) {$ctx1.fill(self,"superSend",{},$globals.SendNode)});
},
args: [],
source: "superSend\x0a\x09^ self receiver value = 'super'",
referencedClasses: [],
messageSends: ["=", "value", "receiver"]
}),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "valueForReceiver:",
protocol: 'building',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$receiver;
$1=$recv($globals.SendNode)._new();
$recv($1)._position_(self._position());
$recv($1)._source_(self._source());
$3=self._receiver();
$ctx1.sendIdx["receiver"]=1;
if(($receiver = $3) == null || $receiver.isNil){
$2=anObject;
} else {
$2=$recv(self._receiver())._valueForReceiver_(anObject);
};
$recv($1)._receiver_($2);
$recv($1)._selector_(self._selector());
$recv($1)._arguments_(self._arguments());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"valueForReceiver:",{anObject:anObject},$globals.SendNode)});
},
args: ["anObject"],
source: "valueForReceiver: anObject\x0a\x09^ SendNode new\x0a\x09\x09position: self position;\x0a\x09\x09source: self source;\x0a\x09\x09receiver: (self receiver\x0a\x09\x09ifNil: [ anObject ] \x0a\x09\x09ifNotNil: [ self receiver valueForReceiver: anObject ]);\x0a\x09\x09selector: self selector;\x0a\x09\x09arguments: self arguments;\x0a\x09\x09yourself",
referencedClasses: ["SendNode"],
messageSends: ["position:", "new", "position", "source:", "source", "receiver:", "ifNil:ifNotNil:", "receiver", "valueForReceiver:", "selector:", "selector", "arguments:", "arguments", "yourself"]
}),
$globals.SendNode);



$core.addClass('SequenceNode', $globals.Node, ['temps', 'scope'], 'Compiler-AST');
$globals.SequenceNode.comment="I represent an sequence node. A sequence represent a set of instructions inside the same scope (the method scope or a block scope).";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitSequenceNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.SequenceNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitSequenceNode: self",
referencedClasses: [],
messageSends: ["visitSequenceNode:"]
}),
$globals.SequenceNode);

$core.addMethod(
$core.method({
selector: "asBlockSequenceNode",
protocol: 'building',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.BlockSequenceNode)._new();
$recv($1)._position_(self._position());
$recv($1)._source_(self._source());
$recv($1)._nodes_(self._nodes());
$recv($1)._temps_(self._temps());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"asBlockSequenceNode",{},$globals.SequenceNode)});
},
args: [],
source: "asBlockSequenceNode\x0a\x09^ BlockSequenceNode new\x0a\x09\x09position: self position;\x0a\x09\x09source: self source;\x0a\x09\x09nodes: self nodes;\x0a\x09\x09temps: self temps;\x0a\x09\x09yourself",
referencedClasses: ["BlockSequenceNode"],
messageSends: ["position:", "new", "position", "source:", "source", "nodes:", "nodes", "temps:", "temps", "yourself"]
}),
$globals.SequenceNode);

$core.addMethod(
$core.method({
selector: "isSequenceNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isSequenceNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.SequenceNode);

$core.addMethod(
$core.method({
selector: "scope",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@scope"];

},
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
messageSends: []
}),
$globals.SequenceNode);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: 'accessing',
fn: function (aLexicalScope){
var self=this;
self["@scope"]=aLexicalScope;
return self;

},
args: ["aLexicalScope"],
source: "scope: aLexicalScope\x0a\x09scope := aLexicalScope",
referencedClasses: [],
messageSends: []
}),
$globals.SequenceNode);

$core.addMethod(
$core.method({
selector: "temps",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@temps"];
if(($receiver = $1) == null || $receiver.isNil){
return [];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"temps",{},$globals.SequenceNode)});
},
args: [],
source: "temps\x0a\x09^ temps ifNil: [ #() ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.SequenceNode);

$core.addMethod(
$core.method({
selector: "temps:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
self["@temps"]=aCollection;
return self;

},
args: ["aCollection"],
source: "temps: aCollection\x0a\x09temps := aCollection",
referencedClasses: [],
messageSends: []
}),
$globals.SequenceNode);



$core.addClass('BlockSequenceNode', $globals.SequenceNode, [], 'Compiler-AST');
$globals.BlockSequenceNode.comment="I represent an special sequence node for block scopes.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitBlockSequenceNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.BlockSequenceNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitBlockSequenceNode: self",
referencedClasses: [],
messageSends: ["visitBlockSequenceNode:"]
}),
$globals.BlockSequenceNode);

$core.addMethod(
$core.method({
selector: "isBlockSequenceNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isBlockSequenceNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.BlockSequenceNode);



$core.addClass('ValueNode', $globals.Node, ['value'], 'Compiler-AST');
$globals.ValueNode.comment="I represent a value node.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitValueNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.ValueNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitValueNode: self",
referencedClasses: [],
messageSends: ["visitValueNode:"]
}),
$globals.ValueNode);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._value())._isImmutable();
}, function($ctx1) {$ctx1.fill(self,"isImmutable",{},$globals.ValueNode)});
},
args: [],
source: "isImmutable\x0a\x09^ self value isImmutable",
referencedClasses: [],
messageSends: ["isImmutable", "value"]
}),
$globals.ValueNode);

$core.addMethod(
$core.method({
selector: "isValueNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isValueNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.ValueNode);

$core.addMethod(
$core.method({
selector: "value",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@value"];

},
args: [],
source: "value\x0a\x09^ value",
referencedClasses: [],
messageSends: []
}),
$globals.ValueNode);

$core.addMethod(
$core.method({
selector: "value:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@value"]=anObject;
return self;

},
args: ["anObject"],
source: "value: anObject\x0a\x09value := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.ValueNode);



$core.addClass('VariableNode', $globals.ValueNode, ['assigned', 'binding'], 'Compiler-AST');
$globals.VariableNode.comment="I represent an variable node.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitVariableNode_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.VariableNode)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitVariableNode: self",
referencedClasses: [],
messageSends: ["visitVariableNode:"]
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "alias",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._binding())._alias();
}, function($ctx1) {$ctx1.fill(self,"alias",{},$globals.VariableNode)});
},
args: [],
source: "alias\x0a\x09^ self binding alias",
referencedClasses: [],
messageSends: ["alias", "binding"]
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "assigned",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@assigned"];
if(($receiver = $1) == null || $receiver.isNil){
return false;
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"assigned",{},$globals.VariableNode)});
},
args: [],
source: "assigned\x0a\x09^ assigned ifNil: [ false ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "assigned:",
protocol: 'accessing',
fn: function (aBoolean){
var self=this;
self["@assigned"]=aBoolean;
return self;

},
args: ["aBoolean"],
source: "assigned: aBoolean\x0a\x09assigned := aBoolean",
referencedClasses: [],
messageSends: []
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "beAssigned",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._binding())._validateAssignment();
self["@assigned"]=true;
return self;
}, function($ctx1) {$ctx1.fill(self,"beAssigned",{},$globals.VariableNode)});
},
args: [],
source: "beAssigned\x0a\x09self binding validateAssignment.\x0a\x09assigned := true",
referencedClasses: [],
messageSends: ["validateAssignment", "binding"]
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "binding",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@binding"];

},
args: [],
source: "binding\x0a\x09^ binding",
referencedClasses: [],
messageSends: []
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "binding:",
protocol: 'accessing',
fn: function (aScopeVar){
var self=this;
self["@binding"]=aScopeVar;
return self;

},
args: ["aScopeVar"],
source: "binding: aScopeVar\x0a\x09binding := aScopeVar",
referencedClasses: [],
messageSends: []
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "isArgument",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._binding())._isArgVar();
}, function($ctx1) {$ctx1.fill(self,"isArgument",{},$globals.VariableNode)});
},
args: [],
source: "isArgument\x0a\x09^ self binding isArgVar",
referencedClasses: [],
messageSends: ["isArgVar", "binding"]
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._binding())._isImmutable();
}, function($ctx1) {$ctx1.fill(self,"isImmutable",{},$globals.VariableNode)});
},
args: [],
source: "isImmutable\x0a\x09^ self binding isImmutable",
referencedClasses: [],
messageSends: ["isImmutable", "binding"]
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "isNavigationNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isNavigationNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "isVariableNode",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isVariableNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "navigationLink",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._value();
}, function($ctx1) {$ctx1.fill(self,"navigationLink",{},$globals.VariableNode)});
},
args: [],
source: "navigationLink\x0a\x09^ self value",
referencedClasses: [],
messageSends: ["value"]
}),
$globals.VariableNode);



$core.addClass('NodeVisitor', $globals.Object, [], 'Compiler-AST');
$globals.NodeVisitor.comment="I am the abstract super class of all AST node visitors.";
$core.addMethod(
$core.method({
selector: "visit:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aNode)._accept_(self);
}, function($ctx1) {$ctx1.fill(self,"visit:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visit: aNode\x0a\x09^ aNode accept: self",
referencedClasses: [],
messageSends: ["accept:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitAll:",
protocol: 'visiting',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aCollection)._collect_((function(each){
return $core.withContext(function($ctx2) {
return self._visit_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"visitAll:",{aCollection:aCollection},$globals.NodeVisitor)});
},
args: ["aCollection"],
source: "visitAll: aCollection\x0a\x09^ aCollection collect: [ :each | self visit: each ]",
referencedClasses: [],
messageSends: ["collect:", "visit:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitAssignmentNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitAssignmentNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitAssignmentNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitBlockNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitBlockNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitBlockNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitBlockSequenceNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitSequenceNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitBlockSequenceNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitBlockSequenceNode: aNode\x0a\x09^ self visitSequenceNode: aNode",
referencedClasses: [],
messageSends: ["visitSequenceNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitCascadeNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitCascadeNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitCascadeNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitDynamicArrayNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitDynamicArrayNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitDynamicArrayNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitDynamicDictionaryNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitDynamicDictionaryNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitDynamicDictionaryNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitJSStatementNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitJSStatementNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitJSStatementNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitMethodNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitMethodNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitMethodNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitAll_($recv(aNode)._nodes());
}, function($ctx1) {$ctx1.fill(self,"visitNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitNode: aNode\x0a\x09^ self visitAll: aNode nodes",
referencedClasses: [],
messageSends: ["visitAll:", "nodes"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitReturnNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitReturnNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitReturnNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitSequenceNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitSequenceNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitSequenceNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitValueNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitValueNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitValueNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitVariableNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitVariableNode:",{aNode:aNode},$globals.NodeVisitor)});
},
args: ["aNode"],
source: "visitVariableNode: aNode\x0a\x09^ self visitNode: aNode",
referencedClasses: [],
messageSends: ["visitNode:"]
}),
$globals.NodeVisitor);


$core.addMethod(
$core.method({
selector: "ast",
protocol: '*Compiler-AST',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._source();
$ctx1.sendIdx["source"]=1;
$recv($1)._ifEmpty_((function(){
return $core.withContext(function($ctx2) {
return self._error_("Method source is empty");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return $recv($globals.Smalltalk)._parse_(self._source());
}, function($ctx1) {$ctx1.fill(self,"ast",{},$globals.CompiledMethod)});
},
args: [],
source: "ast\x0a\x09self source ifEmpty: [ self error: 'Method source is empty' ].\x0a\x09\x0a\x09^ Smalltalk parse: self source",
referencedClasses: ["Smalltalk"],
messageSends: ["ifEmpty:", "source", "error:", "parse:"]
}),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "isNode",
protocol: '*Compiler-AST',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Object);

});

define("amber_core/Compiler-Semantic", ["amber/boot", "amber_core/Kernel-Objects", "amber_core/Compiler-AST", "amber_core/Compiler-Core"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Compiler-Semantic');
$core.packages["Compiler-Semantic"].innerEval = function (expr) { return eval(expr); };
$core.packages["Compiler-Semantic"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('LexicalScope', $globals.Object, ['node', 'instruction', 'temps', 'args', 'outerScope', 'blockIndex'], 'Compiler-Semantic');
$globals.LexicalScope.comment="I represent a lexical scope where variable names are associated with ScopeVars\x0aInstances are used for block scopes. Method scopes are instances of MethodLexicalScope.\x0a\x0aI am attached to a ScopeVar and method/block nodes.\x0aEach context (method/closure) get a fresh scope that inherits from its outer scope.";
$core.addMethod(
$core.method({
selector: "addArg:",
protocol: 'adding',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._args();
$ctx1.sendIdx["args"]=1;
$recv($1)._at_put_(aString,$recv($globals.ArgVar)._on_(aString));
$recv($recv(self._args())._at_(aString))._scope_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"addArg:",{aString:aString},$globals.LexicalScope)});
},
args: ["aString"],
source: "addArg: aString\x0a\x09self args at: aString put: (ArgVar on: aString).\x0a\x09(self args at: aString) scope: self",
referencedClasses: ["ArgVar"],
messageSends: ["at:put:", "args", "on:", "scope:", "at:"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "addTemp:",
protocol: 'adding',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._temps();
$ctx1.sendIdx["temps"]=1;
$recv($1)._at_put_(aString,$recv($globals.TempVar)._on_(aString));
$recv($recv(self._temps())._at_(aString))._scope_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"addTemp:",{aString:aString},$globals.LexicalScope)});
},
args: ["aString"],
source: "addTemp: aString\x0a\x09self temps at: aString put: (TempVar on: aString).\x0a\x09(self temps at: aString) scope: self",
referencedClasses: ["TempVar"],
messageSends: ["at:put:", "temps", "on:", "scope:", "at:"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "alias",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return "$ctx".__comma($recv(self._scopeLevel())._asString());
}, function($ctx1) {$ctx1.fill(self,"alias",{},$globals.LexicalScope)});
},
args: [],
source: "alias\x0a\x09^ '$ctx', self scopeLevel asString",
referencedClasses: [],
messageSends: [",", "asString", "scopeLevel"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "allVariableNames",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self._args())._keys();
$ctx1.sendIdx["keys"]=1;
return $recv($1).__comma($recv(self._temps())._keys());
}, function($ctx1) {$ctx1.fill(self,"allVariableNames",{},$globals.LexicalScope)});
},
args: [],
source: "allVariableNames\x0a\x09^ self args keys, self temps keys",
referencedClasses: [],
messageSends: [",", "keys", "args", "temps"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "args",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@args"];
if(($receiver = $1) == null || $receiver.isNil){
self["@args"]=$recv($globals.Dictionary)._new();
return self["@args"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"args",{},$globals.LexicalScope)});
},
args: [],
source: "args\x0a\x09^ args ifNil: [ args := Dictionary new ]",
referencedClasses: ["Dictionary"],
messageSends: ["ifNil:", "new"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "bindingFor:",
protocol: 'accessing',
fn: function (aStringOrNode){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$4,$5,$1;
$2=self._pseudoVars();
$3=$recv(aStringOrNode)._value();
$ctx1.sendIdx["value"]=1;
$1=$recv($2)._at_ifAbsent_($3,(function(){
return $core.withContext(function($ctx2) {
$4=self._args();
$5=$recv(aStringOrNode)._value();
$ctx2.sendIdx["value"]=2;
return $recv($4)._at_ifAbsent_($5,(function(){
return $core.withContext(function($ctx3) {
return $recv(self._temps())._at_ifAbsent_($recv(aStringOrNode)._value(),(function(){
return nil;

}));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
$ctx2.sendIdx["at:ifAbsent:"]=2;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["at:ifAbsent:"]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"bindingFor:",{aStringOrNode:aStringOrNode},$globals.LexicalScope)});
},
args: ["aStringOrNode"],
source: "bindingFor: aStringOrNode\x0a\x09^ self pseudoVars at: aStringOrNode value ifAbsent: [\x0a\x09\x09self args at: aStringOrNode value ifAbsent: [\x0a\x09\x09\x09self temps at: aStringOrNode value ifAbsent: [ nil ]]]",
referencedClasses: [],
messageSends: ["at:ifAbsent:", "pseudoVars", "value", "args", "temps"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "blockIndex",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@blockIndex"];
if(($receiver = $1) == null || $receiver.isNil){
return (0);
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"blockIndex",{},$globals.LexicalScope)});
},
args: [],
source: "blockIndex\x0a\x09^ blockIndex ifNil: [ 0 ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "blockIndex:",
protocol: 'accessing',
fn: function (anInteger){
var self=this;
self["@blockIndex"]=anInteger;
return self;

},
args: ["anInteger"],
source: "blockIndex: anInteger \x0a\x09blockIndex := anInteger",
referencedClasses: [],
messageSends: []
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "canInlineNonLocalReturns",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._isInlined())._and_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._outerScope())._canInlineNonLocalReturns();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"canInlineNonLocalReturns",{},$globals.LexicalScope)});
},
args: [],
source: "canInlineNonLocalReturns\x0a\x09^ self isInlined and: [ self outerScope canInlineNonLocalReturns ]",
referencedClasses: [],
messageSends: ["and:", "isInlined", "canInlineNonLocalReturns", "outerScope"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "instruction",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@instruction"];

},
args: [],
source: "instruction\x0a\x09^ instruction",
referencedClasses: [],
messageSends: []
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "instruction:",
protocol: 'accessing',
fn: function (anIRInstruction){
var self=this;
self["@instruction"]=anIRInstruction;
return self;

},
args: ["anIRInstruction"],
source: "instruction: anIRInstruction\x0a\x09instruction := anIRInstruction",
referencedClasses: [],
messageSends: []
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "isBlockScope",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._isMethodScope())._not();
}, function($ctx1) {$ctx1.fill(self,"isBlockScope",{},$globals.LexicalScope)});
},
args: [],
source: "isBlockScope\x0a\x09^ self isMethodScope not",
referencedClasses: [],
messageSends: ["not", "isMethodScope"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=self._instruction();
$ctx1.sendIdx["instruction"]=1;
$1=$recv($2)._notNil();
return $recv($1)._and_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._instruction())._isInlined();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"isInlined",{},$globals.LexicalScope)});
},
args: [],
source: "isInlined\x0a\x09^ self instruction notNil and: [\x0a\x09\x09self instruction isInlined ]",
referencedClasses: [],
messageSends: ["and:", "notNil", "instruction", "isInlined"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "isMethodScope",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isMethodScope\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "lookupVariable:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
var lookup;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
lookup=self._bindingFor_(aNode);
$1=lookup;
if(($receiver = $1) == null || $receiver.isNil){
$2=self._outerScope();
$ctx1.sendIdx["outerScope"]=1;
if(($receiver = $2) == null || $receiver.isNil){
lookup=$2;
} else {
lookup=$recv(self._outerScope())._lookupVariable_(aNode);
};
lookup;
} else {
$1;
};
return lookup;
}, function($ctx1) {$ctx1.fill(self,"lookupVariable:",{aNode:aNode,lookup:lookup},$globals.LexicalScope)});
},
args: ["aNode"],
source: "lookupVariable: aNode\x0a\x09| lookup |\x0a\x09lookup := (self bindingFor: aNode).\x0a\x09lookup ifNil: [\x0a\x09\x09lookup := self outerScope ifNotNil: [\x0a\x09\x09\x09(self outerScope lookupVariable: aNode) ]].\x0a\x09^ lookup",
referencedClasses: [],
messageSends: ["bindingFor:", "ifNil:", "ifNotNil:", "outerScope", "lookupVariable:"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "methodScope",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._outerScope();
$ctx1.sendIdx["outerScope"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return $1;
} else {
return $recv(self._outerScope())._methodScope();
};
}, function($ctx1) {$ctx1.fill(self,"methodScope",{},$globals.LexicalScope)});
},
args: [],
source: "methodScope\x0a\x09^ self outerScope ifNotNil: [\x0a\x09\x09self outerScope methodScope ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "outerScope", "methodScope"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "node",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@node"];

},
args: [],
source: "node\x0a\x09\x22Answer the node in which I am defined\x22\x0a\x09\x0a\x09^ node",
referencedClasses: [],
messageSends: []
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "node:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
self["@node"]=aNode;
return self;

},
args: ["aNode"],
source: "node: aNode\x0a\x09node := aNode",
referencedClasses: [],
messageSends: []
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "outerScope",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@outerScope"];

},
args: [],
source: "outerScope\x0a\x09^ outerScope",
referencedClasses: [],
messageSends: []
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "outerScope:",
protocol: 'accessing',
fn: function (aLexicalScope){
var self=this;
self["@outerScope"]=aLexicalScope;
return self;

},
args: ["aLexicalScope"],
source: "outerScope: aLexicalScope\x0a\x09outerScope := aLexicalScope",
referencedClasses: [],
messageSends: []
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "pseudoVars",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._methodScope())._pseudoVars();
}, function($ctx1) {$ctx1.fill(self,"pseudoVars",{},$globals.LexicalScope)});
},
args: [],
source: "pseudoVars\x0a\x09^ self methodScope pseudoVars",
referencedClasses: [],
messageSends: ["pseudoVars", "methodScope"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "scopeLevel",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3,$receiver;
$1=self._outerScope();
$ctx1.sendIdx["outerScope"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return (1);
} else {
$1;
};
$2=self._isInlined();
if($core.assert($2)){
$4=self._outerScope();
$ctx1.sendIdx["outerScope"]=2;
$3=$recv($4)._scopeLevel();
$ctx1.sendIdx["scopeLevel"]=1;
return $3;
};
return $recv($recv(self._outerScope())._scopeLevel()).__plus((1));
}, function($ctx1) {$ctx1.fill(self,"scopeLevel",{},$globals.LexicalScope)});
},
args: [],
source: "scopeLevel\x0a\x09self outerScope ifNil: [ ^ 1 ].\x0a\x09self isInlined ifTrue: [ ^ self outerScope scopeLevel ].\x0a\x09\x0a\x09^ self outerScope scopeLevel + 1",
referencedClasses: [],
messageSends: ["ifNil:", "outerScope", "ifTrue:", "isInlined", "scopeLevel", "+"]
}),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "temps",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@temps"];
if(($receiver = $1) == null || $receiver.isNil){
self["@temps"]=$recv($globals.Dictionary)._new();
return self["@temps"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"temps",{},$globals.LexicalScope)});
},
args: [],
source: "temps\x0a\x09^ temps ifNil: [ temps := Dictionary new ]",
referencedClasses: ["Dictionary"],
messageSends: ["ifNil:", "new"]
}),
$globals.LexicalScope);



$core.addClass('MethodLexicalScope', $globals.LexicalScope, ['iVars', 'pseudoVars', 'unknownVariables', 'localReturn', 'nonLocalReturns'], 'Compiler-Semantic');
$globals.MethodLexicalScope.comment="I represent a method scope.";
$core.addMethod(
$core.method({
selector: "addIVar:",
protocol: 'adding',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._iVars();
$ctx1.sendIdx["iVars"]=1;
$recv($1)._at_put_(aString,$recv($globals.InstanceVar)._on_(aString));
$recv($recv(self._iVars())._at_(aString))._scope_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"addIVar:",{aString:aString},$globals.MethodLexicalScope)});
},
args: ["aString"],
source: "addIVar: aString\x0a\x09self iVars at: aString put: (InstanceVar on: aString).\x0a\x09(self iVars at: aString) scope: self",
referencedClasses: ["InstanceVar"],
messageSends: ["at:put:", "iVars", "on:", "scope:", "at:"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "addNonLocalReturn:",
protocol: 'adding',
fn: function (aScope){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._nonLocalReturns())._add_(aScope);
return self;
}, function($ctx1) {$ctx1.fill(self,"addNonLocalReturn:",{aScope:aScope},$globals.MethodLexicalScope)});
},
args: ["aScope"],
source: "addNonLocalReturn: aScope\x0a\x09self nonLocalReturns add: aScope",
referencedClasses: [],
messageSends: ["add:", "nonLocalReturns"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "allVariableNames",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=(
$ctx1.supercall = true,
($globals.MethodLexicalScope.superclass||$boot.dnu).fn.prototype._allVariableNames.apply($recv(self), []));
$ctx1.supercall = false;
return $recv($1).__comma($recv(self._iVars())._keys());
}, function($ctx1) {$ctx1.fill(self,"allVariableNames",{},$globals.MethodLexicalScope)});
},
args: [],
source: "allVariableNames\x0a\x09^ super allVariableNames, self iVars keys",
referencedClasses: [],
messageSends: [",", "allVariableNames", "keys", "iVars"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "bindingFor:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=(
$ctx1.supercall = true,
($globals.MethodLexicalScope.superclass||$boot.dnu).fn.prototype._bindingFor_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
if(($receiver = $1) == null || $receiver.isNil){
return $recv(self._iVars())._at_ifAbsent_($recv(aNode)._value(),(function(){
return nil;

}));
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"bindingFor:",{aNode:aNode},$globals.MethodLexicalScope)});
},
args: ["aNode"],
source: "bindingFor: aNode\x0a\x09^ (super bindingFor: aNode) ifNil: [\x0a\x09\x09self iVars at: aNode value ifAbsent: [ nil ]]",
referencedClasses: [],
messageSends: ["ifNil:", "bindingFor:", "at:ifAbsent:", "iVars", "value"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "canInlineNonLocalReturns",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "canInlineNonLocalReturns\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "hasLocalReturn",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._localReturn();
}, function($ctx1) {$ctx1.fill(self,"hasLocalReturn",{},$globals.MethodLexicalScope)});
},
args: [],
source: "hasLocalReturn\x0a\x09^ self localReturn",
referencedClasses: [],
messageSends: ["localReturn"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "hasNonLocalReturn",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._nonLocalReturns())._notEmpty();
}, function($ctx1) {$ctx1.fill(self,"hasNonLocalReturn",{},$globals.MethodLexicalScope)});
},
args: [],
source: "hasNonLocalReturn\x0a\x09^ self nonLocalReturns notEmpty",
referencedClasses: [],
messageSends: ["notEmpty", "nonLocalReturns"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "iVars",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@iVars"];
if(($receiver = $1) == null || $receiver.isNil){
self["@iVars"]=$recv($globals.Dictionary)._new();
return self["@iVars"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"iVars",{},$globals.MethodLexicalScope)});
},
args: [],
source: "iVars\x0a\x09^ iVars ifNil: [ iVars := Dictionary new ]",
referencedClasses: ["Dictionary"],
messageSends: ["ifNil:", "new"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "isMethodScope",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isMethodScope\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "localReturn",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@localReturn"];
if(($receiver = $1) == null || $receiver.isNil){
return false;
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"localReturn",{},$globals.MethodLexicalScope)});
},
args: [],
source: "localReturn\x0a\x09^ localReturn ifNil: [ false ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "localReturn:",
protocol: 'accessing',
fn: function (aBoolean){
var self=this;
self["@localReturn"]=aBoolean;
return self;

},
args: ["aBoolean"],
source: "localReturn: aBoolean\x0a\x09localReturn := aBoolean",
referencedClasses: [],
messageSends: []
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "methodScope",
protocol: 'accessing',
fn: function (){
var self=this;
return self;

},
args: [],
source: "methodScope\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "nonLocalReturns",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@nonLocalReturns"];
if(($receiver = $1) == null || $receiver.isNil){
self["@nonLocalReturns"]=$recv($globals.OrderedCollection)._new();
return self["@nonLocalReturns"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"nonLocalReturns",{},$globals.MethodLexicalScope)});
},
args: [],
source: "nonLocalReturns\x0a\x09^ nonLocalReturns ifNil: [ nonLocalReturns := OrderedCollection new ]",
referencedClasses: ["OrderedCollection"],
messageSends: ["ifNil:", "new"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "pseudoVars",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3,$receiver;
$1=self["@pseudoVars"];
if(($receiver = $1) == null || $receiver.isNil){
self["@pseudoVars"]=$recv($globals.Dictionary)._new();
self["@pseudoVars"];
$recv($recv($globals.Smalltalk)._pseudoVariableNames())._do_((function(each){
return $core.withContext(function($ctx2) {
$2=self["@pseudoVars"];
$4=$recv($globals.PseudoVar)._on_(each);
$recv($4)._scope_(self._methodScope());
$3=$recv($4)._yourself();
return $recv($2)._at_put_(each,$3);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
} else {
$1;
};
return self["@pseudoVars"];
}, function($ctx1) {$ctx1.fill(self,"pseudoVars",{},$globals.MethodLexicalScope)});
},
args: [],
source: "pseudoVars\x0a\x09pseudoVars ifNil: [\x0a\x09\x09pseudoVars := Dictionary new.\x0a\x09\x09Smalltalk pseudoVariableNames do: [ :each |\x0a\x09\x09\x09pseudoVars at: each put: ((PseudoVar on: each)\x0a\x09\x09\x09\x09scope: self methodScope;\x0a\x09\x09\x09\x09yourself) ]].\x0a\x09^ pseudoVars",
referencedClasses: ["Dictionary", "Smalltalk", "PseudoVar"],
messageSends: ["ifNil:", "new", "do:", "pseudoVariableNames", "at:put:", "scope:", "on:", "methodScope", "yourself"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "removeNonLocalReturn:",
protocol: 'adding',
fn: function (aScope){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._nonLocalReturns())._remove_ifAbsent_(aScope,(function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"removeNonLocalReturn:",{aScope:aScope},$globals.MethodLexicalScope)});
},
args: ["aScope"],
source: "removeNonLocalReturn: aScope\x0a\x09self nonLocalReturns remove: aScope ifAbsent: []",
referencedClasses: [],
messageSends: ["remove:ifAbsent:", "nonLocalReturns"]
}),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "unknownVariables",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@unknownVariables"];
if(($receiver = $1) == null || $receiver.isNil){
self["@unknownVariables"]=$recv($globals.OrderedCollection)._new();
return self["@unknownVariables"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"unknownVariables",{},$globals.MethodLexicalScope)});
},
args: [],
source: "unknownVariables\x0a\x09^ unknownVariables ifNil: [ unknownVariables := OrderedCollection new ]",
referencedClasses: ["OrderedCollection"],
messageSends: ["ifNil:", "new"]
}),
$globals.MethodLexicalScope);



$core.addClass('ScopeVar', $globals.Object, ['scope', 'name'], 'Compiler-Semantic');
$globals.ScopeVar.comment="I am an entry in a LexicalScope that gets associated with variable nodes of the same name.\x0aThere are 4 different subclasses of vars: temp vars, local vars, args, and unknown/global vars.";
$core.addMethod(
$core.method({
selector: "alias",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._name())._asVariableName();
}, function($ctx1) {$ctx1.fill(self,"alias",{},$globals.ScopeVar)});
},
args: [],
source: "alias\x0a\x09^ self name asVariableName",
referencedClasses: [],
messageSends: ["asVariableName", "name"]
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isArgVar",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isArgVar\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isClassRefVar",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isClassRefVar\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isImmutable\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isInstanceVar",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isInstanceVar\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isPseudoVar",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isPseudoVar\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isTempVar",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isTempVar\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isUnknownVar",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isUnknownVar\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "name",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@name"];

},
args: [],
source: "name\x0a\x09^ name",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "name:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@name"]=aString;
return self;

},
args: ["aString"],
source: "name: aString\x0a\x09name := aString",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "scope",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@scope"];

},
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: 'accessing',
fn: function (aScope){
var self=this;
self["@scope"]=aScope;
return self;

},
args: ["aScope"],
source: "scope: aScope\x0a\x09scope := aScope",
referencedClasses: [],
messageSends: []
}),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "validateAssignment",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv(self._isArgVar())._or_((function(){
return $core.withContext(function($ctx2) {
return self._isPseudoVar();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
if($core.assert($1)){
$2=$recv($globals.InvalidAssignmentError)._new();
$recv($2)._variableName_(self._name());
$recv($2)._signal();
};
return self;
}, function($ctx1) {$ctx1.fill(self,"validateAssignment",{},$globals.ScopeVar)});
},
args: [],
source: "validateAssignment\x0a\x09(self isArgVar or: [ self isPseudoVar ]) ifTrue: [\x0a\x09\x09InvalidAssignmentError new\x0a\x09\x09\x09variableName: self name;\x0a\x09\x09\x09signal]",
referencedClasses: ["InvalidAssignmentError"],
messageSends: ["ifTrue:", "or:", "isArgVar", "isPseudoVar", "variableName:", "new", "name", "signal"]
}),
$globals.ScopeVar);


$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._name_(aString);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aString:aString},$globals.ScopeVar.klass)});
},
args: ["aString"],
source: "on: aString\x0a\x09^ self new\x0a\x09\x09name: aString;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["name:", "new", "yourself"]
}),
$globals.ScopeVar.klass);


$core.addClass('AliasVar', $globals.ScopeVar, ['node'], 'Compiler-Semantic');
$globals.AliasVar.comment="I am an internally defined variable by the compiler";
$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.AliasVar);

$core.addMethod(
$core.method({
selector: "node",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@node"];

},
args: [],
source: "node\x0a\x09^ node",
referencedClasses: [],
messageSends: []
}),
$globals.AliasVar);

$core.addMethod(
$core.method({
selector: "node:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
self["@node"]=aNode;
return self;

},
args: ["aNode"],
source: "node: aNode\x0a\x09node := aNode",
referencedClasses: [],
messageSends: []
}),
$globals.AliasVar);



$core.addClass('ArgVar', $globals.ScopeVar, [], 'Compiler-Semantic');
$globals.ArgVar.comment="I am an argument of a method or block.";
$core.addMethod(
$core.method({
selector: "isArgVar",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isArgVar\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.ArgVar);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.ArgVar);



$core.addClass('ClassRefVar', $globals.ScopeVar, [], 'Compiler-Semantic');
$globals.ClassRefVar.comment="I am an class reference variable";
$core.addMethod(
$core.method({
selector: "alias",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return "$globals.".__comma(self._name());
}, function($ctx1) {$ctx1.fill(self,"alias",{},$globals.ClassRefVar)});
},
args: [],
source: "alias\x0a\x09\x22Fixes issue #190.\x0a\x09A function is created in the method definition, answering the class or nil.\x0a\x09See JSStream >> #nextPutClassRefFunction:\x22\x0a\x09\x0a\x09^ '$globals.', self name",
referencedClasses: [],
messageSends: [",", "name"]
}),
$globals.ClassRefVar);

$core.addMethod(
$core.method({
selector: "isClassRefVar",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isClassRefVar\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.ClassRefVar);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.ClassRefVar);



$core.addClass('InstanceVar', $globals.ScopeVar, [], 'Compiler-Semantic');
$globals.InstanceVar.comment="I am an instance variable of a method or block.";
$core.addMethod(
$core.method({
selector: "alias",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv("self[\x22@".__comma(self._name())).__comma("\x22]");
$ctx1.sendIdx[","]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"alias",{},$globals.InstanceVar)});
},
args: [],
source: "alias\x0a\x09^ 'self[\x22@', self name, '\x22]'",
referencedClasses: [],
messageSends: [",", "name"]
}),
$globals.InstanceVar);

$core.addMethod(
$core.method({
selector: "isInstanceVar",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isInstanceVar\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.InstanceVar);



$core.addClass('PseudoVar', $globals.ScopeVar, [], 'Compiler-Semantic');
$globals.PseudoVar.comment="I am an pseudo variable.\x0a\x0aThe five Smalltalk pseudo variables are: 'self', 'super', 'nil', 'true' and 'false'";
$core.addMethod(
$core.method({
selector: "alias",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._name();
}, function($ctx1) {$ctx1.fill(self,"alias",{},$globals.PseudoVar)});
},
args: [],
source: "alias\x0a\x09^ self name",
referencedClasses: [],
messageSends: ["name"]
}),
$globals.PseudoVar);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.PseudoVar);

$core.addMethod(
$core.method({
selector: "isPseudoVar",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isPseudoVar\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.PseudoVar);



$core.addClass('TempVar', $globals.ScopeVar, [], 'Compiler-Semantic');
$globals.TempVar.comment="I am an temporary variable of a method or block.";
$core.addMethod(
$core.method({
selector: "isTempVar",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isTempVar\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.TempVar);



$core.addClass('UnknownVar', $globals.ScopeVar, [], 'Compiler-Semantic');
$globals.UnknownVar.comment="I am an unknown variable. Amber uses unknown variables as JavaScript globals";
$core.addMethod(
$core.method({
selector: "isUnknownVar",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isUnknownVar\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.UnknownVar);



$core.addClass('SemanticAnalyzer', $globals.NodeVisitor, ['currentScope', 'blockIndex', 'thePackage', 'theClass', 'classReferences', 'messageSends'], 'Compiler-Semantic');
$globals.SemanticAnalyzer.comment="I semantically analyze the abstract syntax tree and annotate it with informations such as non local returns and variable scopes.";
$core.addMethod(
$core.method({
selector: "classReferences",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@classReferences"];
if(($receiver = $1) == null || $receiver.isNil){
self["@classReferences"]=$recv($globals.Set)._new();
return self["@classReferences"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"classReferences",{},$globals.SemanticAnalyzer)});
},
args: [],
source: "classReferences\x0a\x09^ classReferences ifNil: [ classReferences := Set new ]",
referencedClasses: ["Set"],
messageSends: ["ifNil:", "new"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "errorShadowingVariable:",
protocol: 'error handling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ShadowingVariableError)._new();
$recv($1)._variableName_(aString);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"errorShadowingVariable:",{aString:aString},$globals.SemanticAnalyzer)});
},
args: ["aString"],
source: "errorShadowingVariable: aString\x0a\x09ShadowingVariableError new\x0a\x09\x09variableName: aString;\x0a\x09\x09signal",
referencedClasses: ["ShadowingVariableError"],
messageSends: ["variableName:", "new", "signal"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "errorUnknownVariable:",
protocol: 'error handling',
fn: function (aNode){
var self=this;
var identifier;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
identifier=$recv(aNode)._value();
$ctx1.sendIdx["value"]=1;
$1=$recv($recv($recv($recv($globals.Smalltalk)._globalJsVariables())._includes_(identifier))._not())._and_((function(){
return $core.withContext(function($ctx2) {
return self._isVariableUndefined_inPackage_(identifier,self._thePackage());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
if($core.assert($1)){
$2=$recv($globals.UnknownVariableError)._new();
$3=$recv(aNode)._value();
$ctx1.sendIdx["value"]=2;
$recv($2)._variableName_($3);
$recv($2)._signal();
} else {
$recv($recv($recv(self["@currentScope"])._methodScope())._unknownVariables())._add_($recv(aNode)._value());
};
return self;
}, function($ctx1) {$ctx1.fill(self,"errorUnknownVariable:",{aNode:aNode,identifier:identifier},$globals.SemanticAnalyzer)});
},
args: ["aNode"],
source: "errorUnknownVariable: aNode\x0a\x09\x22Throw an error if the variable is undeclared in the global JS scope (i.e. window).\x0a\x09We allow all variables listed by Smalltalk>>#globalJsVariables.\x0a\x09This list includes: `window`, `document`,  `process` and `global`\x0a\x09for nodejs and browser environments.\x0a\x09\x0a\x09This is only to make sure compilation works on both browser-based and nodejs environments.\x0a\x09The ideal solution would be to use a pragma instead\x22\x0a\x0a\x09| identifier |\x0a\x09identifier := aNode value.\x0a\x09\x0a\x09((Smalltalk globalJsVariables includes: identifier) not\x0a\x09\x09and: [ self isVariableUndefined: identifier inPackage: self thePackage ])\x0a\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09UnknownVariableError new\x0a\x09\x09\x09\x09\x09variableName: aNode value;\x0a\x09\x09\x09\x09\x09signal ]\x0a\x09\x09\x09ifFalse: [\x0a\x09\x09\x09\x09currentScope methodScope unknownVariables add: aNode value ]",
referencedClasses: ["Smalltalk", "UnknownVariableError"],
messageSends: ["value", "ifTrue:ifFalse:", "and:", "not", "includes:", "globalJsVariables", "isVariableUndefined:inPackage:", "thePackage", "variableName:", "new", "signal", "add:", "unknownVariables", "methodScope"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "isVariableUndefined:inPackage:",
protocol: 'testing',
fn: function (aString,aPackage){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$receiver;
if(($receiver = aPackage) == null || $receiver.isNil){
aPackage;
} else {
var packageKnownVars;
packageKnownVars=$recv($recv($recv(aPackage)._imports())._reject_("isString"))._collect_("key");
packageKnownVars;
$1=$recv(packageKnownVars)._includes_(aString);
if($core.assert($1)){
return false;
};
};
$2=$recv($globals.Compiler)._new();
$3=$recv("typeof ".__comma(aString)).__comma(" == \x22undefined\x22");
$ctx1.sendIdx[","]=1;
return $recv($2)._eval_($3);
}, function($ctx1) {$ctx1.fill(self,"isVariableUndefined:inPackage:",{aString:aString,aPackage:aPackage},$globals.SemanticAnalyzer)});
},
args: ["aString", "aPackage"],
source: "isVariableUndefined: aString inPackage: aPackage\x0a\x09aPackage ifNotNil: [\x0a\x09\x09| packageKnownVars |\x0a\x09\x09packageKnownVars := (aPackage imports\x0a\x09\x09\x09reject: #isString)\x0a\x09\x09\x09collect: #key.\x0a\x09\x09(packageKnownVars includes: aString) ifTrue: [ ^ false ]].\x0a\x09^ Compiler new\x0a\x09\x09eval: 'typeof ', aString, ' == \x22undefined\x22'",
referencedClasses: ["Compiler"],
messageSends: ["ifNotNil:", "collect:", "reject:", "imports", "ifTrue:", "includes:", "eval:", "new", ","]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "messageSends",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@messageSends"];
if(($receiver = $1) == null || $receiver.isNil){
self["@messageSends"]=$recv($globals.Dictionary)._new();
return self["@messageSends"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"messageSends",{},$globals.SemanticAnalyzer)});
},
args: [],
source: "messageSends\x0a\x09^ messageSends ifNil: [ messageSends := Dictionary new ]",
referencedClasses: ["Dictionary"],
messageSends: ["ifNil:", "new"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "newBlockScope",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._newScopeOfClass_($globals.LexicalScope);
}, function($ctx1) {$ctx1.fill(self,"newBlockScope",{},$globals.SemanticAnalyzer)});
},
args: [],
source: "newBlockScope\x0a\x09^ self newScopeOfClass: LexicalScope",
referencedClasses: ["LexicalScope"],
messageSends: ["newScopeOfClass:"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "newMethodScope",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._newScopeOfClass_($globals.MethodLexicalScope);
}, function($ctx1) {$ctx1.fill(self,"newMethodScope",{},$globals.SemanticAnalyzer)});
},
args: [],
source: "newMethodScope\x0a\x09^ self newScopeOfClass: MethodLexicalScope",
referencedClasses: ["MethodLexicalScope"],
messageSends: ["newScopeOfClass:"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "newScopeOfClass:",
protocol: 'factory',
fn: function (aLexicalScopeClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(aLexicalScopeClass)._new();
$recv($1)._outerScope_(self["@currentScope"]);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"newScopeOfClass:",{aLexicalScopeClass:aLexicalScopeClass},$globals.SemanticAnalyzer)});
},
args: ["aLexicalScopeClass"],
source: "newScopeOfClass: aLexicalScopeClass\x0a\x09^ aLexicalScopeClass new\x0a\x09\x09outerScope: currentScope;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["outerScope:", "new", "yourself"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "nextBlockIndex",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@blockIndex"];
if(($receiver = $1) == null || $receiver.isNil){
self["@blockIndex"]=(0);
self["@blockIndex"];
} else {
$1;
};
self["@blockIndex"]=$recv(self["@blockIndex"]).__plus((1));
return self["@blockIndex"];
}, function($ctx1) {$ctx1.fill(self,"nextBlockIndex",{},$globals.SemanticAnalyzer)});
},
args: [],
source: "nextBlockIndex\x0a\x09blockIndex ifNil: [ blockIndex := 0 ].\x0a\x09\x0a\x09blockIndex := blockIndex + 1.\x0a\x09^ blockIndex",
referencedClasses: [],
messageSends: ["ifNil:", "+"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "popScope",
protocol: 'scope',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@currentScope"];
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
self["@currentScope"]=$recv(self["@currentScope"])._outerScope();
self["@currentScope"];
};
return self;
}, function($ctx1) {$ctx1.fill(self,"popScope",{},$globals.SemanticAnalyzer)});
},
args: [],
source: "popScope\x0a\x09currentScope ifNotNil: [\x0a\x09\x09currentScope := currentScope outerScope ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "outerScope"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "pushScope:",
protocol: 'scope',
fn: function (aScope){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aScope)._outerScope_(self["@currentScope"]);
self["@currentScope"]=aScope;
return self;
}, function($ctx1) {$ctx1.fill(self,"pushScope:",{aScope:aScope},$globals.SemanticAnalyzer)});
},
args: ["aScope"],
source: "pushScope: aScope\x0a\x09aScope outerScope: currentScope.\x0a\x09currentScope := aScope",
referencedClasses: [],
messageSends: ["outerScope:"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@theClass"];

},
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
messageSends: []
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@theClass"]=aClass;
return self;

},
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "thePackage",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@thePackage"];

},
args: [],
source: "thePackage\x0a\x09^ thePackage",
referencedClasses: [],
messageSends: []
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "thePackage:",
protocol: 'accessing',
fn: function (aPackage){
var self=this;
self["@thePackage"]=aPackage;
return self;

},
args: ["aPackage"],
source: "thePackage: aPackage\x0a\x09thePackage := aPackage",
referencedClasses: [],
messageSends: []
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "validateVariableScope:",
protocol: 'scope',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=$recv(self["@currentScope"])._lookupVariable_(aString);
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
self._errorShadowingVariable_(aString);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"validateVariableScope:",{aString:aString},$globals.SemanticAnalyzer)});
},
args: ["aString"],
source: "validateVariableScope: aString\x0a\x09\x22Validate the variable scope in by doing a recursive lookup, up to the method scope\x22\x0a\x0a\x09(currentScope lookupVariable: aString) ifNotNil: [\x0a\x09\x09self errorShadowingVariable: aString ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "lookupVariable:", "errorShadowingVariable:"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitAssignmentNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.SemanticAnalyzer.superclass||$boot.dnu).fn.prototype._visitAssignmentNode_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
$recv($recv(aNode)._left())._beAssigned();
return self;
}, function($ctx1) {$ctx1.fill(self,"visitAssignmentNode:",{aNode:aNode},$globals.SemanticAnalyzer)});
},
args: ["aNode"],
source: "visitAssignmentNode: aNode\x0a\x09super visitAssignmentNode: aNode.\x0a\x09aNode left beAssigned",
referencedClasses: [],
messageSends: ["visitAssignmentNode:", "beAssigned", "left"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitBlockNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
self._pushScope_(self._newBlockScope());
$recv(aNode)._scope_(self["@currentScope"]);
$recv(self["@currentScope"])._node_(aNode);
$recv(self["@currentScope"])._blockIndex_(self._nextBlockIndex());
$recv($recv(aNode)._parameters())._do_((function(each){
return $core.withContext(function($ctx2) {
self._validateVariableScope_(each);
return $recv(self["@currentScope"])._addArg_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
(
$ctx1.supercall = true,
($globals.SemanticAnalyzer.superclass||$boot.dnu).fn.prototype._visitBlockNode_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
self._popScope();
return self;
}, function($ctx1) {$ctx1.fill(self,"visitBlockNode:",{aNode:aNode},$globals.SemanticAnalyzer)});
},
args: ["aNode"],
source: "visitBlockNode: aNode\x0a\x09self pushScope: self newBlockScope.\x0a\x09aNode scope: currentScope.\x0a\x09currentScope node: aNode.\x0a\x09currentScope blockIndex: self nextBlockIndex.\x0a\x0a\x09aNode parameters do: [ :each |\x0a\x09\x09self validateVariableScope: each.\x0a\x09\x09currentScope addArg: each ].\x0a\x0a\x09super visitBlockNode: aNode.\x0a\x09self popScope",
referencedClasses: [],
messageSends: ["pushScope:", "newBlockScope", "scope:", "node:", "blockIndex:", "nextBlockIndex", "do:", "parameters", "validateVariableScope:", "addArg:", "visitBlockNode:", "popScope"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitCascadeNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aNode)._receiver_($recv($recv($recv(aNode)._nodes())._first())._receiver());
(
$ctx1.supercall = true,
($globals.SemanticAnalyzer.superclass||$boot.dnu).fn.prototype._visitCascadeNode_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
return self;
}, function($ctx1) {$ctx1.fill(self,"visitCascadeNode:",{aNode:aNode},$globals.SemanticAnalyzer)});
},
args: ["aNode"],
source: "visitCascadeNode: aNode\x0a\x09aNode receiver: aNode nodes first receiver.\x0a\x09super visitCascadeNode: aNode",
referencedClasses: [],
messageSends: ["receiver:", "receiver", "first", "nodes", "visitCascadeNode:"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitMethodNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
self._pushScope_(self._newMethodScope());
$recv(aNode)._scope_(self["@currentScope"]);
$recv(self["@currentScope"])._node_(aNode);
$recv($recv(self._theClass())._allInstanceVariableNames())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(self["@currentScope"])._addIVar_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["do:"]=1;
$recv($recv(aNode)._arguments())._do_((function(each){
return $core.withContext(function($ctx2) {
self._validateVariableScope_(each);
return $recv(self["@currentScope"])._addArg_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
(
$ctx1.supercall = true,
($globals.SemanticAnalyzer.superclass||$boot.dnu).fn.prototype._visitMethodNode_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
$recv(aNode)._classReferences_(self._classReferences());
$recv(aNode)._sendIndexes_(self._messageSends());
self._popScope();
return self;
}, function($ctx1) {$ctx1.fill(self,"visitMethodNode:",{aNode:aNode},$globals.SemanticAnalyzer)});
},
args: ["aNode"],
source: "visitMethodNode: aNode\x0a\x09self pushScope: self newMethodScope.\x0a\x09aNode scope: currentScope.\x0a\x09currentScope node: aNode.\x0a\x0a\x09self theClass allInstanceVariableNames do: [ :each |\x0a\x09\x09currentScope addIVar: each ].\x0a\x09aNode arguments do: [ :each |\x0a\x09\x09self validateVariableScope: each.\x0a\x09\x09currentScope addArg: each ].\x0a\x0a\x09super visitMethodNode: aNode.\x0a\x0a\x09aNode\x0a\x09\x09classReferences: self classReferences;\x0a\x09\x09sendIndexes: self messageSends.\x0a\x09self popScope",
referencedClasses: [],
messageSends: ["pushScope:", "newMethodScope", "scope:", "node:", "do:", "allInstanceVariableNames", "theClass", "addIVar:", "arguments", "validateVariableScope:", "addArg:", "visitMethodNode:", "classReferences:", "classReferences", "sendIndexes:", "messageSends", "popScope"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitReturnNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(aNode)._scope_(self["@currentScope"]);
$1=$recv(self["@currentScope"])._isMethodScope();
if($core.assert($1)){
$recv(self["@currentScope"])._localReturn_(true);
} else {
$recv($recv(self["@currentScope"])._methodScope())._addNonLocalReturn_(self["@currentScope"]);
};
(
$ctx1.supercall = true,
($globals.SemanticAnalyzer.superclass||$boot.dnu).fn.prototype._visitReturnNode_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
return self;
}, function($ctx1) {$ctx1.fill(self,"visitReturnNode:",{aNode:aNode},$globals.SemanticAnalyzer)});
},
args: ["aNode"],
source: "visitReturnNode: aNode\x0a\x09aNode scope: currentScope.\x0a\x09currentScope isMethodScope\x0a\x09\x09ifTrue: [ currentScope localReturn: true ]\x0a\x09\x09ifFalse: [ currentScope methodScope addNonLocalReturn: currentScope ].\x0a\x09super visitReturnNode: aNode",
referencedClasses: [],
messageSends: ["scope:", "ifTrue:ifFalse:", "isMethodScope", "localReturn:", "addNonLocalReturn:", "methodScope", "visitReturnNode:"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$5,$6,$4,$7,$8,$9,$11,$12,$10,$receiver;
$3=$recv(aNode)._receiver();
$ctx1.sendIdx["receiver"]=1;
$2=$recv($3)._value();
$1=$recv($2).__eq("super");
if(!$core.assert($1)){
$5=$recv($globals.IRSendInliner)._inlinedSelectors();
$6=$recv(aNode)._selector();
$ctx1.sendIdx["selector"]=1;
$4=$recv($5)._includes_($6);
if($core.assert($4)){
$recv(aNode)._shouldBeInlined_(true);
$7=$recv(aNode)._receiver();
if(($receiver = $7) == null || $receiver.isNil){
$7;
} else {
var receiver;
receiver=$receiver;
$recv(receiver)._shouldBeAliased_(true);
};
};
};
$8=self._messageSends();
$ctx1.sendIdx["messageSends"]=1;
$9=$recv(aNode)._selector();
$ctx1.sendIdx["selector"]=2;
$recv($8)._at_ifAbsentPut_($9,(function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Set)._new();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}));
$11=self._messageSends();
$ctx1.sendIdx["messageSends"]=2;
$12=$recv(aNode)._selector();
$ctx1.sendIdx["selector"]=3;
$10=$recv($11)._at_($12);
$ctx1.sendIdx["at:"]=1;
$recv($10)._add_(aNode);
$recv(aNode)._index_($recv($recv(self._messageSends())._at_($recv(aNode)._selector()))._size());
(
$ctx1.supercall = true,
($globals.SemanticAnalyzer.superclass||$boot.dnu).fn.prototype._visitSendNode_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode},$globals.SemanticAnalyzer)});
},
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x0a\x09aNode receiver value = 'super'\x0a\x09\x09ifFalse: [ (IRSendInliner inlinedSelectors includes: aNode selector) ifTrue: [\x0a\x09\x09\x09aNode shouldBeInlined: true.\x0a\x09\x09\x09aNode receiver ifNotNil: [ :receiver |\x0a\x09\x09\x09\x09receiver shouldBeAliased: true ] ] ].\x0a\x0a\x09self messageSends at: aNode selector ifAbsentPut: [ Set new ].\x0a\x09(self messageSends at: aNode selector) add: aNode.\x0a\x0a\x09aNode index: (self messageSends at: aNode selector) size.\x0a\x0a\x09super visitSendNode: aNode",
referencedClasses: ["IRSendInliner", "Set"],
messageSends: ["ifFalse:", "=", "value", "receiver", "ifTrue:", "includes:", "inlinedSelectors", "selector", "shouldBeInlined:", "ifNotNil:", "shouldBeAliased:", "at:ifAbsentPut:", "messageSends", "new", "add:", "at:", "index:", "size", "visitSendNode:"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitSequenceNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aNode)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
self._validateVariableScope_(each);
return $recv(self["@currentScope"])._addTemp_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
(
$ctx1.supercall = true,
($globals.SemanticAnalyzer.superclass||$boot.dnu).fn.prototype._visitSequenceNode_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSequenceNode:",{aNode:aNode},$globals.SemanticAnalyzer)});
},
args: ["aNode"],
source: "visitSequenceNode: aNode\x0a\x09aNode temps do: [ :each |\x0a\x09\x09self validateVariableScope: each.\x0a\x09\x09currentScope addTemp: each ].\x0a\x0a\x09super visitSequenceNode: aNode",
referencedClasses: [],
messageSends: ["do:", "temps", "validateVariableScope:", "addTemp:", "visitSequenceNode:"]
}),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitVariableNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var binding;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$4,$5,$6,$7,$8,$9,$receiver;
binding=$recv(self["@currentScope"])._lookupVariable_(aNode);
$1=binding;
if(($receiver = $1) == null || $receiver.isNil){
$3=$recv(aNode)._value();
$ctx1.sendIdx["value"]=1;
$2=$recv($3)._isCapitalized();
if($core.assert($2)){
$4=$recv($globals.ClassRefVar)._new();
$ctx1.sendIdx["new"]=1;
$5=$recv(aNode)._value();
$ctx1.sendIdx["value"]=2;
$recv($4)._name_($5);
$ctx1.sendIdx["name:"]=1;
$6=$recv($4)._yourself();
$ctx1.sendIdx["yourself"]=1;
binding=$6;
binding;
$7=self._classReferences();
$8=$recv(aNode)._value();
$ctx1.sendIdx["value"]=3;
$recv($7)._add_($8);
} else {
self._errorUnknownVariable_(aNode);
$9=$recv($globals.UnknownVar)._new();
$recv($9)._name_($recv(aNode)._value());
binding=$recv($9)._yourself();
binding;
};
} else {
$1;
};
$recv(aNode)._binding_(binding);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitVariableNode:",{aNode:aNode,binding:binding},$globals.SemanticAnalyzer)});
},
args: ["aNode"],
source: "visitVariableNode: aNode\x0a\x09\x22Bind a ScopeVar to aNode by doing a lookup in the current scope.\x0a\x09If no ScopeVar is found, bind a UnknowVar and throw an error.\x22\x0a\x0a\x09| binding |\x0a\x09binding := currentScope lookupVariable: aNode.\x0a\x09\x0a\x09binding ifNil: [\x0a\x09\x09aNode value isCapitalized\x0a\x09\x09\x09ifTrue: [ \x22Capital letter variables might be globals.\x22\x0a\x09\x09\x09\x09binding := ClassRefVar new name: aNode value; yourself.\x0a\x09\x09\x09\x09self classReferences add: aNode value]\x0a\x09\x09\x09ifFalse: [\x0a\x09\x09\x09\x09self errorUnknownVariable: aNode.\x0a\x09\x09\x09\x09binding := UnknownVar new name: aNode value; yourself ] ].\x0a\x09\x09\x0a\x09aNode binding: binding.",
referencedClasses: ["ClassRefVar", "UnknownVar"],
messageSends: ["lookupVariable:", "ifNil:", "ifTrue:ifFalse:", "isCapitalized", "value", "name:", "new", "yourself", "add:", "classReferences", "errorUnknownVariable:", "binding:"]
}),
$globals.SemanticAnalyzer);


$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._theClass_(aClass);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aClass:aClass},$globals.SemanticAnalyzer.klass)});
},
args: ["aClass"],
source: "on: aClass\x0a\x09^ self new\x0a\x09\x09theClass: aClass;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["theClass:", "new", "yourself"]
}),
$globals.SemanticAnalyzer.klass);


$core.addClass('SemanticError', $globals.CompilerError, [], 'Compiler-Semantic');
$globals.SemanticError.comment="I represent an abstract semantic error thrown by the SemanticAnalyzer.\x0aSemantic errors can be unknown variable errors, etc.\x0aSee my subclasses for concrete errors.\x0a\x0aThe IDE should catch instances of Semantic error to deal with them when compiling";


$core.addClass('InvalidAssignmentError', $globals.SemanticError, ['variableName'], 'Compiler-Semantic');
$globals.InvalidAssignmentError.comment="I get signaled when a pseudo variable gets assigned.";
$core.addMethod(
$core.method({
selector: "messageText",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return " Invalid assignment to variable: ".__comma(self._variableName());
}, function($ctx1) {$ctx1.fill(self,"messageText",{},$globals.InvalidAssignmentError)});
},
args: [],
source: "messageText\x0a\x09^ ' Invalid assignment to variable: ', self variableName",
referencedClasses: [],
messageSends: [",", "variableName"]
}),
$globals.InvalidAssignmentError);

$core.addMethod(
$core.method({
selector: "variableName",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@variableName"];

},
args: [],
source: "variableName\x0a\x09^ variableName",
referencedClasses: [],
messageSends: []
}),
$globals.InvalidAssignmentError);

$core.addMethod(
$core.method({
selector: "variableName:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@variableName"]=aString;
return self;

},
args: ["aString"],
source: "variableName: aString\x0a\x09variableName := aString",
referencedClasses: [],
messageSends: []
}),
$globals.InvalidAssignmentError);



$core.addClass('ShadowingVariableError', $globals.SemanticError, ['variableName'], 'Compiler-Semantic');
$globals.ShadowingVariableError.comment="I get signaled when a variable in a block or method scope shadows a variable of the same name in an outer scope.";
$core.addMethod(
$core.method({
selector: "messageText",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv("Variable shadowing error: ".__comma(self._variableName())).__comma(" is already defined");
$ctx1.sendIdx[","]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"messageText",{},$globals.ShadowingVariableError)});
},
args: [],
source: "messageText\x0a\x09^ 'Variable shadowing error: ', self variableName, ' is already defined'",
referencedClasses: [],
messageSends: [",", "variableName"]
}),
$globals.ShadowingVariableError);

$core.addMethod(
$core.method({
selector: "variableName",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@variableName"];

},
args: [],
source: "variableName\x0a\x09^ variableName",
referencedClasses: [],
messageSends: []
}),
$globals.ShadowingVariableError);

$core.addMethod(
$core.method({
selector: "variableName:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@variableName"]=aString;
return self;

},
args: ["aString"],
source: "variableName: aString\x0a\x09variableName := aString",
referencedClasses: [],
messageSends: []
}),
$globals.ShadowingVariableError);



$core.addClass('UnknownVariableError', $globals.SemanticError, ['variableName'], 'Compiler-Semantic');
$globals.UnknownVariableError.comment="I get signaled when a variable is not defined.\x0aThe default behavior is to allow it, as this is how Amber currently is able to seamlessly send messages to JavaScript objects.";
$core.addMethod(
$core.method({
selector: "messageText",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv("Unknown Variable error: ".__comma(self._variableName())).__comma(" is not defined");
$ctx1.sendIdx[","]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"messageText",{},$globals.UnknownVariableError)});
},
args: [],
source: "messageText\x0a\x09^ 'Unknown Variable error: ', self variableName, ' is not defined'",
referencedClasses: [],
messageSends: [",", "variableName"]
}),
$globals.UnknownVariableError);

$core.addMethod(
$core.method({
selector: "variableName",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@variableName"];

},
args: [],
source: "variableName\x0a\x09^ variableName",
referencedClasses: [],
messageSends: []
}),
$globals.UnknownVariableError);

$core.addMethod(
$core.method({
selector: "variableName:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@variableName"]=aString;
return self;

},
args: ["aString"],
source: "variableName: aString\x0a\x09variableName := aString",
referencedClasses: [],
messageSends: []
}),
$globals.UnknownVariableError);


});

define("amber_core/Compiler-IR", ["amber/boot", "amber_core/Compiler-AST", "amber_core/Kernel-Objects", "amber_core/Kernel-Methods"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Compiler-IR');
$core.packages["Compiler-IR"].innerEval = function (expr) { return eval(expr); };
$core.packages["Compiler-IR"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('IRASTTranslator', $globals.NodeVisitor, ['source', 'theClass', 'method', 'sequence', 'nextAlias'], 'Compiler-IR');
$globals.IRASTTranslator.comment="I am the AST (abstract syntax tree) visitor responsible for building the intermediate representation graph.";
$core.addMethod(
$core.method({
selector: "alias:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var variable;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$4,$6,$7,$9,$8;
$1=$recv(aNode)._isImmutable();
if($core.assert($1)){
$2=self._visit_(aNode);
$ctx1.sendIdx["visit:"]=1;
return $2;
};
$3=$recv($globals.IRVariable)._new();
$ctx1.sendIdx["new"]=1;
$5=$recv($globals.AliasVar)._new();
$ctx1.sendIdx["new"]=2;
$4=$recv($5)._name_("$".__comma(self._nextAlias()));
$recv($3)._variable_($4);
$6=$recv($3)._yourself();
$ctx1.sendIdx["yourself"]=1;
variable=$6;
$7=self._sequence();
$9=$recv($globals.IRAssignment)._new();
$recv($9)._add_(variable);
$ctx1.sendIdx["add:"]=2;
$recv($9)._add_(self._visit_(aNode));
$ctx1.sendIdx["add:"]=3;
$8=$recv($9)._yourself();
$recv($7)._add_($8);
$ctx1.sendIdx["add:"]=1;
$recv($recv(self._method())._internalVariables())._add_(variable);
return variable;
}, function($ctx1) {$ctx1.fill(self,"alias:",{aNode:aNode,variable:variable},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "alias: aNode\x0a\x09| variable |\x0a\x0a\x09aNode isImmutable ifTrue: [ ^ self visit: aNode ].\x0a\x0a\x09variable := IRVariable new\x0a\x09\x09variable: (AliasVar new name: '$', self nextAlias);\x0a\x09\x09yourself.\x0a\x0a\x09self sequence add: (IRAssignment new\x0a\x09\x09add: variable;\x0a\x09\x09add: (self visit: aNode);\x0a\x09\x09yourself).\x0a\x0a\x09self method internalVariables add: variable.\x0a\x0a\x09^ variable",
referencedClasses: ["IRVariable", "AliasVar", "IRAssignment"],
messageSends: ["ifTrue:", "isImmutable", "visit:", "variable:", "new", "name:", ",", "nextAlias", "yourself", "add:", "sequence", "internalVariables", "method"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "aliasTemporally:",
protocol: 'visiting',
fn: function (aCollection){
var self=this;
var threshold,result;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3;
threshold=(0);
$recv(aCollection)._withIndexDo_((function(each,i){
return $core.withContext(function($ctx2) {
$1=$recv(each)._subtreeNeedsAliasing();
if($core.assert($1)){
threshold=i;
return threshold;
};
}, function($ctx2) {$ctx2.fillBlock({each:each,i:i},$ctx1,1)});
}));
$ctx1.sendIdx["withIndexDo:"]=1;
result=$recv($globals.OrderedCollection)._new();
$recv(aCollection)._withIndexDo_((function(each,i){
return $core.withContext(function($ctx2) {
$2=result;
$4=$recv(i).__lt_eq(threshold);
if($core.assert($4)){
$3=self._alias_(each);
} else {
$3=self._visit_(each);
};
return $recv($2)._add_($3);
}, function($ctx2) {$ctx2.fillBlock({each:each,i:i},$ctx1,3)});
}));
return result;
}, function($ctx1) {$ctx1.fill(self,"aliasTemporally:",{aCollection:aCollection,threshold:threshold,result:result},$globals.IRASTTranslator)});
},
args: ["aCollection"],
source: "aliasTemporally: aCollection\x0a\x09\x22https://github.com/NicolasPetton/amber/issues/296\x0a\x09\x0a\x09If a node is aliased, all preceding ones are aliased as well.\x0a\x09The tree is iterated twice. First we get the aliasing dependency,\x0a\x09then the aliasing itself is done\x22\x0a\x0a\x09| threshold result |\x0a\x09threshold := 0.\x0a\x09\x0a\x09aCollection withIndexDo: [ :each :i |\x0a\x09\x09each subtreeNeedsAliasing\x0a\x09\x09\x09ifTrue: [ threshold := i ] ].\x0a\x0a\x09result := OrderedCollection new.\x0a\x09aCollection withIndexDo: [ :each :i |\x0a\x09\x09result add: (i <= threshold\x0a\x09\x09\x09ifTrue: [ self alias: each ]\x0a\x09\x09\x09ifFalse: [ self visit: each ]) ].\x0a\x0a\x09^ result",
referencedClasses: ["OrderedCollection"],
messageSends: ["withIndexDo:", "ifTrue:", "subtreeNeedsAliasing", "new", "add:", "ifTrue:ifFalse:", "<=", "alias:", "visit:"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "method",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@method"];

},
args: [],
source: "method\x0a\x09^ method",
referencedClasses: [],
messageSends: []
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "method:",
protocol: 'accessing',
fn: function (anIRMethod){
var self=this;
self["@method"]=anIRMethod;
return self;

},
args: ["anIRMethod"],
source: "method: anIRMethod\x0a\x09method := anIRMethod",
referencedClasses: [],
messageSends: []
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "nextAlias",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@nextAlias"];
if(($receiver = $1) == null || $receiver.isNil){
self["@nextAlias"]=(0);
self["@nextAlias"];
} else {
$1;
};
self["@nextAlias"]=$recv(self["@nextAlias"]).__plus((1));
return $recv(self["@nextAlias"])._asString();
}, function($ctx1) {$ctx1.fill(self,"nextAlias",{},$globals.IRASTTranslator)});
},
args: [],
source: "nextAlias\x0a\x09nextAlias ifNil: [ nextAlias := 0 ].\x0a\x09nextAlias := nextAlias + 1.\x0a\x09^ nextAlias asString",
referencedClasses: [],
messageSends: ["ifNil:", "+", "asString"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "sequence",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@sequence"];

},
args: [],
source: "sequence\x0a\x09^ sequence",
referencedClasses: [],
messageSends: []
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "sequence:",
protocol: 'accessing',
fn: function (anIRSequence){
var self=this;
self["@sequence"]=anIRSequence;
return self;

},
args: ["anIRSequence"],
source: "sequence: anIRSequence\x0a\x09sequence := anIRSequence",
referencedClasses: [],
messageSends: []
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "source",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@source"];

},
args: [],
source: "source\x0a\x09^ source",
referencedClasses: [],
messageSends: []
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "source:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@source"]=aString;
return self;

},
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
messageSends: []
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@theClass"];

},
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
messageSends: []
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@theClass"]=aClass;
return self;

},
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitAssignmentNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var left,right,assignment;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
right=self._visit_($recv(aNode)._right());
$ctx1.sendIdx["visit:"]=1;
left=self._visit_($recv(aNode)._left());
$1=self._sequence();
$3=$recv($globals.IRAssignment)._new();
$recv($3)._add_(left);
$ctx1.sendIdx["add:"]=2;
$recv($3)._add_(right);
$2=$recv($3)._yourself();
$recv($1)._add_($2);
$ctx1.sendIdx["add:"]=1;
return left;
}, function($ctx1) {$ctx1.fill(self,"visitAssignmentNode:",{aNode:aNode,left:left,right:right,assignment:assignment},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitAssignmentNode: aNode\x0a\x09| left right assignment |\x0a\x09right := self visit: aNode right.\x0a\x09left := self visit: aNode left.\x0a\x09self sequence add: (IRAssignment new\x0a\x09\x09add: left;\x0a\x09\x09add: right;\x0a\x09\x09yourself).\x0a\x09^ left",
referencedClasses: ["IRAssignment"],
messageSends: ["visit:", "right", "left", "add:", "sequence", "new", "yourself"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitBlockNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var closure;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$4,$6,$8,$7;
$1=$recv($globals.IRClosure)._new();
$ctx1.sendIdx["new"]=1;
$recv($1)._arguments_($recv(aNode)._parameters());
$recv($1)._requiresSmalltalkContext_($recv(aNode)._requiresSmalltalkContext());
$2=$recv(aNode)._scope();
$ctx1.sendIdx["scope"]=1;
$recv($1)._scope_($2);
$ctx1.sendIdx["scope:"]=1;
$3=$recv($1)._yourself();
$ctx1.sendIdx["yourself"]=1;
closure=$3;
$5=$recv(aNode)._scope();
$ctx1.sendIdx["scope"]=2;
$4=$recv($5)._temps();
$recv($4)._do_((function(each){
return $core.withContext(function($ctx2) {
$6=closure;
$8=$recv($globals.IRTempDeclaration)._new();
$recv($8)._name_($recv(each)._name());
$recv($8)._scope_($recv(aNode)._scope());
$7=$recv($8)._yourself();
return $recv($6)._add_($7);
$ctx2.sendIdx["add:"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["do:"]=1;
$recv($recv(aNode)._nodes())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(closure)._add_(self._visit_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
return closure;
}, function($ctx1) {$ctx1.fill(self,"visitBlockNode:",{aNode:aNode,closure:closure},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitBlockNode: aNode\x0a\x09| closure |\x0a\x09closure := IRClosure new\x0a\x09\x09arguments: aNode parameters;\x0a\x09\x09requiresSmalltalkContext: aNode requiresSmalltalkContext;\x0a\x09\x09scope: aNode scope;\x0a\x09\x09yourself.\x0a\x09aNode scope temps do: [ :each |\x0a\x09\x09closure add: (IRTempDeclaration new\x0a\x09\x09\x09name: each name;\x0a\x09\x09\x09scope: aNode scope;\x0a\x09\x09\x09yourself) ].\x0a\x09aNode nodes do: [ :each | closure add: (self visit: each) ].\x0a\x09^ closure",
referencedClasses: ["IRClosure", "IRTempDeclaration"],
messageSends: ["arguments:", "new", "parameters", "requiresSmalltalkContext:", "requiresSmalltalkContext", "scope:", "scope", "yourself", "do:", "temps", "add:", "name:", "name", "nodes", "visit:"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitBlockSequenceNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3,$5,$6,$9,$8,$7,$10,$12,$15,$14,$13,$11;
$1=$recv($globals.IRBlockSequence)._new();
$ctx1.sendIdx["new"]=1;
return self._withSequence_do_($1,(function(){
return $core.withContext(function($ctx2) {
$2=$recv(aNode)._nodes();
$ctx2.sendIdx["nodes"]=1;
return $recv($2)._ifNotEmpty_((function(){
return $core.withContext(function($ctx3) {
$4=$recv(aNode)._nodes();
$ctx3.sendIdx["nodes"]=2;
$3=$recv($4)._allButLast();
$recv($3)._do_((function(each){
return $core.withContext(function($ctx4) {
$5=self._sequence();
$ctx4.sendIdx["sequence"]=1;
$6=self._visitOrAlias_(each);
$ctx4.sendIdx["visitOrAlias:"]=1;
return $recv($5)._add_($6);
$ctx4.sendIdx["add:"]=1;
}, function($ctx4) {$ctx4.fillBlock({each:each},$ctx3,3)});
}));
$9=$recv(aNode)._nodes();
$ctx3.sendIdx["nodes"]=3;
$8=$recv($9)._last();
$ctx3.sendIdx["last"]=1;
$7=$recv($8)._isReturnNode();
if($core.assert($7)){
return $recv(self._sequence())._add_(self._visitOrAlias_($recv($recv(aNode)._nodes())._last()));
} else {
$10=self._sequence();
$ctx3.sendIdx["sequence"]=2;
$12=$recv($globals.IRBlockReturn)._new();
$15=$recv(aNode)._nodes();
$ctx3.sendIdx["nodes"]=4;
$14=$recv($15)._last();
$ctx3.sendIdx["last"]=2;
$13=self._visitOrAlias_($14);
$ctx3.sendIdx["visitOrAlias:"]=2;
$recv($12)._add_($13);
$ctx3.sendIdx["add:"]=3;
$11=$recv($12)._yourself();
return $recv($10)._add_($11);
$ctx3.sendIdx["add:"]=2;
};
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"visitBlockSequenceNode:",{aNode:aNode},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitBlockSequenceNode: aNode\x0a\x09^ self\x0a\x09\x09withSequence: IRBlockSequence new\x0a\x09\x09do: [\x0a\x09\x09\x09aNode nodes ifNotEmpty: [\x0a\x09\x09\x09\x09aNode nodes allButLast do: [ :each |\x0a\x09\x09\x09\x09\x09self sequence add: (self visitOrAlias: each) ].\x0a\x09\x09\x09\x09aNode nodes last isReturnNode\x0a\x09\x09\x09\x09\x09ifFalse: [ self sequence add: (IRBlockReturn new add: (self visitOrAlias: aNode nodes last); yourself) ]\x0a\x09\x09\x09\x09\x09ifTrue: [ self sequence add: (self visitOrAlias: aNode nodes last) ] ]]",
referencedClasses: ["IRBlockSequence", "IRBlockReturn"],
messageSends: ["withSequence:do:", "new", "ifNotEmpty:", "nodes", "do:", "allButLast", "add:", "sequence", "visitOrAlias:", "ifFalse:ifTrue:", "isReturnNode", "last", "yourself"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitCascadeNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3;
$1=$recv(aNode)._nodes();
$ctx1.sendIdx["nodes"]=1;
$recv($1)._inject_into_($recv(aNode)._receiver(),(function(previous,each){
var receiver;
return $core.withContext(function($ctx2) {
$2=$recv(previous)._isImmutable();
if($core.assert($2)){
receiver=previous;
} else {
var alias;
alias=self._alias_(previous);
alias;
receiver=$recv($recv($globals.VariableNode)._new())._binding_($recv(alias)._variable());
};
receiver;
$recv(each)._receiver_(receiver);
return receiver;
}, function($ctx2) {$ctx2.fillBlock({previous:previous,each:each,receiver:receiver},$ctx1,1)});
}));
$4=$recv(aNode)._nodes();
$ctx1.sendIdx["nodes"]=2;
$3=$recv($4)._allButLast();
$recv($3)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(self._sequence())._add_(self._visit_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}));
return self._visitOrAlias_($recv($recv(aNode)._nodes())._last());
}, function($ctx1) {$ctx1.fill(self,"visitCascadeNode:",{aNode:aNode},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitCascadeNode: aNode\x0a\x09aNode nodes inject: aNode receiver into: [ :previous :each |\x0a\x09\x09| receiver |\x0a\x09\x09receiver := previous isImmutable \x0a\x09\x09\x09ifTrue: [ previous ]\x0a\x09\x09\x09ifFalse: [\x0a\x09\x09\x09\x09| alias |\x0a\x09\x09\x09\x09alias := self alias: previous.\x0a\x09\x09\x09\x09VariableNode new binding: alias variable ].\x0a\x09\x09each receiver: receiver.\x0a\x09\x09receiver ].\x0a\x0a\x09aNode nodes allButLast do: [ :each |\x0a\x09\x09self sequence add: (self visit: each) ].\x0a\x0a\x09^ self visitOrAlias: aNode nodes last",
referencedClasses: ["VariableNode"],
messageSends: ["inject:into:", "nodes", "receiver", "ifTrue:ifFalse:", "isImmutable", "alias:", "binding:", "new", "variable", "receiver:", "do:", "allButLast", "add:", "sequence", "visit:", "visitOrAlias:", "last"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitDynamicArrayNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var array;
return $core.withContext(function($ctx1) {
array=$recv($globals.IRDynamicArray)._new();
$recv(self._aliasTemporally_($recv(aNode)._nodes()))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(array)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return array;
}, function($ctx1) {$ctx1.fill(self,"visitDynamicArrayNode:",{aNode:aNode,array:array},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitDynamicArrayNode: aNode\x0a\x09| array |\x0a\x09array := IRDynamicArray new.\x0a\x09(self aliasTemporally: aNode nodes) do: [ :each | array add: each ].\x0a\x09^ array",
referencedClasses: ["IRDynamicArray"],
messageSends: ["new", "do:", "aliasTemporally:", "nodes", "add:"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitDynamicDictionaryNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var dictionary;
return $core.withContext(function($ctx1) {
dictionary=$recv($globals.IRDynamicDictionary)._new();
$recv(self._aliasTemporally_($recv(aNode)._nodes()))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(dictionary)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return dictionary;
}, function($ctx1) {$ctx1.fill(self,"visitDynamicDictionaryNode:",{aNode:aNode,dictionary:dictionary},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitDynamicDictionaryNode: aNode\x0a\x09| dictionary |\x0a\x09dictionary := IRDynamicDictionary new.\x0a\x09(self aliasTemporally: aNode nodes) do: [ :each | dictionary add: each ].\x0a\x09^ dictionary",
referencedClasses: ["IRDynamicDictionary"],
messageSends: ["new", "do:", "aliasTemporally:", "nodes", "add:"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitJSStatementNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRVerbatim)._new();
$recv($1)._source_($recv($recv(aNode)._source())._crlfSanitized());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"visitJSStatementNode:",{aNode:aNode},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitJSStatementNode: aNode\x0a\x09^ IRVerbatim new\x0a\x09\x09source: aNode source crlfSanitized;\x0a\x09\x09yourself",
referencedClasses: ["IRVerbatim"],
messageSends: ["source:", "new", "crlfSanitized", "source", "yourself"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitMethodNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$4,$1,$6,$5,$7,$9,$10,$11,$8,$12,$14,$13,$15,$17,$19,$20,$18,$21,$16,$23,$22;
$2=$recv($globals.IRMethod)._new();
$ctx1.sendIdx["new"]=1;
$recv($2)._source_($recv(self._source())._crlfSanitized());
$ctx1.sendIdx["source:"]=1;
$recv($2)._theClass_(self._theClass());
$recv($2)._arguments_($recv(aNode)._arguments());
$recv($2)._selector_($recv(aNode)._selector());
$recv($2)._sendIndexes_($recv(aNode)._sendIndexes());
$recv($2)._requiresSmalltalkContext_($recv(aNode)._requiresSmalltalkContext());
$recv($2)._classReferences_($recv(aNode)._classReferences());
$3=$recv(aNode)._scope();
$ctx1.sendIdx["scope"]=1;
$recv($2)._scope_($3);
$ctx1.sendIdx["scope:"]=1;
$4=$recv($2)._yourself();
$ctx1.sendIdx["yourself"]=1;
$1=$4;
self._method_($1);
$6=$recv(aNode)._scope();
$ctx1.sendIdx["scope"]=2;
$5=$recv($6)._temps();
$recv($5)._do_((function(each){
return $core.withContext(function($ctx2) {
$7=self._method();
$ctx2.sendIdx["method"]=1;
$9=$recv($globals.IRTempDeclaration)._new();
$ctx2.sendIdx["new"]=2;
$recv($9)._name_($recv(each)._name());
$10=$recv(aNode)._scope();
$ctx2.sendIdx["scope"]=3;
$recv($9)._scope_($10);
$11=$recv($9)._yourself();
$ctx2.sendIdx["yourself"]=2;
$8=$11;
return $recv($7)._add_($8);
$ctx2.sendIdx["add:"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["do:"]=1;
$recv($recv(aNode)._nodes())._do_((function(each){
return $core.withContext(function($ctx2) {
$12=self._method();
$ctx2.sendIdx["method"]=2;
return $recv($12)._add_(self._visit_(each));
$ctx2.sendIdx["add:"]=2;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
$14=$recv(aNode)._scope();
$ctx1.sendIdx["scope"]=4;
$13=$recv($14)._hasLocalReturn();
if(!$core.assert($13)){
$15=self._method();
$ctx1.sendIdx["method"]=3;
$17=$recv($globals.IRReturn)._new();
$ctx1.sendIdx["new"]=3;
$19=$recv($globals.IRVariable)._new();
$ctx1.sendIdx["new"]=4;
$recv($19)._variable_($recv($recv($recv(aNode)._scope())._pseudoVars())._at_("self"));
$20=$recv($19)._yourself();
$ctx1.sendIdx["yourself"]=3;
$18=$20;
$recv($17)._add_($18);
$ctx1.sendIdx["add:"]=4;
$21=$recv($17)._yourself();
$ctx1.sendIdx["yourself"]=4;
$16=$21;
$recv($15)._add_($16);
$ctx1.sendIdx["add:"]=3;
$23=$recv($globals.IRVerbatim)._new();
$recv($23)._source_("");
$22=$recv($23)._yourself();
$recv($15)._add_($22);
};
return self._method();
}, function($ctx1) {$ctx1.fill(self,"visitMethodNode:",{aNode:aNode},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitMethodNode: aNode\x0a\x0a\x09self method: (IRMethod new\x0a\x09\x09source: self source crlfSanitized;\x0a\x09\x09theClass: self theClass;\x0a\x09\x09arguments: aNode arguments;\x0a\x09\x09selector: aNode selector;\x0a\x09\x09sendIndexes: aNode sendIndexes;\x0a\x09\x09requiresSmalltalkContext: aNode requiresSmalltalkContext;\x0a\x09\x09classReferences: aNode classReferences;\x0a\x09\x09scope: aNode scope;\x0a\x09\x09yourself).\x0a\x0a\x09aNode scope temps do: [ :each |\x0a\x09\x09self method add: (IRTempDeclaration new\x0a\x09\x09\x09name: each name;\x0a\x09\x09\x09scope: aNode scope;\x0a\x09\x09\x09yourself) ].\x0a\x0a\x09aNode nodes do: [ :each | self method add: (self visit: each) ].\x0a\x0a\x09aNode scope hasLocalReturn ifFalse: [self method\x0a\x09\x09add: (IRReturn new\x0a\x09\x09\x09add: (IRVariable new\x0a\x09\x09\x09\x09variable: (aNode scope pseudoVars at: 'self');\x0a\x09\x09\x09\x09yourself);\x0a\x09\x09\x09yourself);\x0a\x09\x09add: (IRVerbatim new source: ''; yourself) ].\x0a\x0a\x09^ self method",
referencedClasses: ["IRMethod", "IRTempDeclaration", "IRReturn", "IRVariable", "IRVerbatim"],
messageSends: ["method:", "source:", "new", "crlfSanitized", "source", "theClass:", "theClass", "arguments:", "arguments", "selector:", "selector", "sendIndexes:", "sendIndexes", "requiresSmalltalkContext:", "requiresSmalltalkContext", "classReferences:", "classReferences", "scope:", "scope", "yourself", "do:", "temps", "add:", "method", "name:", "name", "nodes", "visit:", "ifFalse:", "hasLocalReturn", "variable:", "at:", "pseudoVars"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitOrAlias:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(aNode)._shouldBeAliased();
if($core.assert($1)){
return self._alias_(aNode);
} else {
return self._visit_(aNode);
};
}, function($ctx1) {$ctx1.fill(self,"visitOrAlias:",{aNode:aNode},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitOrAlias: aNode\x0a\x09^ aNode shouldBeAliased\x0a\x09\x09ifTrue: [ self alias: aNode ]\x0a\x09\x09ifFalse: [ self visit: aNode ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "shouldBeAliased", "alias:", "visit:"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitReturnNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var return_;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(aNode)._nonLocalReturn();
if($core.assert($1)){
return_=$recv($globals.IRNonLocalReturn)._new();
$ctx1.sendIdx["new"]=1;
} else {
return_=$recv($globals.IRReturn)._new();
};
$recv(return_)._scope_($recv(aNode)._scope());
$recv($recv(aNode)._nodes())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(return_)._add_(self._visitOrAlias_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
return return_;
}, function($ctx1) {$ctx1.fill(self,"visitReturnNode:",{aNode:aNode,return_:return_},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitReturnNode: aNode\x0a\x09| return |\x0a\x09return := aNode nonLocalReturn\x0a\x09\x09ifTrue: [ IRNonLocalReturn new ]\x0a\x09\x09ifFalse: [ IRReturn new ].\x0a\x09return scope: aNode scope.\x0a\x09aNode nodes do: [ :each |\x0a\x09\x09return add: (self visitOrAlias: each) ].\x0a\x09^ return",
referencedClasses: ["IRNonLocalReturn", "IRReturn"],
messageSends: ["ifTrue:ifFalse:", "nonLocalReturn", "new", "scope:", "scope", "do:", "nodes", "add:", "visitOrAlias:"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var send;
return $core.withContext(function($ctx1) {
var $1;
send=$recv($globals.IRSend)._new();
$1=send;
$recv($1)._selector_($recv(aNode)._selector());
$recv($1)._index_($recv(aNode)._index());
$recv(self._aliasTemporally_($recv(aNode)._nodes()))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(send)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return send;
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode,send:send},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x09| send |\x0a\x09send := IRSend new.\x0a\x09send\x0a\x09\x09selector: aNode selector;\x0a\x09\x09index: aNode index.\x0a\x09\x0a\x09(self aliasTemporally: aNode nodes) do: [ :each | send add: each ].\x0a\x0a\x09^ send",
referencedClasses: ["IRSend"],
messageSends: ["new", "selector:", "selector", "index:", "index", "do:", "aliasTemporally:", "nodes", "add:"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitSequenceNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return self._withSequence_do_($recv($globals.IRSequence)._new(),(function(){
return $core.withContext(function($ctx2) {
return $recv($recv(aNode)._nodes())._do_((function(each){
var instruction;
return $core.withContext(function($ctx3) {
instruction=self._visitOrAlias_(each);
instruction;
$1=$recv(instruction)._isVariable();
if(!$core.assert($1)){
return $recv(self._sequence())._add_(instruction);
};
}, function($ctx3) {$ctx3.fillBlock({each:each,instruction:instruction},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"visitSequenceNode:",{aNode:aNode},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitSequenceNode: aNode\x0a\x09^ self\x0a\x09\x09withSequence: IRSequence new\x0a\x09\x09do: [\x0a\x09\x09\x09aNode nodes do: [ :each | | instruction |\x0a\x09\x09\x09\x09instruction := self visitOrAlias: each.\x0a\x09\x09\x09\x09instruction isVariable ifFalse: [\x0a\x09\x09\x09\x09\x09self sequence add: instruction ] ]]",
referencedClasses: ["IRSequence"],
messageSends: ["withSequence:do:", "new", "do:", "nodes", "visitOrAlias:", "ifFalse:", "isVariable", "add:", "sequence"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitValueNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRValue)._new();
$recv($1)._value_($recv(aNode)._value());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"visitValueNode:",{aNode:aNode},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitValueNode: aNode\x0a\x09^ IRValue new\x0a\x09\x09value: aNode value;\x0a\x09\x09yourself",
referencedClasses: ["IRValue"],
messageSends: ["value:", "new", "value", "yourself"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitVariableNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRVariable)._new();
$recv($1)._variable_($recv(aNode)._binding());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"visitVariableNode:",{aNode:aNode},$globals.IRASTTranslator)});
},
args: ["aNode"],
source: "visitVariableNode: aNode\x0a\x09^ IRVariable new\x0a\x09\x09variable: aNode binding;\x0a\x09\x09yourself",
referencedClasses: ["IRVariable"],
messageSends: ["variable:", "new", "binding", "yourself"]
}),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "withSequence:do:",
protocol: 'accessing',
fn: function (aSequence,aBlock){
var self=this;
var outerSequence;
return $core.withContext(function($ctx1) {
outerSequence=self._sequence();
self._sequence_(aSequence);
$ctx1.sendIdx["sequence:"]=1;
$recv(aBlock)._value();
self._sequence_(outerSequence);
return aSequence;
}, function($ctx1) {$ctx1.fill(self,"withSequence:do:",{aSequence:aSequence,aBlock:aBlock,outerSequence:outerSequence},$globals.IRASTTranslator)});
},
args: ["aSequence", "aBlock"],
source: "withSequence: aSequence do: aBlock\x0a\x09| outerSequence |\x0a\x09outerSequence := self sequence.\x0a\x09self sequence: aSequence.\x0a\x09aBlock value.\x0a\x09self sequence: outerSequence.\x0a\x09^ aSequence",
referencedClasses: [],
messageSends: ["sequence", "sequence:", "value"]
}),
$globals.IRASTTranslator);



$core.addClass('IRInstruction', $globals.Object, ['parent', 'instructions'], 'Compiler-IR');
$globals.IRInstruction.comment="I am the abstract root class of the IR (intermediate representation) instructions class hierarchy.\x0aThe IR graph is used to emit JavaScript code using a JSStream.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRInstruction_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRInstruction)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRInstruction: self",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "add:",
protocol: 'building',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
$recv(anObject)._parent_(self);
return $recv(self._instructions())._add_(anObject);
}, function($ctx1) {$ctx1.fill(self,"add:",{anObject:anObject},$globals.IRInstruction)});
},
args: ["anObject"],
source: "add: anObject\x0a\x09anObject parent: self.\x0a\x09^ self instructions add: anObject",
referencedClasses: [],
messageSends: ["parent:", "add:", "instructions"]
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "canBeAssigned",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "canBeAssigned\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "instructions",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@instructions"];
if(($receiver = $1) == null || $receiver.isNil){
self["@instructions"]=$recv($globals.OrderedCollection)._new();
return self["@instructions"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"instructions",{},$globals.IRInstruction)});
},
args: [],
source: "instructions\x0a\x09^ instructions ifNil: [ instructions := OrderedCollection new ]",
referencedClasses: ["OrderedCollection"],
messageSends: ["ifNil:", "new"]
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isClosure",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isClosure\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isInlined\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isLocalReturn",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isLocalReturn\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isMethod",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isMethod\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isReturn",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isReturn\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isSend",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isSend\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isSequence",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isSequence\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isTempDeclaration",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isTempDeclaration\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isVariable",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isVariable\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "method",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._parent())._method();
}, function($ctx1) {$ctx1.fill(self,"method",{},$globals.IRInstruction)});
},
args: [],
source: "method\x0a\x09^ self parent method",
referencedClasses: [],
messageSends: ["method", "parent"]
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "needsBoxingAsReceiver",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "needsBoxingAsReceiver\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "parent",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@parent"];

},
args: [],
source: "parent\x0a\x09^ parent",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "parent:",
protocol: 'accessing',
fn: function (anIRInstruction){
var self=this;
self["@parent"]=anIRInstruction;
return self;

},
args: ["anIRInstruction"],
source: "parent: anIRInstruction\x0a\x09parent := anIRInstruction",
referencedClasses: [],
messageSends: []
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "remove",
protocol: 'building',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._parent())._remove_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"remove",{},$globals.IRInstruction)});
},
args: [],
source: "remove\x0a\x09self parent remove: self",
referencedClasses: [],
messageSends: ["remove:", "parent"]
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "remove:",
protocol: 'building',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._instructions())._remove_(anIRInstruction);
return self;
}, function($ctx1) {$ctx1.fill(self,"remove:",{anIRInstruction:anIRInstruction},$globals.IRInstruction)});
},
args: ["anIRInstruction"],
source: "remove: anIRInstruction\x0a\x09self instructions remove: anIRInstruction",
referencedClasses: [],
messageSends: ["remove:", "instructions"]
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "replace:with:",
protocol: 'building',
fn: function (anIRInstruction,anotherIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(anotherIRInstruction)._parent_(self);
$1=self._instructions();
$ctx1.sendIdx["instructions"]=1;
$recv($1)._at_put_($recv(self._instructions())._indexOf_(anIRInstruction),anotherIRInstruction);
return self;
}, function($ctx1) {$ctx1.fill(self,"replace:with:",{anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction},$globals.IRInstruction)});
},
args: ["anIRInstruction", "anotherIRInstruction"],
source: "replace: anIRInstruction with: anotherIRInstruction\x0a\x09anotherIRInstruction parent: self.\x0a\x09self instructions\x0a\x09\x09at: (self instructions indexOf: anIRInstruction)\x0a\x09\x09put: anotherIRInstruction",
referencedClasses: [],
messageSends: ["parent:", "at:put:", "instructions", "indexOf:"]
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "replaceWith:",
protocol: 'building',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._parent())._replace_with_(self,anIRInstruction);
return self;
}, function($ctx1) {$ctx1.fill(self,"replaceWith:",{anIRInstruction:anIRInstruction},$globals.IRInstruction)});
},
args: ["anIRInstruction"],
source: "replaceWith: anIRInstruction\x0a\x09self parent replace: self with: anIRInstruction",
referencedClasses: [],
messageSends: ["replace:with:", "parent"]
}),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "scope",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._parent();
if(($receiver = $1) == null || $receiver.isNil){
return $1;
} else {
var node;
node=$receiver;
return $recv(node)._scope();
};
}, function($ctx1) {$ctx1.fill(self,"scope",{},$globals.IRInstruction)});
},
args: [],
source: "scope\x0a\x09^ self parent ifNotNil: [ :node | \x0a\x09\x09node scope ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "parent", "scope"]
}),
$globals.IRInstruction);


$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (aBuilder){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._builder_(aBuilder);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aBuilder:aBuilder},$globals.IRInstruction.klass)});
},
args: ["aBuilder"],
source: "on: aBuilder\x0a\x09^ self new\x0a\x09\x09builder: aBuilder;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["builder:", "new", "yourself"]
}),
$globals.IRInstruction.klass);


$core.addClass('IRAssignment', $globals.IRInstruction, [], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRAssignment_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRAssignment)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRAssignment: self",
referencedClasses: [],
messageSends: ["visitIRAssignment:"]
}),
$globals.IRAssignment);



$core.addClass('IRDynamicArray', $globals.IRInstruction, [], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRDynamicArray_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRDynamicArray)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRDynamicArray: self",
referencedClasses: [],
messageSends: ["visitIRDynamicArray:"]
}),
$globals.IRDynamicArray);



$core.addClass('IRDynamicDictionary', $globals.IRInstruction, [], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRDynamicDictionary_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRDynamicDictionary)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRDynamicDictionary: self",
referencedClasses: [],
messageSends: ["visitIRDynamicDictionary:"]
}),
$globals.IRDynamicDictionary);



$core.addClass('IRScopedInstruction', $globals.IRInstruction, ['scope'], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "scope",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@scope"];

},
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
messageSends: []
}),
$globals.IRScopedInstruction);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: 'accessing',
fn: function (aScope){
var self=this;
self["@scope"]=aScope;
return self;

},
args: ["aScope"],
source: "scope: aScope\x0a\x09scope := aScope",
referencedClasses: [],
messageSends: []
}),
$globals.IRScopedInstruction);



$core.addClass('IRClosureInstruction', $globals.IRScopedInstruction, ['arguments', 'requiresSmalltalkContext'], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "arguments",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@arguments"];
if(($receiver = $1) == null || $receiver.isNil){
return [];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"arguments",{},$globals.IRClosureInstruction)});
},
args: [],
source: "arguments\x0a\x09^ arguments ifNil: [ #() ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
self["@arguments"]=aCollection;
return self;

},
args: ["aCollection"],
source: "arguments: aCollection\x0a\x09arguments := aCollection",
referencedClasses: [],
messageSends: []
}),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "locals",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self._arguments())._copy();
$recv($1)._addAll_($recv(self._tempDeclarations())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._name();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"locals",{},$globals.IRClosureInstruction)});
},
args: [],
source: "locals\x0a\x09^ self arguments copy\x0a\x09\x09addAll: (self tempDeclarations collect: [ :each | each name ]);\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["addAll:", "copy", "arguments", "collect:", "tempDeclarations", "name", "yourself"]
}),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "requiresSmalltalkContext",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@requiresSmalltalkContext"];
if(($receiver = $1) == null || $receiver.isNil){
return false;
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"requiresSmalltalkContext",{},$globals.IRClosureInstruction)});
},
args: [],
source: "requiresSmalltalkContext\x0a\x09^ requiresSmalltalkContext ifNil: [ false ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "requiresSmalltalkContext:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@requiresSmalltalkContext"]=anObject;
return self;

},
args: ["anObject"],
source: "requiresSmalltalkContext: anObject\x0a\x09requiresSmalltalkContext := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: 'accessing',
fn: function (aScope){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.IRClosureInstruction.superclass||$boot.dnu).fn.prototype._scope_.apply($recv(self), [aScope]));
$ctx1.supercall = false;
$recv(aScope)._instruction_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"scope:",{aScope:aScope},$globals.IRClosureInstruction)});
},
args: ["aScope"],
source: "scope: aScope\x0a\x09super scope: aScope.\x0a\x09aScope instruction: self",
referencedClasses: [],
messageSends: ["scope:", "instruction:"]
}),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "tempDeclarations",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._instructions())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._isTempDeclaration();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"tempDeclarations",{},$globals.IRClosureInstruction)});
},
args: [],
source: "tempDeclarations\x0a\x09^ self instructions select: [ :each |\x0a\x09\x09each isTempDeclaration ]",
referencedClasses: [],
messageSends: ["select:", "instructions", "isTempDeclaration"]
}),
$globals.IRClosureInstruction);



$core.addClass('IRClosure', $globals.IRClosureInstruction, [], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRClosure_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRClosure)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRClosure: self",
referencedClasses: [],
messageSends: ["visitIRClosure:"]
}),
$globals.IRClosure);

$core.addMethod(
$core.method({
selector: "isClosure",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isClosure\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRClosure);

$core.addMethod(
$core.method({
selector: "sequence",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._instructions())._last();
}, function($ctx1) {$ctx1.fill(self,"sequence",{},$globals.IRClosure)});
},
args: [],
source: "sequence\x0a\x09^ self instructions last",
referencedClasses: [],
messageSends: ["last", "instructions"]
}),
$globals.IRClosure);



$core.addClass('IRMethod', $globals.IRClosureInstruction, ['theClass', 'source', 'selector', 'classReferences', 'sendIndexes', 'requiresSmalltalkContext', 'internalVariables'], 'Compiler-IR');
$globals.IRMethod.comment="I am a method instruction";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRMethod_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRMethod)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRMethod: self",
referencedClasses: [],
messageSends: ["visitIRMethod:"]
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "classReferences",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@classReferences"];

},
args: [],
source: "classReferences\x0a\x09^ classReferences",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "classReferences:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
self["@classReferences"]=aCollection;
return self;

},
args: ["aCollection"],
source: "classReferences: aCollection\x0a\x09classReferences := aCollection",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "internalVariables",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@internalVariables"];
if(($receiver = $1) == null || $receiver.isNil){
self["@internalVariables"]=$recv($globals.Set)._new();
return self["@internalVariables"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"internalVariables",{},$globals.IRMethod)});
},
args: [],
source: "internalVariables\x0a\x09^ internalVariables ifNil: [ internalVariables := Set new ]",
referencedClasses: ["Set"],
messageSends: ["ifNil:", "new"]
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "isMethod",
protocol: 'accessing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isMethod\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "messageSends",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._sendIndexes())._keys();
}, function($ctx1) {$ctx1.fill(self,"messageSends",{},$globals.IRMethod)});
},
args: [],
source: "messageSends\x0a\x09^ self sendIndexes keys",
referencedClasses: [],
messageSends: ["keys", "sendIndexes"]
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "method",
protocol: 'accessing',
fn: function (){
var self=this;
return self;

},
args: [],
source: "method\x0a\x09^ self",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@selector"];

},
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@selector"]=aString;
return self;

},
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "sendIndexes",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@sendIndexes"];

},
args: [],
source: "sendIndexes\x0a\x09^ sendIndexes",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "sendIndexes:",
protocol: 'accessing',
fn: function (aDictionary){
var self=this;
self["@sendIndexes"]=aDictionary;
return self;

},
args: ["aDictionary"],
source: "sendIndexes: aDictionary\x0a\x09sendIndexes := aDictionary",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "source",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@source"];

},
args: [],
source: "source\x0a\x09^ source",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "source:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@source"]=aString;
return self;

},
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@theClass"];

},
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@theClass"]=aClass;
return self;

},
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.IRMethod);



$core.addClass('IRReturn', $globals.IRScopedInstruction, [], 'Compiler-IR');
$globals.IRReturn.comment="I am a local return instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRReturn_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRReturn)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRReturn: self",
referencedClasses: [],
messageSends: ["visitIRReturn:"]
}),
$globals.IRReturn);

$core.addMethod(
$core.method({
selector: "canBeAssigned",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "canBeAssigned\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRReturn);

$core.addMethod(
$core.method({
selector: "isBlockReturn",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isBlockReturn\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRReturn);

$core.addMethod(
$core.method({
selector: "isLocalReturn",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isLocalReturn\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRReturn);

$core.addMethod(
$core.method({
selector: "isNonLocalReturn",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._isLocalReturn())._not();
}, function($ctx1) {$ctx1.fill(self,"isNonLocalReturn",{},$globals.IRReturn)});
},
args: [],
source: "isNonLocalReturn\x0a\x09^ self isLocalReturn not",
referencedClasses: [],
messageSends: ["not", "isLocalReturn"]
}),
$globals.IRReturn);

$core.addMethod(
$core.method({
selector: "isReturn",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isReturn\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRReturn);

$core.addMethod(
$core.method({
selector: "scope",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@scope"];
if(($receiver = $1) == null || $receiver.isNil){
return $recv(self._parent())._scope();
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"scope",{},$globals.IRReturn)});
},
args: [],
source: "scope\x0a\x09^ scope ifNil: [ self parent scope ]",
referencedClasses: [],
messageSends: ["ifNil:", "scope", "parent"]
}),
$globals.IRReturn);



$core.addClass('IRBlockReturn', $globals.IRReturn, [], 'Compiler-IR');
$globals.IRBlockReturn.comment="Smalltalk blocks return their last statement. I am a implicit block return instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRBlockReturn_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRBlockReturn)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRBlockReturn: self",
referencedClasses: [],
messageSends: ["visitIRBlockReturn:"]
}),
$globals.IRBlockReturn);

$core.addMethod(
$core.method({
selector: "isBlockReturn",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isBlockReturn\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRBlockReturn);



$core.addClass('IRNonLocalReturn', $globals.IRReturn, [], 'Compiler-IR');
$globals.IRNonLocalReturn.comment="I am a non local return instruction.\x0aNon local returns are handled using a try/catch JavaScript statement.\x0a\x0aSee `IRNonLocalReturnHandling` class.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRNonLocalReturn_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRNonLocalReturn)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRNonLocalReturn: self",
referencedClasses: [],
messageSends: ["visitIRNonLocalReturn:"]
}),
$globals.IRNonLocalReturn);

$core.addMethod(
$core.method({
selector: "isLocalReturn",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isLocalReturn\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRNonLocalReturn);



$core.addClass('IRTempDeclaration', $globals.IRScopedInstruction, ['name'], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRTempDeclaration_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRTempDeclaration)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRTempDeclaration: self",
referencedClasses: [],
messageSends: ["visitIRTempDeclaration:"]
}),
$globals.IRTempDeclaration);

$core.addMethod(
$core.method({
selector: "isTempDeclaration",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isTempDeclaration\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRTempDeclaration);

$core.addMethod(
$core.method({
selector: "name",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@name"];

},
args: [],
source: "name\x0a\x09^ name",
referencedClasses: [],
messageSends: []
}),
$globals.IRTempDeclaration);

$core.addMethod(
$core.method({
selector: "name:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@name"]=aString;
return self;

},
args: ["aString"],
source: "name: aString\x0a\x09name := aString",
referencedClasses: [],
messageSends: []
}),
$globals.IRTempDeclaration);



$core.addClass('IRSend', $globals.IRInstruction, ['selector', 'index'], 'Compiler-IR');
$globals.IRSend.comment="I am a message send instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRSend_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRSend)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRSend: self",
referencedClasses: [],
messageSends: ["visitIRSend:"]
}),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "index",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@index"];

},
args: [],
source: "index\x0a\x09^ index",
referencedClasses: [],
messageSends: []
}),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "index:",
protocol: 'accessing',
fn: function (anInteger){
var self=this;
self["@index"]=anInteger;
return self;

},
args: ["anInteger"],
source: "index: anInteger\x0a\x09index := anInteger",
referencedClasses: [],
messageSends: []
}),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "isSend",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isSend\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "isSuperSend",
protocol: 'accessing',
fn: function (){
var self=this;
var receiver;
return $core.withContext(function($ctx1) {
receiver=$recv(self._instructions())._first();
return $recv($recv(receiver)._isVariable())._and_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv($recv(receiver)._variable())._name()).__eq("super");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"isSuperSend",{receiver:receiver},$globals.IRSend)});
},
args: [],
source: "isSuperSend\x0a\x09| receiver |\x0a\x09receiver := self instructions first.\x0a\x09^ receiver isVariable and: [ receiver variable name = 'super' ]",
referencedClasses: [],
messageSends: ["first", "instructions", "and:", "isVariable", "=", "name", "variable"]
}),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@selector"];

},
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
messageSends: []
}),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@selector"]=aString;
return self;

},
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
messageSends: []
}),
$globals.IRSend);



$core.addClass('IRSequence', $globals.IRInstruction, [], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRSequence_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRSequence)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRSequence: self",
referencedClasses: [],
messageSends: ["visitIRSequence:"]
}),
$globals.IRSequence);

$core.addMethod(
$core.method({
selector: "isSequence",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isSequence\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRSequence);



$core.addClass('IRBlockSequence', $globals.IRSequence, [], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRBlockSequence_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRBlockSequence)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRBlockSequence: self",
referencedClasses: [],
messageSends: ["visitIRBlockSequence:"]
}),
$globals.IRBlockSequence);



$core.addClass('IRValue', $globals.IRInstruction, ['value'], 'Compiler-IR');
$globals.IRValue.comment="I am the simplest possible instruction. I represent a value.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRValue_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRValue)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRValue: self",
referencedClasses: [],
messageSends: ["visitIRValue:"]
}),
$globals.IRValue);

$core.addMethod(
$core.method({
selector: "needsBoxingAsReceiver",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "needsBoxingAsReceiver\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.IRValue);

$core.addMethod(
$core.method({
selector: "value",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@value"];

},
args: [],
source: "value\x0a\x09^ value",
referencedClasses: [],
messageSends: []
}),
$globals.IRValue);

$core.addMethod(
$core.method({
selector: "value:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@value"]=aString;
return self;

},
args: ["aString"],
source: "value: aString\x0a\x09value := aString",
referencedClasses: [],
messageSends: []
}),
$globals.IRValue);



$core.addClass('IRVariable', $globals.IRInstruction, ['variable'], 'Compiler-IR');
$globals.IRVariable.comment="I am a variable instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRVariable_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRVariable)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRVariable: self",
referencedClasses: [],
messageSends: ["visitIRVariable:"]
}),
$globals.IRVariable);

$core.addMethod(
$core.method({
selector: "isVariable",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isVariable\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRVariable);

$core.addMethod(
$core.method({
selector: "needsBoxingAsReceiver",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._variable())._isPseudoVar())._not();
}, function($ctx1) {$ctx1.fill(self,"needsBoxingAsReceiver",{},$globals.IRVariable)});
},
args: [],
source: "needsBoxingAsReceiver\x0a\x09^ self variable isPseudoVar not",
referencedClasses: [],
messageSends: ["not", "isPseudoVar", "variable"]
}),
$globals.IRVariable);

$core.addMethod(
$core.method({
selector: "variable",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@variable"];

},
args: [],
source: "variable\x0a\x09^ variable",
referencedClasses: [],
messageSends: []
}),
$globals.IRVariable);

$core.addMethod(
$core.method({
selector: "variable:",
protocol: 'accessing',
fn: function (aScopeVariable){
var self=this;
self["@variable"]=aScopeVariable;
return self;

},
args: ["aScopeVariable"],
source: "variable: aScopeVariable\x0a\x09variable := aScopeVariable",
referencedClasses: [],
messageSends: []
}),
$globals.IRVariable);



$core.addClass('IRVerbatim', $globals.IRInstruction, ['source'], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRVerbatim_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRVerbatim)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRVerbatim: self",
referencedClasses: [],
messageSends: ["visitIRVerbatim:"]
}),
$globals.IRVerbatim);

$core.addMethod(
$core.method({
selector: "source",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@source"];

},
args: [],
source: "source\x0a\x09^ source",
referencedClasses: [],
messageSends: []
}),
$globals.IRVerbatim);

$core.addMethod(
$core.method({
selector: "source:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@source"]=aString;
return self;

},
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
messageSends: []
}),
$globals.IRVerbatim);



$core.addClass('IRVisitor', $globals.Object, [], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "visit:",
protocol: 'visiting',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(anIRInstruction)._accept_(self);
}, function($ctx1) {$ctx1.fill(self,"visit:",{anIRInstruction:anIRInstruction},$globals.IRVisitor)});
},
args: ["anIRInstruction"],
source: "visit: anIRInstruction\x0a\x09^ anIRInstruction accept: self",
referencedClasses: [],
messageSends: ["accept:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRAssignment:",
protocol: 'visiting',
fn: function (anIRAssignment){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRAssignment);
}, function($ctx1) {$ctx1.fill(self,"visitIRAssignment:",{anIRAssignment:anIRAssignment},$globals.IRVisitor)});
},
args: ["anIRAssignment"],
source: "visitIRAssignment: anIRAssignment\x0a\x09^ self visitIRInstruction: anIRAssignment",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRBlockReturn:",
protocol: 'visiting',
fn: function (anIRBlockReturn){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRReturn_(anIRBlockReturn);
}, function($ctx1) {$ctx1.fill(self,"visitIRBlockReturn:",{anIRBlockReturn:anIRBlockReturn},$globals.IRVisitor)});
},
args: ["anIRBlockReturn"],
source: "visitIRBlockReturn: anIRBlockReturn\x0a\x09^ self visitIRReturn: anIRBlockReturn",
referencedClasses: [],
messageSends: ["visitIRReturn:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRBlockSequence:",
protocol: 'visiting',
fn: function (anIRBlockSequence){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRSequence_(anIRBlockSequence);
}, function($ctx1) {$ctx1.fill(self,"visitIRBlockSequence:",{anIRBlockSequence:anIRBlockSequence},$globals.IRVisitor)});
},
args: ["anIRBlockSequence"],
source: "visitIRBlockSequence: anIRBlockSequence\x0a\x09^ self visitIRSequence: anIRBlockSequence",
referencedClasses: [],
messageSends: ["visitIRSequence:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRClosure:",
protocol: 'visiting',
fn: function (anIRClosure){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRClosure);
}, function($ctx1) {$ctx1.fill(self,"visitIRClosure:",{anIRClosure:anIRClosure},$globals.IRVisitor)});
},
args: ["anIRClosure"],
source: "visitIRClosure: anIRClosure\x0a\x09^ self visitIRInstruction: anIRClosure",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRDynamicArray:",
protocol: 'visiting',
fn: function (anIRDynamicArray){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRDynamicArray);
}, function($ctx1) {$ctx1.fill(self,"visitIRDynamicArray:",{anIRDynamicArray:anIRDynamicArray},$globals.IRVisitor)});
},
args: ["anIRDynamicArray"],
source: "visitIRDynamicArray: anIRDynamicArray\x0a\x09^ self visitIRInstruction: anIRDynamicArray",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRDynamicDictionary:",
protocol: 'visiting',
fn: function (anIRDynamicDictionary){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRDynamicDictionary);
}, function($ctx1) {$ctx1.fill(self,"visitIRDynamicDictionary:",{anIRDynamicDictionary:anIRDynamicDictionary},$globals.IRVisitor)});
},
args: ["anIRDynamicDictionary"],
source: "visitIRDynamicDictionary: anIRDynamicDictionary\x0a\x09^ self visitIRInstruction: anIRDynamicDictionary",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRInlinedClosure:",
protocol: 'visiting',
fn: function (anIRInlinedClosure){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRClosure_(anIRInlinedClosure);
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedClosure:",{anIRInlinedClosure:anIRInlinedClosure},$globals.IRVisitor)});
},
args: ["anIRInlinedClosure"],
source: "visitIRInlinedClosure: anIRInlinedClosure\x0a\x09^ self visitIRClosure: anIRInlinedClosure",
referencedClasses: [],
messageSends: ["visitIRClosure:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRInlinedSequence:",
protocol: 'visiting',
fn: function (anIRInlinedSequence){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRSequence_(anIRInlinedSequence);
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedSequence:",{anIRInlinedSequence:anIRInlinedSequence},$globals.IRVisitor)});
},
args: ["anIRInlinedSequence"],
source: "visitIRInlinedSequence: anIRInlinedSequence\x0a\x09^ self visitIRSequence: anIRInlinedSequence",
referencedClasses: [],
messageSends: ["visitIRSequence:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRInstruction:",
protocol: 'visiting',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(anIRInstruction)._instructions())._do_((function(each){
return $core.withContext(function($ctx2) {
return self._visit_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return anIRInstruction;
}, function($ctx1) {$ctx1.fill(self,"visitIRInstruction:",{anIRInstruction:anIRInstruction},$globals.IRVisitor)});
},
args: ["anIRInstruction"],
source: "visitIRInstruction: anIRInstruction\x0a\x09anIRInstruction instructions do: [ :each | self visit: each ].\x0a\x09^ anIRInstruction",
referencedClasses: [],
messageSends: ["do:", "instructions", "visit:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRMethod:",
protocol: 'visiting',
fn: function (anIRMethod){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRMethod);
}, function($ctx1) {$ctx1.fill(self,"visitIRMethod:",{anIRMethod:anIRMethod},$globals.IRVisitor)});
},
args: ["anIRMethod"],
source: "visitIRMethod: anIRMethod\x0a\x09^ self visitIRInstruction: anIRMethod",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRNonLocalReturn:",
protocol: 'visiting',
fn: function (anIRNonLocalReturn){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRNonLocalReturn);
}, function($ctx1) {$ctx1.fill(self,"visitIRNonLocalReturn:",{anIRNonLocalReturn:anIRNonLocalReturn},$globals.IRVisitor)});
},
args: ["anIRNonLocalReturn"],
source: "visitIRNonLocalReturn: anIRNonLocalReturn\x0a\x09^ self visitIRInstruction: anIRNonLocalReturn",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRNonLocalReturnHandling:",
protocol: 'visiting',
fn: function (anIRNonLocalReturnHandling){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRNonLocalReturnHandling);
}, function($ctx1) {$ctx1.fill(self,"visitIRNonLocalReturnHandling:",{anIRNonLocalReturnHandling:anIRNonLocalReturnHandling},$globals.IRVisitor)});
},
args: ["anIRNonLocalReturnHandling"],
source: "visitIRNonLocalReturnHandling: anIRNonLocalReturnHandling\x0a\x09^ self visitIRInstruction: anIRNonLocalReturnHandling",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRReturn:",
protocol: 'visiting',
fn: function (anIRReturn){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRReturn);
}, function($ctx1) {$ctx1.fill(self,"visitIRReturn:",{anIRReturn:anIRReturn},$globals.IRVisitor)});
},
args: ["anIRReturn"],
source: "visitIRReturn: anIRReturn\x0a\x09^ self visitIRInstruction: anIRReturn",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRSend:",
protocol: 'visiting',
fn: function (anIRSend){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRSend);
}, function($ctx1) {$ctx1.fill(self,"visitIRSend:",{anIRSend:anIRSend},$globals.IRVisitor)});
},
args: ["anIRSend"],
source: "visitIRSend: anIRSend\x0a\x09^ self visitIRInstruction: anIRSend",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRSequence:",
protocol: 'visiting',
fn: function (anIRSequence){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRSequence);
}, function($ctx1) {$ctx1.fill(self,"visitIRSequence:",{anIRSequence:anIRSequence},$globals.IRVisitor)});
},
args: ["anIRSequence"],
source: "visitIRSequence: anIRSequence\x0a\x09^ self visitIRInstruction: anIRSequence",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRTempDeclaration:",
protocol: 'visiting',
fn: function (anIRTempDeclaration){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRTempDeclaration);
}, function($ctx1) {$ctx1.fill(self,"visitIRTempDeclaration:",{anIRTempDeclaration:anIRTempDeclaration},$globals.IRVisitor)});
},
args: ["anIRTempDeclaration"],
source: "visitIRTempDeclaration: anIRTempDeclaration\x0a\x09^ self visitIRInstruction: anIRTempDeclaration",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRValue:",
protocol: 'visiting',
fn: function (anIRValue){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRValue);
}, function($ctx1) {$ctx1.fill(self,"visitIRValue:",{anIRValue:anIRValue},$globals.IRVisitor)});
},
args: ["anIRValue"],
source: "visitIRValue: anIRValue\x0a\x09^ self visitIRInstruction: anIRValue",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRVariable:",
protocol: 'visiting',
fn: function (anIRVariable){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRVariable);
}, function($ctx1) {$ctx1.fill(self,"visitIRVariable:",{anIRVariable:anIRVariable},$globals.IRVisitor)});
},
args: ["anIRVariable"],
source: "visitIRVariable: anIRVariable\x0a\x09^ self visitIRInstruction: anIRVariable",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRVerbatim:",
protocol: 'visiting',
fn: function (anIRVerbatim){
var self=this;
return $core.withContext(function($ctx1) {
return self._visitIRInstruction_(anIRVerbatim);
}, function($ctx1) {$ctx1.fill(self,"visitIRVerbatim:",{anIRVerbatim:anIRVerbatim},$globals.IRVisitor)});
},
args: ["anIRVerbatim"],
source: "visitIRVerbatim: anIRVerbatim\x0a\x09^ self visitIRInstruction: anIRVerbatim",
referencedClasses: [],
messageSends: ["visitIRInstruction:"]
}),
$globals.IRVisitor);



$core.addClass('IRJSTranslator', $globals.IRVisitor, ['stream', 'currentClass'], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "contents",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._stream())._contents();
}, function($ctx1) {$ctx1.fill(self,"contents",{},$globals.IRJSTranslator)});
},
args: [],
source: "contents\x0a\x09^ self stream contents",
referencedClasses: [],
messageSends: ["contents", "stream"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "currentClass",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@currentClass"];

},
args: [],
source: "currentClass\x0a\x09^ currentClass",
referencedClasses: [],
messageSends: []
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "currentClass:",
protocol: 'accessing',
fn: function (aClass){
var self=this;
self["@currentClass"]=aClass;
return self;

},
args: ["aClass"],
source: "currentClass: aClass\x0a\x09currentClass := aClass",
referencedClasses: [],
messageSends: []
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.IRJSTranslator.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@stream"]=$recv($globals.JSStream)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.IRJSTranslator)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09stream := JSStream new.",
referencedClasses: ["JSStream"],
messageSends: ["initialize", "new"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "stream",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@stream"];

},
args: [],
source: "stream\x0a\x09^ stream",
referencedClasses: [],
messageSends: []
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "stream:",
protocol: 'accessing',
fn: function (aStream){
var self=this;
self["@stream"]=aStream;
return self;

},
args: ["aStream"],
source: "stream: aStream\x0a\x09stream := aStream",
referencedClasses: [],
messageSends: []
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRAssignment:",
protocol: 'visiting',
fn: function (anIRAssignment){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$recv(self._stream())._nextPutAssignLhs_rhs_((function(){
return $core.withContext(function($ctx2) {
$2=$recv(anIRAssignment)._instructions();
$ctx2.sendIdx["instructions"]=1;
$1=$recv($2)._first();
return self._visit_($1);
$ctx2.sendIdx["visit:"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return self._visit_($recv($recv(anIRAssignment)._instructions())._last());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRAssignment:",{anIRAssignment:anIRAssignment},$globals.IRJSTranslator)});
},
args: ["anIRAssignment"],
source: "visitIRAssignment: anIRAssignment\x0a\x09self stream\x0a\x09\x09nextPutAssignLhs: [self visit: anIRAssignment instructions first]\x0a\x09\x09rhs: [self visit: anIRAssignment instructions last].",
referencedClasses: [],
messageSends: ["nextPutAssignLhs:rhs:", "stream", "visit:", "first", "instructions", "last"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRClosure:",
protocol: 'visiting',
fn: function (anIRClosure){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutClosureWith_arguments_((function(){
return $core.withContext(function($ctx2) {
$2=self._stream();
$ctx2.sendIdx["stream"]=2;
$recv($2)._nextPutVars_($recv($recv(anIRClosure)._tempDeclarations())._collect_((function(each){
return $core.withContext(function($ctx3) {
return $recv($recv(each)._name())._asVariableName();
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
})));
return $recv(self._stream())._nextPutBlockContextFor_during_(anIRClosure,(function(){
return $core.withContext(function($ctx3) {
return (
$ctx3.supercall = true,
($globals.IRJSTranslator.superclass||$boot.dnu).fn.prototype._visitIRClosure_.apply($recv(self), [anIRClosure]));
$ctx3.supercall = false;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$recv(anIRClosure)._arguments());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRClosure:",{anIRClosure:anIRClosure},$globals.IRJSTranslator)});
},
args: ["anIRClosure"],
source: "visitIRClosure: anIRClosure\x0a\x09self stream\x0a\x09\x09nextPutClosureWith: [\x0a\x09\x09\x09self stream nextPutVars: (anIRClosure tempDeclarations collect: [ :each |\x0a\x09\x09\x09\x09\x09each name asVariableName ]).\x0a\x09\x09\x09self stream\x0a\x09\x09\x09\x09nextPutBlockContextFor: anIRClosure\x0a\x09\x09\x09\x09during: [ super visitIRClosure: anIRClosure ] ]\x0a\x09\x09arguments: anIRClosure arguments",
referencedClasses: [],
messageSends: ["nextPutClosureWith:arguments:", "stream", "nextPutVars:", "collect:", "tempDeclarations", "asVariableName", "name", "nextPutBlockContextFor:during:", "visitIRClosure:", "arguments"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRDynamicArray:",
protocol: 'visiting',
fn: function (anIRDynamicArray){
var self=this;
return $core.withContext(function($ctx1) {
self._visitInstructionList_enclosedBetween_and_($recv(anIRDynamicArray)._instructions(),"[","]");
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRDynamicArray:",{anIRDynamicArray:anIRDynamicArray},$globals.IRJSTranslator)});
},
args: ["anIRDynamicArray"],
source: "visitIRDynamicArray: anIRDynamicArray\x0a\x09self\x0a\x09\x09visitInstructionList: anIRDynamicArray instructions\x0a\x09\x09enclosedBetween: '[' and: ']'",
referencedClasses: [],
messageSends: ["visitInstructionList:enclosedBetween:and:", "instructions"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRDynamicDictionary:",
protocol: 'visiting',
fn: function (anIRDynamicDictionary){
var self=this;
return $core.withContext(function($ctx1) {
self._visitInstructionList_enclosedBetween_and_($recv(anIRDynamicDictionary)._instructions(),"$globals.HashedCollection._newFromPairs_([","])");
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRDynamicDictionary:",{anIRDynamicDictionary:anIRDynamicDictionary},$globals.IRJSTranslator)});
},
args: ["anIRDynamicDictionary"],
source: "visitIRDynamicDictionary: anIRDynamicDictionary\x0a\x09self\x0a\x09\x09visitInstructionList: anIRDynamicDictionary instructions\x0a\x09\x09enclosedBetween: '$globals.HashedCollection._newFromPairs_([' and: '])'",
referencedClasses: [],
messageSends: ["visitInstructionList:enclosedBetween:and:", "instructions"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRMethod:",
protocol: 'visiting',
fn: function (anIRMethod){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$7,$6,$8,$9;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutMethodDeclaration_with_(anIRMethod,(function(){
return $core.withContext(function($ctx2) {
$2=self._stream();
$ctx2.sendIdx["stream"]=2;
return $recv($2)._nextPutFunctionWith_arguments_((function(){
return $core.withContext(function($ctx3) {
$3=self._stream();
$ctx3.sendIdx["stream"]=3;
$4=$recv($recv(anIRMethod)._tempDeclarations())._collect_((function(each){
return $core.withContext(function($ctx4) {
return $recv($recv(each)._name())._asVariableName();
}, function($ctx4) {$ctx4.fillBlock({each:each},$ctx3,3)});
}));
$ctx3.sendIdx["collect:"]=1;
$recv($3)._nextPutVars_($4);
$ctx3.sendIdx["nextPutVars:"]=1;
$5=self._stream();
$ctx3.sendIdx["stream"]=4;
return $recv($5)._nextPutContextFor_during_(anIRMethod,(function(){
return $core.withContext(function($ctx4) {
$7=$recv(anIRMethod)._internalVariables();
$ctx4.sendIdx["internalVariables"]=1;
$6=$recv($7)._notEmpty();
if($core.assert($6)){
$8=self._stream();
$ctx4.sendIdx["stream"]=5;
$recv($8)._nextPutVars_($recv($recv($recv(anIRMethod)._internalVariables())._asSet())._collect_((function(each){
return $core.withContext(function($ctx5) {
return $recv($recv(each)._variable())._alias();
}, function($ctx5) {$ctx5.fillBlock({each:each},$ctx4,6)});
})));
};
$9=$recv($recv(anIRMethod)._scope())._hasNonLocalReturn();
if($core.assert($9)){
return $recv(self._stream())._nextPutNonLocalReturnHandlingWith_((function(){
return $core.withContext(function($ctx5) {
return (
$ctx5.supercall = true,
($globals.IRJSTranslator.superclass||$boot.dnu).fn.prototype._visitIRMethod_.apply($recv(self), [anIRMethod]));
$ctx5.supercall = false;
$ctx5.sendIdx["visitIRMethod:"]=1;
}, function($ctx5) {$ctx5.fillBlock({},$ctx4,8)});
}));
} else {
return (
$ctx4.supercall = true,
($globals.IRJSTranslator.superclass||$boot.dnu).fn.prototype._visitIRMethod_.apply($recv(self), [anIRMethod]));
$ctx4.supercall = false;
};
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,4)});
}));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),$recv(anIRMethod)._arguments());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRMethod:",{anIRMethod:anIRMethod},$globals.IRJSTranslator)});
},
args: ["anIRMethod"],
source: "visitIRMethod: anIRMethod\x0a\x0a\x09self stream\x0a\x09\x09nextPutMethodDeclaration: anIRMethod\x0a\x09\x09with: [ self stream\x0a\x09\x09\x09nextPutFunctionWith: [\x0a\x09\x09\x09\x09self stream nextPutVars: (anIRMethod tempDeclarations collect: [ :each |\x0a\x09\x09\x09\x09\x09each name asVariableName ]).\x0a\x09\x09\x09\x09self stream nextPutContextFor: anIRMethod during: [\x0a\x09\x09\x09\x09anIRMethod internalVariables notEmpty ifTrue: [\x0a\x09\x09\x09\x09\x09self stream nextPutVars: (anIRMethod internalVariables asSet collect: [ :each |\x0a\x09\x09\x09\x09\x09\x09each variable alias ]) ].\x0a\x09\x09\x09\x09anIRMethod scope hasNonLocalReturn\x0a\x09\x09\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09\x09\x09self stream nextPutNonLocalReturnHandlingWith: [\x0a\x09\x09\x09\x09\x09\x09\x09super visitIRMethod: anIRMethod ] ]\x0a\x09\x09\x09\x09\x09ifFalse: [ super visitIRMethod: anIRMethod ] ]]\x0a\x09\x09\x09arguments: anIRMethod arguments ]",
referencedClasses: [],
messageSends: ["nextPutMethodDeclaration:with:", "stream", "nextPutFunctionWith:arguments:", "nextPutVars:", "collect:", "tempDeclarations", "asVariableName", "name", "nextPutContextFor:during:", "ifTrue:", "notEmpty", "internalVariables", "asSet", "alias", "variable", "ifTrue:ifFalse:", "hasNonLocalReturn", "scope", "nextPutNonLocalReturnHandlingWith:", "visitIRMethod:", "arguments"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRNonLocalReturn:",
protocol: 'visiting',
fn: function (anIRNonLocalReturn){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._stream())._nextPutNonLocalReturnWith_((function(){
return $core.withContext(function($ctx2) {
return (
$ctx2.supercall = true,
($globals.IRJSTranslator.superclass||$boot.dnu).fn.prototype._visitIRNonLocalReturn_.apply($recv(self), [anIRNonLocalReturn]));
$ctx2.supercall = false;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRNonLocalReturn:",{anIRNonLocalReturn:anIRNonLocalReturn},$globals.IRJSTranslator)});
},
args: ["anIRNonLocalReturn"],
source: "visitIRNonLocalReturn: anIRNonLocalReturn\x0a\x09self stream nextPutNonLocalReturnWith: [\x0a\x09\x09super visitIRNonLocalReturn: anIRNonLocalReturn ]",
referencedClasses: [],
messageSends: ["nextPutNonLocalReturnWith:", "stream", "visitIRNonLocalReturn:"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRReturn:",
protocol: 'visiting',
fn: function (anIRReturn){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._stream())._nextPutReturnWith_((function(){
return $core.withContext(function($ctx2) {
return (
$ctx2.supercall = true,
($globals.IRJSTranslator.superclass||$boot.dnu).fn.prototype._visitIRReturn_.apply($recv(self), [anIRReturn]));
$ctx2.supercall = false;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRReturn:",{anIRReturn:anIRReturn},$globals.IRJSTranslator)});
},
args: ["anIRReturn"],
source: "visitIRReturn: anIRReturn\x0a\x09self stream nextPutReturnWith: [\x0a\x09\x09super visitIRReturn: anIRReturn ]",
referencedClasses: [],
messageSends: ["nextPutReturnWith:", "stream", "visitIRReturn:"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRSend:",
protocol: 'visiting',
fn: function (anIRSend){
var self=this;
var sends,superclass;
return $core.withContext(function($ctx1) {
var $1,$2;
sends=$recv($recv($recv($recv(anIRSend)._method())._sendIndexes())._at_($recv(anIRSend)._selector()))._size();
$1=$recv(anIRSend)._isSuperSend();
if($core.assert($1)){
self._visitSuperSend_(anIRSend);
} else {
self._visitSend_(anIRSend);
};
$2=$recv($recv(sends).__gt((1)))._and_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv(anIRSend)._index()).__lt(sends);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
if($core.assert($2)){
$recv(self._stream())._nextPutSendIndexFor_(anIRSend);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRSend:",{anIRSend:anIRSend,sends:sends,superclass:superclass},$globals.IRJSTranslator)});
},
args: ["anIRSend"],
source: "visitIRSend: anIRSend\x0a\x09| sends superclass |\x0a\x09sends := (anIRSend method sendIndexes at: anIRSend selector) size.\x0a\x09\x0a\x09anIRSend isSuperSend\x0a\x09\x09ifTrue: [ self visitSuperSend: anIRSend ]\x0a\x09\x09ifFalse: [ self visitSend: anIRSend ].\x0a\x09\x09\x0a\x09(sends > 1 and: [ anIRSend index < sends ])\x0a\x09\x09ifTrue: [ self stream nextPutSendIndexFor: anIRSend ]",
referencedClasses: [],
messageSends: ["size", "at:", "sendIndexes", "method", "selector", "ifTrue:ifFalse:", "isSuperSend", "visitSuperSend:", "visitSend:", "ifTrue:", "and:", ">", "<", "index", "nextPutSendIndexFor:", "stream"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRSequence:",
protocol: 'visiting',
fn: function (anIRSequence){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutSequenceWith_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv(anIRSequence)._instructions())._do_((function(each){
return $core.withContext(function($ctx3) {
return $recv(self._stream())._nextPutStatementWith_(self._visit_(each));
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRSequence:",{anIRSequence:anIRSequence},$globals.IRJSTranslator)});
},
args: ["anIRSequence"],
source: "visitIRSequence: anIRSequence\x0a\x09self stream nextPutSequenceWith: [\x0a\x09\x09anIRSequence instructions do: [ :each |\x0a\x09\x09\x09self stream nextPutStatementWith: (self visit: each) ] ]",
referencedClasses: [],
messageSends: ["nextPutSequenceWith:", "stream", "do:", "instructions", "nextPutStatementWith:", "visit:"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRTempDeclaration:",
protocol: 'visiting',
fn: function (anIRTempDeclaration){
var self=this;
return self;

},
args: ["anIRTempDeclaration"],
source: "visitIRTempDeclaration: anIRTempDeclaration\x0a\x09\x22self stream\x0a\x09\x09nextPutAll: 'var ', anIRTempDeclaration name asVariableName, ';';\x0a\x09\x09lf\x22",
referencedClasses: [],
messageSends: []
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRValue:",
protocol: 'visiting',
fn: function (anIRValue){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._stream())._nextPutAll_($recv($recv(anIRValue)._value())._asJavascript());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRValue:",{anIRValue:anIRValue},$globals.IRJSTranslator)});
},
args: ["anIRValue"],
source: "visitIRValue: anIRValue\x0a\x09self stream nextPutAll: anIRValue value asJavascript",
referencedClasses: [],
messageSends: ["nextPutAll:", "stream", "asJavascript", "value"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRVariable:",
protocol: 'visiting',
fn: function (anIRVariable){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$4;
$3=$recv(anIRVariable)._variable();
$ctx1.sendIdx["variable"]=1;
$2=$recv($3)._name();
$1=$recv($2).__eq("thisContext");
if($core.assert($1)){
$4=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($4)._nextPutAll_("$core.getThisContext()");
$ctx1.sendIdx["nextPutAll:"]=1;
} else {
$recv(self._stream())._nextPutAll_($recv($recv(anIRVariable)._variable())._alias());
};
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRVariable:",{anIRVariable:anIRVariable},$globals.IRJSTranslator)});
},
args: ["anIRVariable"],
source: "visitIRVariable: anIRVariable\x0a\x09anIRVariable variable name = 'thisContext'\x0a\x09\x09ifTrue: [ self stream nextPutAll: '$core.getThisContext()' ]\x0a\x09\x09ifFalse: [ self stream nextPutAll: anIRVariable variable alias ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "=", "name", "variable", "nextPutAll:", "stream", "alias"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRVerbatim:",
protocol: 'visiting',
fn: function (anIRVerbatim){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutStatementWith_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._stream())._nextPutAll_($recv(anIRVerbatim)._source());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRVerbatim:",{anIRVerbatim:anIRVerbatim},$globals.IRJSTranslator)});
},
args: ["anIRVerbatim"],
source: "visitIRVerbatim: anIRVerbatim\x0a\x09self stream nextPutStatementWith: [\x0a\x09\x09self stream nextPutAll: anIRVerbatim source ]",
referencedClasses: [],
messageSends: ["nextPutStatementWith:", "stream", "nextPutAll:", "source"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitInstructionList:enclosedBetween:and:",
protocol: 'visiting',
fn: function (anArray,aString,anotherString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutAll_(aString);
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(anArray)._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return self._visit_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(self._stream())._nextPutAll_(",");
$ctx2.sendIdx["nextPutAll:"]=2;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv(self["@stream"])._nextPutAll_(anotherString);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitInstructionList:enclosedBetween:and:",{anArray:anArray,aString:aString,anotherString:anotherString},$globals.IRJSTranslator)});
},
args: ["anArray", "aString", "anotherString"],
source: "visitInstructionList: anArray enclosedBetween: aString and: anotherString\x0a\x09self stream nextPutAll: aString.\x0a\x09anArray\x0a\x09\x09do: [ :each | self visit: each ]\x0a\x09\x09separatedBy: [ self stream nextPutAll: ',' ].\x0a\x09stream nextPutAll: anotherString",
referencedClasses: [],
messageSends: ["nextPutAll:", "stream", "do:separatedBy:", "visit:"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitReceiver:",
protocol: 'visiting',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$1=$recv(anIRInstruction)._needsBoxingAsReceiver();
if(!$core.assert($1)){
$2=self._visit_(anIRInstruction);
$ctx1.sendIdx["visit:"]=1;
return $2;
};
$3=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($3)._nextPutAll_("$recv(");
$ctx1.sendIdx["nextPutAll:"]=1;
self._visit_(anIRInstruction);
$recv(self._stream())._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"visitReceiver:",{anIRInstruction:anIRInstruction},$globals.IRJSTranslator)});
},
args: ["anIRInstruction"],
source: "visitReceiver: anIRInstruction\x0a\x09anIRInstruction needsBoxingAsReceiver ifFalse: [ ^ self visit: anIRInstruction ].\x0a\x09\x0a\x09self stream nextPutAll: '$recv('.\x0a\x09self visit: anIRInstruction.\x0a\x09self stream nextPutAll: ')'",
referencedClasses: [],
messageSends: ["ifFalse:", "needsBoxingAsReceiver", "visit:", "nextPutAll:", "stream"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitSend:",
protocol: 'visiting',
fn: function (anIRSend){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=$recv(anIRSend)._instructions();
$ctx1.sendIdx["instructions"]=1;
$1=$recv($2)._first();
self._visitReceiver_($1);
$recv(self._stream())._nextPutAll_(".".__comma($recv($recv(anIRSend)._selector())._asJavaScriptMethodName()));
self._visitInstructionList_enclosedBetween_and_($recv($recv(anIRSend)._instructions())._allButFirst(),"(",")");
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSend:",{anIRSend:anIRSend},$globals.IRJSTranslator)});
},
args: ["anIRSend"],
source: "visitSend: anIRSend\x0a\x09self visitReceiver: anIRSend instructions first.\x0a\x09self stream nextPutAll: '.', anIRSend selector asJavaScriptMethodName.\x0a\x09self\x0a\x09\x09visitInstructionList: anIRSend instructions allButFirst\x0a\x09\x09enclosedBetween: '(' and: ')'",
referencedClasses: [],
messageSends: ["visitReceiver:", "first", "instructions", "nextPutAll:", "stream", ",", "asJavaScriptMethodName", "selector", "visitInstructionList:enclosedBetween:and:", "allButFirst"]
}),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitSuperSend:",
protocol: 'visiting',
fn: function (anIRSend){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$4,$3,$2,$5,$6,$7,$8;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutAll_("(");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv($1)._lf();
$ctx1.sendIdx["lf"]=1;
$recv($1)._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);");
$ctx1.sendIdx["nextPutAll:"]=2;
$recv($1)._lf();
$ctx1.sendIdx["lf"]=2;
$4=$recv(anIRSend)._scope();
$ctx1.sendIdx["scope"]=1;
$3=$recv($4)._alias();
$ctx1.sendIdx["alias"]=1;
$2=$recv($3).__comma(".supercall = true,");
$ctx1.sendIdx[","]=1;
$recv($1)._nextPutAll_($2);
$ctx1.sendIdx["nextPutAll:"]=3;
$recv($1)._lf();
$ctx1.sendIdx["lf"]=3;
$recv($1)._nextPutAll_("//>>excludeEnd(\x22ctx\x22);");
$ctx1.sendIdx["nextPutAll:"]=4;
$recv($1)._lf();
$ctx1.sendIdx["lf"]=4;
$5="(".__comma($recv(self._currentClass())._asJavascript());
$ctx1.sendIdx[","]=2;
$recv($1)._nextPutAll_($5);
$ctx1.sendIdx["nextPutAll:"]=5;
$recv($1)._nextPutAll_(".superclass||$boot.dnu).fn.prototype.");
$ctx1.sendIdx["nextPutAll:"]=6;
$6=$recv($recv($recv(anIRSend)._selector())._asJavaScriptMethodName()).__comma(".apply(");
$ctx1.sendIdx[","]=3;
$recv($1)._nextPutAll_($6);
$ctx1.sendIdx["nextPutAll:"]=7;
$7=$recv($1)._nextPutAll_("$recv(self), ");
$ctx1.sendIdx["nextPutAll:"]=8;
self._visitInstructionList_enclosedBetween_and_($recv($recv(anIRSend)._instructions())._allButFirst(),"[","]");
$8=self._stream();
$recv($8)._nextPutAll_("));");
$ctx1.sendIdx["nextPutAll:"]=9;
$recv($8)._lf();
$ctx1.sendIdx["lf"]=5;
$recv($8)._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);");
$ctx1.sendIdx["nextPutAll:"]=10;
$recv($8)._lf();
$ctx1.sendIdx["lf"]=6;
$recv($8)._nextPutAll_($recv($recv($recv(anIRSend)._scope())._alias()).__comma(".supercall = false;"));
$ctx1.sendIdx["nextPutAll:"]=11;
$recv($8)._lf();
$recv($8)._nextPutAll_("//>>excludeEnd(\x22ctx\x22);");
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSuperSend:",{anIRSend:anIRSend},$globals.IRJSTranslator)});
},
args: ["anIRSend"],
source: "visitSuperSend: anIRSend\x0a\x09self stream\x0a\x09\x09nextPutAll: '('; lf;\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);'; lf;\x0a\x09\x09nextPutAll: anIRSend scope alias, '.supercall = true,'; lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);'; lf;\x0a\x09\x09nextPutAll: '(', self currentClass asJavascript;\x0a\x09\x09nextPutAll: '.superclass||$boot.dnu).fn.prototype.';\x0a\x09\x09nextPutAll: anIRSend selector asJavaScriptMethodName, '.apply(';\x0a\x09\x09nextPutAll: '$recv(self), '.\x0a\x09self\x0a\x09\x09visitInstructionList: anIRSend instructions allButFirst\x0a\x09\x09enclosedBetween: '[' and: ']'.\x0a\x09self stream \x0a\x09\x09nextPutAll: '));'; lf;\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);'; lf;\x0a\x09\x09nextPutAll: anIRSend scope alias, '.supercall = false;'; lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);'",
referencedClasses: [],
messageSends: ["nextPutAll:", "stream", "lf", ",", "alias", "scope", "asJavascript", "currentClass", "asJavaScriptMethodName", "selector", "visitInstructionList:enclosedBetween:and:", "allButFirst", "instructions"]
}),
$globals.IRJSTranslator);



$core.addClass('JSStream', $globals.Object, ['stream'], 'Compiler-IR');
$core.addMethod(
$core.method({
selector: "contents",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@stream"])._contents();
}, function($ctx1) {$ctx1.fill(self,"contents",{},$globals.JSStream)});
},
args: [],
source: "contents\x0a\x09^ stream contents",
referencedClasses: [],
messageSends: ["contents"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.JSStream.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@stream"]=""._writeStream();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.JSStream)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09stream := '' writeStream.",
referencedClasses: [],
messageSends: ["initialize", "writeStream"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "lf",
protocol: 'streaming',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@stream"])._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"lf",{},$globals.JSStream)});
},
args: [],
source: "lf\x0a\x09stream lf",
referencedClasses: [],
messageSends: ["lf"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPut:",
protocol: 'streaming',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@stream"])._nextPut_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPut:",{aString:aString},$globals.JSStream)});
},
args: ["aString"],
source: "nextPut: aString\x0a\x09stream nextPut: aString",
referencedClasses: [],
messageSends: ["nextPut:"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutAll:",
protocol: 'streaming',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@stream"])._nextPutAll_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutAll:",{aString:aString},$globals.JSStream)});
},
args: ["aString"],
source: "nextPutAll: aString\x0a\x09stream nextPutAll: aString",
referencedClasses: [],
messageSends: ["nextPutAll:"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutAssignLhs:rhs:",
protocol: 'streaming',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aBlock)._value();
$ctx1.sendIdx["value"]=1;
$recv(self["@stream"])._nextPutAll_("=");
$recv(anotherBlock)._value();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutAssignLhs:rhs:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.JSStream)});
},
args: ["aBlock", "anotherBlock"],
source: "nextPutAssignLhs: aBlock rhs: anotherBlock\x0a\x09aBlock value.\x0a\x09stream nextPutAll: '='.\x0a\x09anotherBlock value",
referencedClasses: [],
messageSends: ["value", "nextPutAll:"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutBlockContextFor:during:",
protocol: 'streaming',
fn: function (anIRClosure,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$6,$5,$4,$3,$7,$11,$10,$9,$8,$15,$14,$13,$12,$16,$17,$23,$22,$21,$20,$19,$18;
$1=$recv(anIRClosure)._requiresSmalltalkContext();
if(!$core.assert($1)){
$2=$recv(aBlock)._value();
$ctx1.sendIdx["value"]=1;
return $2;
};
self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);");
$ctx1.sendIdx["nextPutAll:"]=1;
self._lf();
$ctx1.sendIdx["lf"]=1;
$6=$recv(anIRClosure)._scope();
$ctx1.sendIdx["scope"]=1;
$5=$recv($6)._alias();
$ctx1.sendIdx["alias"]=1;
$4="return $core.withContext(function(".__comma($5);
$ctx1.sendIdx[","]=2;
$3=$recv($4).__comma(") {");
$ctx1.sendIdx[","]=1;
self._nextPutAll_($3);
$ctx1.sendIdx["nextPutAll:"]=2;
self._lf();
$ctx1.sendIdx["lf"]=2;
self._nextPutAll_("//>>excludeEnd(\x22ctx\x22);");
$ctx1.sendIdx["nextPutAll:"]=3;
$7=self._lf();
$ctx1.sendIdx["lf"]=3;
$recv(aBlock)._value();
self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);");
$ctx1.sendIdx["nextPutAll:"]=4;
self._lf();
$ctx1.sendIdx["lf"]=4;
$11=$recv(anIRClosure)._scope();
$ctx1.sendIdx["scope"]=2;
$10=$recv($11)._alias();
$ctx1.sendIdx["alias"]=2;
$9="}, function(".__comma($10);
$ctx1.sendIdx[","]=4;
$8=$recv($9).__comma(") {");
$ctx1.sendIdx[","]=3;
self._nextPutAll_($8);
$ctx1.sendIdx["nextPutAll:"]=5;
$15=$recv(anIRClosure)._scope();
$ctx1.sendIdx["scope"]=3;
$14=$recv($15)._alias();
$ctx1.sendIdx["alias"]=3;
$13=$recv($14).__comma(".fillBlock({");
$ctx1.sendIdx[","]=5;
$12=self._nextPutAll_($13);
$ctx1.sendIdx["nextPutAll:"]=6;
$recv($recv(anIRClosure)._locals())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
$16=$recv(each)._asVariableName();
$ctx2.sendIdx["asVariableName"]=1;
self._nextPutAll_($16);
$ctx2.sendIdx["nextPutAll:"]=7;
self._nextPutAll_(":");
$ctx2.sendIdx["nextPutAll:"]=8;
$17=self._nextPutAll_($recv(each)._asVariableName());
$ctx2.sendIdx["nextPutAll:"]=9;
return $17;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return self._nextPutAll_(",");
$ctx2.sendIdx["nextPutAll:"]=10;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
self._nextPutAll_("},");
$ctx1.sendIdx["nextPutAll:"]=11;
$23=$recv(anIRClosure)._scope();
$ctx1.sendIdx["scope"]=4;
$22=$recv($23)._outerScope();
$21=$recv($22)._alias();
$20=$recv($21).__comma(",");
$19=$recv($20).__comma($recv($recv($recv(anIRClosure)._scope())._blockIndex())._asString());
$ctx1.sendIdx[","]=7;
$18=$recv($19).__comma(")});");
$ctx1.sendIdx[","]=6;
self._nextPutAll_($18);
$ctx1.sendIdx["nextPutAll:"]=12;
self._lf();
self._nextPutAll_("//>>excludeEnd(\x22ctx\x22);");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutBlockContextFor:during:",{anIRClosure:anIRClosure,aBlock:aBlock},$globals.JSStream)});
},
args: ["anIRClosure", "aBlock"],
source: "nextPutBlockContextFor: anIRClosure during: aBlock\x0a\x09anIRClosure requiresSmalltalkContext ifFalse: [ ^ aBlock value ].\x0a\x09self\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: 'return $core.withContext(function(', anIRClosure scope alias, ') {';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);';\x0a\x09\x09lf.\x0a\x09\x0a\x09aBlock value.\x0a\x09\x0a\x09self\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '}, function(', anIRClosure scope alias, ') {';\x0a\x09\x09nextPutAll: anIRClosure scope alias, '.fillBlock({'.\x0a\x09\x0a\x09anIRClosure locals\x0a\x09\x09do: [ :each |\x0a\x09\x09\x09self\x0a\x09\x09\x09\x09nextPutAll: each asVariableName;\x0a\x09\x09\x09\x09nextPutAll: ':';\x0a\x09\x09\x09\x09nextPutAll: each asVariableName ]\x0a\x09\x09separatedBy: [ self nextPutAll: ',' ].\x0a\x09\x0a\x09self\x0a\x09\x09nextPutAll: '},';\x0a\x09\x09nextPutAll: anIRClosure scope outerScope alias, ',', anIRClosure scope blockIndex asString, ')});';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);'",
referencedClasses: [],
messageSends: ["ifFalse:", "requiresSmalltalkContext", "value", "nextPutAll:", "lf", ",", "alias", "scope", "do:separatedBy:", "locals", "asVariableName", "outerScope", "asString", "blockIndex"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutClosureWith:arguments:",
protocol: 'streaming',
fn: function (aBlock,anArray){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$recv(self["@stream"])._nextPutAll_("(function(");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(anArray)._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(self["@stream"])._nextPutAll_($recv(each)._asVariableName());
$ctx2.sendIdx["nextPutAll:"]=2;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(self["@stream"])._nextPut_(",");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$1=self["@stream"];
$recv($1)._nextPutAll_("){");
$ctx1.sendIdx["nextPutAll:"]=3;
$2=$recv($1)._lf();
$ctx1.sendIdx["lf"]=1;
$recv(aBlock)._value();
$3=self["@stream"];
$recv($3)._lf();
$recv($3)._nextPutAll_("})");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutClosureWith:arguments:",{aBlock:aBlock,anArray:anArray},$globals.JSStream)});
},
args: ["aBlock", "anArray"],
source: "nextPutClosureWith: aBlock arguments: anArray\x0a\x09stream nextPutAll: '(function('.\x0a\x09anArray\x0a\x09\x09do: [ :each | stream nextPutAll: each asVariableName ]\x0a\x09\x09separatedBy: [ stream nextPut: ',' ].\x0a\x09stream nextPutAll: '){'; lf.\x0a\x09aBlock value.\x0a\x09stream lf; nextPutAll: '})'",
referencedClasses: [],
messageSends: ["nextPutAll:", "do:separatedBy:", "asVariableName", "nextPut:", "lf", "value"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutContextFor:during:",
protocol: 'streaming',
fn: function (aMethod,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$6,$5,$4,$3,$7,$12,$11,$10,$9,$8,$16,$15,$14,$13,$17,$18;
$1=$recv(aMethod)._requiresSmalltalkContext();
if(!$core.assert($1)){
$2=$recv(aBlock)._value();
$ctx1.sendIdx["value"]=1;
return $2;
};
self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);");
$ctx1.sendIdx["nextPutAll:"]=1;
self._lf();
$ctx1.sendIdx["lf"]=1;
$6=$recv(aMethod)._scope();
$ctx1.sendIdx["scope"]=1;
$5=$recv($6)._alias();
$ctx1.sendIdx["alias"]=1;
$4="return $core.withContext(function(".__comma($5);
$ctx1.sendIdx[","]=2;
$3=$recv($4).__comma(") {");
$ctx1.sendIdx[","]=1;
self._nextPutAll_($3);
$ctx1.sendIdx["nextPutAll:"]=2;
self._lf();
$ctx1.sendIdx["lf"]=2;
self._nextPutAll_("//>>excludeEnd(\x22ctx\x22);");
$ctx1.sendIdx["nextPutAll:"]=3;
$7=self._lf();
$ctx1.sendIdx["lf"]=3;
$recv(aBlock)._value();
self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);");
$ctx1.sendIdx["nextPutAll:"]=4;
self._lf();
$ctx1.sendIdx["lf"]=4;
$12=$recv(aMethod)._scope();
$ctx1.sendIdx["scope"]=2;
$11=$recv($12)._alias();
$ctx1.sendIdx["alias"]=2;
$10="}, function(".__comma($11);
$ctx1.sendIdx[","]=5;
$9=$recv($10).__comma(") {");
$ctx1.sendIdx[","]=4;
$8=$recv($9).__comma($recv($recv(aMethod)._scope())._alias());
$ctx1.sendIdx[","]=3;
self._nextPutAll_($8);
$ctx1.sendIdx["nextPutAll:"]=5;
$16=$recv($recv(aMethod)._selector())._asJavascript();
$ctx1.sendIdx["asJavascript"]=1;
$15=".fill(self,".__comma($16);
$14=$recv($15).__comma(",{");
$ctx1.sendIdx[","]=6;
$13=self._nextPutAll_($14);
$ctx1.sendIdx["nextPutAll:"]=6;
$recv($recv(aMethod)._locals())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
$17=$recv(each)._asVariableName();
$ctx2.sendIdx["asVariableName"]=1;
self._nextPutAll_($17);
$ctx2.sendIdx["nextPutAll:"]=7;
self._nextPutAll_(":");
$ctx2.sendIdx["nextPutAll:"]=8;
$18=self._nextPutAll_($recv(each)._asVariableName());
$ctx2.sendIdx["nextPutAll:"]=9;
return $18;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return self._nextPutAll_(",");
$ctx2.sendIdx["nextPutAll:"]=10;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
self._nextPutAll_("},");
$ctx1.sendIdx["nextPutAll:"]=11;
self._nextPutAll_($recv($recv(aMethod)._theClass())._asJavascript());
$ctx1.sendIdx["nextPutAll:"]=12;
self._nextPutAll_(")});");
$ctx1.sendIdx["nextPutAll:"]=13;
self._lf();
self._nextPutAll_("//>>excludeEnd(\x22ctx\x22);");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutContextFor:during:",{aMethod:aMethod,aBlock:aBlock},$globals.JSStream)});
},
args: ["aMethod", "aBlock"],
source: "nextPutContextFor: aMethod during: aBlock\x0a\x09aMethod requiresSmalltalkContext ifFalse: [ ^ aBlock value ].\x0a\x09\x0a\x09self\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: 'return $core.withContext(function(', aMethod scope alias, ') {';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);';\x0a\x09\x09lf.\x0a\x0a\x09aBlock value.\x0a\x09\x0a\x09self\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '}, function(', aMethod scope alias, ') {', aMethod scope alias;\x0a\x09\x09nextPutAll: '.fill(self,', aMethod selector asJavascript, ',{'.\x0a\x0a\x09aMethod locals\x0a\x09\x09do: [ :each |\x0a\x09\x09\x09self\x0a\x09\x09\x09\x09nextPutAll: each asVariableName;\x0a\x09\x09\x09\x09nextPutAll: ':';\x0a\x09\x09\x09\x09nextPutAll: each asVariableName ]\x0a\x09\x09separatedBy: [ self nextPutAll: ',' ].\x0a\x09\x0a\x09self\x0a\x09\x09nextPutAll: '},';\x0a\x09\x09nextPutAll: aMethod theClass asJavascript;\x0a\x09\x09nextPutAll: ')});';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);'",
referencedClasses: [],
messageSends: ["ifFalse:", "requiresSmalltalkContext", "value", "nextPutAll:", "lf", ",", "alias", "scope", "asJavascript", "selector", "do:separatedBy:", "locals", "asVariableName", "theClass"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutFunctionWith:arguments:",
protocol: 'streaming',
fn: function (aBlock,anArray){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5;
$recv(self["@stream"])._nextPutAll_("fn: function(");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(anArray)._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(self["@stream"])._nextPutAll_($recv(each)._asVariableName());
$ctx2.sendIdx["nextPutAll:"]=2;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(self["@stream"])._nextPut_(",");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$1=self["@stream"];
$recv($1)._nextPutAll_("){");
$ctx1.sendIdx["nextPutAll:"]=3;
$2=$recv($1)._lf();
$ctx1.sendIdx["lf"]=1;
$3=self["@stream"];
$recv($3)._nextPutAll_("var self=this;");
$ctx1.sendIdx["nextPutAll:"]=4;
$4=$recv($3)._lf();
$ctx1.sendIdx["lf"]=2;
$recv(aBlock)._value();
$5=self["@stream"];
$recv($5)._lf();
$recv($5)._nextPutAll_("}");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutFunctionWith:arguments:",{aBlock:aBlock,anArray:anArray},$globals.JSStream)});
},
args: ["aBlock", "anArray"],
source: "nextPutFunctionWith: aBlock arguments: anArray\x0a\x09stream nextPutAll: 'fn: function('.\x0a\x09anArray\x0a\x09\x09do: [ :each | stream nextPutAll: each asVariableName ]\x0a\x09\x09separatedBy: [ stream nextPut: ',' ].\x0a\x09stream nextPutAll: '){'; lf.\x0a\x09stream nextPutAll: 'var self=this;'; lf.\x0a\x09aBlock value.\x0a\x09stream lf; nextPutAll: '}'",
referencedClasses: [],
messageSends: ["nextPutAll:", "do:separatedBy:", "asVariableName", "nextPut:", "lf", "value"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutIf:then:",
protocol: 'streaming',
fn: function (aBlock,anotherBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(self["@stream"])._nextPutAll_("if(");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aBlock)._value();
$ctx1.sendIdx["value"]=1;
$1=self["@stream"];
$recv($1)._nextPutAll_("){");
$ctx1.sendIdx["nextPutAll:"]=2;
$recv($1)._lf();
$recv(anotherBlock)._value();
$recv(self["@stream"])._nextPutAll_("}");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutIf:then:",{aBlock:aBlock,anotherBlock:anotherBlock},$globals.JSStream)});
},
args: ["aBlock", "anotherBlock"],
source: "nextPutIf: aBlock then: anotherBlock\x0a\x09stream nextPutAll: 'if('.\x0a\x09aBlock value.\x0a\x09stream nextPutAll: '){'; lf.\x0a\x09anotherBlock value.\x0a\x09stream nextPutAll: '}'",
referencedClasses: [],
messageSends: ["nextPutAll:", "value", "lf"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutIf:then:else:",
protocol: 'streaming',
fn: function (aBlock,ifBlock,elseBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$recv(self["@stream"])._nextPutAll_("if(");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aBlock)._value();
$ctx1.sendIdx["value"]=1;
$1=self["@stream"];
$recv($1)._nextPutAll_("){");
$ctx1.sendIdx["nextPutAll:"]=2;
$2=$recv($1)._lf();
$ctx1.sendIdx["lf"]=1;
$recv(ifBlock)._value();
$ctx1.sendIdx["value"]=2;
$3=self["@stream"];
$recv($3)._nextPutAll_("} else {");
$ctx1.sendIdx["nextPutAll:"]=3;
$recv($3)._lf();
$recv(elseBlock)._value();
$recv(self["@stream"])._nextPutAll_("}");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutIf:then:else:",{aBlock:aBlock,ifBlock:ifBlock,elseBlock:elseBlock},$globals.JSStream)});
},
args: ["aBlock", "ifBlock", "elseBlock"],
source: "nextPutIf: aBlock then: ifBlock else: elseBlock\x0a\x09stream nextPutAll: 'if('.\x0a\x09aBlock value.\x0a\x09stream nextPutAll: '){'; lf.\x0a\x09ifBlock value.\x0a\x09stream nextPutAll: '} else {'; lf.\x0a\x09elseBlock value.\x0a\x09stream nextPutAll: '}'",
referencedClasses: [],
messageSends: ["nextPutAll:", "value", "lf"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutMethodDeclaration:with:",
protocol: 'streaming',
fn: function (aMethod,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$4,$3,$2,$7,$6,$5,$8,$9,$12,$11,$10,$15,$14,$13,$18,$17,$16,$19,$20;
$1=self["@stream"];
$recv($1)._nextPutAll_("$core.method({");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv($1)._lf();
$ctx1.sendIdx["lf"]=1;
$4=$recv($recv(aMethod)._selector())._asJavascript();
$ctx1.sendIdx["asJavascript"]=1;
$3="selector: ".__comma($4);
$ctx1.sendIdx[","]=2;
$2=$recv($3).__comma(",");
$ctx1.sendIdx[","]=1;
$recv($1)._nextPutAll_($2);
$ctx1.sendIdx["nextPutAll:"]=2;
$recv($1)._lf();
$ctx1.sendIdx["lf"]=2;
$7=$recv($recv(aMethod)._source())._asJavascript();
$ctx1.sendIdx["asJavascript"]=2;
$6="source: ".__comma($7);
$ctx1.sendIdx[","]=4;
$5=$recv($6).__comma(",");
$ctx1.sendIdx[","]=3;
$recv($1)._nextPutAll_($5);
$ctx1.sendIdx["nextPutAll:"]=3;
$8=$recv($1)._lf();
$ctx1.sendIdx["lf"]=3;
$recv(aBlock)._value();
$ctx1.sendIdx["value"]=1;
$9=self["@stream"];
$12=$recv($globals.String)._lf();
$ctx1.sendIdx["lf"]=4;
$11=",".__comma($12);
$ctx1.sendIdx[","]=6;
$10=$recv($11).__comma("messageSends: ");
$ctx1.sendIdx[","]=5;
$recv($9)._nextPutAll_($10);
$ctx1.sendIdx["nextPutAll:"]=4;
$15=$recv($recv(aMethod)._messageSends())._asArray();
$ctx1.sendIdx["asArray"]=1;
$14=$recv($15)._asJavascript();
$ctx1.sendIdx["asJavascript"]=3;
$13=$recv($14).__comma(",");
$ctx1.sendIdx[","]=7;
$recv($9)._nextPutAll_($13);
$ctx1.sendIdx["nextPutAll:"]=5;
$recv($9)._lf();
$ctx1.sendIdx["lf"]=5;
$18=$recv($recv($recv($recv(aMethod)._arguments())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._value();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._asArray())._asJavascript();
$ctx1.sendIdx["asJavascript"]=4;
$17="args: ".__comma($18);
$16=$recv($17).__comma(",");
$ctx1.sendIdx[","]=8;
$recv($9)._nextPutAll_($16);
$ctx1.sendIdx["nextPutAll:"]=6;
$recv($9)._lf();
$19=$recv($9)._nextPutAll_("referencedClasses: [");
$ctx1.sendIdx["nextPutAll:"]=7;
$recv($recv(aMethod)._classReferences())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(self["@stream"])._nextPutAll_($recv(each)._asJavascript());
$ctx2.sendIdx["nextPutAll:"]=8;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(self["@stream"])._nextPutAll_(",");
$ctx2.sendIdx["nextPutAll:"]=9;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
$20=self["@stream"];
$recv($20)._nextPutAll_("]");
$ctx1.sendIdx["nextPutAll:"]=10;
$recv($20)._nextPutAll_("})");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutMethodDeclaration:with:",{aMethod:aMethod,aBlock:aBlock},$globals.JSStream)});
},
args: ["aMethod", "aBlock"],
source: "nextPutMethodDeclaration: aMethod with: aBlock\x0a\x09stream\x0a\x09\x09nextPutAll: '$core.method({'; lf;\x0a\x09\x09nextPutAll: 'selector: ', aMethod selector asJavascript, ','; lf;\x0a\x09\x09nextPutAll: 'source: ', aMethod source asJavascript, ',';lf.\x0a\x09aBlock value.\x0a\x09stream\x0a\x09\x09nextPutAll: ',', String lf, 'messageSends: ';\x0a\x09\x09nextPutAll: aMethod messageSends asArray asJavascript, ','; lf;\x0a\x09\x09nextPutAll: 'args: ', (aMethod arguments collect: [ :each | each value ]) asArray asJavascript, ','; lf;\x0a\x09\x09nextPutAll: 'referencedClasses: ['.\x0a\x09aMethod classReferences\x0a\x09\x09do: [ :each | stream nextPutAll: each asJavascript ]\x0a\x09\x09separatedBy: [ stream nextPutAll: ',' ].\x0a\x09stream\x0a\x09\x09nextPutAll: ']';\x0a\x09\x09nextPutAll: '})'",
referencedClasses: ["String"],
messageSends: ["nextPutAll:", "lf", ",", "asJavascript", "selector", "source", "value", "asArray", "messageSends", "collect:", "arguments", "do:separatedBy:", "classReferences"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutNonLocalReturnHandlingWith:",
protocol: 'streaming',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$1=self["@stream"];
$recv($1)._nextPutAll_("var $early={};");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv($1)._lf();
$ctx1.sendIdx["lf"]=1;
$recv($1)._nextPutAll_("try {");
$ctx1.sendIdx["nextPutAll:"]=2;
$2=$recv($1)._lf();
$ctx1.sendIdx["lf"]=2;
$recv(aBlock)._value();
$3=self["@stream"];
$recv($3)._nextPutAll_("}");
$ctx1.sendIdx["nextPutAll:"]=3;
$recv($3)._lf();
$ctx1.sendIdx["lf"]=3;
$recv($3)._nextPutAll_("catch(e) {if(e===$early)return e[0]; throw e}");
$recv($3)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutNonLocalReturnHandlingWith:",{aBlock:aBlock},$globals.JSStream)});
},
args: ["aBlock"],
source: "nextPutNonLocalReturnHandlingWith: aBlock\x0a\x09stream\x0a\x09\x09nextPutAll: 'var $early={};'; lf;\x0a\x09\x09nextPutAll: 'try {'; lf.\x0a\x09aBlock value.\x0a\x09stream\x0a\x09\x09nextPutAll: '}'; lf;\x0a\x09\x09nextPutAll: 'catch(e) {if(e===$early)return e[0]; throw e}'; lf",
referencedClasses: [],
messageSends: ["nextPutAll:", "lf", "value"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutNonLocalReturnWith:",
protocol: 'streaming',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@stream"])._nextPutAll_("throw $early=[");
$ctx1.sendIdx["nextPutAll:"]=1;
$recv(aBlock)._value();
$recv(self["@stream"])._nextPutAll_("]");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutNonLocalReturnWith:",{aBlock:aBlock},$globals.JSStream)});
},
args: ["aBlock"],
source: "nextPutNonLocalReturnWith: aBlock\x0a\x09stream nextPutAll: 'throw $early=['.\x0a\x09aBlock value.\x0a\x09stream nextPutAll: ']'",
referencedClasses: [],
messageSends: ["nextPutAll:", "value"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutReturnWith:",
protocol: 'streaming',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@stream"])._nextPutAll_("return ");
$recv(aBlock)._value();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutReturnWith:",{aBlock:aBlock},$globals.JSStream)});
},
args: ["aBlock"],
source: "nextPutReturnWith: aBlock\x0a\x09stream nextPutAll: 'return '.\x0a\x09aBlock value",
referencedClasses: [],
messageSends: ["nextPutAll:", "value"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutSendIndexFor:",
protocol: 'streaming',
fn: function (anIRSend){
var self=this;
return $core.withContext(function($ctx1) {
self._nextPutAll_(";");
$ctx1.sendIdx["nextPutAll:"]=1;
self._lf();
$ctx1.sendIdx["lf"]=1;
self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);");
$ctx1.sendIdx["nextPutAll:"]=2;
self._lf();
$ctx1.sendIdx["lf"]=2;
self._nextPutAll_($recv($recv(anIRSend)._scope())._alias());
$ctx1.sendIdx["nextPutAll:"]=3;
self._nextPutAll_(".sendIdx[");
$ctx1.sendIdx["nextPutAll:"]=4;
self._nextPutAll_($recv($recv(anIRSend)._selector())._asJavascript());
$ctx1.sendIdx["nextPutAll:"]=5;
self._nextPutAll_("]=");
$ctx1.sendIdx["nextPutAll:"]=6;
self._nextPutAll_($recv($recv(anIRSend)._index())._asString());
$ctx1.sendIdx["nextPutAll:"]=7;
self._nextPutAll_(";");
$ctx1.sendIdx["nextPutAll:"]=8;
self._lf();
self._nextPutAll_("//>>excludeEnd(\x22ctx\x22)");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutSendIndexFor:",{anIRSend:anIRSend},$globals.JSStream)});
},
args: ["anIRSend"],
source: "nextPutSendIndexFor: anIRSend\x0a\x09self \x0a\x09\x09nextPutAll: ';'; lf;\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);'; lf;\x0a\x09\x09nextPutAll: anIRSend scope alias;\x0a\x09\x09nextPutAll: '.sendIdx[';\x0a\x09\x09nextPutAll: anIRSend selector asJavascript;\x0a\x09\x09nextPutAll: ']=';\x0a\x09\x09nextPutAll: anIRSend index asString;\x0a\x09\x09nextPutAll: ';'; lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22)'",
referencedClasses: [],
messageSends: ["nextPutAll:", "lf", "alias", "scope", "asJavascript", "selector", "asString", "index"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutSequenceWith:",
protocol: 'streaming',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aBlock)._value();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutSequenceWith:",{aBlock:aBlock},$globals.JSStream)});
},
args: ["aBlock"],
source: "nextPutSequenceWith: aBlock\x0a\x09\x22stream\x0a\x09\x09nextPutAll: 'switch($core.thisContext.pc){'; lf.\x22\x0a\x09aBlock value.\x0a\x09\x22stream\x0a\x09\x09nextPutAll: '};'; lf\x22",
referencedClasses: [],
messageSends: ["value"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutStatementWith:",
protocol: 'streaming',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(aBlock)._value();
$1=self["@stream"];
$recv($1)._nextPutAll_(";");
$recv($1)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutStatementWith:",{aBlock:aBlock},$globals.JSStream)});
},
args: ["aBlock"],
source: "nextPutStatementWith: aBlock\x0a\x09aBlock value.\x0a\x09stream nextPutAll: ';'; lf",
referencedClasses: [],
messageSends: ["value", "nextPutAll:", "lf"]
}),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutVars:",
protocol: 'streaming',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(aCollection)._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
$recv(self["@stream"])._nextPutAll_("var ");
$ctx2.sendIdx["nextPutAll:"]=1;
$recv(aCollection)._do_separatedBy_((function(each){
return $core.withContext(function($ctx3) {
return $recv(self["@stream"])._nextPutAll_(each);
$ctx3.sendIdx["nextPutAll:"]=2;
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return $recv(self["@stream"])._nextPutAll_(",");
$ctx3.sendIdx["nextPutAll:"]=3;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
$1=self["@stream"];
$recv($1)._nextPutAll_(";");
return $recv($1)._lf();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutVars:",{aCollection:aCollection},$globals.JSStream)});
},
args: ["aCollection"],
source: "nextPutVars: aCollection\x0a\x09aCollection ifNotEmpty: [\x0a\x09\x09stream nextPutAll: 'var '.\x0a\x09\x09aCollection\x0a\x09\x09\x09do: [ :each | stream nextPutAll: each ]\x0a\x09\x09\x09separatedBy: [ stream nextPutAll: ',' ].\x0a\x09\x09stream nextPutAll: ';'; lf ]",
referencedClasses: [],
messageSends: ["ifNotEmpty:", "nextPutAll:", "do:separatedBy:", "lf"]
}),
$globals.JSStream);


$core.addMethod(
$core.method({
selector: "appendToInstruction:",
protocol: '*Compiler-IR',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
$recv(anIRInstruction)._appendBlock_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"appendToInstruction:",{anIRInstruction:anIRInstruction},$globals.BlockClosure)});
},
args: ["anIRInstruction"],
source: "appendToInstruction: anIRInstruction\x0a\x09anIRInstruction appendBlock: self",
referencedClasses: [],
messageSends: ["appendBlock:"]
}),
$globals.BlockClosure);

});

define("amber_core/Compiler-Inlining", ["amber/boot", "amber_core/Compiler-IR", "amber_core/Kernel-Objects", "amber_core/Compiler-Core", "amber_core/Compiler-Semantic"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Compiler-Inlining');
$core.packages["Compiler-Inlining"].innerEval = function (expr) { return eval(expr); };
$core.packages["Compiler-Inlining"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('IRInlinedAssignment', $globals.IRAssignment, [], 'Compiler-Inlining');
$globals.IRInlinedAssignment.comment="I represent an inlined assignment instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRInlinedAssignment_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRInlinedAssignment)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRInlinedAssignment: self",
referencedClasses: [],
messageSends: ["visitIRInlinedAssignment:"]
}),
$globals.IRInlinedAssignment);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isInlined\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRInlinedAssignment);



$core.addClass('IRInlinedClosure', $globals.IRClosure, [], 'Compiler-Inlining');
$globals.IRInlinedClosure.comment="I represent an inlined closure instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedClosure_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRInlinedClosure)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09aVisitor visitIRInlinedClosure: self",
referencedClasses: [],
messageSends: ["visitIRInlinedClosure:"]
}),
$globals.IRInlinedClosure);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isInlined\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRInlinedClosure);



$core.addClass('IRInlinedReturn', $globals.IRReturn, [], 'Compiler-Inlining');
$globals.IRInlinedReturn.comment="I represent an inlined local return instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRInlinedReturn_(self);
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRInlinedReturn)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09^ aVisitor visitIRInlinedReturn: self",
referencedClasses: [],
messageSends: ["visitIRInlinedReturn:"]
}),
$globals.IRInlinedReturn);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isInlined\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRInlinedReturn);



$core.addClass('IRInlinedSend', $globals.IRSend, [], 'Compiler-Inlining');
$globals.IRInlinedSend.comment="I am the abstract super class of inlined message send instructions.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitInlinedSend_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRInlinedSend)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09aVisitor visitInlinedSend: self",
referencedClasses: [],
messageSends: ["visitInlinedSend:"]
}),
$globals.IRInlinedSend);

$core.addMethod(
$core.method({
selector: "internalVariables",
protocol: 'accessing',
fn: function (){
var self=this;
return [];

},
args: [],
source: "internalVariables\x0a\x09\x22Answer a collection of internal variables required \x0a\x09to perform the inlining\x22\x0a\x09\x0a\x09^ #()",
referencedClasses: [],
messageSends: []
}),
$globals.IRInlinedSend);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isInlined\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRInlinedSend);



$core.addClass('IRInlinedIfFalse', $globals.IRInlinedSend, [], 'Compiler-Inlining');
$globals.IRInlinedIfFalse.comment="I represent an inlined `#ifFalse:` message send instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedIfFalse_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRInlinedIfFalse)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09aVisitor visitIRInlinedIfFalse: self",
referencedClasses: [],
messageSends: ["visitIRInlinedIfFalse:"]
}),
$globals.IRInlinedIfFalse);



$core.addClass('IRInlinedIfNilIfNotNil', $globals.IRInlinedSend, [], 'Compiler-Inlining');
$globals.IRInlinedIfNilIfNotNil.comment="I represent an inlined `#ifNil:ifNotNil:` message send instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedIfNilIfNotNil_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRInlinedIfNilIfNotNil)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09aVisitor visitIRInlinedIfNilIfNotNil: self",
referencedClasses: [],
messageSends: ["visitIRInlinedIfNilIfNotNil:"]
}),
$globals.IRInlinedIfNilIfNotNil);

$core.addMethod(
$core.method({
selector: "internalVariables",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Array)._with_(self._receiverInternalVariable());
}, function($ctx1) {$ctx1.fill(self,"internalVariables",{},$globals.IRInlinedIfNilIfNotNil)});
},
args: [],
source: "internalVariables\x0a\x09^ Array with: self receiverInternalVariable",
referencedClasses: ["Array"],
messageSends: ["with:", "receiverInternalVariable"]
}),
$globals.IRInlinedIfNilIfNotNil);

$core.addMethod(
$core.method({
selector: "receiverInternalVariable",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRVariable)._new();
$ctx1.sendIdx["new"]=1;
$recv($1)._variable_($recv($recv($globals.AliasVar)._new())._name_(self._receiverInternalVariableName()));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"receiverInternalVariable",{},$globals.IRInlinedIfNilIfNotNil)});
},
args: [],
source: "receiverInternalVariable\x0a\x09^ IRVariable new\x0a\x09\x09variable: (AliasVar new name: self receiverInternalVariableName);\x0a\x09\x09yourself.",
referencedClasses: ["IRVariable", "AliasVar"],
messageSends: ["variable:", "new", "name:", "receiverInternalVariableName", "yourself"]
}),
$globals.IRInlinedIfNilIfNotNil);

$core.addMethod(
$core.method({
selector: "receiverInternalVariableName",
protocol: 'accessing',
fn: function (){
var self=this;
return "$receiver";

},
args: [],
source: "receiverInternalVariableName\x0a\x09^ '$receiver'",
referencedClasses: [],
messageSends: []
}),
$globals.IRInlinedIfNilIfNotNil);



$core.addClass('IRInlinedIfTrue', $globals.IRInlinedSend, [], 'Compiler-Inlining');
$globals.IRInlinedIfTrue.comment="I represent an inlined `#ifTrue:` message send instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedIfTrue_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRInlinedIfTrue)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09aVisitor visitIRInlinedIfTrue: self",
referencedClasses: [],
messageSends: ["visitIRInlinedIfTrue:"]
}),
$globals.IRInlinedIfTrue);



$core.addClass('IRInlinedIfTrueIfFalse', $globals.IRInlinedSend, [], 'Compiler-Inlining');
$globals.IRInlinedIfTrueIfFalse.comment="I represent an inlined `#ifTrue:ifFalse:` message send instruction.";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedIfTrueIfFalse_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRInlinedIfTrueIfFalse)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09aVisitor visitIRInlinedIfTrueIfFalse: self",
referencedClasses: [],
messageSends: ["visitIRInlinedIfTrueIfFalse:"]
}),
$globals.IRInlinedIfTrueIfFalse);



$core.addClass('IRInlinedSequence', $globals.IRBlockSequence, [], 'Compiler-Inlining');
$globals.IRInlinedSequence.comment="I represent a (block) sequence inside an inlined closure instruction (instance of `IRInlinedClosure`).";
$core.addMethod(
$core.method({
selector: "accept:",
protocol: 'visiting',
fn: function (aVisitor){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedSequence_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"accept:",{aVisitor:aVisitor},$globals.IRInlinedSequence)});
},
args: ["aVisitor"],
source: "accept: aVisitor\x0a\x09aVisitor visitIRInlinedSequence: self",
referencedClasses: [],
messageSends: ["visitIRInlinedSequence:"]
}),
$globals.IRInlinedSequence);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: 'testing',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isInlined\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.IRInlinedSequence);



$core.addClass('IRInliner', $globals.IRVisitor, [], 'Compiler-Inlining');
$globals.IRInliner.comment="I visit an IR tree, inlining message sends and block closures.\x0a\x0aMessage selectors that can be inlined are answered by `IRSendInliner >> #inlinedSelectors`";
$core.addMethod(
$core.method({
selector: "assignmentInliner",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRAssignmentInliner)._new();
$recv($1)._translator_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"assignmentInliner",{},$globals.IRInliner)});
},
args: [],
source: "assignmentInliner\x0a\x09^ IRAssignmentInliner new\x0a\x09\x09translator: self;\x0a\x09\x09yourself",
referencedClasses: ["IRAssignmentInliner"],
messageSends: ["translator:", "new", "yourself"]
}),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "returnInliner",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRReturnInliner)._new();
$recv($1)._translator_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"returnInliner",{},$globals.IRInliner)});
},
args: [],
source: "returnInliner\x0a\x09^ IRReturnInliner new\x0a\x09\x09translator: self;\x0a\x09\x09yourself",
referencedClasses: ["IRReturnInliner"],
messageSends: ["translator:", "new", "yourself"]
}),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "sendInliner",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRSendInliner)._new();
$recv($1)._translator_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"sendInliner",{},$globals.IRInliner)});
},
args: [],
source: "sendInliner\x0a\x09^ IRSendInliner new\x0a\x09\x09translator: self;\x0a\x09\x09yourself",
referencedClasses: ["IRSendInliner"],
messageSends: ["translator:", "new", "yourself"]
}),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "shouldInlineAssignment:",
protocol: 'testing',
fn: function (anIRAssignment){
var self=this;
return $core.withContext(function($ctx1) {
var $4,$3,$2,$1;
$1=$recv($recv($recv(anIRAssignment)._isInlined())._not())._and_((function(){
return $core.withContext(function($ctx2) {
$4=$recv(anIRAssignment)._instructions();
$ctx2.sendIdx["instructions"]=1;
$3=$recv($4)._last();
$ctx2.sendIdx["last"]=1;
$2=$recv($3)._isSend();
return $recv($2)._and_((function(){
return $core.withContext(function($ctx3) {
return self._shouldInlineSend_($recv($recv(anIRAssignment)._instructions())._last());
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["and:"]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"shouldInlineAssignment:",{anIRAssignment:anIRAssignment},$globals.IRInliner)});
},
args: ["anIRAssignment"],
source: "shouldInlineAssignment: anIRAssignment\x0a\x09^ anIRAssignment isInlined not and: [\x0a\x09\x09anIRAssignment instructions last isSend and: [\x0a\x09\x09\x09self shouldInlineSend: (anIRAssignment instructions last) ]]",
referencedClasses: [],
messageSends: ["and:", "not", "isInlined", "isSend", "last", "instructions", "shouldInlineSend:"]
}),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "shouldInlineReturn:",
protocol: 'testing',
fn: function (anIRReturn){
var self=this;
return $core.withContext(function($ctx1) {
var $4,$3,$2,$1;
$1=$recv($recv($recv(anIRReturn)._isInlined())._not())._and_((function(){
return $core.withContext(function($ctx2) {
$4=$recv(anIRReturn)._instructions();
$ctx2.sendIdx["instructions"]=1;
$3=$recv($4)._first();
$ctx2.sendIdx["first"]=1;
$2=$recv($3)._isSend();
return $recv($2)._and_((function(){
return $core.withContext(function($ctx3) {
return self._shouldInlineSend_($recv($recv(anIRReturn)._instructions())._first());
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["and:"]=1;
return $1;
}, function($ctx1) {$ctx1.fill(self,"shouldInlineReturn:",{anIRReturn:anIRReturn},$globals.IRInliner)});
},
args: ["anIRReturn"],
source: "shouldInlineReturn: anIRReturn\x0a\x09^ anIRReturn isInlined not and: [\x0a\x09\x09anIRReturn instructions first isSend and: [\x0a\x09\x09\x09self shouldInlineSend: (anIRReturn instructions first) ]]",
referencedClasses: [],
messageSends: ["and:", "not", "isInlined", "isSend", "first", "instructions", "shouldInlineSend:"]
}),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "shouldInlineSend:",
protocol: 'testing',
fn: function (anIRSend){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv(anIRSend)._isInlined())._not())._and_((function(){
return $core.withContext(function($ctx2) {
return $recv($globals.IRSendInliner)._shouldInline_(anIRSend);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"shouldInlineSend:",{anIRSend:anIRSend},$globals.IRInliner)});
},
args: ["anIRSend"],
source: "shouldInlineSend: anIRSend\x0a\x09^ anIRSend isInlined not and: [\x0a\x09\x09IRSendInliner shouldInline: anIRSend ]",
referencedClasses: ["IRSendInliner"],
messageSends: ["and:", "not", "isInlined", "shouldInline:"]
}),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "transformNonLocalReturn:",
protocol: 'visiting',
fn: function (anIRNonLocalReturn){
var self=this;
var localReturn;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$5,$6,$7;
$2=$recv(anIRNonLocalReturn)._scope();
$ctx1.sendIdx["scope"]=1;
$1=$recv($2)._canInlineNonLocalReturns();
if($core.assert($1)){
$4=$recv(anIRNonLocalReturn)._scope();
$ctx1.sendIdx["scope"]=2;
$3=$recv($4)._methodScope();
$5=$recv(anIRNonLocalReturn)._scope();
$ctx1.sendIdx["scope"]=3;
$recv($3)._removeNonLocalReturn_($5);
$6=$recv($globals.IRReturn)._new();
$recv($6)._scope_($recv(anIRNonLocalReturn)._scope());
localReturn=$recv($6)._yourself();
localReturn;
$recv($recv(anIRNonLocalReturn)._instructions())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(localReturn)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
$recv(anIRNonLocalReturn)._replaceWith_(localReturn);
return localReturn;
};
$7=(
$ctx1.supercall = true,
($globals.IRInliner.superclass||$boot.dnu).fn.prototype._visitIRNonLocalReturn_.apply($recv(self), [anIRNonLocalReturn]));
$ctx1.supercall = false;
return $7;
}, function($ctx1) {$ctx1.fill(self,"transformNonLocalReturn:",{anIRNonLocalReturn:anIRNonLocalReturn,localReturn:localReturn},$globals.IRInliner)});
},
args: ["anIRNonLocalReturn"],
source: "transformNonLocalReturn: anIRNonLocalReturn\x0a\x09\x22Replace a non local return into a local return\x22\x0a\x0a\x09| localReturn |\x0a\x09anIRNonLocalReturn scope canInlineNonLocalReturns ifTrue: [\x0a\x09\x09anIRNonLocalReturn scope methodScope removeNonLocalReturn: anIRNonLocalReturn scope.\x0a\x09\x09localReturn := IRReturn new\x0a\x09\x09\x09scope: anIRNonLocalReturn scope;\x0a\x09\x09\x09yourself.\x0a\x09\x09anIRNonLocalReturn instructions do: [ :each |\x0a\x09\x09\x09localReturn add: each ].\x0a\x09\x09anIRNonLocalReturn replaceWith: localReturn.\x0a\x09\x09^ localReturn ].\x0a\x09^ super visitIRNonLocalReturn: anIRNonLocalReturn",
referencedClasses: ["IRReturn"],
messageSends: ["ifTrue:", "canInlineNonLocalReturns", "scope", "removeNonLocalReturn:", "methodScope", "scope:", "new", "yourself", "do:", "instructions", "add:", "replaceWith:", "visitIRNonLocalReturn:"]
}),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "visitIRAssignment:",
protocol: 'visiting',
fn: function (anIRAssignment){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._shouldInlineAssignment_(anIRAssignment);
if($core.assert($1)){
return $recv(self._assignmentInliner())._inlineAssignment_(anIRAssignment);
} else {
return (
$ctx1.supercall = true,
($globals.IRInliner.superclass||$boot.dnu).fn.prototype._visitIRAssignment_.apply($recv(self), [anIRAssignment]));
$ctx1.supercall = false;
};
}, function($ctx1) {$ctx1.fill(self,"visitIRAssignment:",{anIRAssignment:anIRAssignment},$globals.IRInliner)});
},
args: ["anIRAssignment"],
source: "visitIRAssignment: anIRAssignment\x0a\x09^ (self shouldInlineAssignment: anIRAssignment)\x0a\x09\x09ifTrue: [ self assignmentInliner inlineAssignment: anIRAssignment ]\x0a\x09\x09ifFalse: [ super visitIRAssignment: anIRAssignment ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "shouldInlineAssignment:", "inlineAssignment:", "assignmentInliner", "visitIRAssignment:"]
}),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "visitIRNonLocalReturn:",
protocol: 'visiting',
fn: function (anIRNonLocalReturn){
var self=this;
return $core.withContext(function($ctx1) {
return self._transformNonLocalReturn_(anIRNonLocalReturn);
}, function($ctx1) {$ctx1.fill(self,"visitIRNonLocalReturn:",{anIRNonLocalReturn:anIRNonLocalReturn},$globals.IRInliner)});
},
args: ["anIRNonLocalReturn"],
source: "visitIRNonLocalReturn: anIRNonLocalReturn\x0a\x09^ self transformNonLocalReturn: anIRNonLocalReturn",
referencedClasses: [],
messageSends: ["transformNonLocalReturn:"]
}),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "visitIRReturn:",
protocol: 'visiting',
fn: function (anIRReturn){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._shouldInlineReturn_(anIRReturn);
if($core.assert($1)){
return $recv(self._returnInliner())._inlineReturn_(anIRReturn);
} else {
return (
$ctx1.supercall = true,
($globals.IRInliner.superclass||$boot.dnu).fn.prototype._visitIRReturn_.apply($recv(self), [anIRReturn]));
$ctx1.supercall = false;
};
}, function($ctx1) {$ctx1.fill(self,"visitIRReturn:",{anIRReturn:anIRReturn},$globals.IRInliner)});
},
args: ["anIRReturn"],
source: "visitIRReturn: anIRReturn\x0a\x09^ (self shouldInlineReturn: anIRReturn)\x0a\x09\x09ifTrue: [ self returnInliner inlineReturn: anIRReturn ]\x0a\x09\x09ifFalse: [ super visitIRReturn: anIRReturn ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "shouldInlineReturn:", "inlineReturn:", "returnInliner", "visitIRReturn:"]
}),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "visitIRSend:",
protocol: 'visiting',
fn: function (anIRSend){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._shouldInlineSend_(anIRSend);
if($core.assert($1)){
return $recv(self._sendInliner())._inlineSend_(anIRSend);
} else {
return (
$ctx1.supercall = true,
($globals.IRInliner.superclass||$boot.dnu).fn.prototype._visitIRSend_.apply($recv(self), [anIRSend]));
$ctx1.supercall = false;
};
}, function($ctx1) {$ctx1.fill(self,"visitIRSend:",{anIRSend:anIRSend},$globals.IRInliner)});
},
args: ["anIRSend"],
source: "visitIRSend: anIRSend\x0a\x09^ (self shouldInlineSend: anIRSend)\x0a\x09\x09ifTrue: [ self sendInliner inlineSend: anIRSend ]\x0a\x09\x09ifFalse: [ super visitIRSend: anIRSend ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "shouldInlineSend:", "inlineSend:", "sendInliner", "visitIRSend:"]
}),
$globals.IRInliner);



$core.addClass('IRInliningJSTranslator', $globals.IRJSTranslator, [], 'Compiler-Inlining');
$globals.IRInliningJSTranslator.comment="I am a specialized JavaScript translator able to write inlined IR instructions to JavaScript stream (`JSStream` instance).";
$core.addMethod(
$core.method({
selector: "visitIRInlinedAssignment:",
protocol: 'visiting',
fn: function (anIRInlinedAssignment){
var self=this;
return $core.withContext(function($ctx1) {
self._visit_($recv($recv(anIRInlinedAssignment)._instructions())._last());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedAssignment:",{anIRInlinedAssignment:anIRInlinedAssignment},$globals.IRInliningJSTranslator)});
},
args: ["anIRInlinedAssignment"],
source: "visitIRInlinedAssignment: anIRInlinedAssignment\x0a\x09self visit: anIRInlinedAssignment instructions last",
referencedClasses: [],
messageSends: ["visit:", "last", "instructions"]
}),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedClosure:",
protocol: 'visiting',
fn: function (anIRInlinedClosure){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._stream())._nextPutVars_($recv($recv(anIRInlinedClosure)._tempDeclarations())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._name())._asVariableName();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})));
$recv($recv(anIRInlinedClosure)._instructions())._do_((function(each){
return $core.withContext(function($ctx2) {
return self._visit_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedClosure:",{anIRInlinedClosure:anIRInlinedClosure},$globals.IRInliningJSTranslator)});
},
args: ["anIRInlinedClosure"],
source: "visitIRInlinedClosure: anIRInlinedClosure\x0a\x09self stream nextPutVars: (anIRInlinedClosure tempDeclarations collect: [ :each |\x0a\x09\x09each name asVariableName ]).\x0a\x09anIRInlinedClosure instructions do: [ :each |\x0a\x09\x09self visit: each ]",
referencedClasses: [],
messageSends: ["nextPutVars:", "stream", "collect:", "tempDeclarations", "asVariableName", "name", "do:", "instructions", "visit:"]
}),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedIfFalse:",
protocol: 'visiting',
fn: function (anIRInlinedIfFalse){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutIf_then_((function(){
return $core.withContext(function($ctx2) {
$2=self._stream();
$ctx2.sendIdx["stream"]=2;
$recv($2)._nextPutAll_("!$core.assert(");
$ctx2.sendIdx["nextPutAll:"]=1;
$4=$recv(anIRInlinedIfFalse)._instructions();
$ctx2.sendIdx["instructions"]=1;
$3=$recv($4)._first();
self._visit_($3);
$ctx2.sendIdx["visit:"]=1;
return $recv(self._stream())._nextPutAll_(")");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return self._visit_($recv($recv(anIRInlinedIfFalse)._instructions())._last());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedIfFalse:",{anIRInlinedIfFalse:anIRInlinedIfFalse},$globals.IRInliningJSTranslator)});
},
args: ["anIRInlinedIfFalse"],
source: "visitIRInlinedIfFalse: anIRInlinedIfFalse\x0a\x09self stream nextPutIf: [\x0a\x09\x09self stream nextPutAll: '!$core.assert('.\x0a\x09\x09self visit: anIRInlinedIfFalse instructions first.\x0a\x09\x09self stream nextPutAll: ')' ]\x0a\x09\x09then: [ self visit: anIRInlinedIfFalse instructions last ]",
referencedClasses: [],
messageSends: ["nextPutIf:then:", "stream", "nextPutAll:", "visit:", "first", "instructions", "last"]
}),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedIfNilIfNotNil:",
protocol: 'visiting',
fn: function (anIRInlinedIfNilIfNotNil){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3,$6,$5,$7,$8,$10,$9;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutIf_then_else_((function(){
var recvVarName;
return $core.withContext(function($ctx2) {
recvVarName=$recv(anIRInlinedIfNilIfNotNil)._receiverInternalVariableName();
recvVarName;
$2=self._stream();
$ctx2.sendIdx["stream"]=2;
$4="(".__comma(recvVarName);
$ctx2.sendIdx[","]=2;
$3=$recv($4).__comma(" = ");
$ctx2.sendIdx[","]=1;
$recv($2)._nextPutAll_($3);
$ctx2.sendIdx["nextPutAll:"]=1;
$6=$recv(anIRInlinedIfNilIfNotNil)._instructions();
$ctx2.sendIdx["instructions"]=1;
$5=$recv($6)._first();
self._visit_($5);
$ctx2.sendIdx["visit:"]=1;
$7=self._stream();
$8=$recv(") == null || ".__comma(recvVarName)).__comma(".isNil");
$ctx2.sendIdx[","]=3;
return $recv($7)._nextPutAll_($8);
}, function($ctx2) {$ctx2.fillBlock({recvVarName:recvVarName},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
$10=$recv(anIRInlinedIfNilIfNotNil)._instructions();
$ctx2.sendIdx["instructions"]=2;
$9=$recv($10)._second();
return self._visit_($9);
$ctx2.sendIdx["visit:"]=2;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return self._visit_($recv($recv(anIRInlinedIfNilIfNotNil)._instructions())._third());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedIfNilIfNotNil:",{anIRInlinedIfNilIfNotNil:anIRInlinedIfNilIfNotNil},$globals.IRInliningJSTranslator)});
},
args: ["anIRInlinedIfNilIfNotNil"],
source: "visitIRInlinedIfNilIfNotNil: anIRInlinedIfNilIfNotNil\x0a\x09self stream\x0a\x09\x09nextPutIf: [\x0a\x09\x09\x09| recvVarName |\x0a\x09\x09\x09recvVarName := anIRInlinedIfNilIfNotNil receiverInternalVariableName.\x0a\x09\x09\x09self stream nextPutAll: '(', recvVarName, ' = '.\x0a\x09\x09\x09self visit: anIRInlinedIfNilIfNotNil instructions first.\x0a\x09\x09\x09self stream nextPutAll: ') == null || ', recvVarName, '.isNil' ]\x0a\x09\x09then: [ self visit: anIRInlinedIfNilIfNotNil instructions second ]\x0a\x09\x09else: [ self visit: anIRInlinedIfNilIfNotNil instructions third ]",
referencedClasses: [],
messageSends: ["nextPutIf:then:else:", "stream", "receiverInternalVariableName", "nextPutAll:", ",", "visit:", "first", "instructions", "second", "third"]
}),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedIfTrue:",
protocol: 'visiting',
fn: function (anIRInlinedIfTrue){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutIf_then_((function(){
return $core.withContext(function($ctx2) {
$2=self._stream();
$ctx2.sendIdx["stream"]=2;
$recv($2)._nextPutAll_("$core.assert(");
$ctx2.sendIdx["nextPutAll:"]=1;
$4=$recv(anIRInlinedIfTrue)._instructions();
$ctx2.sendIdx["instructions"]=1;
$3=$recv($4)._first();
self._visit_($3);
$ctx2.sendIdx["visit:"]=1;
return $recv(self._stream())._nextPutAll_(")");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return self._visit_($recv($recv(anIRInlinedIfTrue)._instructions())._last());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedIfTrue:",{anIRInlinedIfTrue:anIRInlinedIfTrue},$globals.IRInliningJSTranslator)});
},
args: ["anIRInlinedIfTrue"],
source: "visitIRInlinedIfTrue: anIRInlinedIfTrue\x0a\x09self stream nextPutIf: [\x0a\x09\x09self stream nextPutAll: '$core.assert('.\x0a\x09\x09self visit: anIRInlinedIfTrue instructions first.\x0a\x09\x09self stream nextPutAll: ')' ]\x0a\x09\x09then: [ self visit: anIRInlinedIfTrue instructions last ]",
referencedClasses: [],
messageSends: ["nextPutIf:then:", "stream", "nextPutAll:", "visit:", "first", "instructions", "last"]
}),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedIfTrueIfFalse:",
protocol: 'visiting',
fn: function (anIRInlinedIfTrueIfFalse){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3,$6,$5;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutIf_then_else_((function(){
return $core.withContext(function($ctx2) {
$2=self._stream();
$ctx2.sendIdx["stream"]=2;
$recv($2)._nextPutAll_("$core.assert(");
$ctx2.sendIdx["nextPutAll:"]=1;
$4=$recv(anIRInlinedIfTrueIfFalse)._instructions();
$ctx2.sendIdx["instructions"]=1;
$3=$recv($4)._first();
self._visit_($3);
$ctx2.sendIdx["visit:"]=1;
return $recv(self._stream())._nextPutAll_(")");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
$6=$recv(anIRInlinedIfTrueIfFalse)._instructions();
$ctx2.sendIdx["instructions"]=2;
$5=$recv($6)._second();
return self._visit_($5);
$ctx2.sendIdx["visit:"]=2;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return self._visit_($recv($recv(anIRInlinedIfTrueIfFalse)._instructions())._third());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedIfTrueIfFalse:",{anIRInlinedIfTrueIfFalse:anIRInlinedIfTrueIfFalse},$globals.IRInliningJSTranslator)});
},
args: ["anIRInlinedIfTrueIfFalse"],
source: "visitIRInlinedIfTrueIfFalse: anIRInlinedIfTrueIfFalse\x0a\x09self stream\x0a\x09\x09nextPutIf: [\x0a\x09\x09\x09self stream nextPutAll: '$core.assert('.\x0a\x09\x09\x09self visit: anIRInlinedIfTrueIfFalse instructions first.\x0a\x09\x09\x09self stream nextPutAll: ')' ]\x0a\x09\x09then: [ self visit: anIRInlinedIfTrueIfFalse instructions second ]\x0a\x09\x09else: [ self visit: anIRInlinedIfTrueIfFalse instructions third ]",
referencedClasses: [],
messageSends: ["nextPutIf:then:else:", "stream", "nextPutAll:", "visit:", "first", "instructions", "second", "third"]
}),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedNonLocalReturn:",
protocol: 'visiting',
fn: function (anIRInlinedReturn){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._stream();
$ctx1.sendIdx["stream"]=1;
$recv($1)._nextPutStatementWith_((function(){
return $core.withContext(function($ctx2) {
return self._visit_($recv($recv(anIRInlinedReturn)._instructions())._last());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(self._stream())._nextPutNonLocalReturnWith_((function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedNonLocalReturn:",{anIRInlinedReturn:anIRInlinedReturn},$globals.IRInliningJSTranslator)});
},
args: ["anIRInlinedReturn"],
source: "visitIRInlinedNonLocalReturn: anIRInlinedReturn\x0a\x09self stream nextPutStatementWith: [\x0a\x09\x09self visit: anIRInlinedReturn instructions last ].\x0a\x09self stream nextPutNonLocalReturnWith: [ ]",
referencedClasses: [],
messageSends: ["nextPutStatementWith:", "stream", "visit:", "last", "instructions", "nextPutNonLocalReturnWith:"]
}),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedReturn:",
protocol: 'visiting',
fn: function (anIRInlinedReturn){
var self=this;
return $core.withContext(function($ctx1) {
self._visit_($recv($recv(anIRInlinedReturn)._instructions())._last());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedReturn:",{anIRInlinedReturn:anIRInlinedReturn},$globals.IRInliningJSTranslator)});
},
args: ["anIRInlinedReturn"],
source: "visitIRInlinedReturn: anIRInlinedReturn\x0a\x09self visit: anIRInlinedReturn instructions last",
referencedClasses: [],
messageSends: ["visit:", "last", "instructions"]
}),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedSequence:",
protocol: 'visiting',
fn: function (anIRInlinedSequence){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(anIRInlinedSequence)._instructions())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(self._stream())._nextPutStatementWith_((function(){
return $core.withContext(function($ctx3) {
return self._visit_(each);
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedSequence:",{anIRInlinedSequence:anIRInlinedSequence},$globals.IRInliningJSTranslator)});
},
args: ["anIRInlinedSequence"],
source: "visitIRInlinedSequence: anIRInlinedSequence\x0a\x09anIRInlinedSequence instructions do: [ :each |\x0a\x09\x09self stream nextPutStatementWith: [ self visit: each ]]",
referencedClasses: [],
messageSends: ["do:", "instructions", "nextPutStatementWith:", "stream", "visit:"]
}),
$globals.IRInliningJSTranslator);



$core.addClass('IRSendInliner', $globals.Object, ['send', 'translator'], 'Compiler-Inlining');
$globals.IRSendInliner.comment="I inline some message sends and block closure arguments. I heavily rely on #perform: to dispatch inlining methods.";
$core.addMethod(
$core.method({
selector: "ifFalse:",
protocol: 'inlining',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
return self._inlinedSend_withBlock_($recv($globals.IRInlinedIfFalse)._new(),anIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifFalse:",{anIRInstruction:anIRInstruction},$globals.IRSendInliner)});
},
args: ["anIRInstruction"],
source: "ifFalse: anIRInstruction\x0a\x09^ self inlinedSend: IRInlinedIfFalse new withBlock: anIRInstruction",
referencedClasses: ["IRInlinedIfFalse"],
messageSends: ["inlinedSend:withBlock:", "new"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifFalse:ifTrue:",
protocol: 'inlining',
fn: function (anIRInstruction,anotherIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
return self._perform_withArguments_("ifTrue:ifFalse:",[anotherIRInstruction,anIRInstruction]);
}, function($ctx1) {$ctx1.fill(self,"ifFalse:ifTrue:",{anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction},$globals.IRSendInliner)});
},
args: ["anIRInstruction", "anotherIRInstruction"],
source: "ifFalse: anIRInstruction ifTrue: anotherIRInstruction\x0a\x09^ self perform: #ifTrue:ifFalse: withArguments: { anotherIRInstruction. anIRInstruction }",
referencedClasses: [],
messageSends: ["perform:withArguments:"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifNil:",
protocol: 'inlining',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$5,$6,$4,$2;
$1=$recv($globals.IRInlinedIfNilIfNotNil)._new();
$ctx1.sendIdx["new"]=1;
$3=$recv($globals.IRClosure)._new();
$ctx1.sendIdx["new"]=2;
$recv($3)._scope_($recv($recv(anIRInstruction)._scope())._copy());
$5=$recv($globals.IRBlockSequence)._new();
$recv($5)._add_($recv($recv(self._send())._instructions())._first());
$6=$recv($5)._yourself();
$ctx1.sendIdx["yourself"]=1;
$4=$6;
$recv($3)._add_($4);
$ctx1.sendIdx["add:"]=1;
$2=$recv($3)._yourself();
return self._inlinedSend_withBlock_withBlock_($1,anIRInstruction,$2);
}, function($ctx1) {$ctx1.fill(self,"ifNil:",{anIRInstruction:anIRInstruction},$globals.IRSendInliner)});
},
args: ["anIRInstruction"],
source: "ifNil: anIRInstruction\x0a\x09^ self\x0a\x09\x09inlinedSend: IRInlinedIfNilIfNotNil new\x0a\x09\x09withBlock: anIRInstruction\x0a\x09\x09withBlock: (IRClosure new\x0a\x09\x09\x09scope: anIRInstruction scope copy;\x0a\x09\x09\x09add: (IRBlockSequence new\x0a\x09\x09\x09\x09add: self send instructions first;\x0a\x09\x09\x09\x09yourself);\x0a\x09\x09\x09yourself)",
referencedClasses: ["IRInlinedIfNilIfNotNil", "IRClosure", "IRBlockSequence"],
messageSends: ["inlinedSend:withBlock:withBlock:", "new", "scope:", "copy", "scope", "add:", "first", "instructions", "send", "yourself"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifNil:ifNotNil:",
protocol: 'inlining',
fn: function (anIRInstruction,anotherIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
return self._inlinedSend_withBlock_withBlock_($recv($globals.IRInlinedIfNilIfNotNil)._new(),anIRInstruction,anotherIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifNil:ifNotNil:",{anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction},$globals.IRSendInliner)});
},
args: ["anIRInstruction", "anotherIRInstruction"],
source: "ifNil: anIRInstruction ifNotNil: anotherIRInstruction\x0a\x09^ self inlinedSend: IRInlinedIfNilIfNotNil new withBlock: anIRInstruction withBlock: anotherIRInstruction",
referencedClasses: ["IRInlinedIfNilIfNotNil"],
messageSends: ["inlinedSend:withBlock:withBlock:", "new"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifNotNil:",
protocol: 'inlining',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$5,$6,$4,$2;
$1=$recv($globals.IRInlinedIfNilIfNotNil)._new();
$ctx1.sendIdx["new"]=1;
$3=$recv($globals.IRClosure)._new();
$ctx1.sendIdx["new"]=2;
$recv($3)._scope_($recv($recv(anIRInstruction)._scope())._copy());
$5=$recv($globals.IRBlockSequence)._new();
$recv($5)._add_($recv($recv(self._send())._instructions())._first());
$6=$recv($5)._yourself();
$ctx1.sendIdx["yourself"]=1;
$4=$6;
$recv($3)._add_($4);
$ctx1.sendIdx["add:"]=1;
$2=$recv($3)._yourself();
return self._inlinedSend_withBlock_withBlock_($1,$2,anIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifNotNil:",{anIRInstruction:anIRInstruction},$globals.IRSendInliner)});
},
args: ["anIRInstruction"],
source: "ifNotNil: anIRInstruction\x0a\x09^ self\x0a\x09\x09inlinedSend: IRInlinedIfNilIfNotNil new\x0a\x09\x09withBlock: (IRClosure new\x0a\x09\x09\x09scope: anIRInstruction scope copy;\x0a\x09\x09\x09add: (IRBlockSequence new\x0a\x09\x09\x09\x09add: self send instructions first;\x0a\x09\x09\x09\x09yourself);\x0a\x09\x09\x09yourself)\x0a\x09\x09withBlock: anIRInstruction",
referencedClasses: ["IRInlinedIfNilIfNotNil", "IRClosure", "IRBlockSequence"],
messageSends: ["inlinedSend:withBlock:withBlock:", "new", "scope:", "copy", "scope", "add:", "first", "instructions", "send", "yourself"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifNotNil:ifNil:",
protocol: 'inlining',
fn: function (anIRInstruction,anotherIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
return self._inlinedSend_withBlock_withBlock_($recv($globals.IRInlinedIfNilIfNotNil)._new(),anotherIRInstruction,anIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifNotNil:ifNil:",{anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction},$globals.IRSendInliner)});
},
args: ["anIRInstruction", "anotherIRInstruction"],
source: "ifNotNil: anIRInstruction ifNil: anotherIRInstruction\x0a\x09^ self inlinedSend: IRInlinedIfNilIfNotNil new withBlock: anotherIRInstruction withBlock: anIRInstruction",
referencedClasses: ["IRInlinedIfNilIfNotNil"],
messageSends: ["inlinedSend:withBlock:withBlock:", "new"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifTrue:",
protocol: 'inlining',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
return self._inlinedSend_withBlock_($recv($globals.IRInlinedIfTrue)._new(),anIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifTrue:",{anIRInstruction:anIRInstruction},$globals.IRSendInliner)});
},
args: ["anIRInstruction"],
source: "ifTrue: anIRInstruction\x0a\x09^ self inlinedSend: IRInlinedIfTrue new withBlock: anIRInstruction",
referencedClasses: ["IRInlinedIfTrue"],
messageSends: ["inlinedSend:withBlock:", "new"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifTrue:ifFalse:",
protocol: 'inlining',
fn: function (anIRInstruction,anotherIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
return self._inlinedSend_withBlock_withBlock_($recv($globals.IRInlinedIfTrueIfFalse)._new(),anIRInstruction,anotherIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifTrue:ifFalse:",{anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction},$globals.IRSendInliner)});
},
args: ["anIRInstruction", "anotherIRInstruction"],
source: "ifTrue: anIRInstruction ifFalse: anotherIRInstruction\x0a\x09^ self inlinedSend: IRInlinedIfTrueIfFalse new withBlock: anIRInstruction withBlock: anotherIRInstruction",
referencedClasses: ["IRInlinedIfTrueIfFalse"],
messageSends: ["inlinedSend:withBlock:withBlock:", "new"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlineClosure:",
protocol: 'inlining',
fn: function (anIRClosure){
var self=this;
var inlinedClosure,sequence,statements;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$6,$4,$7,$9,$11,$13,$14,$15,$12,$10,$17,$19,$20,$18,$16,$8,$22,$21,$25,$24,$26,$23,$27,$30,$29,$28;
inlinedClosure=self._inlinedClosure();
$1=inlinedClosure;
$2=$recv(anIRClosure)._scope();
$ctx1.sendIdx["scope"]=1;
$recv($1)._scope_($2);
$ctx1.sendIdx["scope:"]=1;
$recv($1)._parent_($recv(anIRClosure)._parent());
$recv($recv(anIRClosure)._tempDeclarations())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(inlinedClosure)._add_(each);
$ctx2.sendIdx["add:"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["do:"]=1;
sequence=self._inlinedSequence();
$recv($recv(anIRClosure)._arguments())._do_((function(each){
return $core.withContext(function($ctx2) {
$3=inlinedClosure;
$5=$recv($globals.IRTempDeclaration)._new();
$ctx2.sendIdx["new"]=1;
$recv($5)._name_(each);
$ctx2.sendIdx["name:"]=1;
$6=$recv($5)._yourself();
$ctx2.sendIdx["yourself"]=1;
$4=$6;
$recv($3)._add_($4);
$ctx2.sendIdx["add:"]=2;
$7=sequence;
$9=$recv($globals.IRAssignment)._new();
$ctx2.sendIdx["new"]=2;
$11=$recv($globals.IRVariable)._new();
$ctx2.sendIdx["new"]=3;
$13=$recv($globals.AliasVar)._new();
$ctx2.sendIdx["new"]=4;
$14=$recv(inlinedClosure)._scope();
$ctx2.sendIdx["scope"]=2;
$recv($13)._scope_($14);
$ctx2.sendIdx["scope:"]=2;
$recv($13)._name_(each);
$ctx2.sendIdx["name:"]=2;
$15=$recv($13)._yourself();
$ctx2.sendIdx["yourself"]=2;
$12=$15;
$10=$recv($11)._variable_($12);
$ctx2.sendIdx["variable:"]=1;
$recv($9)._add_($10);
$ctx2.sendIdx["add:"]=4;
$17=$recv($globals.IRVariable)._new();
$ctx2.sendIdx["new"]=5;
$19=$recv($globals.AliasVar)._new();
$recv($19)._scope_($recv(inlinedClosure)._scope());
$recv($19)._name_("$receiver");
$20=$recv($19)._yourself();
$ctx2.sendIdx["yourself"]=3;
$18=$20;
$16=$recv($17)._variable_($18);
$recv($9)._add_($16);
$ctx2.sendIdx["add:"]=5;
$8=$recv($9)._yourself();
return $recv($7)._add_($8);
$ctx2.sendIdx["add:"]=3;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
$ctx1.sendIdx["do:"]=2;
$recv(inlinedClosure)._add_(sequence);
$ctx1.sendIdx["add:"]=6;
$22=$recv(anIRClosure)._instructions();
$ctx1.sendIdx["instructions"]=2;
$21=$recv($22)._last();
$ctx1.sendIdx["last"]=1;
statements=$recv($21)._instructions();
$ctx1.sendIdx["instructions"]=1;
$recv(statements)._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
$recv($recv(statements)._allButLast())._do_((function(each){
return $core.withContext(function($ctx3) {
return $recv(sequence)._add_(each);
$ctx3.sendIdx["add:"]=7;
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,4)});
}));
$25=$recv(statements)._last();
$ctx2.sendIdx["last"]=2;
$24=$recv($25)._isReturn();
$23=$recv($24)._and_((function(){
return $core.withContext(function($ctx3) {
$26=$recv(statements)._last();
$ctx3.sendIdx["last"]=3;
return $recv($26)._isBlockReturn();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,5)});
}));
if($core.assert($23)){
$27=sequence;
$30=$recv(statements)._last();
$ctx2.sendIdx["last"]=4;
$29=$recv($30)._instructions();
$28=$recv($29)._first();
return $recv($27)._add_($28);
$ctx2.sendIdx["add:"]=8;
} else {
return $recv(sequence)._add_($recv(statements)._last());
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return inlinedClosure;
}, function($ctx1) {$ctx1.fill(self,"inlineClosure:",{anIRClosure:anIRClosure,inlinedClosure:inlinedClosure,sequence:sequence,statements:statements},$globals.IRSendInliner)});
},
args: ["anIRClosure"],
source: "inlineClosure: anIRClosure\x0a\x09| inlinedClosure sequence statements |\x0a\x0a\x09inlinedClosure := self inlinedClosure.\x0a\x09inlinedClosure \x0a\x09\x09scope: anIRClosure scope;\x0a\x09\x09parent: anIRClosure parent.\x0a\x0a\x09\x22Add the possible temp declarations\x22\x0a\x09anIRClosure tempDeclarations do: [ :each |\x0a\x09\x09\x09inlinedClosure add: each ].\x0a\x0a\x09\x22Add a block sequence\x22\x0a\x09sequence := self inlinedSequence.\x0a\x0a\x09\x22Map the closure arguments to the receiver of the message send\x22\x0a\x09anIRClosure arguments do: [ :each |\x0a\x09\x09inlinedClosure add: (IRTempDeclaration new name: each; yourself).\x0a\x09\x09sequence add: (IRAssignment new\x0a\x09\x09\x09add: (IRVariable new variable: (AliasVar new scope: inlinedClosure scope; name: each; yourself));\x0a\x09\x09\x09add: (IRVariable new variable: (AliasVar new scope: inlinedClosure scope; name: '$receiver'; yourself));\x0a\x09\x09\x09yourself) ].\x0a\x09\x09\x09\x0a\x09\x22To ensure the correct order of the closure instructions: first the temps then the sequence\x22\x0a\x09inlinedClosure add: sequence.\x0a\x0a\x09\x22Get all the statements\x22\x0a\x09statements := anIRClosure instructions last instructions.\x0a\x09\x0a\x09statements ifNotEmpty: [\x0a\x09\x09statements allButLast do: [ :each | sequence add: each ].\x0a\x0a\x09\x09\x22Inlined closures don't have implicit local returns\x22\x0a\x09\x09(statements last isReturn and: [ statements last isBlockReturn ])\x0a\x09\x09\x09ifTrue: [ sequence add: statements last instructions first ]\x0a\x09\x09\x09ifFalse: [ sequence add: statements last ] ].\x0a\x0a\x09^ inlinedClosure",
referencedClasses: ["IRTempDeclaration", "IRAssignment", "IRVariable", "AliasVar"],
messageSends: ["inlinedClosure", "scope:", "scope", "parent:", "parent", "do:", "tempDeclarations", "add:", "inlinedSequence", "arguments", "name:", "new", "yourself", "variable:", "instructions", "last", "ifNotEmpty:", "allButLast", "ifTrue:ifFalse:", "and:", "isReturn", "isBlockReturn", "first"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlineSend:",
protocol: 'inlining',
fn: function (anIRSend){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
self._send_(anIRSend);
$2=self._send();
$ctx1.sendIdx["send"]=1;
$1=$recv($2)._selector();
return self._perform_withArguments_($1,$recv($recv(self._send())._instructions())._allButFirst());
}, function($ctx1) {$ctx1.fill(self,"inlineSend:",{anIRSend:anIRSend},$globals.IRSendInliner)});
},
args: ["anIRSend"],
source: "inlineSend: anIRSend\x0a\x09self send: anIRSend.\x0a\x09^ self\x0a\x09\x09perform: self send selector\x0a\x09\x09withArguments: self send instructions allButFirst",
referencedClasses: [],
messageSends: ["send:", "perform:withArguments:", "selector", "send", "allButFirst", "instructions"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlinedClosure",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.IRInlinedClosure)._new();
}, function($ctx1) {$ctx1.fill(self,"inlinedClosure",{},$globals.IRSendInliner)});
},
args: [],
source: "inlinedClosure\x0a\x09^ IRInlinedClosure new",
referencedClasses: ["IRInlinedClosure"],
messageSends: ["new"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlinedSend:withBlock:",
protocol: 'inlining',
fn: function (inlinedSend,anIRInstruction){
var self=this;
var inlinedClosure;
return $core.withContext(function($ctx1) {
var $1,$2,$5,$4,$3,$6;
$1=$recv(anIRInstruction)._isClosure();
if(!$core.assert($1)){
self._inliningError_("Message argument should be a block");
$ctx1.sendIdx["inliningError:"]=1;
};
$2=$recv($recv($recv(anIRInstruction)._arguments())._size()).__eq((0));
if(!$core.assert($2)){
self._inliningError_("Inlined block should have zero argument");
};
inlinedClosure=$recv(self._translator())._visit_(self._inlineClosure_(anIRInstruction));
$5=self._send();
$ctx1.sendIdx["send"]=1;
$4=$recv($5)._instructions();
$3=$recv($4)._first();
$recv(inlinedSend)._add_($3);
$ctx1.sendIdx["add:"]=1;
$recv(inlinedSend)._add_(inlinedClosure);
$recv(self._send())._replaceWith_(inlinedSend);
$6=$recv($recv(inlinedSend)._method())._internalVariables();
$ctx1.sendIdx["internalVariables"]=1;
$recv($6)._addAll_($recv(inlinedSend)._internalVariables());
return inlinedSend;
}, function($ctx1) {$ctx1.fill(self,"inlinedSend:withBlock:",{inlinedSend:inlinedSend,anIRInstruction:anIRInstruction,inlinedClosure:inlinedClosure},$globals.IRSendInliner)});
},
args: ["inlinedSend", "anIRInstruction"],
source: "inlinedSend: inlinedSend withBlock: anIRInstruction\x0a\x09| inlinedClosure |\x0a\x0a\x09anIRInstruction isClosure ifFalse: [ self inliningError: 'Message argument should be a block' ].\x0a\x09anIRInstruction arguments size = 0 ifFalse: [ self inliningError: 'Inlined block should have zero argument' ].\x0a\x0a\x09inlinedClosure := self translator visit: (self inlineClosure: anIRInstruction).\x0a\x0a\x09inlinedSend\x0a\x09\x09add: self send instructions first;\x0a\x09\x09add: inlinedClosure.\x0a\x0a\x09self send replaceWith: inlinedSend.\x0a\x09inlinedSend method internalVariables \x0a\x09\x09addAll: inlinedSend internalVariables.\x0a\x0a\x09^ inlinedSend",
referencedClasses: [],
messageSends: ["ifFalse:", "isClosure", "inliningError:", "=", "size", "arguments", "visit:", "translator", "inlineClosure:", "add:", "first", "instructions", "send", "replaceWith:", "addAll:", "internalVariables", "method"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlinedSend:withBlock:withBlock:",
protocol: 'inlining',
fn: function (inlinedSend,anIRInstruction,anotherIRInstruction){
var self=this;
var inlinedClosure1,inlinedClosure2;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$7,$6,$5,$8;
$1=$recv(anIRInstruction)._isClosure();
$ctx1.sendIdx["isClosure"]=1;
if(!$core.assert($1)){
self._inliningError_("Message argument should be a block");
$ctx1.sendIdx["inliningError:"]=1;
};
$2=$recv(anotherIRInstruction)._isClosure();
if(!$core.assert($2)){
self._inliningError_("Message argument should be a block");
};
$3=self._translator();
$ctx1.sendIdx["translator"]=1;
$4=self._inlineClosure_(anIRInstruction);
$ctx1.sendIdx["inlineClosure:"]=1;
inlinedClosure1=$recv($3)._visit_($4);
$ctx1.sendIdx["visit:"]=1;
inlinedClosure2=$recv(self._translator())._visit_(self._inlineClosure_(anotherIRInstruction));
$7=self._send();
$ctx1.sendIdx["send"]=1;
$6=$recv($7)._instructions();
$5=$recv($6)._first();
$recv(inlinedSend)._add_($5);
$ctx1.sendIdx["add:"]=1;
$recv(inlinedSend)._add_(inlinedClosure1);
$ctx1.sendIdx["add:"]=2;
$recv(inlinedSend)._add_(inlinedClosure2);
$recv(self._send())._replaceWith_(inlinedSend);
$8=$recv($recv(inlinedSend)._method())._internalVariables();
$ctx1.sendIdx["internalVariables"]=1;
$recv($8)._addAll_($recv(inlinedSend)._internalVariables());
return inlinedSend;
}, function($ctx1) {$ctx1.fill(self,"inlinedSend:withBlock:withBlock:",{inlinedSend:inlinedSend,anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction,inlinedClosure1:inlinedClosure1,inlinedClosure2:inlinedClosure2},$globals.IRSendInliner)});
},
args: ["inlinedSend", "anIRInstruction", "anotherIRInstruction"],
source: "inlinedSend: inlinedSend withBlock: anIRInstruction withBlock: anotherIRInstruction\x0a\x09| inlinedClosure1 inlinedClosure2 |\x0a\x0a\x09anIRInstruction isClosure ifFalse: [ self inliningError: 'Message argument should be a block' ].\x0a\x09anotherIRInstruction isClosure ifFalse: [ self inliningError: 'Message argument should be a block' ].\x0a\x0a\x09inlinedClosure1 := self translator visit: (self inlineClosure: anIRInstruction).\x0a\x09inlinedClosure2 := self translator visit: (self inlineClosure: anotherIRInstruction).\x0a\x0a\x09inlinedSend\x0a\x09\x09add: self send instructions first;\x0a\x09\x09add: inlinedClosure1;\x0a\x09\x09add: inlinedClosure2.\x0a\x0a\x09self send replaceWith: inlinedSend.\x0a\x09inlinedSend method internalVariables \x0a\x09\x09addAll: inlinedSend internalVariables.\x0a\x09\x09\x0a\x09^ inlinedSend",
referencedClasses: [],
messageSends: ["ifFalse:", "isClosure", "inliningError:", "visit:", "translator", "inlineClosure:", "add:", "first", "instructions", "send", "replaceWith:", "addAll:", "internalVariables", "method"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlinedSequence",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.IRInlinedSequence)._new();
}, function($ctx1) {$ctx1.fill(self,"inlinedSequence",{},$globals.IRSendInliner)});
},
args: [],
source: "inlinedSequence\x0a\x09^ IRInlinedSequence new",
referencedClasses: ["IRInlinedSequence"],
messageSends: ["new"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inliningError:",
protocol: 'error handling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.InliningError)._signal_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"inliningError:",{aString:aString},$globals.IRSendInliner)});
},
args: ["aString"],
source: "inliningError: aString\x0a\x09InliningError signal: aString",
referencedClasses: ["InliningError"],
messageSends: ["signal:"]
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "send",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@send"];

},
args: [],
source: "send\x0a\x09^ send",
referencedClasses: [],
messageSends: []
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "send:",
protocol: 'accessing',
fn: function (anIRSend){
var self=this;
self["@send"]=anIRSend;
return self;

},
args: ["anIRSend"],
source: "send: anIRSend\x0a\x09send := anIRSend",
referencedClasses: [],
messageSends: []
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "translator",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@translator"];

},
args: [],
source: "translator\x0a\x09^ translator",
referencedClasses: [],
messageSends: []
}),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "translator:",
protocol: 'accessing',
fn: function (anASTTranslator){
var self=this;
self["@translator"]=anASTTranslator;
return self;

},
args: ["anASTTranslator"],
source: "translator: anASTTranslator\x0a\x09translator := anASTTranslator",
referencedClasses: [],
messageSends: []
}),
$globals.IRSendInliner);


$core.addMethod(
$core.method({
selector: "inlinedSelectors",
protocol: 'accessing',
fn: function (){
var self=this;
return ["ifTrue:", "ifFalse:", "ifTrue:ifFalse:", "ifFalse:ifTrue:", "ifNil:", "ifNotNil:", "ifNil:ifNotNil:", "ifNotNil:ifNil:"];

},
args: [],
source: "inlinedSelectors\x0a\x09^ #('ifTrue:' 'ifFalse:' 'ifTrue:ifFalse:' 'ifFalse:ifTrue:' 'ifNil:' 'ifNotNil:' 'ifNil:ifNotNil:' 'ifNotNil:ifNil:')",
referencedClasses: [],
messageSends: []
}),
$globals.IRSendInliner.klass);

$core.addMethod(
$core.method({
selector: "shouldInline:",
protocol: 'accessing',
fn: function (anIRInstruction){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self._inlinedSelectors())._includes_($recv(anIRInstruction)._selector());
if(!$core.assert($1)){
return false;
};
return $recv($recv($recv(anIRInstruction)._instructions())._allButFirst())._allSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._isClosure();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"shouldInline:",{anIRInstruction:anIRInstruction},$globals.IRSendInliner.klass)});
},
args: ["anIRInstruction"],
source: "shouldInline: anIRInstruction\x0a\x09(self inlinedSelectors includes: anIRInstruction selector) ifFalse: [ ^ false ].\x0a\x09^ anIRInstruction instructions allButFirst allSatisfy: [ :each | each isClosure]",
referencedClasses: [],
messageSends: ["ifFalse:", "includes:", "inlinedSelectors", "selector", "allSatisfy:", "allButFirst", "instructions", "isClosure"]
}),
$globals.IRSendInliner.klass);


$core.addClass('IRAssignmentInliner', $globals.IRSendInliner, ['assignment'], 'Compiler-Inlining');
$globals.IRAssignmentInliner.comment="I inline message sends together with assignments by moving them around into the inline closure instructions.\x0a\x0a##Example\x0a\x0a\x09foo\x0a\x09\x09| a |\x0a\x09\x09a := true ifTrue: [ 1 ]\x0a\x0aWill produce:\x0a\x0a\x09if($core.assert(true) {\x0a\x09\x09a = 1;\x0a\x09};";
$core.addMethod(
$core.method({
selector: "assignment",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@assignment"];

},
args: [],
source: "assignment\x0a\x09^ assignment",
referencedClasses: [],
messageSends: []
}),
$globals.IRAssignmentInliner);

$core.addMethod(
$core.method({
selector: "assignment:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
self["@assignment"]=aNode;
return self;

},
args: ["aNode"],
source: "assignment: aNode\x0a\x09assignment := aNode",
referencedClasses: [],
messageSends: []
}),
$globals.IRAssignmentInliner);

$core.addMethod(
$core.method({
selector: "inlineAssignment:",
protocol: 'inlining',
fn: function (anIRAssignment){
var self=this;
var inlinedAssignment;
return $core.withContext(function($ctx1) {
var $1;
self._assignment_(anIRAssignment);
inlinedAssignment=$recv($globals.IRInlinedAssignment)._new();
$1=$recv(anIRAssignment)._instructions();
$ctx1.sendIdx["instructions"]=1;
$recv($1)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(inlinedAssignment)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$recv(anIRAssignment)._replaceWith_(inlinedAssignment);
self._inlineSend_($recv($recv(inlinedAssignment)._instructions())._last());
return inlinedAssignment;
}, function($ctx1) {$ctx1.fill(self,"inlineAssignment:",{anIRAssignment:anIRAssignment,inlinedAssignment:inlinedAssignment},$globals.IRAssignmentInliner)});
},
args: ["anIRAssignment"],
source: "inlineAssignment: anIRAssignment\x0a\x09| inlinedAssignment |\x0a\x09self assignment: anIRAssignment.\x0a\x09inlinedAssignment := IRInlinedAssignment new.\x0a\x09anIRAssignment instructions do: [ :each |\x0a\x09\x09inlinedAssignment add: each ].\x0a\x09anIRAssignment replaceWith: inlinedAssignment.\x0a\x09self inlineSend: inlinedAssignment instructions last.\x0a\x09^ inlinedAssignment",
referencedClasses: ["IRInlinedAssignment"],
messageSends: ["assignment:", "new", "do:", "instructions", "add:", "replaceWith:", "inlineSend:", "last"]
}),
$globals.IRAssignmentInliner);

$core.addMethod(
$core.method({
selector: "inlineClosure:",
protocol: 'inlining',
fn: function (anIRClosure){
var self=this;
var inlinedClosure,statements;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$5,$7,$6;
inlinedClosure=(
$ctx1.supercall = true,
($globals.IRAssignmentInliner.superclass||$boot.dnu).fn.prototype._inlineClosure_.apply($recv(self), [anIRClosure]));
$ctx1.supercall = false;
$2=$recv(inlinedClosure)._instructions();
$ctx1.sendIdx["instructions"]=2;
$1=$recv($2)._last();
$ctx1.sendIdx["last"]=1;
statements=$recv($1)._instructions();
$ctx1.sendIdx["instructions"]=1;
$recv(statements)._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
$4=$recv(statements)._last();
$ctx2.sendIdx["last"]=2;
$3=$recv($4)._canBeAssigned();
if($core.assert($3)){
$5=$recv(statements)._last();
$ctx2.sendIdx["last"]=3;
$7=$recv($globals.IRAssignment)._new();
$recv($7)._add_($recv($recv(self._assignment())._instructions())._first());
$ctx2.sendIdx["add:"]=1;
$recv($7)._add_($recv($recv(statements)._last())._copy());
$6=$recv($7)._yourself();
return $recv($5)._replaceWith_($6);
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return inlinedClosure;
}, function($ctx1) {$ctx1.fill(self,"inlineClosure:",{anIRClosure:anIRClosure,inlinedClosure:inlinedClosure,statements:statements},$globals.IRAssignmentInliner)});
},
args: ["anIRClosure"],
source: "inlineClosure: anIRClosure\x0a\x09| inlinedClosure statements |\x0a\x0a\x09inlinedClosure := super inlineClosure: anIRClosure.\x0a\x09statements := inlinedClosure instructions last instructions.\x0a\x09\x0a\x09statements ifNotEmpty: [\x0a\x09\x09statements last canBeAssigned ifTrue: [\x0a\x09\x09\x09statements last replaceWith: (IRAssignment new\x0a\x09\x09\x09\x09add: self assignment instructions first;\x0a\x09\x09\x09\x09add: statements last copy;\x0a\x09\x09\x09\x09yourself) ] ].\x0a\x0a\x09^ inlinedClosure",
referencedClasses: ["IRAssignment"],
messageSends: ["inlineClosure:", "instructions", "last", "ifNotEmpty:", "ifTrue:", "canBeAssigned", "replaceWith:", "add:", "new", "first", "assignment", "copy", "yourself"]
}),
$globals.IRAssignmentInliner);



$core.addClass('IRReturnInliner', $globals.IRSendInliner, [], 'Compiler-Inlining');
$globals.IRReturnInliner.comment="I inline message sends with inlined closure together with a return instruction.";
$core.addMethod(
$core.method({
selector: "inlineClosure:",
protocol: 'inlining',
fn: function (anIRClosure){
var self=this;
var closure,statements;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$4,$6,$5;
closure=(
$ctx1.supercall = true,
($globals.IRReturnInliner.superclass||$boot.dnu).fn.prototype._inlineClosure_.apply($recv(self), [anIRClosure]));
$ctx1.supercall = false;
$1=$recv($recv(closure)._instructions())._last();
$ctx1.sendIdx["last"]=1;
statements=$recv($1)._instructions();
$ctx1.sendIdx["instructions"]=1;
$recv(statements)._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
$3=$recv(statements)._last();
$ctx2.sendIdx["last"]=2;
$2=$recv($3)._isReturn();
if(!$core.assert($2)){
$4=$recv(statements)._last();
$ctx2.sendIdx["last"]=3;
$6=$recv($globals.IRReturn)._new();
$recv($6)._add_($recv($recv(statements)._last())._copy());
$5=$recv($6)._yourself();
return $recv($4)._replaceWith_($5);
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return closure;
}, function($ctx1) {$ctx1.fill(self,"inlineClosure:",{anIRClosure:anIRClosure,closure:closure,statements:statements},$globals.IRReturnInliner)});
},
args: ["anIRClosure"],
source: "inlineClosure: anIRClosure\x0a\x09| closure statements |\x0a\x0a\x09closure := super inlineClosure: anIRClosure.\x0a\x09statements := closure instructions last instructions.\x0a\x09\x0a\x09statements ifNotEmpty: [\x0a\x09\x09statements last isReturn\x0a\x09\x09\x09ifFalse: [ statements last replaceWith: (IRReturn new\x0a\x09\x09\x09\x09add: statements last copy;\x0a\x09\x09\x09\x09yourself)] ].\x0a\x0a\x09^ closure",
referencedClasses: ["IRReturn"],
messageSends: ["inlineClosure:", "instructions", "last", "ifNotEmpty:", "ifFalse:", "isReturn", "replaceWith:", "add:", "new", "copy", "yourself"]
}),
$globals.IRReturnInliner);

$core.addMethod(
$core.method({
selector: "inlineReturn:",
protocol: 'inlining',
fn: function (anIRReturn){
var self=this;
var return_;
return $core.withContext(function($ctx1) {
var $1;
return_=self._inlinedReturn();
$1=$recv(anIRReturn)._instructions();
$ctx1.sendIdx["instructions"]=1;
$recv($1)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(return_)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$recv(anIRReturn)._replaceWith_(return_);
self._inlineSend_($recv($recv(return_)._instructions())._last());
return return_;
}, function($ctx1) {$ctx1.fill(self,"inlineReturn:",{anIRReturn:anIRReturn,return_:return_},$globals.IRReturnInliner)});
},
args: ["anIRReturn"],
source: "inlineReturn: anIRReturn\x0a\x09| return |\x0a\x09return := self inlinedReturn.\x0a\x09anIRReturn instructions do: [ :each |\x0a\x09\x09return add: each ].\x0a\x09anIRReturn replaceWith: return.\x0a\x09self inlineSend: return instructions last.\x0a\x09^ return",
referencedClasses: [],
messageSends: ["inlinedReturn", "do:", "instructions", "add:", "replaceWith:", "inlineSend:", "last"]
}),
$globals.IRReturnInliner);

$core.addMethod(
$core.method({
selector: "inlinedReturn",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.IRInlinedReturn)._new();
}, function($ctx1) {$ctx1.fill(self,"inlinedReturn",{},$globals.IRReturnInliner)});
},
args: [],
source: "inlinedReturn\x0a\x09^ IRInlinedReturn new",
referencedClasses: ["IRInlinedReturn"],
messageSends: ["new"]
}),
$globals.IRReturnInliner);



$core.addClass('InliningCodeGenerator', $globals.CodeGenerator, [], 'Compiler-Inlining');
$globals.InliningCodeGenerator.comment="I am a specialized code generator that uses inlining to produce more optimized JavaScript output";
$core.addMethod(
$core.method({
selector: "compileNode:",
protocol: 'compiling',
fn: function (aNode){
var self=this;
var ir,stream;
return $core.withContext(function($ctx1) {
var $1;
$recv(self._semanticAnalyzer())._visit_(aNode);
$ctx1.sendIdx["visit:"]=1;
ir=$recv(self._translator())._visit_(aNode);
$ctx1.sendIdx["visit:"]=2;
$recv(self._inliner())._visit_(ir);
$ctx1.sendIdx["visit:"]=3;
$1=self._irTranslator();
$recv($1)._currentClass_(self._currentClass());
$recv($1)._visit_(ir);
return $recv($1)._contents();
}, function($ctx1) {$ctx1.fill(self,"compileNode:",{aNode:aNode,ir:ir,stream:stream},$globals.InliningCodeGenerator)});
},
args: ["aNode"],
source: "compileNode: aNode\x0a\x09| ir stream |\x0a\x0a\x09self semanticAnalyzer visit: aNode.\x0a\x09ir := self translator visit: aNode.\x0a\x09self inliner visit: ir.\x0a\x0a\x09^ self irTranslator\x0a\x09\x09currentClass: self currentClass;\x0a\x09\x09visit: ir;\x0a\x09\x09contents",
referencedClasses: [],
messageSends: ["visit:", "semanticAnalyzer", "translator", "inliner", "currentClass:", "irTranslator", "currentClass", "contents"]
}),
$globals.InliningCodeGenerator);

$core.addMethod(
$core.method({
selector: "inliner",
protocol: 'compiling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.IRInliner)._new();
}, function($ctx1) {$ctx1.fill(self,"inliner",{},$globals.InliningCodeGenerator)});
},
args: [],
source: "inliner\x0a\x09^ IRInliner new",
referencedClasses: ["IRInliner"],
messageSends: ["new"]
}),
$globals.InliningCodeGenerator);

$core.addMethod(
$core.method({
selector: "irTranslator",
protocol: 'compiling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.IRInliningJSTranslator)._new();
}, function($ctx1) {$ctx1.fill(self,"irTranslator",{},$globals.InliningCodeGenerator)});
},
args: [],
source: "irTranslator\x0a\x09^ IRInliningJSTranslator new",
referencedClasses: ["IRInliningJSTranslator"],
messageSends: ["new"]
}),
$globals.InliningCodeGenerator);



$core.addClass('InliningError', $globals.SemanticError, [], 'Compiler-Inlining');
$globals.InliningError.comment="Instances of InliningError are signaled when using an `InliningCodeGenerator`in a `Compiler`.";

});

define("amber_core/Compiler-Interpreter", ["amber/boot", "amber_core/Kernel-Methods", "amber_core/Compiler-Semantic", "amber_core/Kernel-Objects", "amber_core/Compiler-AST", "amber_core/Kernel-Exceptions"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Compiler-Interpreter');
$core.packages["Compiler-Interpreter"].innerEval = function (expr) { return eval(expr); };
$core.packages["Compiler-Interpreter"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('AIBlockClosure', $globals.BlockClosure, ['node', 'outerContext'], 'Compiler-Interpreter');
$globals.AIBlockClosure.comment="I am a special `BlockClosure` subclass used by an interpreter to interpret a block node.\x0a\x0aWhile I am polymorphic with `BlockClosure`, some methods such as `#new` will raise interpretation errors. Unlike a `BlockClosure`, my instance are not JavaScript functions.\x0a\x0aEvaluating an instance will result in interpreting the `node` instance variable (instance of `BlockNode`).";
$core.addMethod(
$core.method({
selector: "applyTo:arguments:",
protocol: 'evaluating',
fn: function (anObject,aCollection){
var self=this;
return $core.withContext(function($ctx1) {
self._interpreterError();
return self;
}, function($ctx1) {$ctx1.fill(self,"applyTo:arguments:",{anObject:anObject,aCollection:aCollection},$globals.AIBlockClosure)});
},
args: ["anObject", "aCollection"],
source: "applyTo: anObject arguments: aCollection\x0a\x09self interpreterError",
referencedClasses: [],
messageSends: ["interpreterError"]
}),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "compiledSource",
protocol: 'accessing',
fn: function (){
var self=this;
return "[ AST Block closure ]";

},
args: [],
source: "compiledSource\x0a\x09\x22Unlike blocks, the receiver doesn't represent a JS function\x22\x0a\x09\x0a\x09^ '[ AST Block closure ]'",
referencedClasses: [],
messageSends: []
}),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "currySelf",
protocol: 'converting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._interpreterError();
return self;
}, function($ctx1) {$ctx1.fill(self,"currySelf",{},$globals.AIBlockClosure)});
},
args: [],
source: "currySelf\x0a\x09self interpreterError",
referencedClasses: [],
messageSends: ["interpreterError"]
}),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "initializeWithContext:node:",
protocol: 'initialization',
fn: function (aContext,aNode){
var self=this;
self["@node"]=aNode;
self["@outerContext"]=aContext;
return self;

},
args: ["aContext", "aNode"],
source: "initializeWithContext: aContext node: aNode\x0a\x09node := aNode.\x0a\x09outerContext := aContext",
referencedClasses: [],
messageSends: []
}),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "interpreterError",
protocol: 'error handling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ASTInterpreterError)._signal_("Method cannot be interpreted by the interpreter.");
return self;
}, function($ctx1) {$ctx1.fill(self,"interpreterError",{},$globals.AIBlockClosure)});
},
args: [],
source: "interpreterError\x0a\x09ASTInterpreterError signal: 'Method cannot be interpreted by the interpreter.'",
referencedClasses: ["ASTInterpreterError"],
messageSends: ["signal:"]
}),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "numArgs",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self["@node"])._temps())._size();
}, function($ctx1) {$ctx1.fill(self,"numArgs",{},$globals.AIBlockClosure)});
},
args: [],
source: "numArgs\x0a\x09^ node temps size",
referencedClasses: [],
messageSends: ["size", "temps"]
}),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "value",
protocol: 'evaluating',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._valueWithPossibleArguments_([]);
}, function($ctx1) {$ctx1.fill(self,"value",{},$globals.AIBlockClosure)});
},
args: [],
source: "value\x0a\x09^ self valueWithPossibleArguments: #()",
referencedClasses: [],
messageSends: ["valueWithPossibleArguments:"]
}),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "value:",
protocol: 'evaluating',
fn: function (anArgument){
var self=this;
return $core.withContext(function($ctx1) {
return self._valueWithPossibleArguments_([anArgument]);
}, function($ctx1) {$ctx1.fill(self,"value:",{anArgument:anArgument},$globals.AIBlockClosure)});
},
args: ["anArgument"],
source: "value: anArgument\x0a\x09^ self valueWithPossibleArguments: {anArgument}",
referencedClasses: [],
messageSends: ["valueWithPossibleArguments:"]
}),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "value:value:",
protocol: 'evaluating',
fn: function (firstArgument,secondArgument){
var self=this;
return $core.withContext(function($ctx1) {
return self._valueWithPossibleArguments_([firstArgument,secondArgument]);
}, function($ctx1) {$ctx1.fill(self,"value:value:",{firstArgument:firstArgument,secondArgument:secondArgument},$globals.AIBlockClosure)});
},
args: ["firstArgument", "secondArgument"],
source: "value: firstArgument value: secondArgument\x0a\x09^ self valueWithPossibleArguments: {firstArgument . secondArgument}",
referencedClasses: [],
messageSends: ["valueWithPossibleArguments:"]
}),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "value:value:value:",
protocol: 'evaluating',
fn: function (firstArgument,secondArgument,thirdArgument){
var self=this;
return $core.withContext(function($ctx1) {
return self._valueWithPossibleArguments_([firstArgument,secondArgument,thirdArgument]);
}, function($ctx1) {$ctx1.fill(self,"value:value:value:",{firstArgument:firstArgument,secondArgument:secondArgument,thirdArgument:thirdArgument},$globals.AIBlockClosure)});
},
args: ["firstArgument", "secondArgument", "thirdArgument"],
source: "value: firstArgument value: secondArgument value: thirdArgument\x0a\x09^ self valueWithPossibleArguments: {firstArgument . secondArgument . thirdArgument}",
referencedClasses: [],
messageSends: ["valueWithPossibleArguments:"]
}),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "valueWithPossibleArguments:",
protocol: 'evaluating',
fn: function (aCollection){
var self=this;
var context,sequenceNode;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
context=$recv(self["@outerContext"])._newInnerContext();
$1=$recv($recv($recv(self["@node"])._nodes())._first())._copy();
$recv($1)._parent_(nil);
sequenceNode=$recv($1)._yourself();
$recv($recv(sequenceNode)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(context)._defineLocal_(each);
$ctx2.sendIdx["defineLocal:"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$recv($recv(self["@node"])._parameters())._withIndexDo_((function(each,index){
return $core.withContext(function($ctx2) {
$recv(context)._defineLocal_(each);
return $recv(context)._localAt_put_(each,$recv(aCollection)._at_ifAbsent_(index,(function(){
return nil;

})));
}, function($ctx2) {$ctx2.fillBlock({each:each,index:index},$ctx1,2)});
}));
$2=$recv(context)._interpreter();
$ctx1.sendIdx["interpreter"]=1;
$recv($2)._node_(sequenceNode);
$recv($2)._enterNode();
$recv($2)._proceed();
$3=$recv(self["@outerContext"])._interpreter();
$ctx1.sendIdx["interpreter"]=2;
$recv($3)._setNonLocalReturnFromContext_(context);
return $recv($recv(context)._interpreter())._pop();
}, function($ctx1) {$ctx1.fill(self,"valueWithPossibleArguments:",{aCollection:aCollection,context:context,sequenceNode:sequenceNode},$globals.AIBlockClosure)});
},
args: ["aCollection"],
source: "valueWithPossibleArguments: aCollection\x0a\x09| context sequenceNode |\x0a\x09context := outerContext newInnerContext.\x0a\x0a\x09\x22Interpret a copy of the sequence node to avoid creating a new AIBlockClosure\x22\x0a\x09sequenceNode := node nodes first copy\x0a\x09\x09parent: nil;\x0a\x09\x09yourself.\x0a\x09\x09\x0a\x09\x22Define locals in the context\x22\x0a\x09sequenceNode temps do: [ :each |\x0a\x09\x09context defineLocal: each ].\x0a\x09\x09\x0a\x09\x22Populate the arguments into the context locals\x22\x09\x0a\x09node parameters withIndexDo: [ :each :index |\x0a\x09\x09context defineLocal: each.\x0a\x09\x09context localAt: each put: (aCollection at: index ifAbsent: [ nil ]) ].\x0a\x0a\x09\x22Interpret the first node of the BlockSequenceNode\x22\x0a\x09context interpreter\x0a\x09\x09node: sequenceNode;\x0a\x09\x09enterNode;\x0a\x09\x09proceed.\x0a\x09\x09\x0a\x09outerContext interpreter\x0a\x09\x09setNonLocalReturnFromContext: context.\x0a\x09\x09\x0a\x09^ context interpreter pop",
referencedClasses: [],
messageSends: ["newInnerContext", "parent:", "copy", "first", "nodes", "yourself", "do:", "temps", "defineLocal:", "withIndexDo:", "parameters", "localAt:put:", "at:ifAbsent:", "node:", "interpreter", "enterNode", "proceed", "setNonLocalReturnFromContext:", "pop"]
}),
$globals.AIBlockClosure);


$core.addMethod(
$core.method({
selector: "forContext:node:",
protocol: 'instance creation',
fn: function (aContext,aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._initializeWithContext_node_(aContext,aNode);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"forContext:node:",{aContext:aContext,aNode:aNode},$globals.AIBlockClosure.klass)});
},
args: ["aContext", "aNode"],
source: "forContext: aContext node: aNode\x0a\x09^ self new\x0a\x09\x09initializeWithContext: aContext node: aNode;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["initializeWithContext:node:", "new", "yourself"]
}),
$globals.AIBlockClosure.klass);


$core.addClass('AIContext', $globals.MethodContext, ['outerContext', 'innerContext', 'pc', 'locals', 'selector', 'index', 'sendIndexes', 'evaluatedSelector', 'ast', 'interpreter', 'supercall'], 'Compiler-Interpreter');
$globals.AIContext.comment="I am like a `MethodContext`, used by the `ASTInterpreter`.\x0aUnlike a `MethodContext`, my instances are not read-only.\x0a\x0aWhen debugging, my instances are created by copying the current `MethodContext` (thisContext)";
$core.addMethod(
$core.method({
selector: "arguments",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._ast())._arguments())._collect_((function(each){
return $core.withContext(function($ctx2) {
return self._localAt_ifAbsent_(each,(function(){
return $core.withContext(function($ctx3) {
return self._error_("Argument not in context");
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"arguments",{},$globals.AIContext)});
},
args: [],
source: "arguments\x0a\x09^ self ast arguments collect: [ :each |\x0a\x09\x09self localAt: each ifAbsent: [ self error: 'Argument not in context' ] ]",
referencedClasses: [],
messageSends: ["collect:", "arguments", "ast", "localAt:ifAbsent:", "error:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "ast",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$receiver;
$1=self._isBlockContext();
if($core.assert($1)){
$2=self._outerContext();
return $recv($2)._ifNotNil_((function(context){
return $core.withContext(function($ctx2) {
return $recv(context)._ast();
}, function($ctx2) {$ctx2.fillBlock({context:context},$ctx1,2)});
}));
};
$3=self["@ast"];
if(($receiver = $3) == null || $receiver.isNil){
self._initializeAST();
} else {
$3;
};
return self["@ast"];
}, function($ctx1) {$ctx1.fill(self,"ast",{},$globals.AIContext)});
},
args: [],
source: "ast\x0a\x09self isBlockContext ifTrue: [ \x0a\x09\x09^ self outerContext ifNotNil: [ :context | context ast ] ].\x0a\x0a\x09ast ifNil: [ self initializeAST ].\x0a\x09^ ast",
referencedClasses: [],
messageSends: ["ifTrue:", "isBlockContext", "ifNotNil:", "outerContext", "ast", "ifNil:", "initializeAST"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "basicLocalAt:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._locals())._at_(aString);
}, function($ctx1) {$ctx1.fill(self,"basicLocalAt:",{aString:aString},$globals.AIContext)});
},
args: ["aString"],
source: "basicLocalAt: aString\x0a\x09^ self locals at: aString",
referencedClasses: [],
messageSends: ["at:", "locals"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "basicLocalAt:put:",
protocol: 'private',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._locals())._at_put_(aString,anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicLocalAt:put:",{aString:aString,anObject:anObject},$globals.AIContext)});
},
args: ["aString", "anObject"],
source: "basicLocalAt: aString put: anObject\x0a\x09self locals at: aString put: anObject",
referencedClasses: [],
messageSends: ["at:put:", "locals"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "basicReceiver",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self._localAt_("self");
}, function($ctx1) {$ctx1.fill(self,"basicReceiver",{},$globals.AIContext)});
},
args: [],
source: "basicReceiver\x0a\x09^ self localAt: 'self'",
referencedClasses: [],
messageSends: ["localAt:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "defineLocal:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._locals())._at_put_(aString,nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"defineLocal:",{aString:aString},$globals.AIContext)});
},
args: ["aString"],
source: "defineLocal: aString\x0a\x09self locals at: aString put: nil",
referencedClasses: [],
messageSends: ["at:put:", "locals"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "evaluate:on:",
protocol: 'evaluating',
fn: function (aString,anEvaluator){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(anEvaluator)._evaluate_context_(aString,self);
}, function($ctx1) {$ctx1.fill(self,"evaluate:on:",{aString:aString,anEvaluator:anEvaluator},$globals.AIContext)});
},
args: ["aString", "anEvaluator"],
source: "evaluate: aString on: anEvaluator\x0a\x09^ anEvaluator evaluate: aString context: self",
referencedClasses: [],
messageSends: ["evaluate:context:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "evaluateNode:",
protocol: 'evaluating',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ASTInterpreter)._new();
$recv($1)._context_(self);
$recv($1)._node_(aNode);
$recv($1)._enterNode();
$recv($1)._proceed();
return $recv($1)._result();
}, function($ctx1) {$ctx1.fill(self,"evaluateNode:",{aNode:aNode},$globals.AIContext)});
},
args: ["aNode"],
source: "evaluateNode: aNode\x0a\x09^ ASTInterpreter new\x0a\x09\x09context: self;\x0a\x09\x09node: aNode;\x0a\x09\x09enterNode;\x0a\x09\x09proceed;\x0a\x09\x09result",
referencedClasses: ["ASTInterpreter"],
messageSends: ["context:", "new", "node:", "enterNode", "proceed", "result"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "evaluatedSelector",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@evaluatedSelector"];

},
args: [],
source: "evaluatedSelector\x0a\x09^ evaluatedSelector",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "evaluatedSelector:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@evaluatedSelector"]=aString;
return self;

},
args: ["aString"],
source: "evaluatedSelector: aString\x0a\x09evaluatedSelector := aString",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "index",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@index"];
if(($receiver = $1) == null || $receiver.isNil){
return (0);
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"index",{},$globals.AIContext)});
},
args: [],
source: "index\x0a\x09^ index ifNil: [ 0 ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "index:",
protocol: 'accessing',
fn: function (anInteger){
var self=this;
self["@index"]=anInteger;
return self;

},
args: ["anInteger"],
source: "index: anInteger\x0a\x09index := anInteger",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "initializeAST",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._method();
$ctx1.sendIdx["method"]=1;
self["@ast"]=$recv($1)._ast();
$recv($recv($globals.SemanticAnalyzer)._on_($recv(self._method())._methodClass()))._visit_(self["@ast"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeAST",{},$globals.AIContext)});
},
args: [],
source: "initializeAST\x0a\x09ast := self method ast.\x0a\x09(SemanticAnalyzer on: self method methodClass)\x0a\x09\x09visit: ast",
referencedClasses: ["SemanticAnalyzer"],
messageSends: ["ast", "method", "visit:", "on:", "methodClass"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "initializeFromMethodContext:",
protocol: 'initialization',
fn: function (aMethodContext){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$receiver;
self._evaluatedSelector_($recv(aMethodContext)._evaluatedSelector());
self._index_($recv(aMethodContext)._index());
self._sendIndexes_($recv(aMethodContext)._sendIndexes());
self._receiver_($recv(aMethodContext)._receiver());
self._supercall_($recv(aMethodContext)._supercall());
self._selector_($recv(aMethodContext)._selector());
$1=$recv(aMethodContext)._outerContext();
$ctx1.sendIdx["outerContext"]=1;
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
var outer;
outer=$receiver;
$2=$recv(outer)._methodContext();
if(($receiver = $2) == null || $receiver.isNil){
$2;
} else {
self._outerContext_($recv(self._class())._fromMethodContext_($recv(aMethodContext)._outerContext()));
};
$3=$recv(aMethodContext)._locals();
$ctx1.sendIdx["locals"]=1;
$recv($3)._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(self._locals())._at_put_(key,value);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,3)});
}));
};
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeFromMethodContext:",{aMethodContext:aMethodContext},$globals.AIContext)});
},
args: ["aMethodContext"],
source: "initializeFromMethodContext: aMethodContext\x0a\x0a\x09self\x0a\x09\x09evaluatedSelector: aMethodContext evaluatedSelector;\x0a\x09\x09index: aMethodContext index;\x0a\x09\x09sendIndexes: aMethodContext sendIndexes;\x0a\x09\x09receiver: aMethodContext receiver;\x0a\x09\x09supercall: aMethodContext supercall;\x0a\x09\x09selector: aMethodContext selector.\x0a\x09\x09\x0a\x09aMethodContext outerContext ifNotNil: [ :outer |\x0a\x09\x09\x22If the method context is nil, the block was defined in JS, so ignore it\x22\x0a\x09\x09outer methodContext ifNotNil: [\x0a\x09\x09\x09self outerContext: (self class fromMethodContext: aMethodContext outerContext) ].\x0a\x09\x09\x09aMethodContext locals keysAndValuesDo: [ :key :value |\x0a\x09\x09\x09\x09self locals at: key put: value ] ]",
referencedClasses: [],
messageSends: ["evaluatedSelector:", "evaluatedSelector", "index:", "index", "sendIndexes:", "sendIndexes", "receiver:", "receiver", "supercall:", "supercall", "selector:", "selector", "ifNotNil:", "outerContext", "methodContext", "outerContext:", "fromMethodContext:", "class", "keysAndValuesDo:", "locals", "at:put:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "initializeInterpreter",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
$1=$recv($globals.ASTInterpreter)._new();
$recv($1)._context_(self);
self["@interpreter"]=$recv($1)._yourself();
$2=self._innerContext();
if(($receiver = $2) == null || $receiver.isNil){
$2;
} else {
self._setupInterpreter_(self["@interpreter"]);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeInterpreter",{},$globals.AIContext)});
},
args: [],
source: "initializeInterpreter\x0a\x09interpreter := ASTInterpreter new\x0a\x09\x09context: self;\x0a\x09\x09yourself.\x0a\x09\x0a\x09self innerContext ifNotNil: [\x0a\x09\x09self setupInterpreter: interpreter ]",
referencedClasses: ["ASTInterpreter"],
messageSends: ["context:", "new", "yourself", "ifNotNil:", "innerContext", "setupInterpreter:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "initializeLocals",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@locals"]=$recv($globals.Dictionary)._new();
$recv(self["@locals"])._at_put_("thisContext",self);
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeLocals",{},$globals.AIContext)});
},
args: [],
source: "initializeLocals\x0a\x09locals := Dictionary new.\x0a\x09locals at: 'thisContext' put: self.",
referencedClasses: ["Dictionary"],
messageSends: ["new", "at:put:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "innerContext",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@innerContext"];

},
args: [],
source: "innerContext\x0a\x09^ innerContext",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "innerContext:",
protocol: 'accessing',
fn: function (anAIContext){
var self=this;
self["@innerContext"]=anAIContext;
return self;

},
args: ["anAIContext"],
source: "innerContext: anAIContext\x0a\x09innerContext := anAIContext",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "interpreter",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@interpreter"];
if(($receiver = $1) == null || $receiver.isNil){
self._initializeInterpreter();
} else {
$1;
};
return self["@interpreter"];
}, function($ctx1) {$ctx1.fill(self,"interpreter",{},$globals.AIContext)});
},
args: [],
source: "interpreter\x0a\x09interpreter ifNil: [ self initializeInterpreter ].\x0a\x09^ interpreter",
referencedClasses: [],
messageSends: ["ifNil:", "initializeInterpreter"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "interpreter:",
protocol: 'interpreting',
fn: function (anInterpreter){
var self=this;
self["@interpreter"]=anInterpreter;
return self;

},
args: ["anInterpreter"],
source: "interpreter: anInterpreter\x0a\x09interpreter := anInterpreter",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "isTopContext",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._innerContext())._isNil();
}, function($ctx1) {$ctx1.fill(self,"isTopContext",{},$globals.AIContext)});
},
args: [],
source: "isTopContext\x0a\x09^ self innerContext isNil",
referencedClasses: [],
messageSends: ["isNil", "innerContext"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "localAt:",
protocol: 'accessing',
fn: function (aString){
var self=this;
var context;
return $core.withContext(function($ctx1) {
context=self._lookupContextForLocal_(aString);
return $recv(context)._basicLocalAt_(aString);
}, function($ctx1) {$ctx1.fill(self,"localAt:",{aString:aString,context:context},$globals.AIContext)});
},
args: ["aString"],
source: "localAt: aString\x0a\x09\x22Lookup the local value up to the method context\x22\x0a\x0a\x09| context |\x0a\x09\x0a\x09context := self lookupContextForLocal: aString.\x0a\x09^ context basicLocalAt: aString",
referencedClasses: [],
messageSends: ["lookupContextForLocal:", "basicLocalAt:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "localAt:ifAbsent:",
protocol: 'accessing',
fn: function (aString,aBlock){
var self=this;
var context;
return $core.withContext(function($ctx1) {
var $early={};
try {
context=self._lookupContextForLocal_ifNone_(aString,(function(){
return $core.withContext(function($ctx2) {
throw $early=[$recv(aBlock)._value()];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return $recv(context)._basicLocalAt_(aString);
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"localAt:ifAbsent:",{aString:aString,aBlock:aBlock,context:context},$globals.AIContext)});
},
args: ["aString", "aBlock"],
source: "localAt: aString ifAbsent: aBlock\x0a\x09\x22Lookup the local value up to the method context\x22\x0a\x0a\x09| context |\x0a\x09\x0a\x09context := self \x09\x0a\x09\x09lookupContextForLocal: aString \x0a\x09\x09ifNone: [ ^ aBlock value ].\x0a\x09\x0a\x09^ context basicLocalAt: aString",
referencedClasses: [],
messageSends: ["lookupContextForLocal:ifNone:", "value", "basicLocalAt:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "localAt:put:",
protocol: 'accessing',
fn: function (aString,anObject){
var self=this;
var context;
return $core.withContext(function($ctx1) {
context=self._lookupContextForLocal_(aString);
$recv(context)._basicLocalAt_put_(aString,anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"localAt:put:",{aString:aString,anObject:anObject,context:context},$globals.AIContext)});
},
args: ["aString", "anObject"],
source: "localAt: aString put: anObject\x0a\x09| context |\x0a\x09\x0a\x09context := self lookupContextForLocal: aString.\x0a\x09context basicLocalAt: aString put: anObject",
referencedClasses: [],
messageSends: ["lookupContextForLocal:", "basicLocalAt:put:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "locals",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@locals"];
if(($receiver = $1) == null || $receiver.isNil){
self._initializeLocals();
} else {
$1;
};
return self["@locals"];
}, function($ctx1) {$ctx1.fill(self,"locals",{},$globals.AIContext)});
},
args: [],
source: "locals\x0a\x09locals ifNil: [ self initializeLocals ].\x0a\x09\x0a\x09^ locals",
referencedClasses: [],
messageSends: ["ifNil:", "initializeLocals"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "lookupContextForLocal:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return self._lookupContextForLocal_ifNone_(aString,(function(){
return $core.withContext(function($ctx2) {
return self._variableNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"lookupContextForLocal:",{aString:aString},$globals.AIContext)});
},
args: ["aString"],
source: "lookupContextForLocal: aString\x0a\x09\x22Lookup the context defining the local named `aString` \x0a\x09up to the method context\x22\x0a\x0a\x09^ self \x0a\x09\x09lookupContextForLocal: aString \x0a\x09\x09ifNone: [ self variableNotFound ]",
referencedClasses: [],
messageSends: ["lookupContextForLocal:ifNone:", "variableNotFound"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "lookupContextForLocal:ifNone:",
protocol: 'private',
fn: function (aString,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv(self._locals())._at_ifPresent_ifAbsent_(aString,(function(){
return self;

}),(function(){
return $core.withContext(function($ctx2) {
$1=self._outerContext();
return $recv($1)._ifNil_ifNotNil_(aBlock,(function(context){
return $core.withContext(function($ctx3) {
return $recv(context)._lookupContextForLocal_(aString);
}, function($ctx3) {$ctx3.fillBlock({context:context},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"lookupContextForLocal:ifNone:",{aString:aString,aBlock:aBlock},$globals.AIContext)});
},
args: ["aString", "aBlock"],
source: "lookupContextForLocal: aString ifNone: aBlock\x0a\x09\x22Lookup the context defining the local named `aString` \x0a\x09up to the method context\x22\x0a\x0a\x09^ self locals \x0a\x09\x09at: aString\x0a\x09\x09ifPresent: [ self ]\x0a\x09\x09ifAbsent: [ \x0a\x09\x09\x09self outerContext \x0a\x09\x09\x09\x09ifNil: aBlock\x0a\x09\x09\x09\x09ifNotNil: [ :context | \x0a\x09\x09\x09\x09\x09context lookupContextForLocal: aString ] ]",
referencedClasses: [],
messageSends: ["at:ifPresent:ifAbsent:", "locals", "ifNil:ifNotNil:", "outerContext", "lookupContextForLocal:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "newInnerContext",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self._class())._new();
$recv($1)._outerContext_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"newInnerContext",{},$globals.AIContext)});
},
args: [],
source: "newInnerContext\x0a\x09^ self class new\x0a\x09\x09outerContext: self;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["outerContext:", "new", "class", "yourself"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "outerContext",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@outerContext"];

},
args: [],
source: "outerContext\x0a\x09^ outerContext",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "outerContext:",
protocol: 'accessing',
fn: function (anAIContext){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
self["@outerContext"]=anAIContext;
$1=self["@outerContext"];
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
var context;
context=$receiver;
$recv(context)._innerContext_(self);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"outerContext:",{anAIContext:anAIContext},$globals.AIContext)});
},
args: ["anAIContext"],
source: "outerContext: anAIContext\x0a\x09outerContext := anAIContext.\x0a\x09outerContext ifNotNil: [ :context | \x0a\x09\x09context innerContext: self ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "innerContext:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: 'interpreting',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._locals())._at_put_("self",anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"receiver:",{anObject:anObject},$globals.AIContext)});
},
args: ["anObject"],
source: "receiver: anObject\x0a\x09self locals at: 'self' put: anObject",
referencedClasses: [],
messageSends: ["at:put:", "locals"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@selector"];

},
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@selector"]=aString;
return self;

},
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "sendIndexAt:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._sendIndexes())._at_ifAbsent_(aString,(function(){
return (0);

}));
}, function($ctx1) {$ctx1.fill(self,"sendIndexAt:",{aString:aString},$globals.AIContext)});
},
args: ["aString"],
source: "sendIndexAt: aString\x0a\x09^ self sendIndexes at: aString ifAbsent: [ 0 ]",
referencedClasses: [],
messageSends: ["at:ifAbsent:", "sendIndexes"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "sendIndexes",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@sendIndexes"];
if(($receiver = $1) == null || $receiver.isNil){
return $recv($globals.Dictionary)._new();
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"sendIndexes",{},$globals.AIContext)});
},
args: [],
source: "sendIndexes\x0a\x09^ sendIndexes ifNil: [ Dictionary new ]",
referencedClasses: ["Dictionary"],
messageSends: ["ifNil:", "new"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "sendIndexes:",
protocol: 'accessing',
fn: function (aDictionary){
var self=this;
self["@sendIndexes"]=aDictionary;
return self;

},
args: ["aDictionary"],
source: "sendIndexes: aDictionary\x0a\x09sendIndexes := aDictionary",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "setupInterpreter:",
protocol: 'interpreting',
fn: function (anInterpreter){
var self=this;
var currentNode;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$6,$5,$4,$receiver;
$1=$recv($globals.ASTPCNodeVisitor)._new();
$recv($1)._selector_(self._evaluatedSelector());
$recv($1)._context_(self);
$2=self._ast();
$ctx1.sendIdx["ast"]=1;
$recv($1)._visit_($2);
currentNode=$recv($1)._currentNode();
$3=$recv(self._ast())._sequenceNode();
if(($receiver = $3) == null || $receiver.isNil){
$3;
} else {
var sequence;
sequence=$receiver;
$recv($recv(sequence)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
return self._defineLocal_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
$ctx1.sendIdx["do:"]=1;
};
$recv(anInterpreter)._node_(currentNode);
$6=self._innerContext();
$ctx1.sendIdx["innerContext"]=1;
$5=$recv($6)._arguments();
$4=$recv($5)._reversed();
$recv($4)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(anInterpreter)._push_(each);
$ctx2.sendIdx["push:"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
$recv(anInterpreter)._push_($recv(self._innerContext())._receiver());
return self;
}, function($ctx1) {$ctx1.fill(self,"setupInterpreter:",{anInterpreter:anInterpreter,currentNode:currentNode},$globals.AIContext)});
},
args: ["anInterpreter"],
source: "setupInterpreter: anInterpreter\x0a\x09| currentNode |\x0a\x09\x0a\x09\x22Retrieve the current node\x22\x0a\x09currentNode := ASTPCNodeVisitor new\x0a\x09\x09\x09selector: self evaluatedSelector;\x0a\x09\x09\x09context: self;\x0a\x09\x09\x09visit: self ast;\x0a\x09\x09\x09currentNode.\x0a\x09\x0a\x09\x22Define locals for the context\x22\x0a\x09self ast sequenceNode ifNotNil: [ :sequence |\x0a\x09\x09sequence temps do: [ :each |\x0a\x09\x09\x09self defineLocal: each ] ].\x0a\x09\x0a\x09anInterpreter node: currentNode.\x0a\x0a\x09\x22Push the send args and receiver to the interpreter stack\x22\x09\x0a\x09self innerContext arguments reversed do: [ :each | \x0a\x09\x09anInterpreter push: each ].\x0a\x09\x09\x0a\x09anInterpreter push: (self innerContext receiver)",
referencedClasses: ["ASTPCNodeVisitor"],
messageSends: ["selector:", "new", "evaluatedSelector", "context:", "visit:", "ast", "currentNode", "ifNotNil:", "sequenceNode", "do:", "temps", "defineLocal:", "node:", "reversed", "arguments", "innerContext", "push:", "receiver"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "supercall",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@supercall"];
if(($receiver = $1) == null || $receiver.isNil){
return false;
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"supercall",{},$globals.AIContext)});
},
args: [],
source: "supercall\x0a\x09^ supercall ifNil: [ false ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "supercall:",
protocol: 'interpreting',
fn: function (aBoolean){
var self=this;
self["@supercall"]=aBoolean;
return self;

},
args: ["aBoolean"],
source: "supercall: aBoolean\x0a\x09supercall := aBoolean",
referencedClasses: [],
messageSends: []
}),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "variableNotFound",
protocol: 'error handling',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._error_("Variable missing");
return self;
}, function($ctx1) {$ctx1.fill(self,"variableNotFound",{},$globals.AIContext)});
},
args: [],
source: "variableNotFound\x0a\x09\x22Error thrown whenever a variable lookup fails\x22\x0a\x09\x0a\x09self error: 'Variable missing'",
referencedClasses: [],
messageSends: ["error:"]
}),
$globals.AIContext);


$core.addMethod(
$core.method({
selector: "fromMethodContext:",
protocol: 'instance creation',
fn: function (aMethodContext){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._initializeFromMethodContext_(aMethodContext);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"fromMethodContext:",{aMethodContext:aMethodContext},$globals.AIContext.klass)});
},
args: ["aMethodContext"],
source: "fromMethodContext: aMethodContext\x0a\x09^ self new\x0a\x09\x09initializeFromMethodContext: aMethodContext;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["initializeFromMethodContext:", "new", "yourself"]
}),
$globals.AIContext.klass);


$core.addClass('AISemanticAnalyzer', $globals.SemanticAnalyzer, ['context'], 'Compiler-Interpreter');
$globals.AISemanticAnalyzer.comment="I perform the same semantic analysis than `SemanticAnalyzer`, with the difference that provided an `AIContext` context, variables are bound with the context variables.";
$core.addMethod(
$core.method({
selector: "context",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@context"];

},
args: [],
source: "context\x0a\x09^ context",
referencedClasses: [],
messageSends: []
}),
$globals.AISemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "context:",
protocol: 'accessing',
fn: function (anAIContext){
var self=this;
self["@context"]=anAIContext;
return self;

},
args: ["anAIContext"],
source: "context: anAIContext\x0a\x09context := anAIContext",
referencedClasses: [],
messageSends: []
}),
$globals.AISemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitVariableNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
$recv(self._context())._localAt_ifAbsent_($recv(aNode)._value(),(function(){
return $core.withContext(function($ctx2) {
$1=(
$ctx2.supercall = true,
($globals.AISemanticAnalyzer.superclass||$boot.dnu).fn.prototype._visitVariableNode_.apply($recv(self), [aNode]));
$ctx2.supercall = false;
throw $early=[$1];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(aNode)._binding_($recv($globals.ASTContextVar)._new());
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"visitVariableNode:",{aNode:aNode},$globals.AISemanticAnalyzer)});
},
args: ["aNode"],
source: "visitVariableNode: aNode\x0a\x09self context \x0a\x09\x09localAt: aNode value \x0a\x09\x09ifAbsent: [ ^ super visitVariableNode: aNode ].\x0a\x0a\x09aNode binding: ASTContextVar new",
referencedClasses: ["ASTContextVar"],
messageSends: ["localAt:ifAbsent:", "context", "value", "visitVariableNode:", "binding:", "new"]
}),
$globals.AISemanticAnalyzer);



$core.addClass('ASTContextVar', $globals.ScopeVar, ['context'], 'Compiler-Interpreter');
$globals.ASTContextVar.comment="I am a variable defined in a `context`.";
$core.addMethod(
$core.method({
selector: "context",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@context"];

},
args: [],
source: "context\x0a\x09^ context",
referencedClasses: [],
messageSends: []
}),
$globals.ASTContextVar);

$core.addMethod(
$core.method({
selector: "context:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@context"]=anObject;
return self;

},
args: ["anObject"],
source: "context: anObject\x0a\x09context := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.ASTContextVar);



$core.addClass('ASTDebugger', $globals.Object, ['interpreter', 'context', 'result'], 'Compiler-Interpreter');
$globals.ASTDebugger.comment="I am a stepping debugger interface for Amber code.\x0aI internally use an instance of `ASTInterpreter` to actually step through node and interpret them.\x0a\x0aMy instances are created from an `AIContext` with `ASTDebugger class >> context:`.\x0aThey hold an `AIContext` instance internally, recursive copy of the `MethodContext`.\x0a\x0a## API\x0a\x0aUse the methods of the `'stepping'` protocol to do stepping.";
$core.addMethod(
$core.method({
selector: "atEnd",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._context();
$ctx1.sendIdx["context"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return true;
} else {
$1;
};
return $recv($recv(self._interpreter())._atEnd())._and_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._context())._isTopContext();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"atEnd",{},$globals.ASTDebugger)});
},
args: [],
source: "atEnd\x09\x0a\x09self context ifNil: [ ^ true ].\x0a\x09\x0a\x09^ self interpreter atEnd and: [ \x0a\x09\x09self context isTopContext ]",
referencedClasses: [],
messageSends: ["ifNil:", "context", "and:", "atEnd", "interpreter", "isTopContext"]
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "context",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@context"];

},
args: [],
source: "context\x0a\x09^ context",
referencedClasses: [],
messageSends: []
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "context:",
protocol: 'accessing',
fn: function (aContext){
var self=this;
self["@context"]=aContext;
return self;

},
args: ["aContext"],
source: "context: aContext\x0a\x09context := aContext",
referencedClasses: [],
messageSends: []
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "flushInnerContexts",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._context();
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
var cxt;
cxt=$receiver;
$recv(cxt)._innerContext_(nil);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"flushInnerContexts",{},$globals.ASTDebugger)});
},
args: [],
source: "flushInnerContexts\x0a\x09\x22When stepping, the inner contexts are not relevent anymore,\x0a\x09and can be flushed\x22\x0a\x09\x0a\x09self context ifNotNil: [ :cxt | \x0a\x09\x09cxt innerContext: nil ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "context", "innerContext:"]
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "interpreter",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._context();
if(($receiver = $1) == null || $receiver.isNil){
return $1;
} else {
var ctx;
ctx=$receiver;
return $recv(ctx)._interpreter();
};
}, function($ctx1) {$ctx1.fill(self,"interpreter",{},$globals.ASTDebugger)});
},
args: [],
source: "interpreter\x0a\x09^ self context ifNotNil: [ :ctx | \x0a\x09\x09ctx interpreter ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "context", "interpreter"]
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "method",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._context())._method();
}, function($ctx1) {$ctx1.fill(self,"method",{},$globals.ASTDebugger)});
},
args: [],
source: "method\x0a\x09^ self context method",
referencedClasses: [],
messageSends: ["method", "context"]
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "node",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self._interpreter();
$ctx1.sendIdx["interpreter"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return $1;
} else {
return $recv(self._interpreter())._node();
};
}, function($ctx1) {$ctx1.fill(self,"node",{},$globals.ASTDebugger)});
},
args: [],
source: "node\x0a\x09^ self interpreter ifNotNil: [\x0a\x09\x09self interpreter node ]",
referencedClasses: [],
messageSends: ["ifNotNil:", "interpreter", "node"]
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "onStep",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$4,$6,$5,$receiver;
$1=self._interpreter();
$ctx1.sendIdx["interpreter"]=1;
self["@result"]=$recv($1)._result();
$3=self._interpreter();
$ctx1.sendIdx["interpreter"]=2;
$2=$recv($3)._atEnd();
$ctx1.sendIdx["atEnd"]=1;
if($core.assert($2)){
$4=$recv(self._context())._outerContext();
if(($receiver = $4) == null || $receiver.isNil){
$4;
} else {
var outerContext;
outerContext=$receiver;
self._context_(outerContext);
};
$6=self._interpreter();
$ctx1.sendIdx["interpreter"]=3;
$5=$recv($6)._atEnd();
if(!$core.assert($5)){
$recv(self._interpreter())._skip();
};
};
self._flushInnerContexts();
return self;
}, function($ctx1) {$ctx1.fill(self,"onStep",{},$globals.ASTDebugger)});
},
args: [],
source: "onStep\x0a\x09\x22After each step, check if the interpreter is at the end,\x0a\x09and if it is move to its outer context if any, skipping its \x0a\x09current node (which was just evaluated by the current \x0a\x09interpreter).\x0a\x09\x0a\x09After each step we also flush inner contexts.\x22\x0a\x09\x0a\x09result := self interpreter result.\x0a\x09\x0a\x09self interpreter atEnd ifTrue: [\x0a\x09\x09self context outerContext ifNotNil: [ :outerContext | \x0a\x09\x09\x09self context: outerContext ].\x0a\x09\x09self interpreter atEnd ifFalse: [ self interpreter skip ] ].\x0a\x09\x09\x0a\x09self flushInnerContexts",
referencedClasses: [],
messageSends: ["result", "interpreter", "ifTrue:", "atEnd", "ifNotNil:", "outerContext", "context", "context:", "ifFalse:", "skip", "flushInnerContexts"]
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "proceed",
protocol: 'stepping',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return self._atEnd();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
return self._stepOver();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"proceed",{},$globals.ASTDebugger)});
},
args: [],
source: "proceed\x0a\x09[ self atEnd ] whileFalse: [ self stepOver ]",
referencedClasses: [],
messageSends: ["whileFalse:", "atEnd", "stepOver"]
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "restart",
protocol: 'stepping',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._interpreter())._restart();
self._flushInnerContexts();
return self;
}, function($ctx1) {$ctx1.fill(self,"restart",{},$globals.ASTDebugger)});
},
args: [],
source: "restart\x0a\x09self interpreter restart.\x0a\x09self flushInnerContexts",
referencedClasses: [],
messageSends: ["restart", "interpreter", "flushInnerContexts"]
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "result",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@result"];

},
args: [],
source: "result\x0a\x09^ result",
referencedClasses: [],
messageSends: []
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "stepInto",
protocol: 'stepping',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._shouldBeImplemented();
return self;
}, function($ctx1) {$ctx1.fill(self,"stepInto",{},$globals.ASTDebugger)});
},
args: [],
source: "stepInto\x0a\x09self shouldBeImplemented",
referencedClasses: [],
messageSends: ["shouldBeImplemented"]
}),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "stepOver",
protocol: 'stepping',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv(self._context())._isTopContext();
if($core.assert($1)){
$recv(self._interpreter())._stepOver();
} else {
$2=self._interpreter();
$ctx1.sendIdx["interpreter"]=1;
$recv($2)._skip();
};
self._onStep();
return self;
}, function($ctx1) {$ctx1.fill(self,"stepOver",{},$globals.ASTDebugger)});
},
args: [],
source: "stepOver\x0a\x09self context isTopContext \x0a\x09\x09ifFalse: [ self interpreter skip ]\x0a\x09\x09ifTrue: [ self interpreter stepOver ].\x0a\x09self onStep",
referencedClasses: [],
messageSends: ["ifFalse:ifTrue:", "isTopContext", "context", "skip", "interpreter", "stepOver", "onStep"]
}),
$globals.ASTDebugger);


$core.addMethod(
$core.method({
selector: "context:",
protocol: 'instance creation',
fn: function (aContext){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._context_(aContext);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"context:",{aContext:aContext},$globals.ASTDebugger.klass)});
},
args: ["aContext"],
source: "context: aContext\x0a\x09^ self new\x0a\x09\x09context: aContext;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["context:", "new", "yourself"]
}),
$globals.ASTDebugger.klass);


$core.addClass('ASTEnterNode', $globals.NodeVisitor, ['interpreter'], 'Compiler-Interpreter');
$core.addMethod(
$core.method({
selector: "interpreter",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@interpreter"];

},
args: [],
source: "interpreter\x0a\x09^ interpreter",
referencedClasses: [],
messageSends: []
}),
$globals.ASTEnterNode);

$core.addMethod(
$core.method({
selector: "interpreter:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@interpreter"]=anObject;
return self;

},
args: ["anObject"],
source: "interpreter: anObject\x0a\x09interpreter := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.ASTEnterNode);

$core.addMethod(
$core.method({
selector: "visitBlockNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return aNode;

},
args: ["aNode"],
source: "visitBlockNode: aNode\x0a\x09\x22Answer the node as we want to avoid eager evaluation\x22\x0a\x09\x0a\x09^ aNode",
referencedClasses: [],
messageSends: []
}),
$globals.ASTEnterNode);

$core.addMethod(
$core.method({
selector: "visitNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$recv($recv(aNode)._nodes())._ifEmpty_ifNotEmpty_((function(){
throw $early=[aNode];

}),(function(nodes){
return $core.withContext(function($ctx2) {
throw $early=[self._visit_($recv(nodes)._first())];
}, function($ctx2) {$ctx2.fillBlock({nodes:nodes},$ctx1,2)});
}));
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"visitNode:",{aNode:aNode},$globals.ASTEnterNode)});
},
args: ["aNode"],
source: "visitNode: aNode\x0a\x09aNode nodes\x0a\x09\x09ifEmpty: [ ^ aNode ]\x0a\x09\x09ifNotEmpty: [ :nodes | ^ self visit: nodes first ]",
referencedClasses: [],
messageSends: ["ifEmpty:ifNotEmpty:", "nodes", "visit:", "first"]
}),
$globals.ASTEnterNode);

$core.addMethod(
$core.method({
selector: "visitSequenceNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv($recv(aNode)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(self._interpreter())._context())._defineLocal_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$1=(
$ctx1.supercall = true,
($globals.ASTEnterNode.superclass||$boot.dnu).fn.prototype._visitSequenceNode_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
return $1;
}, function($ctx1) {$ctx1.fill(self,"visitSequenceNode:",{aNode:aNode},$globals.ASTEnterNode)});
},
args: ["aNode"],
source: "visitSequenceNode: aNode\x0a\x09aNode temps do: [ :each |\x0a\x09\x09self interpreter context defineLocal: each ].\x0a\x09^ super visitSequenceNode: aNode",
referencedClasses: [],
messageSends: ["do:", "temps", "defineLocal:", "context", "interpreter", "visitSequenceNode:"]
}),
$globals.ASTEnterNode);


$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (anInterpreter){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._interpreter_(anInterpreter);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{anInterpreter:anInterpreter},$globals.ASTEnterNode.klass)});
},
args: ["anInterpreter"],
source: "on: anInterpreter\x0a\x09^ self new\x0a\x09\x09interpreter: anInterpreter;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["interpreter:", "new", "yourself"]
}),
$globals.ASTEnterNode.klass);


$core.addClass('ASTInterpreter', $globals.NodeVisitor, ['node', 'context', 'stack', 'returnValue', 'returned', 'forceAtEnd'], 'Compiler-Interpreter');
$globals.ASTInterpreter.comment="I visit an AST, interpreting (evaluating) nodes one after the other, using a small stack machine.\x0a\x0a## API\x0a\x0aWhile my instances should be used from within an `ASTDebugger`, which provides a more high level interface,\x0ayou can use methods from the `interpreting` protocol:\x0a\x0a- `#step` evaluates the current `node` only\x0a- `#stepOver` evaluates the AST from the current `node` up to the next stepping node (most likely the next send node)\x0a- `#proceed` evaluates eagerly the AST\x0a- `#restart` select the first node of the AST\x0a- `#skip` skips the current node, moving to the next one if any";
$core.addMethod(
$core.method({
selector: "assign:to:",
protocol: 'private',
fn: function (aNode,anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$4;
$1=$recv($recv(aNode)._binding())._isInstanceVar();
if($core.assert($1)){
$3=self._context();
$ctx1.sendIdx["context"]=1;
$2=$recv($3)._receiver();
$4=$recv(aNode)._value();
$ctx1.sendIdx["value"]=1;
$recv($2)._instVarAt_put_($4,anObject);
} else {
$recv(self._context())._localAt_put_($recv(aNode)._value(),anObject);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"assign:to:",{aNode:aNode,anObject:anObject},$globals.ASTInterpreter)});
},
args: ["aNode", "anObject"],
source: "assign: aNode to: anObject\x0a\x09aNode binding isInstanceVar\x0a\x09\x09ifTrue: [ self context receiver instVarAt: aNode value put: anObject ]\x0a\x09\x09ifFalse: [ self context localAt: aNode value put: anObject ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "isInstanceVar", "binding", "instVarAt:put:", "receiver", "context", "value", "localAt:put:"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "atEnd",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self["@forceAtEnd"];
if($core.assert($1)){
return true;
};
return $recv(self._hasReturned())._or_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._node())._isNil();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"atEnd",{},$globals.ASTInterpreter)});
},
args: [],
source: "atEnd\x0a\x09forceAtEnd ifTrue: [ ^ true ].\x0a\x09\x0a\x09^ self hasReturned or: [ self node isNil ]",
referencedClasses: [],
messageSends: ["ifTrue:", "or:", "hasReturned", "isNil", "node"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "context",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@context"];

},
args: [],
source: "context\x0a\x09^ context",
referencedClasses: [],
messageSends: []
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "context:",
protocol: 'accessing',
fn: function (aContext){
var self=this;
self["@context"]=aContext;
return self;

},
args: ["aContext"],
source: "context: aContext\x0a\x09context := aContext",
referencedClasses: [],
messageSends: []
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "enterNode",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._node_($recv($recv($globals.ASTEnterNode)._on_(self))._visit_(self._node()));
return self;
}, function($ctx1) {$ctx1.fill(self,"enterNode",{},$globals.ASTInterpreter)});
},
args: [],
source: "enterNode\x0a\x09self node: ((ASTEnterNode on: self) visit: self node)",
referencedClasses: ["ASTEnterNode"],
messageSends: ["node:", "visit:", "on:", "node"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "eval:",
protocol: 'private',
fn: function (aString){
var self=this;
var source,function_;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
source=$recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
$recv(str)._nextPutAll_("0,(function(");
$ctx2.sendIdx["nextPutAll:"]=1;
$3=self._context();
$ctx2.sendIdx["context"]=1;
$2=$recv($3)._locals();
$ctx2.sendIdx["locals"]=1;
$1=$recv($2)._keys();
$recv($1)._do_separatedBy_((function(each){
return $core.withContext(function($ctx3) {
return $recv(str)._nextPutAll_(each);
$ctx3.sendIdx["nextPutAll:"]=2;
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return $recv(str)._nextPutAll_(",");
$ctx3.sendIdx["nextPutAll:"]=3;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
$recv(str)._nextPutAll_("){ return (function() {");
$ctx2.sendIdx["nextPutAll:"]=4;
$recv(str)._nextPutAll_(aString);
$ctx2.sendIdx["nextPutAll:"]=5;
return $recv(str)._nextPutAll_("})()})");
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
function_=$recv($recv($globals.Compiler)._new())._eval_(source);
return $recv(function_)._valueWithPossibleArguments_($recv($recv(self._context())._locals())._values());
}, function($ctx1) {$ctx1.fill(self,"eval:",{aString:aString,source:source,function_:function_},$globals.ASTInterpreter)});
},
args: ["aString"],
source: "eval: aString\x0a\x09\x22Evaluate aString as JS source inside an JS function.\x0a\x09aString is not sandboxed.\x22\x0a\x09\x0a\x09| source function |\x0a\x09\x0a\x09source := String streamContents: [ :str |\x0a\x09\x09str nextPutAll: '0,(function('.\x0a\x09\x09self context locals keys\x0a\x09\x09\x09do: [ :each | str nextPutAll: each ]\x0a\x09\x09\x09separatedBy: [ str nextPutAll: ',' ].\x0a\x09\x09str\x0a\x09\x09\x09nextPutAll: '){ return (function() {';\x0a\x09\x09\x09nextPutAll: aString;\x0a\x09\x09\x09nextPutAll: '})()})' ].\x0a\x09\x09\x09\x0a\x09function := Compiler new eval: source.\x0a\x09\x0a\x09^ function valueWithPossibleArguments: self context locals values",
referencedClasses: ["String", "Compiler"],
messageSends: ["streamContents:", "nextPutAll:", "do:separatedBy:", "keys", "locals", "context", "eval:", "new", "valueWithPossibleArguments:", "values"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "hasReturned",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@returned"];
if(($receiver = $1) == null || $receiver.isNil){
return false;
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"hasReturned",{},$globals.ASTInterpreter)});
},
args: [],
source: "hasReturned\x0a\x09^ returned ifNil: [ false ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.ASTInterpreter.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@forceAtEnd"]=false;
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.ASTInterpreter)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x0a\x09forceAtEnd := false",
referencedClasses: [],
messageSends: ["initialize"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "interpret",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._visit_(self._node());
return self;
}, function($ctx1) {$ctx1.fill(self,"interpret",{},$globals.ASTInterpreter)});
},
args: [],
source: "interpret\x0a\x09\x22Interpret the next node to be evaluated\x22\x0a\x09\x0a\x09self visit: self node",
referencedClasses: [],
messageSends: ["visit:", "node"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "messageFromSendNode:arguments:",
protocol: 'private',
fn: function (aSendNode,aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Message)._new();
$recv($1)._selector_($recv(aSendNode)._selector());
$recv($1)._arguments_(aCollection);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"messageFromSendNode:arguments:",{aSendNode:aSendNode,aCollection:aCollection},$globals.ASTInterpreter)});
},
args: ["aSendNode", "aCollection"],
source: "messageFromSendNode: aSendNode arguments: aCollection\x0a\x09^ Message new\x0a\x09\x09selector: aSendNode selector;\x0a\x09\x09arguments: aCollection;\x0a\x09\x09yourself",
referencedClasses: ["Message"],
messageSends: ["selector:", "new", "selector", "arguments:", "yourself"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "messageNotUnderstood:receiver:",
protocol: 'private',
fn: function (aMessage,anObject){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.MessageNotUnderstood)._new();
$recv($1)._message_(aMessage);
$recv($1)._receiver_(anObject);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"messageNotUnderstood:receiver:",{aMessage:aMessage,anObject:anObject},$globals.ASTInterpreter)});
},
args: ["aMessage", "anObject"],
source: "messageNotUnderstood: aMessage receiver: anObject\x0a\x09MessageNotUnderstood new\x0a\x09\x09message: aMessage;\x0a\x09\x09receiver: anObject;\x0a\x09\x09signal",
referencedClasses: ["MessageNotUnderstood"],
messageSends: ["message:", "new", "receiver:", "signal"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "next",
protocol: 'interpreting',
fn: function (){
var self=this;
var nd,nextNode;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
nd=self._node();
$1=$recv(nd)._parent();
if(($receiver = $1) == null || $receiver.isNil){
nextNode=$1;
} else {
var parent;
parent=$receiver;
$2=$recv(parent)._nextSiblingNode_(nd);
if(($receiver = $2) == null || $receiver.isNil){
nextNode=parent;
} else {
var sibling;
sibling=$receiver;
nextNode=$recv($recv($globals.ASTEnterNode)._on_(self))._visit_(sibling);
};
};
self._node_(nextNode);
return self;
}, function($ctx1) {$ctx1.fill(self,"next",{nd:nd,nextNode:nextNode},$globals.ASTInterpreter)});
},
args: [],
source: "next\x0a\x09| nd nextNode |\x0a\x09nd := self node.\x0a\x09nextNode := nd parent ifNotNil: [ :parent |\x0a\x09\x09(parent nextSiblingNode: nd)\x0a\x09\x09\x09ifNil: [ parent ]\x0a\x09\x09\x09ifNotNil: [ :sibling | (ASTEnterNode on: self) visit: sibling ] ].\x0a\x09self node: nextNode",
referencedClasses: ["ASTEnterNode"],
messageSends: ["node", "ifNotNil:", "parent", "ifNil:ifNotNil:", "nextSiblingNode:", "visit:", "on:", "node:"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "node",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@node"];

},
args: [],
source: "node\x0a\x09\x22Answer the next node, ie the node to be evaluated in the next step\x22\x0a\x09\x0a\x09^ node",
referencedClasses: [],
messageSends: []
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "node:",
protocol: 'accessing',
fn: function (aNode){
var self=this;
self["@node"]=aNode;
return self;

},
args: ["aNode"],
source: "node: aNode\x0a\x09node := aNode",
referencedClasses: [],
messageSends: []
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "peek",
protocol: 'stack',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
$1=self._stack();
$ctx1.sendIdx["stack"]=1;
$recv($1)._ifEmpty_((function(){
throw $early=[nil];

}));
return $recv(self._stack())._last();
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"peek",{},$globals.ASTInterpreter)});
},
args: [],
source: "peek\x0a\x09\x22Peek the top object of the context stack\x22\x0a\x09\x0a\x09self stack ifEmpty: [ ^ nil ].\x0a\x09\x0a\x09^ self stack last",
referencedClasses: [],
messageSends: ["ifEmpty:", "stack", "last"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "pop",
protocol: 'stack',
fn: function (){
var self=this;
var peekedValue;
return $core.withContext(function($ctx1) {
peekedValue=self._peek();
$recv(self._stack())._removeLast();
return peekedValue;
}, function($ctx1) {$ctx1.fill(self,"pop",{peekedValue:peekedValue},$globals.ASTInterpreter)});
},
args: [],
source: "pop\x0a\x09\x22Pop an object from the context stack\x22\x0a\x09\x0a\x09| peekedValue |\x0a\x09\x0a\x09peekedValue := self peek.\x0a\x09self stack removeLast.\x0a\x09^ peekedValue",
referencedClasses: [],
messageSends: ["peek", "removeLast", "stack"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "proceed",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return self._atEnd();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
return self._step();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"proceed",{},$globals.ASTInterpreter)});
},
args: [],
source: "proceed\x0a\x09\x22Eagerly evaluate the ast\x22\x0a\x09\x0a\x09[ self atEnd ] \x0a\x09\x09whileFalse: [ self step ]",
referencedClasses: [],
messageSends: ["whileFalse:", "atEnd", "step"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "push:",
protocol: 'stack',
fn: function (anObject){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._stack())._add_(anObject);
}, function($ctx1) {$ctx1.fill(self,"push:",{anObject:anObject},$globals.ASTInterpreter)});
},
args: ["anObject"],
source: "push: anObject\x0a\x09\x22Push an object to the context stack\x22\x0a\x09\x0a\x09^ self stack add: anObject",
referencedClasses: [],
messageSends: ["add:", "stack"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "restart",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._node_($recv(self._context())._ast());
self._enterNode();
return self;
}, function($ctx1) {$ctx1.fill(self,"restart",{},$globals.ASTInterpreter)});
},
args: [],
source: "restart\x0a\x09self node: self context ast; enterNode",
referencedClasses: [],
messageSends: ["node:", "ast", "context", "enterNode"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "result",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._hasReturned();
if($core.assert($1)){
return self._returnValue();
} else {
return $recv(self._context())._receiver();
};
}, function($ctx1) {$ctx1.fill(self,"result",{},$globals.ASTInterpreter)});
},
args: [],
source: "result\x0a\x09^ self hasReturned \x0a\x09\x09ifTrue: [ self returnValue ] \x0a\x09\x09ifFalse: [ self context receiver ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "hasReturned", "returnValue", "receiver", "context"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "returnValue",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@returnValue"];

},
args: [],
source: "returnValue\x0a\x09^ returnValue",
referencedClasses: [],
messageSends: []
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "returnValue:",
protocol: 'accessing',
fn: function (anObject){
var self=this;
self["@returnValue"]=anObject;
return self;

},
args: ["anObject"],
source: "returnValue: anObject\x0a\x09returnValue := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "sendMessage:to:superSend:",
protocol: 'private',
fn: function (aMessage,anObject,aBoolean){
var self=this;
var method;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$receiver;
var $early={};
try {
if(!$core.assert(aBoolean)){
return $recv(aMessage)._sendTo_(anObject);
};
$2=$recv(anObject)._class();
$ctx1.sendIdx["class"]=1;
$1=$recv($2)._superclass();
$ctx1.sendIdx["superclass"]=1;
if(($receiver = $1) == null || $receiver.isNil){
$3=self._messageNotUnderstood_receiver_(aMessage,anObject);
$ctx1.sendIdx["messageNotUnderstood:receiver:"]=1;
return $3;
} else {
$1;
};
method=$recv($recv($recv($recv(anObject)._class())._superclass())._methodDictionary())._at_ifAbsent_($recv(aMessage)._selector(),(function(){
return $core.withContext(function($ctx2) {
throw $early=[self._messageNotUnderstood_receiver_(aMessage,anObject)];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return $recv(method)._sendTo_arguments_(anObject,$recv(aMessage)._arguments());
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"sendMessage:to:superSend:",{aMessage:aMessage,anObject:anObject,aBoolean:aBoolean,method:method},$globals.ASTInterpreter)});
},
args: ["aMessage", "anObject", "aBoolean"],
source: "sendMessage: aMessage to: anObject superSend: aBoolean\x0a\x09| method |\x0a\x09\x0a\x09aBoolean ifFalse: [ ^ aMessage sendTo: anObject ].\x0a\x09anObject class superclass ifNil: [ ^ self messageNotUnderstood: aMessage receiver: anObject ].\x0a\x09\x0a\x09method := anObject class superclass methodDictionary\x0a\x09\x09at: aMessage selector\x0a\x09\x09ifAbsent: [ ^ self messageNotUnderstood: aMessage receiver: anObject ].\x0a\x09\x09\x0a\x09^ method sendTo: anObject arguments: aMessage arguments",
referencedClasses: [],
messageSends: ["ifFalse:", "sendTo:", "ifNil:", "superclass", "class", "messageNotUnderstood:receiver:", "at:ifAbsent:", "methodDictionary", "selector", "sendTo:arguments:", "arguments"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "setNonLocalReturnFromContext:",
protocol: 'interpreting',
fn: function (aContext){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=$recv(aContext)._interpreter();
$ctx1.sendIdx["interpreter"]=1;
$1=$recv($2)._hasReturned();
if($core.assert($1)){
self["@returned"]=true;
self["@returned"];
self._returnValue_($recv($recv(aContext)._interpreter())._returnValue());
};
return self;
}, function($ctx1) {$ctx1.fill(self,"setNonLocalReturnFromContext:",{aContext:aContext},$globals.ASTInterpreter)});
},
args: ["aContext"],
source: "setNonLocalReturnFromContext: aContext\x0a\x09aContext interpreter hasReturned ifTrue: [\x0a\x09\x09returned := true.\x0a\x09\x09self returnValue: aContext interpreter returnValue ]",
referencedClasses: [],
messageSends: ["ifTrue:", "hasReturned", "interpreter", "returnValue:", "returnValue"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "skip",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._next();
return self;
}, function($ctx1) {$ctx1.fill(self,"skip",{},$globals.ASTInterpreter)});
},
args: [],
source: "skip\x0a\x09self next",
referencedClasses: [],
messageSends: ["next"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "stack",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@stack"];
if(($receiver = $1) == null || $receiver.isNil){
self["@stack"]=$recv($globals.OrderedCollection)._new();
return self["@stack"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"stack",{},$globals.ASTInterpreter)});
},
args: [],
source: "stack\x0a\x09^ stack ifNil: [ stack := OrderedCollection new ]",
referencedClasses: ["OrderedCollection"],
messageSends: ["ifNil:", "new"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "step",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._interpret();
self._next();
return self;
}, function($ctx1) {$ctx1.fill(self,"step",{},$globals.ASTInterpreter)});
},
args: [],
source: "step\x0a\x09self \x0a\x09\x09interpret; \x0a\x09\x09next",
referencedClasses: [],
messageSends: ["interpret", "next"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "stepOver",
protocol: 'interpreting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
self._step();
$ctx1.sendIdx["step"]=1;
$recv((function(){
return $core.withContext(function($ctx2) {
$2=self._node();
$ctx2.sendIdx["node"]=1;
$1=$recv($2)._isNil();
return $recv($1)._or_((function(){
return $core.withContext(function($ctx3) {
return $recv(self._node())._isSteppingNode();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
return self._step();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"stepOver",{},$globals.ASTInterpreter)});
},
args: [],
source: "stepOver\x0a\x09self step.\x0a\x09\x0a\x09[ self node isNil or: [ self node isSteppingNode ] ] whileFalse: [ \x0a\x09\x09self step ]",
referencedClasses: [],
messageSends: ["step", "whileFalse:", "or:", "isNil", "node", "isSteppingNode"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visit:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._hasReturned();
if(!$core.assert($1)){
(
$ctx1.supercall = true,
($globals.ASTInterpreter.superclass||$boot.dnu).fn.prototype._visit_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
};
return self;
}, function($ctx1) {$ctx1.fill(self,"visit:",{aNode:aNode},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visit: aNode\x0a\x09self hasReturned ifFalse: [ super visit: aNode ]",
referencedClasses: [],
messageSends: ["ifFalse:", "hasReturned", "visit:"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitAssignmentNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var poppedValue;
return $core.withContext(function($ctx1) {
poppedValue=self._pop();
$ctx1.sendIdx["pop"]=1;
self._pop();
self._push_(poppedValue);
self._assign_to_($recv(aNode)._left(),poppedValue);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitAssignmentNode:",{aNode:aNode,poppedValue:poppedValue},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visitAssignmentNode: aNode\x0a\x09| poppedValue |\x0a\x09\x0a\x09poppedValue := self pop.\x0a\x09\x0a\x09\x22Pop the left side of the assignment.\x0a\x09It already has been visited, and we don't need its value.\x22\x0a\x09self pop.\x0a\x09\x0a\x09self push: poppedValue.\x0a\x09self assign: aNode left to: poppedValue",
referencedClasses: [],
messageSends: ["pop", "push:", "assign:to:", "left"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitBlockNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var block;
return $core.withContext(function($ctx1) {
block=$recv($globals.AIBlockClosure)._forContext_node_(self._context(),aNode);
self._push_(block);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitBlockNode:",{aNode:aNode,block:block},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visitBlockNode: aNode\x0a\x09\x22Do not evaluate the block node.\x0a\x09Instead, put all instructions into a block that we push to the stack for later evaluation\x22\x0a\x09\x0a\x09| block |\x0a\x09\x0a\x09block := AIBlockClosure forContext: self context node: aNode.\x0a\x09\x0a\x09self push: block",
referencedClasses: ["AIBlockClosure"],
messageSends: ["forContext:node:", "context", "push:"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitBlockSequenceNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.ASTInterpreter.superclass||$boot.dnu).fn.prototype._visitBlockSequenceNode_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
self["@forceAtEnd"]=true;
return self;
}, function($ctx1) {$ctx1.fill(self,"visitBlockSequenceNode:",{aNode:aNode},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visitBlockSequenceNode: aNode\x0a\x09\x22If the receiver is actually visiting a BlockSequenceNode,\x0a\x09it means the the context is a block context. Evaluation should \x0a\x09stop right after evaluating the block sequence and the outer\x0a\x09context's interpreter should take over. \x0a\x09Therefore we force #atEnd.\x22\x0a\x09\x0a\x09super visitBlockSequenceNode: aNode.\x0a\x09forceAtEnd := true",
referencedClasses: [],
messageSends: ["visitBlockSequenceNode:"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitDynamicArrayNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var array;
return $core.withContext(function($ctx1) {
array=[];
$recv($recv(aNode)._nodes())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(array)._addFirst_(self._pop());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
self._push_(array);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitDynamicArrayNode:",{aNode:aNode,array:array},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visitDynamicArrayNode: aNode\x0a\x09| array |\x0a\x09\x0a\x09array := #().\x0a\x09aNode nodes do: [ :each |\x0a\x09\x09array addFirst: self pop ].\x0a\x09\x0a\x09self push: array",
referencedClasses: [],
messageSends: ["do:", "nodes", "addFirst:", "pop", "push:"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitDynamicDictionaryNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var keyValueList;
return $core.withContext(function($ctx1) {
keyValueList=$recv($globals.OrderedCollection)._new();
$recv($recv(aNode)._nodes())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(keyValueList)._add_(self._pop());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
self._push_($recv($globals.HashedCollection)._newFromPairs_($recv(keyValueList)._reversed()));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitDynamicDictionaryNode:",{aNode:aNode,keyValueList:keyValueList},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visitDynamicDictionaryNode: aNode\x0a\x09| keyValueList |\x0a\x09\x0a\x09keyValueList := OrderedCollection new.\x0a\x09\x0a\x09aNode nodes do: [ :each | \x0a\x09\x09keyValueList add: self pop ].\x0a\x09\x0a\x09self push: (HashedCollection newFromPairs: keyValueList reversed)",
referencedClasses: ["OrderedCollection", "HashedCollection"],
messageSends: ["new", "do:", "nodes", "add:", "pop", "push:", "newFromPairs:", "reversed"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitJSStatementNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
self["@returned"]=true;
self._returnValue_(self._eval_($recv(aNode)._source()));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitJSStatementNode:",{aNode:aNode},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visitJSStatementNode: aNode\x0a\x09returned := true.\x0a\x09self returnValue: (self eval: aNode source)",
referencedClasses: [],
messageSends: ["returnValue:", "eval:", "source"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return self;

},
args: ["aNode"],
source: "visitNode: aNode\x0a\x09\x22Do nothing by default. Especially, do not visit children recursively.\x22",
referencedClasses: [],
messageSends: []
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitReturnNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
self["@returned"]=true;
self._returnValue_(self._pop());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitReturnNode:",{aNode:aNode},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visitReturnNode: aNode\x0a\x09returned := true.\x0a\x09self returnValue: self pop",
referencedClasses: [],
messageSends: ["returnValue:", "pop"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var receiver,args,message,result;
return $core.withContext(function($ctx1) {
var $1;
args=$recv($recv(aNode)._arguments())._collect_((function(each){
return $core.withContext(function($ctx2) {
return self._pop();
$ctx2.sendIdx["pop"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
receiver=self._peek();
message=self._messageFromSendNode_arguments_(aNode,$recv(args)._reversed());
result=self._sendMessage_to_superSend_(message,receiver,$recv(aNode)._superSend());
$1=$recv($recv(aNode)._isCascadeSendNode())._and_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv(aNode)._isLastChild())._not();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
if(!$core.assert($1)){
self._pop();
self._push_(result);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode,receiver:receiver,args:args,message:message,result:result},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x09| receiver args message result |\x0a\x09\x0a\x09args := aNode arguments collect: [ :each | self pop ].\x0a\x09receiver := self peek.\x0a\x09\x0a\x09message := self\x0a\x09\x09messageFromSendNode: aNode\x0a\x09\x09arguments: args reversed.\x0a\x09\x0a\x09result := self sendMessage: message to: receiver superSend: aNode superSend.\x0a\x09\x0a\x09\x22For cascade sends, push the reciever if the send is not the last one\x22\x0a\x09(aNode isCascadeSendNode and: [ aNode isLastChild not ])\x0a\x09\x09ifFalse: [ self pop; push: result ]",
referencedClasses: [],
messageSends: ["collect:", "arguments", "pop", "peek", "messageFromSendNode:arguments:", "reversed", "sendMessage:to:superSend:", "superSend", "ifFalse:", "and:", "isCascadeSendNode", "not", "isLastChild", "push:"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitValueNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
self._push_($recv(aNode)._value());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitValueNode:",{aNode:aNode},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visitValueNode: aNode\x0a\x09self push: aNode value",
referencedClasses: [],
messageSends: ["push:", "value"]
}),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitVariableNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$5,$6,$4,$3,$8,$10,$9,$11,$12,$13,$15,$14,$16,$17,$7;
$2=$recv(aNode)._binding();
$ctx1.sendIdx["binding"]=1;
$1=$recv($2)._isUnknownVar();
if($core.assert($1)){
$5=$recv($globals.Platform)._globals();
$ctx1.sendIdx["globals"]=1;
$6=$recv(aNode)._value();
$ctx1.sendIdx["value"]=1;
$4=$recv($5)._at_ifAbsent_($6,(function(){
return $core.withContext(function($ctx2) {
return self._error_("Unknown variable");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$ctx1.sendIdx["at:ifAbsent:"]=1;
$3=self._push_($4);
$ctx1.sendIdx["push:"]=1;
return $3;
};
$8=$recv($recv(aNode)._binding())._isInstanceVar();
if($core.assert($8)){
$10=self._context();
$ctx1.sendIdx["context"]=1;
$9=$recv($10)._receiver();
$11=$recv(aNode)._value();
$ctx1.sendIdx["value"]=2;
$7=$recv($9)._instVarAt_($11);
} else {
$12=self._context();
$13=$recv(aNode)._value();
$ctx1.sendIdx["value"]=3;
$7=$recv($12)._localAt_ifAbsent_($13,(function(){
return $core.withContext(function($ctx2) {
$15=$recv(aNode)._value();
$ctx2.sendIdx["value"]=4;
$14=$recv($15)._isCapitalized();
if($core.assert($14)){
$16=$recv($globals.Smalltalk)._globals();
$ctx2.sendIdx["globals"]=2;
$17=$recv(aNode)._value();
$ctx2.sendIdx["value"]=5;
return $recv($16)._at_ifAbsent_($17,(function(){
return $core.withContext(function($ctx3) {
return $recv($recv($globals.Platform)._globals())._at_($recv(aNode)._value());
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,7)});
}));
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}));
};
self._push_($7);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitVariableNode:",{aNode:aNode},$globals.ASTInterpreter)});
},
args: ["aNode"],
source: "visitVariableNode: aNode\x0a\x09aNode binding isUnknownVar ifTrue: [\x0a\x09\x09^ self push: (Platform globals at: aNode value ifAbsent: [ self error: 'Unknown variable' ]) ].\x0a\x09\x09\x0a\x09self push: (aNode binding isInstanceVar\x0a\x09\x09ifTrue: [ self context receiver instVarAt: aNode value ]\x0a\x09\x09ifFalse: [ self context \x0a\x09\x09\x09localAt: aNode value\x0a\x09\x09\x09ifAbsent: [\x0a\x09\x09\x09\x09aNode value isCapitalized\x0a\x09\x09\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09\x09\x09Smalltalk globals \x0a\x09\x09\x09\x09\x09\x09\x09at: aNode value \x0a\x09\x09\x09\x09\x09\x09\x09ifAbsent: [ Platform globals at: aNode value ] ] ] ])",
referencedClasses: ["Platform", "Smalltalk"],
messageSends: ["ifTrue:", "isUnknownVar", "binding", "push:", "at:ifAbsent:", "globals", "value", "error:", "ifTrue:ifFalse:", "isInstanceVar", "instVarAt:", "receiver", "context", "localAt:ifAbsent:", "isCapitalized", "at:"]
}),
$globals.ASTInterpreter);



$core.addClass('ASTInterpreterError', $globals.Error, [], 'Compiler-Interpreter');
$globals.ASTInterpreterError.comment="I get signaled when an AST interpreter is unable to interpret a node.";


$core.addClass('ASTPCNodeVisitor', $globals.NodeVisitor, ['context', 'index', 'selector', 'currentNode'], 'Compiler-Interpreter');
$globals.ASTPCNodeVisitor.comment="I visit an AST until I get to the current node for the `context` and answer it.\x0a\x0a## API\x0a\x0aMy instances must be filled with a context object using `#context:`.\x0a\x0aAfter visiting the AST the current node is answered by `#currentNode`";
$core.addMethod(
$core.method({
selector: "context",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@context"];

},
args: [],
source: "context\x0a\x09^ context",
referencedClasses: [],
messageSends: []
}),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "context:",
protocol: 'accessing',
fn: function (aContext){
var self=this;
self["@context"]=aContext;
return self;

},
args: ["aContext"],
source: "context: aContext\x0a\x09context := aContext",
referencedClasses: [],
messageSends: []
}),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "currentNode",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@currentNode"];

},
args: [],
source: "currentNode\x0a\x09^ currentNode",
referencedClasses: [],
messageSends: []
}),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "increaseIndex",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@index"]=$recv(self._index()).__plus((1));
return self;
}, function($ctx1) {$ctx1.fill(self,"increaseIndex",{},$globals.ASTPCNodeVisitor)});
},
args: [],
source: "increaseIndex\x0a\x09index := self index + 1",
referencedClasses: [],
messageSends: ["+", "index"]
}),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "index",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@index"];
if(($receiver = $1) == null || $receiver.isNil){
self["@index"]=(0);
return self["@index"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"index",{},$globals.ASTPCNodeVisitor)});
},
args: [],
source: "index\x0a\x09^ index ifNil: [ index := 0 ]",
referencedClasses: [],
messageSends: ["ifNil:"]
}),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@selector"];

},
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
messageSends: []
}),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@selector"]=aString;
return self;

},
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
messageSends: []
}),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "visitJSStatementNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
self["@currentNode"]=aNode;
return self;

},
args: ["aNode"],
source: "visitJSStatementNode: aNode\x0a\x09\x22If a JSStatementNode is encountered, it always is the current node.\x0a\x09Stop visiting the AST there\x22\x0a\x09\x0a\x09currentNode := aNode",
referencedClasses: [],
messageSends: []
}),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: 'visiting',
fn: function (aNode){
var self=this;
var sendIndex;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3,$5;
$1=self._context();
$2=self._selector();
$ctx1.sendIdx["selector"]=1;
sendIndex=$recv($1)._sendIndexAt_($2);
(
$ctx1.supercall = true,
($globals.ASTPCNodeVisitor.superclass||$boot.dnu).fn.prototype._visitSendNode_.apply($recv(self), [aNode]));
$ctx1.supercall = false;
$4=self._selector();
$ctx1.sendIdx["selector"]=2;
$3=$recv($4).__eq($recv(aNode)._selector());
$ctx1.sendIdx["="]=1;
if($core.assert($3)){
$5=$recv(self._index()).__eq(sendIndex);
if($core.assert($5)){
self["@currentNode"]=aNode;
self["@currentNode"];
};
self._increaseIndex();
};
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode,sendIndex:sendIndex},$globals.ASTPCNodeVisitor)});
},
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x09| sendIndex |\x0a\x09sendIndex := self context sendIndexAt: self selector.\x0a\x09\x0a\x09super visitSendNode: aNode.\x0a\x09\x0a\x09self selector = aNode selector ifTrue: [\x0a\x09\x09self index = sendIndex ifTrue: [ currentNode := aNode ].\x0a\x09\x09self increaseIndex ]",
referencedClasses: [],
messageSends: ["sendIndexAt:", "context", "selector", "visitSendNode:", "ifTrue:", "=", "index", "increaseIndex"]
}),
$globals.ASTPCNodeVisitor);


$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: '*Compiler-Interpreter',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: '*Compiler-Interpreter',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "nextSiblingNode:",
protocol: '*Compiler-Interpreter',
fn: function (aNode){
var self=this;
return nil;

},
args: ["aNode"],
source: "nextSiblingNode: aNode\x0a\x09\x22Answer nil as we want to avoid eager evaluation\x22\x0a\x09\x0a\x09\x22In fact, this should not have been called, ever. IMO. -- herby\x22\x0a\x09\x0a\x09^ nil",
referencedClasses: [],
messageSends: []
}),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: '*Compiler-Interpreter',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.DynamicArrayNode);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: '*Compiler-Interpreter',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.DynamicDictionaryNode);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: '*Compiler-Interpreter',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.JSStatementNode);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: '*Compiler-Interpreter',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isSteppingNode\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "nextSiblingNode:",
protocol: '*Compiler-Interpreter',
fn: function (aNode){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
$1=self._nodes();
$ctx1.sendIdx["nodes"]=1;
return $recv($1)._at_ifAbsent_($recv($recv(self._nodes())._indexOf_(aNode)).__plus((1)),(function(){
throw $early=[nil];

}));
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"nextSiblingNode:",{aNode:aNode},$globals.Node)});
},
args: ["aNode"],
source: "nextSiblingNode: aNode\x0a\x09\x22Answer the next node after aNode or nil\x22\x0a\x09\x0a\x09^ self nodes \x0a\x09\x09at: (self nodes indexOf: aNode) + 1\x0a\x09\x09ifAbsent: [ ^ nil ]",
referencedClasses: [],
messageSends: ["at:ifAbsent:", "nodes", "+", "indexOf:"]
}),
$globals.Node);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: '*Compiler-Interpreter',
fn: function (){
var self=this;
return true;

},
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
messageSends: []
}),
$globals.SendNode);

});

define('amber/lang',[
    './helpers', // pre-fetch, dep of ./deploy
    './deploy',
    './parser',
    // --- packages for the Amber reflection begin here ---
    'amber_core/Platform-ImportExport',
    'amber_core/Compiler-Core',
    'amber_core/Compiler-AST',
    'amber_core/Compiler-Semantic',
    'amber_core/Compiler-IR',
    'amber_core/Compiler-Inlining',
    'amber_core/Compiler-Interpreter'
    // --- packages for the Amber reflection end here ---
], function (amber) { return amber; });

define("amber_core/SUnit", ["amber/boot", "amber_core/Kernel-Objects", "amber_core/Kernel-Exceptions", "amber_core/Kernel-Infrastructure", "amber_core/Kernel-Classes"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('SUnit');
$core.packages["SUnit"].innerEval = function (expr) { return eval(expr); };
$core.packages["SUnit"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('ResultAnnouncement', $globals.Object, ['result'], 'SUnit');
$globals.ResultAnnouncement.comment="I get signaled when a `TestCase` has been run.\x0a\x0aMy instances hold the result (instance of `TestResult`) of the test run.";
$core.addMethod(
$core.method({
selector: "result",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@result"];

},
args: [],
source: "result\x0a\x09^ result",
referencedClasses: [],
messageSends: []
}),
$globals.ResultAnnouncement);

$core.addMethod(
$core.method({
selector: "result:",
protocol: 'accessing',
fn: function (aTestResult){
var self=this;
self["@result"]=aTestResult;
return self;

},
args: ["aTestResult"],
source: "result: aTestResult\x0a\x09result := aTestResult",
referencedClasses: [],
messageSends: []
}),
$globals.ResultAnnouncement);



$core.addClass('TestCase', $globals.Object, ['testSelector', 'asyncTimeout', 'context'], 'SUnit');
$globals.TestCase.comment="I am an implementation of the command pattern to run a test.\x0a\x0a## API\x0a\x0aMy instances are created with the class method `#selector:`,\x0apassing the symbol that names the method to be executed when the test case runs.\x0a\x0aWhen you discover a new fixture, subclass `TestCase` and create a `#test...` method for the first test.\x0aAs that method develops and more `#test...` methods are added, you will find yourself refactoring temps\x0ainto instance variables for the objects in the fixture and overriding `#setUp` to initialize these variables.\x0aAs required, override `#tearDown` to nil references, release objects and deallocate.";
$core.addMethod(
$core.method({
selector: "assert:",
protocol: 'testing',
fn: function (aBoolean){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_description_(aBoolean,"Assertion failed");
return self;
}, function($ctx1) {$ctx1.fill(self,"assert:",{aBoolean:aBoolean},$globals.TestCase)});
},
args: ["aBoolean"],
source: "assert: aBoolean\x0a\x09self assert: aBoolean description: 'Assertion failed'",
referencedClasses: [],
messageSends: ["assert:description:"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "assert:description:",
protocol: 'testing',
fn: function (aBoolean,aString){
var self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert(aBoolean)){
self._signalFailure_(aString);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"assert:description:",{aBoolean:aBoolean,aString:aString},$globals.TestCase)});
},
args: ["aBoolean", "aString"],
source: "assert: aBoolean description: aString\x0a\x09aBoolean ifFalse: [ self signalFailure: aString ]",
referencedClasses: [],
messageSends: ["ifFalse:", "signalFailure:"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "assert:equals:",
protocol: 'testing',
fn: function (actual,expected){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$5,$4,$3,$2;
$1=$recv(actual).__eq(expected);
$5=$recv(expected)._printString();
$ctx1.sendIdx["printString"]=1;
$4="Expected: ".__comma($5);
$3=$recv($4).__comma(" but was: ");
$ctx1.sendIdx[","]=2;
$2=$recv($3).__comma($recv(actual)._printString());
$ctx1.sendIdx[","]=1;
return self._assert_description_($1,$2);
}, function($ctx1) {$ctx1.fill(self,"assert:equals:",{actual:actual,expected:expected},$globals.TestCase)});
},
args: ["actual", "expected"],
source: "assert: actual equals: expected\x0a\x09^ self assert: (actual = expected) description: 'Expected: ', expected printString, ' but was: ', actual printString",
referencedClasses: [],
messageSends: ["assert:description:", "=", ",", "printString"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "async:",
protocol: 'async',
fn: function (aBlock){
var self=this;
var c;
return $core.withContext(function($ctx1) {
var $1;
self._errorIfNotAsync_("#async");
c=self["@context"];
return (function(){
return $core.withContext(function($ctx2) {
$1=self._isAsync();
if($core.assert($1)){
return $recv(c)._execute_(aBlock);
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
});
}, function($ctx1) {$ctx1.fill(self,"async:",{aBlock:aBlock,c:c},$globals.TestCase)});
},
args: ["aBlock"],
source: "async: aBlock\x0a\x09| c |\x0a\x09self errorIfNotAsync: '#async'.\x0a\x09c := context.\x0a\x09^ [ self isAsync ifTrue: [ c execute: aBlock ] ]",
referencedClasses: [],
messageSends: ["errorIfNotAsync:", "ifTrue:", "isAsync", "execute:"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "context:",
protocol: 'accessing',
fn: function (aRunningTestContext){
var self=this;
self["@context"]=aRunningTestContext;
return self;

},
args: ["aRunningTestContext"],
source: "context: aRunningTestContext\x0a\x09context := aRunningTestContext",
referencedClasses: [],
messageSends: []
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "deny:",
protocol: 'testing',
fn: function (aBoolean){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_($recv(aBoolean)._not());
return self;
}, function($ctx1) {$ctx1.fill(self,"deny:",{aBoolean:aBoolean},$globals.TestCase)});
},
args: ["aBoolean"],
source: "deny: aBoolean\x0a\x09self assert: aBoolean not",
referencedClasses: [],
messageSends: ["assert:", "not"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "errorIfNotAsync:",
protocol: 'error handling',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._isAsync();
if(!$core.assert($1)){
self._error_($recv(aString).__comma(" used without prior #timeout:"));
};
return self;
}, function($ctx1) {$ctx1.fill(self,"errorIfNotAsync:",{aString:aString},$globals.TestCase)});
},
args: ["aString"],
source: "errorIfNotAsync: aString\x0a\x09self isAsync ifFalse: [\x0a\x09\x09self error: aString, ' used without prior #timeout:' ]",
referencedClasses: [],
messageSends: ["ifFalse:", "isAsync", "error:", ","]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "finished",
protocol: 'async',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._errorIfNotAsync_("#finished");
self["@asyncTimeout"]=nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"finished",{},$globals.TestCase)});
},
args: [],
source: "finished\x0a\x09self errorIfNotAsync: '#finished'.\x0a\x09asyncTimeout := nil",
referencedClasses: [],
messageSends: ["errorIfNotAsync:"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "isAsync",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@asyncTimeout"])._notNil();
}, function($ctx1) {$ctx1.fill(self,"isAsync",{},$globals.TestCase)});
},
args: [],
source: "isAsync\x0a\x09^ asyncTimeout notNil",
referencedClasses: [],
messageSends: ["notNil"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "performTest",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@asyncTimeout"]=nil;
self._perform_(self._selector());
return self;
}, function($ctx1) {$ctx1.fill(self,"performTest",{},$globals.TestCase)});
},
args: [],
source: "performTest\x0a\x09asyncTimeout := nil.\x0a\x09self perform: self selector",
referencedClasses: [],
messageSends: ["perform:", "selector"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "runCase",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.TestContext)._testCase_(self))._start();
return self;
}, function($ctx1) {$ctx1.fill(self,"runCase",{},$globals.TestCase)});
},
args: [],
source: "runCase\x0a\x09\x22Runs a test case in isolated context, leaking all errors.\x22\x0a\x0a\x09(TestContext testCase: self) start",
referencedClasses: ["TestContext"],
messageSends: ["start", "testCase:"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "selector",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@testSelector"];

},
args: [],
source: "selector\x0a\x09^ testSelector",
referencedClasses: [],
messageSends: []
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "setTestSelector:",
protocol: 'accessing',
fn: function (aSelector){
var self=this;
self["@testSelector"]=aSelector;
return self;

},
args: ["aSelector"],
source: "setTestSelector: aSelector\x0a\x09testSelector := aSelector",
referencedClasses: [],
messageSends: []
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "setUp",
protocol: 'running',
fn: function (){
var self=this;
return self;

},
args: [],
source: "setUp",
referencedClasses: [],
messageSends: []
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "should:",
protocol: 'testing',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_($recv(aBlock)._value());
return self;
}, function($ctx1) {$ctx1.fill(self,"should:",{aBlock:aBlock},$globals.TestCase)});
},
args: ["aBlock"],
source: "should: aBlock\x0a\x09self assert: aBlock value",
referencedClasses: [],
messageSends: ["assert:", "value"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "should:raise:",
protocol: 'testing',
fn: function (aBlock,anExceptionClass){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_($recv((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value();
return false;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_(anExceptionClass,(function(ex){
return true;

})));
return self;
}, function($ctx1) {$ctx1.fill(self,"should:raise:",{aBlock:aBlock,anExceptionClass:anExceptionClass},$globals.TestCase)});
},
args: ["aBlock", "anExceptionClass"],
source: "should: aBlock raise: anExceptionClass\x0a\x09self assert: ([ aBlock value. false ]\x0a\x09\x09on: anExceptionClass\x0a\x09\x09do: [ :ex | true ])",
referencedClasses: [],
messageSends: ["assert:", "on:do:", "value"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "shouldnt:raise:",
protocol: 'testing',
fn: function (aBlock,anExceptionClass){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_($recv((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value();
return true;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_(anExceptionClass,(function(ex){
return false;

})));
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldnt:raise:",{aBlock:aBlock,anExceptionClass:anExceptionClass},$globals.TestCase)});
},
args: ["aBlock", "anExceptionClass"],
source: "shouldnt: aBlock raise: anExceptionClass\x0a\x09self assert: ([ aBlock value. true ]\x0a\x09\x09on: anExceptionClass\x0a\x09\x09do: [ :ex | false ])",
referencedClasses: [],
messageSends: ["assert:", "on:do:", "value"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "signalFailure:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.TestFailure)._new();
$recv($1)._messageText_(aString);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"signalFailure:",{aString:aString},$globals.TestCase)});
},
args: ["aString"],
source: "signalFailure: aString\x0a\x09TestFailure new\x0a\x09\x09messageText: aString;\x0a\x09\x09signal",
referencedClasses: ["TestFailure"],
messageSends: ["messageText:", "new", "signal"]
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: 'running',
fn: function (){
var self=this;
return self;

},
args: [],
source: "tearDown",
referencedClasses: [],
messageSends: []
}),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "timeout:",
protocol: 'async',
fn: function (aNumber){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@asyncTimeout"];
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
$recv(self["@asyncTimeout"])._clearTimeout();
};
self["@asyncTimeout"]=(0);
self["@asyncTimeout"]=$recv(self._async_((function(){
return $core.withContext(function($ctx2) {
return self._assert_description_(false,"SUnit grace time exhausted");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
})))._valueWithTimeout_(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"timeout:",{aNumber:aNumber},$globals.TestCase)});
},
args: ["aNumber"],
source: "timeout: aNumber\x0a\x09\x22Set a grace time timeout in milliseconds to run the test asynchronously\x22\x0a\x09\x0a\x09asyncTimeout ifNotNil: [ asyncTimeout clearTimeout ].\x0a\x09\x0a\x09\x22to allow #async: message send without throwing an error\x22\x0a\x09asyncTimeout := 0.\x0a\x09\x0a\x09asyncTimeout := (self async: [\x0a\x09\x09self assert: false description: 'SUnit grace time exhausted' ])\x0a\x09\x09\x09valueWithTimeout: aNumber",
referencedClasses: [],
messageSends: ["ifNotNil:", "clearTimeout", "valueWithTimeout:", "async:", "assert:description:"]
}),
$globals.TestCase);


$core.addMethod(
$core.method({
selector: "allTestSelectors",
protocol: 'accessing',
fn: function (){
var self=this;
var selectors;
return $core.withContext(function($ctx1) {
var $1;
selectors=self._testSelectors();
$1=self._shouldInheritSelectors();
if($core.assert($1)){
$recv(selectors)._addAll_($recv(self._superclass())._allTestSelectors());
};
return selectors;
}, function($ctx1) {$ctx1.fill(self,"allTestSelectors",{selectors:selectors},$globals.TestCase.klass)});
},
args: [],
source: "allTestSelectors\x0a\x09| selectors |\x0a\x09selectors := self testSelectors.\x0a\x09self shouldInheritSelectors ifTrue: [\x0a\x09\x09selectors addAll: self superclass allTestSelectors ].\x0a\x09^ selectors",
referencedClasses: [],
messageSends: ["testSelectors", "ifTrue:", "shouldInheritSelectors", "addAll:", "allTestSelectors", "superclass"]
}),
$globals.TestCase.klass);

$core.addMethod(
$core.method({
selector: "buildSuite",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._allTestSelectors())._collect_((function(each){
return $core.withContext(function($ctx2) {
return self._selector_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"buildSuite",{},$globals.TestCase.klass)});
},
args: [],
source: "buildSuite\x0a\x09^ self allTestSelectors collect: [ :each | self selector: each ]",
referencedClasses: [],
messageSends: ["collect:", "allTestSelectors", "selector:"]
}),
$globals.TestCase.klass);

$core.addMethod(
$core.method({
selector: "classTag",
protocol: 'accessing',
fn: function (){
var self=this;
return "test";

},
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'test'",
referencedClasses: [],
messageSends: []
}),
$globals.TestCase.klass);

$core.addMethod(
$core.method({
selector: "isAbstract",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._name()).__eq("TestCase");
}, function($ctx1) {$ctx1.fill(self,"isAbstract",{},$globals.TestCase.klass)});
},
args: [],
source: "isAbstract\x0a\x09^ self name = 'TestCase'",
referencedClasses: [],
messageSends: ["=", "name"]
}),
$globals.TestCase.klass);

$core.addMethod(
$core.method({
selector: "lookupHierarchyRoot",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.TestCase;

},
args: [],
source: "lookupHierarchyRoot\x0a\x09^ TestCase",
referencedClasses: ["TestCase"],
messageSends: []
}),
$globals.TestCase.klass);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: 'accessing',
fn: function (aSelector){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._setTestSelector_(aSelector);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"selector:",{aSelector:aSelector},$globals.TestCase.klass)});
},
args: ["aSelector"],
source: "selector: aSelector\x0a\x09^ self new\x0a\x09\x09setTestSelector: aSelector;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["setTestSelector:", "new", "yourself"]
}),
$globals.TestCase.klass);

$core.addMethod(
$core.method({
selector: "shouldInheritSelectors",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return self.__tild_eq(self._lookupHierarchyRoot());
}, function($ctx1) {$ctx1.fill(self,"shouldInheritSelectors",{},$globals.TestCase.klass)});
},
args: [],
source: "shouldInheritSelectors\x0a\x09^ self ~= self lookupHierarchyRoot",
referencedClasses: [],
messageSends: ["~=", "lookupHierarchyRoot"]
}),
$globals.TestCase.klass);

$core.addMethod(
$core.method({
selector: "testSelectors",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._methodDictionary())._keys())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._match_("^test");
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"testSelectors",{},$globals.TestCase.klass)});
},
args: [],
source: "testSelectors\x0a\x09^ self methodDictionary keys select: [ :each | each match: '^test' ]",
referencedClasses: [],
messageSends: ["select:", "keys", "methodDictionary", "match:"]
}),
$globals.TestCase.klass);


$core.addClass('TestContext', $globals.Object, ['testCase'], 'SUnit');
$globals.TestContext.comment="I govern running a particular test case.\x0a\x0aMy main added value is `#execute:` method which runs a block as a part of test case (restores context, nilling it afterwards, cleaning/calling `#tearDown` as appropriate for sync/async scenario).";
$core.addMethod(
$core.method({
selector: "execute:",
protocol: 'running',
fn: function (aBlock){
var self=this;
var failed;
return $core.withContext(function($ctx1) {
var $1,$2;
$recv(self["@testCase"])._context_(self);
$ctx1.sendIdx["context:"]=1;
$recv((function(){
return $core.withContext(function($ctx2) {
failed=true;
failed;
$recv(aBlock)._value();
failed=false;
return failed;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._ensure_((function(){
return $core.withContext(function($ctx2) {
$recv(self["@testCase"])._context_(nil);
$1=$recv(failed)._and_((function(){
return $core.withContext(function($ctx3) {
return $recv(self["@testCase"])._isAsync();
$ctx3.sendIdx["isAsync"]=1;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
if($core.assert($1)){
$recv(self["@testCase"])._finished();
};
$2=$recv(self["@testCase"])._isAsync();
if(!$core.assert($2)){
return $recv(self["@testCase"])._tearDown();
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"execute:",{aBlock:aBlock,failed:failed},$globals.TestContext)});
},
args: ["aBlock"],
source: "execute: aBlock\x0a\x09| failed |\x0a\x09\x0a\x09testCase context: self.\x0a\x09[\x0a\x09\x09failed := true.\x0a\x09\x09aBlock value.\x0a\x09\x09failed := false\x0a\x09]\x0a\x09\x09ensure: [\x0a\x09\x09\x09testCase context: nil.\x0a\x09\x09\x09\x0a\x09\x09\x09(failed and: [ testCase isAsync ]) ifTrue: [\x0a\x09\x09\x09\x09testCase finished ].\x0a\x09\x09\x09testCase isAsync ifFalse: [\x0a\x09\x09\x09\x09testCase tearDown ] ]",
referencedClasses: [],
messageSends: ["context:", "ensure:", "value", "ifTrue:", "and:", "isAsync", "finished", "ifFalse:", "tearDown"]
}),
$globals.TestContext);

$core.addMethod(
$core.method({
selector: "start",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._execute_((function(){
return $core.withContext(function($ctx2) {
$recv(self["@testCase"])._setUp();
return $recv(self["@testCase"])._performTest();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"start",{},$globals.TestContext)});
},
args: [],
source: "start\x0a\x09self execute: [\x0a\x09\x09testCase setUp.\x0a\x09\x09testCase performTest ]",
referencedClasses: [],
messageSends: ["execute:", "setUp", "performTest"]
}),
$globals.TestContext);

$core.addMethod(
$core.method({
selector: "testCase:",
protocol: 'accessing',
fn: function (aTestCase){
var self=this;
self["@testCase"]=aTestCase;
return self;

},
args: ["aTestCase"],
source: "testCase: aTestCase\x0a\x09testCase := aTestCase",
referencedClasses: [],
messageSends: []
}),
$globals.TestContext);


$core.addMethod(
$core.method({
selector: "testCase:",
protocol: 'instance creation',
fn: function (aTestCase){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._new();
$recv($1)._testCase_(aTestCase);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"testCase:",{aTestCase:aTestCase},$globals.TestContext.klass)});
},
args: ["aTestCase"],
source: "testCase: aTestCase\x0a\x09^ self new\x0a\x09\x09testCase: aTestCase;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["testCase:", "new", "yourself"]
}),
$globals.TestContext.klass);


$core.addClass('ReportingTestContext', $globals.TestContext, ['finished', 'result'], 'SUnit');
$globals.ReportingTestContext.comment="I add `TestResult` reporting to `TestContext`.\x0a\x0aErrors are caught and save into a `TestResult`,\x0aWhen test case is finished (which can be later for async tests), a callback block is executed; this is used by a `TestSuiteRunner`.";
$core.addMethod(
$core.method({
selector: "execute:",
protocol: 'running',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv((function(){
return $core.withContext(function($ctx2) {
return self._withErrorReporting_((function(){
return $core.withContext(function($ctx3) {
return (
$ctx3.supercall = true,
($globals.ReportingTestContext.superclass||$boot.dnu).fn.prototype._execute_.apply($recv(self), [aBlock]));
$ctx3.supercall = false;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._ensure_((function(){
return $core.withContext(function($ctx2) {
$1=$recv(self["@testCase"])._isAsync();
if(!$core.assert($1)){
$recv(self["@result"])._increaseRuns();
return $recv(self["@finished"])._value();
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"execute:",{aBlock:aBlock},$globals.ReportingTestContext)});
},
args: ["aBlock"],
source: "execute: aBlock\x0a\x09[\x0a\x09\x09self withErrorReporting: [ super execute: aBlock ]\x0a\x09]\x0a\x09\x09ensure: [\x0a\x09\x09\x09testCase isAsync ifFalse: [\x0a\x09\x09\x09\x09result increaseRuns. finished value ] ]",
referencedClasses: [],
messageSends: ["ensure:", "withErrorReporting:", "execute:", "ifFalse:", "isAsync", "increaseRuns", "value"]
}),
$globals.ReportingTestContext);

$core.addMethod(
$core.method({
selector: "finished:",
protocol: 'accessing',
fn: function (aBlock){
var self=this;
self["@finished"]=aBlock;
return self;

},
args: ["aBlock"],
source: "finished: aBlock\x0a\x09finished := aBlock",
referencedClasses: [],
messageSends: []
}),
$globals.ReportingTestContext);

$core.addMethod(
$core.method({
selector: "result:",
protocol: 'accessing',
fn: function (aTestResult){
var self=this;
self["@result"]=aTestResult;
return self;

},
args: ["aTestResult"],
source: "result: aTestResult\x0a\x09result := aTestResult",
referencedClasses: [],
messageSends: []
}),
$globals.ReportingTestContext);

$core.addMethod(
$core.method({
selector: "withErrorReporting:",
protocol: 'private',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._on_do_($globals.TestFailure,(function(ex){
return $core.withContext(function($ctx3) {
return $recv(self["@result"])._addFailure_(self["@testCase"]);
}, function($ctx3) {$ctx3.fillBlock({ex:ex},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx2) {
return $recv(self["@result"])._addError_(self["@testCase"]);
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,3)});
}));
$ctx1.sendIdx["on:do:"]=1;
return self;
}, function($ctx1) {$ctx1.fill(self,"withErrorReporting:",{aBlock:aBlock},$globals.ReportingTestContext)});
},
args: ["aBlock"],
source: "withErrorReporting: aBlock\x0a\x09[ aBlock\x0a\x09\x09on: TestFailure\x0a\x09\x09do: [ :ex | result addFailure: testCase ]\x0a\x09]\x0a\x09\x09on: Error\x0a\x09\x09do: [ :ex | result addError: testCase ]",
referencedClasses: ["TestFailure", "Error"],
messageSends: ["on:do:", "addFailure:", "addError:"]
}),
$globals.ReportingTestContext);


$core.addMethod(
$core.method({
selector: "testCase:result:finished:",
protocol: 'instance creation',
fn: function (aTestCase,aTestResult,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=(
$ctx1.supercall = true,
($globals.ReportingTestContext.klass.superclass||$boot.dnu).fn.prototype._testCase_.apply($recv(self), [aTestCase]));
$ctx1.supercall = false;
$recv($1)._result_(aTestResult);
$recv($1)._finished_(aBlock);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"testCase:result:finished:",{aTestCase:aTestCase,aTestResult:aTestResult,aBlock:aBlock},$globals.ReportingTestContext.klass)});
},
args: ["aTestCase", "aTestResult", "aBlock"],
source: "testCase: aTestCase result: aTestResult finished: aBlock\x0a\x09^ (super testCase: aTestCase)\x0a\x09\x09result: aTestResult;\x0a\x09\x09finished: aBlock;\x0a\x09\x09yourself",
referencedClasses: [],
messageSends: ["result:", "testCase:", "finished:", "yourself"]
}),
$globals.ReportingTestContext.klass);


$core.addClass('TestFailure', $globals.Error, [], 'SUnit');
$globals.TestFailure.comment="I am raised when the boolean parameter of an #`assert:` or `#deny:` call is the opposite of what the assertion claims.\x0a\x0aThe test framework distinguishes between failures and errors.\x0aA failure is an event whose possibiity is explicitly anticipated and checked for in an assertion,\x0awhereas an error is an unanticipated problem like a division by 0 or an index out of bounds.";


$core.addClass('TestResult', $globals.Object, ['timestamp', 'runs', 'errors', 'failures', 'total'], 'SUnit');
$globals.TestResult.comment="I implement the collecting parameter pattern for running a bunch of tests.\x0a\x0aMy instances hold tests that have run, sorted into the result categories of passed, failures and errors.\x0a\x0a`TestResult` is an interesting object to subclass or substitute. `#runCase:` is the external protocol you need to reproduce";
$core.addMethod(
$core.method({
selector: "addError:",
protocol: 'accessing',
fn: function (anError){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._errors())._add_(anError);
return self;
}, function($ctx1) {$ctx1.fill(self,"addError:",{anError:anError},$globals.TestResult)});
},
args: ["anError"],
source: "addError: anError\x0a\x09self errors add: anError",
referencedClasses: [],
messageSends: ["add:", "errors"]
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "addFailure:",
protocol: 'accessing',
fn: function (aFailure){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._failures())._add_(aFailure);
return self;
}, function($ctx1) {$ctx1.fill(self,"addFailure:",{aFailure:aFailure},$globals.TestResult)});
},
args: ["aFailure"],
source: "addFailure: aFailure\x0a\x09self failures add: aFailure",
referencedClasses: [],
messageSends: ["add:", "failures"]
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "errors",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@errors"];

},
args: [],
source: "errors\x0a\x09^ errors",
referencedClasses: [],
messageSends: []
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "failures",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@failures"];

},
args: [],
source: "failures\x0a\x09^ failures",
referencedClasses: [],
messageSends: []
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "increaseRuns",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@runs"]=$recv(self["@runs"]).__plus((1));
return self;
}, function($ctx1) {$ctx1.fill(self,"increaseRuns",{},$globals.TestResult)});
},
args: [],
source: "increaseRuns\x0a\x09runs := runs + 1",
referencedClasses: [],
messageSends: ["+"]
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.TestResult.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@timestamp"]=$recv($globals.Date)._now();
self["@runs"]=(0);
self["@errors"]=$recv($globals.Array)._new();
$ctx1.sendIdx["new"]=1;
self["@failures"]=$recv($globals.Array)._new();
self["@total"]=(0);
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.TestResult)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09timestamp := Date now.\x0a\x09runs := 0.\x0a\x09errors := Array new.\x0a\x09failures := Array new.\x0a\x09total := 0",
referencedClasses: ["Date", "Array"],
messageSends: ["initialize", "now", "new"]
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "nextRunDo:",
protocol: 'running',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=self._runs();
$ctx1.sendIdx["runs"]=1;
$1=$recv($2).__eq_eq(self._total());
if(!$core.assert($1)){
return $recv(aBlock)._value_($recv(self._runs()).__plus((1)));
};
}, function($ctx1) {$ctx1.fill(self,"nextRunDo:",{aBlock:aBlock},$globals.TestResult)});
},
args: ["aBlock"],
source: "nextRunDo: aBlock\x0a\x09\x22Runs aBlock with index of next run or does nothing if no more runs\x22\x0a\x09^ self runs == self total\x0a\x09\x09ifFalse: [ aBlock value: self runs + 1 ]",
referencedClasses: [],
messageSends: ["ifFalse:", "==", "runs", "total", "value:", "+"]
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "runCase:",
protocol: 'running',
fn: function (aTestCase){
var self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv((function(){
return $core.withContext(function($ctx3) {
self._increaseRuns();
return $recv(aTestCase)._runCase();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._on_do_($globals.TestFailure,(function(ex){
return $core.withContext(function($ctx3) {
return self._addFailure_(aTestCase);
}, function($ctx3) {$ctx3.fillBlock({ex:ex},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx2) {
return self._addError_(aTestCase);
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,4)});
}));
$ctx1.sendIdx["on:do:"]=1;
return self;
}, function($ctx1) {$ctx1.fill(self,"runCase:",{aTestCase:aTestCase},$globals.TestResult)});
},
args: ["aTestCase"],
source: "runCase: aTestCase\x0a\x09[ [ self increaseRuns.\x0a\x09\x09aTestCase runCase ]\x0a\x09on: TestFailure do: [ :ex | self addFailure: aTestCase ]]\x0a\x09on: Error do: [ :ex | self addError: aTestCase ]",
referencedClasses: ["TestFailure", "Error"],
messageSends: ["on:do:", "increaseRuns", "runCase", "addFailure:", "addError:"]
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "runs",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@runs"];

},
args: [],
source: "runs\x0a\x09^ runs",
referencedClasses: [],
messageSends: []
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "status",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1;
$2=$recv(self._errors())._isEmpty();
$ctx1.sendIdx["isEmpty"]=1;
if($core.assert($2)){
$3=$recv(self._failures())._isEmpty();
if($core.assert($3)){
$1="success";
} else {
$1="failure";
};
} else {
$1="error";
};
return $1;
}, function($ctx1) {$ctx1.fill(self,"status",{},$globals.TestResult)});
},
args: [],
source: "status\x0a\x09^ self errors isEmpty\x0a\x09\x09ifTrue: [\x0a\x09\x09\x09self failures isEmpty\x0a\x09\x09\x09\x09ifTrue: [ 'success' ]\x0a\x09\x09\x09\x09ifFalse: [ 'failure' ]]\x0a\x09\x09ifFalse: [ 'error' ]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "isEmpty", "errors", "failures"]
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "timestamp",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@timestamp"];

},
args: [],
source: "timestamp\x0a\x09^ timestamp",
referencedClasses: [],
messageSends: []
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "total",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@total"];

},
args: [],
source: "total\x0a\x09^ total",
referencedClasses: [],
messageSends: []
}),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "total:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
self["@total"]=aNumber;
return self;

},
args: ["aNumber"],
source: "total: aNumber\x0a\x09total := aNumber",
referencedClasses: [],
messageSends: []
}),
$globals.TestResult);



$core.addClass('TestSuiteRunner', $globals.Object, ['suite', 'result', 'announcer', 'runNextTest'], 'SUnit');
$globals.TestSuiteRunner.comment="I am responsible for running a collection (`suite`) of tests.\x0a\x0a## API\x0a\x0aInstances should be created using the class-side `#on:` method, taking a collection of tests to run as parameter.\x0aTo run the test suite, use `#run`.";
$core.addMethod(
$core.method({
selector: "announcer",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@announcer"];

},
args: [],
source: "announcer\x0a\x09^ announcer",
referencedClasses: [],
messageSends: []
}),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "contextOf:",
protocol: 'private',
fn: function (anInteger){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.ReportingTestContext)._testCase_result_finished_($recv(self["@suite"])._at_(anInteger),self["@result"],(function(){
return $core.withContext(function($ctx2) {
return self._resume();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"contextOf:",{anInteger:anInteger},$globals.TestSuiteRunner)});
},
args: ["anInteger"],
source: "contextOf: anInteger\x0a\x09^ ReportingTestContext testCase: (suite at: anInteger) result: result finished: [ self resume ]",
referencedClasses: ["ReportingTestContext"],
messageSends: ["testCase:result:finished:", "at:", "resume"]
}),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
(
$ctx1.supercall = true,
($globals.TestSuiteRunner.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@announcer"]=$recv($globals.Announcer)._new();
$ctx1.sendIdx["new"]=1;
self["@result"]=$recv($globals.TestResult)._new();
self["@runNextTest"]=(function(){
var runs;
return $core.withContext(function($ctx2) {
runs=$recv(self["@result"])._runs();
runs;
$1=$recv(runs).__lt($recv(self["@result"])._total());
if($core.assert($1)){
return $recv(self._contextOf_($recv(runs).__plus((1))))._start();
};
}, function($ctx2) {$ctx2.fillBlock({runs:runs},$ctx1,1)});
});
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.TestSuiteRunner)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09announcer := Announcer new.\x0a\x09result := TestResult new.\x0a\x09runNextTest := [ | runs | runs := result runs. runs < result total ifTrue: [ (self contextOf: runs + 1) start ] ].",
referencedClasses: ["Announcer", "TestResult"],
messageSends: ["initialize", "new", "runs", "ifTrue:", "<", "total", "start", "contextOf:", "+"]
}),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "result",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@result"];

},
args: [],
source: "result\x0a\x09^ result",
referencedClasses: [],
messageSends: []
}),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "resume",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@runNextTest"])._fork();
$recv(self["@announcer"])._announce_($recv($recv($globals.ResultAnnouncement)._new())._result_(self["@result"]));
return self;
}, function($ctx1) {$ctx1.fill(self,"resume",{},$globals.TestSuiteRunner)});
},
args: [],
source: "resume\x0a\x09runNextTest fork.\x0a\x09announcer announce: (ResultAnnouncement new result: result)",
referencedClasses: ["ResultAnnouncement"],
messageSends: ["fork", "announce:", "result:", "new"]
}),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "run",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@result"])._total_($recv(self["@suite"])._size());
self._resume();
return self;
}, function($ctx1) {$ctx1.fill(self,"run",{},$globals.TestSuiteRunner)});
},
args: [],
source: "run\x0a\x09result total: suite size.\x0a\x09self resume",
referencedClasses: [],
messageSends: ["total:", "size", "resume"]
}),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "suite:",
protocol: 'accessing',
fn: function (aCollection){
var self=this;
self["@suite"]=aCollection;
return self;

},
args: ["aCollection"],
source: "suite: aCollection\x0a\x09suite := aCollection",
referencedClasses: [],
messageSends: []
}),
$globals.TestSuiteRunner);


$core.addMethod(
$core.method({
selector: "new",
protocol: 'instance creation',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._shouldNotImplement();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{},$globals.TestSuiteRunner.klass)});
},
args: [],
source: "new\x0a\x09self shouldNotImplement",
referencedClasses: [],
messageSends: ["shouldNotImplement"]
}),
$globals.TestSuiteRunner.klass);

$core.addMethod(
$core.method({
selector: "on:",
protocol: 'instance creation',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=(
$ctx1.supercall = true,
($globals.TestSuiteRunner.klass.superclass||$boot.dnu).fn.prototype._new.apply($recv(self), []));
$ctx1.supercall = false;
return $recv($1)._suite_(aCollection);
}, function($ctx1) {$ctx1.fill(self,"on:",{aCollection:aCollection},$globals.TestSuiteRunner.klass)});
},
args: ["aCollection"],
source: "on: aCollection\x0a\x09^ super new suite: aCollection",
referencedClasses: [],
messageSends: ["suite:", "new"]
}),
$globals.TestSuiteRunner.klass);

$core.addMethod(
$core.method({
selector: "isTestClass",
protocol: '*SUnit',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._includesBehavior_($globals.TestCase))._and_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._isAbstract())._not();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"isTestClass",{},$globals.Behavior)});
},
args: [],
source: "isTestClass\x0a\x09^(self includesBehavior: TestCase) and: [ \x0a\x09\x09\x09self isAbstract not ]",
referencedClasses: ["TestCase"],
messageSends: ["and:", "includesBehavior:", "not", "isAbstract"]
}),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "isTestPackage",
protocol: '*SUnit',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._classes())._anySatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._isTestClass();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"isTestPackage",{},$globals.Package)});
},
args: [],
source: "isTestPackage\x0a\x09^ self classes anySatisfy: [ :each | each isTestClass ]",
referencedClasses: [],
messageSends: ["anySatisfy:", "classes", "isTestClass"]
}),
$globals.Package);

});

define("amber_core/Compiler-Tests", ["amber/boot", "amber_core/SUnit"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Compiler-Tests');
$core.packages["Compiler-Tests"].innerEval = function (expr) { return eval(expr); };
$core.packages["Compiler-Tests"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('ASTParsingTest', $globals.TestCase, [], 'Compiler-Tests');
$core.addMethod(
$core.method({
selector: "analyze:forClass:",
protocol: 'convenience',
fn: function (aNode,aClass){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.SemanticAnalyzer)._on_(aClass))._visit_(aNode);
return aNode;
}, function($ctx1) {$ctx1.fill(self,"analyze:forClass:",{aNode:aNode,aClass:aClass},$globals.ASTParsingTest)});
},
args: ["aNode", "aClass"],
source: "analyze: aNode forClass: aClass\x0a\x09(SemanticAnalyzer on: aClass) visit: aNode.\x0a\x09^ aNode",
referencedClasses: ["SemanticAnalyzer"],
messageSends: ["visit:", "on:"]
}),
$globals.ASTParsingTest);

$core.addMethod(
$core.method({
selector: "parse:",
protocol: 'parsing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._parse_(aString);
}, function($ctx1) {$ctx1.fill(self,"parse:",{aString:aString},$globals.ASTParsingTest)});
},
args: ["aString"],
source: "parse: aString\x0a\x09^ Smalltalk parse: aString",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:"]
}),
$globals.ASTParsingTest);

$core.addMethod(
$core.method({
selector: "parse:forClass:",
protocol: 'parsing',
fn: function (aString,aClass){
var self=this;
return $core.withContext(function($ctx1) {
return self._analyze_forClass_(self._parse_(aString),aClass);
}, function($ctx1) {$ctx1.fill(self,"parse:forClass:",{aString:aString,aClass:aClass},$globals.ASTParsingTest)});
},
args: ["aString", "aClass"],
source: "parse: aString forClass: aClass\x0a\x09^ self analyze: (self parse: aString) forClass: aClass",
referencedClasses: [],
messageSends: ["analyze:forClass:", "parse:"]
}),
$globals.ASTParsingTest);



$core.addClass('ASTPCNodeVisitorTest', $globals.ASTParsingTest, [], 'Compiler-Tests');
$core.addMethod(
$core.method({
selector: "astPCNodeVisitor",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv($globals.ASTPCNodeVisitor)._new();
$ctx1.sendIdx["new"]=1;
$2=$recv($recv($globals.AIContext)._new())._yourself();
$ctx1.sendIdx["yourself"]=1;
$recv($1)._context_($2);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"astPCNodeVisitor",{},$globals.ASTPCNodeVisitorTest)});
},
args: [],
source: "astPCNodeVisitor\x0a\x09^ ASTPCNodeVisitor new\x0a\x09\x09context: (AIContext new\x0a\x09\x09\x09yourself);\x0a\x09\x09yourself",
referencedClasses: ["ASTPCNodeVisitor", "AIContext"],
messageSends: ["context:", "new", "yourself"]
}),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "astPCNodeVisitorForSelector:",
protocol: 'factory',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv($globals.ASTPCNodeVisitor)._new();
$ctx1.sendIdx["new"]=1;
$recv($1)._selector_(aString);
$2=$recv($recv($globals.AIContext)._new())._yourself();
$ctx1.sendIdx["yourself"]=1;
$recv($1)._context_($2);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"astPCNodeVisitorForSelector:",{aString:aString},$globals.ASTPCNodeVisitorTest)});
},
args: ["aString"],
source: "astPCNodeVisitorForSelector: aString\x0a\x09^ ASTPCNodeVisitor new\x0a\x09\x09selector: aString;\x0a\x09\x09context: (AIContext new\x0a\x09\x09\x09yourself);\x0a\x09\x09yourself",
referencedClasses: ["ASTPCNodeVisitor", "AIContext"],
messageSends: ["selector:", "new", "context:", "yourself"]
}),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testJSStatementNode",
protocol: 'tests',
fn: function (){
var self=this;
var ast,visitor;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
ast=self._parse_forClass_("foo <consolee.log(1)>",$globals.Object);
$3=self._astPCNodeVisitor();
$recv($3)._visit_(ast);
$2=$recv($3)._currentNode();
$1=$recv($2)._isJSStatementNode();
self._assert_($1);
return self;
}, function($ctx1) {$ctx1.fill(self,"testJSStatementNode",{ast:ast,visitor:visitor},$globals.ASTPCNodeVisitorTest)});
},
args: [],
source: "testJSStatementNode\x0a\x09| ast visitor |\x0a\x09\x0a\x09ast := self parse: 'foo <consolee.log(1)>' forClass: Object.\x0a\x09self assert: (self astPCNodeVisitor\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) isJSStatementNode",
referencedClasses: ["Object"],
messageSends: ["parse:forClass:", "assert:", "isJSStatementNode", "visit:", "astPCNodeVisitor", "currentNode"]
}),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testMessageSend",
protocol: 'tests',
fn: function (){
var self=this;
var ast;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
ast=self._parse_forClass_("foo self asString yourself. ^ self asBoolean",$globals.Object);
$3=self._astPCNodeVisitorForSelector_("yourself");
$recv($3)._visit_(ast);
$2=$recv($3)._currentNode();
$1=$recv($2)._selector();
self._assert_equals_($1,"yourself");
return self;
}, function($ctx1) {$ctx1.fill(self,"testMessageSend",{ast:ast},$globals.ASTPCNodeVisitorTest)});
},
args: [],
source: "testMessageSend\x0a\x09| ast |\x0a\x09\x0a\x09ast := self parse: 'foo self asString yourself. ^ self asBoolean' forClass: Object.\x0a\x09self assert: ((self astPCNodeVisitorForSelector: 'yourself')\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) selector equals: 'yourself'",
referencedClasses: ["Object"],
messageSends: ["parse:forClass:", "assert:equals:", "selector", "visit:", "astPCNodeVisitorForSelector:", "currentNode"]
}),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testMessageSendWithBlocks",
protocol: 'tests',
fn: function (){
var self=this;
var ast;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
ast=self._parse_forClass_("foo true ifTrue: [ [ self asString yourself ] value.  ]. ^ self asBoolean",$globals.Object);
$3=self._astPCNodeVisitorForSelector_("yourself");
$recv($3)._visit_(ast);
$2=$recv($3)._currentNode();
$1=$recv($2)._selector();
self._assert_equals_($1,"yourself");
return self;
}, function($ctx1) {$ctx1.fill(self,"testMessageSendWithBlocks",{ast:ast},$globals.ASTPCNodeVisitorTest)});
},
args: [],
source: "testMessageSendWithBlocks\x0a\x09| ast |\x0a\x09\x0a\x09ast := self parse: 'foo true ifTrue: [ [ self asString yourself ] value.  ]. ^ self asBoolean' forClass: Object.\x0a\x09self assert: ((self astPCNodeVisitorForSelector: 'yourself')\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) selector equals: 'yourself'",
referencedClasses: ["Object"],
messageSends: ["parse:forClass:", "assert:equals:", "selector", "visit:", "astPCNodeVisitorForSelector:", "currentNode"]
}),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testMessageSendWithInlining",
protocol: 'tests',
fn: function (){
var self=this;
var ast;
return $core.withContext(function($ctx1) {
var $3,$4,$2,$1,$7,$6,$5;
ast=self._parse_forClass_("foo true ifTrue: [ self asString yourself ]. ^ self asBoolean",$globals.Object);
$ctx1.sendIdx["parse:forClass:"]=1;
$3=self._astPCNodeVisitorForSelector_("yourself");
$ctx1.sendIdx["astPCNodeVisitorForSelector:"]=1;
$recv($3)._visit_(ast);
$ctx1.sendIdx["visit:"]=1;
$4=$recv($3)._currentNode();
$ctx1.sendIdx["currentNode"]=1;
$2=$4;
$1=$recv($2)._selector();
$ctx1.sendIdx["selector"]=1;
self._assert_equals_($1,"yourself");
$ctx1.sendIdx["assert:equals:"]=1;
ast=self._parse_forClass_("foo true ifTrue: [ self asString yourself ]. ^ self asBoolean",$globals.Object);
$7=self._astPCNodeVisitorForSelector_("asBoolean");
$recv($7)._visit_(ast);
$6=$recv($7)._currentNode();
$5=$recv($6)._selector();
self._assert_equals_($5,"asBoolean");
return self;
}, function($ctx1) {$ctx1.fill(self,"testMessageSendWithInlining",{ast:ast},$globals.ASTPCNodeVisitorTest)});
},
args: [],
source: "testMessageSendWithInlining\x0a\x09| ast |\x0a\x09\x0a\x09ast := self parse: 'foo true ifTrue: [ self asString yourself ]. ^ self asBoolean' forClass: Object.\x0a\x09self assert: ((self astPCNodeVisitorForSelector: 'yourself')\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) selector equals: 'yourself'.\x0a\x09\x09\x0a\x09ast := self parse: 'foo true ifTrue: [ self asString yourself ]. ^ self asBoolean' forClass: Object.\x0a\x09self assert: ((self astPCNodeVisitorForSelector: 'asBoolean')\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) selector equals: 'asBoolean'",
referencedClasses: ["Object"],
messageSends: ["parse:forClass:", "assert:equals:", "selector", "visit:", "astPCNodeVisitorForSelector:", "currentNode"]
}),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testNoMessageSend",
protocol: 'tests',
fn: function (){
var self=this;
var ast;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
ast=self._parse_forClass_("foo ^ self",$globals.Object);
$3=self._astPCNodeVisitor();
$recv($3)._visit_(ast);
$2=$recv($3)._currentNode();
$1=$recv($2)._isNil();
self._assert_($1);
return self;
}, function($ctx1) {$ctx1.fill(self,"testNoMessageSend",{ast:ast},$globals.ASTPCNodeVisitorTest)});
},
args: [],
source: "testNoMessageSend\x0a\x09| ast |\x0a\x09\x0a\x09ast := self parse: 'foo ^ self' forClass: Object.\x0a\x09self assert: (self astPCNodeVisitor\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) isNil",
referencedClasses: ["Object"],
messageSends: ["parse:forClass:", "assert:", "isNil", "visit:", "astPCNodeVisitor", "currentNode"]
}),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testPC",
protocol: 'tests',
fn: function (){
var self=this;
var ast,visitor;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
ast=self._parse_forClass_("foo <console.log(1)>",$globals.Object);
$3=self._astPCNodeVisitor();
$recv($3)._visit_(ast);
$2=$recv($3)._currentNode();
$1=$recv($2)._isJSStatementNode();
self._assert_($1);
return self;
}, function($ctx1) {$ctx1.fill(self,"testPC",{ast:ast,visitor:visitor},$globals.ASTPCNodeVisitorTest)});
},
args: [],
source: "testPC\x0a\x09| ast visitor |\x0a\x09\x0a\x09ast := self parse: 'foo <console.log(1)>' forClass: Object.\x0a\x09self assert: (self astPCNodeVisitor\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) isJSStatementNode",
referencedClasses: ["Object"],
messageSends: ["parse:forClass:", "assert:", "isJSStatementNode", "visit:", "astPCNodeVisitor", "currentNode"]
}),
$globals.ASTPCNodeVisitorTest);



$core.addClass('ASTPositionTest', $globals.ASTParsingTest, [], 'Compiler-Tests');
$core.addMethod(
$core.method({
selector: "testNodeAtPosition",
protocol: 'tests',
fn: function (){
var self=this;
var node;
return $core.withContext(function($ctx1) {
var $3,$4,$2,$1,$7,$8,$6,$5;
node=self._parse_("yourself\x0a\x09^ self");
$ctx1.sendIdx["parse:"]=1;
$3=node;
$4=(2).__at((4));
$ctx1.sendIdx["@"]=1;
$2=$recv($3)._navigationNodeAt_ifAbsent_($4,(function(){
return nil;

}));
$ctx1.sendIdx["navigationNodeAt:ifAbsent:"]=1;
$1=$recv($2)._source();
self._assert_equals_($1,"self");
$ctx1.sendIdx["assert:equals:"]=1;
node=self._parse_("foo\x0a\x09true ifTrue: [ 1 ]");
$ctx1.sendIdx["parse:"]=2;
$7=node;
$8=(2).__at((7));
$ctx1.sendIdx["@"]=2;
$6=$recv($7)._navigationNodeAt_ifAbsent_($8,(function(){
return nil;

}));
$ctx1.sendIdx["navigationNodeAt:ifAbsent:"]=2;
$5=$recv($6)._selector();
$ctx1.sendIdx["selector"]=1;
self._assert_equals_($5,"ifTrue:");
$ctx1.sendIdx["assert:equals:"]=2;
node=self._parse_("foo\x0a\x09self foo; bar; baz");
self._assert_equals_($recv($recv(node)._navigationNodeAt_ifAbsent_((2).__at((8)),(function(){
return nil;

})))._selector(),"foo");
return self;
}, function($ctx1) {$ctx1.fill(self,"testNodeAtPosition",{node:node},$globals.ASTPositionTest)});
},
args: [],
source: "testNodeAtPosition\x0a\x09| node |\x0a\x09\x0a\x09node := self parse: 'yourself\x0a\x09^ self'.\x0a\x09\x0a\x09self assert: (node navigationNodeAt: 2@4 ifAbsent: [ nil ]) source equals: 'self'.\x0a\x09\x0a\x09node := self parse: 'foo\x0a\x09true ifTrue: [ 1 ]'.\x0a\x09\x0a\x09self assert: (node navigationNodeAt: 2@7 ifAbsent: [ nil ]) selector equals: 'ifTrue:'.\x0a\x09\x0a\x09node := self parse: 'foo\x0a\x09self foo; bar; baz'.\x0a\x09\x0a\x09self assert: (node navigationNodeAt: 2@8 ifAbsent: [ nil ]) selector equals: 'foo'",
referencedClasses: [],
messageSends: ["parse:", "assert:equals:", "source", "navigationNodeAt:ifAbsent:", "@", "selector"]
}),
$globals.ASTPositionTest);



$core.addClass('CodeGeneratorTest', $globals.ASTParsingTest, ['receiver'], 'Compiler-Tests');
$core.addMethod(
$core.method({
selector: "codeGeneratorClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.CodeGenerator;

},
args: [],
source: "codeGeneratorClass\x0a\x09^ CodeGenerator",
referencedClasses: ["CodeGenerator"],
messageSends: []
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "compiler",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Compiler)._new();
$recv($1)._codeGeneratorClass_(self._codeGeneratorClass());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"compiler",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "compiler\x0a\x09^ Compiler new\x0a\x09\x09codeGeneratorClass: self codeGeneratorClass;\x0a\x09\x09yourself",
referencedClasses: ["Compiler"],
messageSends: ["codeGeneratorClass:", "new", "codeGeneratorClass", "yourself"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "setUp",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@receiver"]=$recv($globals.DoIt)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "setUp\x0a\x09receiver := DoIt new",
referencedClasses: ["DoIt"],
messageSends: ["new"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "should:receiver:raise:",
protocol: 'testing',
fn: function (aString,anObject,anErrorClass){
var self=this;
var method,result;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$receiver;
self["@receiver"]=anObject;
$recv((function(){
return $core.withContext(function($ctx2) {
return self._should_raise_((function(){
return $core.withContext(function($ctx3) {
$1=self._compiler();
$2=$recv(anObject)._class();
$ctx3.sendIdx["class"]=1;
method=$recv($1)._install_forClass_protocol_(aString,$2,"tests");
method;
return $recv(self["@receiver"])._perform_($recv(method)._selector());
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),anErrorClass);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._ensure_((function(){
return $core.withContext(function($ctx2) {
$3=method;
if(($receiver = $3) == null || $receiver.isNil){
return $3;
} else {
return $recv($recv(anObject)._class())._removeCompiledMethod_(method);
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"should:receiver:raise:",{aString:aString,anObject:anObject,anErrorClass:anErrorClass,method:method,result:result},$globals.CodeGeneratorTest)});
},
args: ["aString", "anObject", "anErrorClass"],
source: "should: aString receiver: anObject raise: anErrorClass\x0a\x09| method result |\x0a\x0a\x09receiver := anObject.\x0a\x09[ self should: [\x0a\x09\x09method := self compiler install: aString forClass: anObject class protocol: 'tests'.\x0a\x09\x09receiver perform: method selector ] raise: anErrorClass ]\x0a\x09ensure: [ method ifNotNil: [ anObject class removeCompiledMethod: method ] ]",
referencedClasses: [],
messageSends: ["ensure:", "should:raise:", "install:forClass:protocol:", "compiler", "class", "perform:", "selector", "ifNotNil:", "removeCompiledMethod:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "should:receiver:return:",
protocol: 'testing',
fn: function (aString,anObject,aResult){
var self=this;
var method,result;
return $core.withContext(function($ctx1) {
var $1,$2;
self["@receiver"]=anObject;
$1=self._compiler();
$2=$recv(anObject)._class();
$ctx1.sendIdx["class"]=1;
method=$recv($1)._install_forClass_protocol_(aString,$2,"tests");
result=$recv(self["@receiver"])._perform_($recv(method)._selector());
$recv($recv(anObject)._class())._removeCompiledMethod_(method);
self._assert_equals_(aResult,result);
return self;
}, function($ctx1) {$ctx1.fill(self,"should:receiver:return:",{aString:aString,anObject:anObject,aResult:aResult,method:method,result:result},$globals.CodeGeneratorTest)});
},
args: ["aString", "anObject", "aResult"],
source: "should: aString receiver: anObject return: aResult\x0a\x09| method result |\x0a\x0a\x09receiver := anObject.\x0a\x09method := self compiler install: aString forClass: anObject class protocol: 'tests'.\x0a\x09result := receiver perform: method selector.\x0a\x09anObject class removeCompiledMethod: method.\x0a\x09self assert: aResult equals: result",
referencedClasses: [],
messageSends: ["install:forClass:protocol:", "compiler", "class", "perform:", "selector", "removeCompiledMethod:", "assert:equals:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "should:return:",
protocol: 'testing',
fn: function (aString,anObject){
var self=this;
return $core.withContext(function($ctx1) {
return self._should_receiver_return_(aString,self["@receiver"],anObject);
}, function($ctx1) {$ctx1.fill(self,"should:return:",{aString:aString,anObject:anObject},$globals.CodeGeneratorTest)});
},
args: ["aString", "anObject"],
source: "should: aString return: anObject\x0a\x09^ self \x0a\x09\x09should: aString \x0a\x09\x09receiver: receiver \x0a\x09\x09return: anObject",
referencedClasses: [],
messageSends: ["should:receiver:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: 'initialization',
fn: function (){
var self=this;
return self;

},
args: [],
source: "tearDown\x0a\x09\x22receiver := nil\x22",
referencedClasses: [],
messageSends: []
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testAssignment",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo | a | a := true ifTrue: [ 1 ]. ^ a",(1));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo | a | a := false ifTrue: [ 1 ]. ^ a",nil);
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo | a | ^ a := true ifTrue: [ 1 ]",(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAssignment",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testAssignment\x0a\x09self should: 'foo | a | a := true ifTrue: [ 1 ]. ^ a' return: 1.\x0a\x09self should: 'foo | a | a := false ifTrue: [ 1 ]. ^ a' return: nil.\x0a\x0a\x09self should: 'foo | a | ^ a := true ifTrue: [ 1 ]' return: 1",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testBackslashSelectors",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("\x5c arg ^ 4",(4));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("\x5c\x5c arg ^ 42",(42));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBackslashSelectors",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testBackslashSelectors\x0a\x09\x0a\x09self should: '\x5c arg ^ 4' return: 4.\x0a\x09self should: '\x5c\x5c arg ^ 42' return: 42",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testBlockReturn",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ #(1 2 3) collect: [ :each | true ifTrue: [ each + 1 ] ]",[(2), (3), (4)]);
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ #(1 2 3) collect: [ :each | false ifFalse: [ each + 1 ] ]",[(2), (3), (4)]);
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo ^ #(1 2 3) collect: [ :each | each odd ifTrue: [ each + 1 ] ifFalse: [ each - 1 ] ]",[(2), (1), (4)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testBlockReturn",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testBlockReturn\x0a\x09self should: 'foo ^ #(1 2 3) collect: [ :each | true ifTrue: [ each + 1 ] ]' return: #(2 3 4).\x0a\x09self should: 'foo ^ #(1 2 3) collect: [ :each | false ifFalse: [ each + 1 ] ]' return: #(2 3 4).\x0a\x09self should: 'foo ^ #(1 2 3) collect: [ :each | each odd ifTrue: [ each + 1 ] ifFalse: [ each - 1 ] ]' return: #(2 1 4).",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testCascades",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ Array new add: 3; add: 4; yourself",[(3), (4)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCascades",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testCascades\x0a\x09\x0a\x09self should: 'foo ^ Array new add: 3; add: 4; yourself' return: #(3 4)",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testCascadesInDynamicArray",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo | x | x := 1. ^ {x. [x:=2] value; in: [x]}",[(1), (2)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCascadesInDynamicArray",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testCascadesInDynamicArray\x0a\x09self should: 'foo | x | x := 1. ^ {x. [x:=2] value; in: [x]}' return: #(1 2)",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testCascadesInDynamicDictioary",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo | x | x := 1. ^ #{'one' -> x. 'two' -> ([x:=2] value; in: [x])}",$globals.HashedCollection._newFromPairs_(["one",(1),"two",(2)]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCascadesInDynamicDictioary",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testCascadesInDynamicDictioary\x0a\x09self should: 'foo | x | x := 1. ^ #{''one'' -> x. ''two'' -> ([x:=2] value; in: [x])}' return: #{'one' -> 1. 'two' -> 2}",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testCascadesInSend",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo | x | x := 1. ^ Array with: x with: ([x:=2] value; in: [x])",[(1), (2)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCascadesInSend",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testCascadesInSend\x0a\x09self should: 'foo | x | x := 1. ^ Array with: x with: ([x:=2] value; in: [x])' return: #(1 2)",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testCascadesWithInlining",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ true class; ifTrue: [ 1 ] ifFalse: [ 2 ]",(1));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ false class; ifTrue: [ 1 ] ifFalse: [ 2 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCascadesWithInlining",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testCascadesWithInlining\x0a\x09\x0a\x09self should: 'foo ^ true class; ifTrue: [ 1 ] ifFalse: [ 2 ]' return: 1.\x0a\x09self should: 'foo ^ false class; ifTrue: [ 1 ] ifFalse: [ 2 ]' return: 2",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testDynamicArrayElementsOrdered",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { x. x := 2 }\x0a",[(1), (2)]);
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { x. true ifTrue: [ x := 2 ] }\x0a",[(1), (2)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDynamicArrayElementsOrdered",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testDynamicArrayElementsOrdered\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { x. x := 2 }\x0a' return: #(1 2).\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { x. true ifTrue: [ x := 2 ] }\x0a' return: #(1 2).",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testDynamicDictionaryElementsOrdered",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo\x0a\x09| x |\x0a\x09x := 'foo'.\x0a\x09^ #{ x->1. 'bar'->(true ifTrue: [ 2 ]) }\x0a",$globals.HashedCollection._newFromPairs_(["foo",(1),"bar",(2)]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDynamicDictionaryElementsOrdered",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testDynamicDictionaryElementsOrdered\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := ''foo''.\x0a\x09^ #{ x->1. ''bar''->(true ifTrue: [ 2 ]) }\x0a' return: #{'foo'->1. 'bar'->2}.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testDynamicDictionaryWithMoreArrows",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=$recv((1).__minus_gt((2))).__minus_gt((3));
$ctx1.sendIdx["->"]=1;
$1=$recv($globals.HashedCollection)._with_($2);
self._should_return_("foo ^ #{1->2->3}",$1);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDynamicDictionaryWithMoreArrows",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testDynamicDictionaryWithMoreArrows\x0a\x09self should: 'foo ^ #{1->2->3}' return: (HashedCollection with: 1->2->3)",
referencedClasses: ["HashedCollection"],
messageSends: ["should:return:", "with:", "->"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testGlobalVar",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ eval class",$globals.BlockClosure);
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ Math cos: 0",(1));
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo ^ NonExistingVar",nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testGlobalVar",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testGlobalVar\x0a\x09self should: 'foo ^ eval class' return: BlockClosure.\x0a\x09self should: 'foo ^ Math cos: 0' return: 1.\x0a\x09self should: 'foo ^ NonExistingVar' return: nil",
referencedClasses: ["BlockClosure"],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testInnerTemporalDependentElementsOrdered",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$5,$6,$4,$8,$9,$7,$11,$10;
$2="foo".__minus_gt($globals.Array);
$ctx1.sendIdx["->"]=1;
$3="bar".__minus_gt((2));
$ctx1.sendIdx["->"]=2;
$1=[$2,$3];
self._should_return_("foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: 'foo'->x with: 'bar'->(x := 2)\x0a",$1);
$ctx1.sendIdx["should:return:"]=1;
$5="foo".__minus_gt($globals.Array);
$ctx1.sendIdx["->"]=3;
$6="bar".__minus_gt((2));
$ctx1.sendIdx["->"]=4;
$4=[$5,$6];
self._should_return_("foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: 'foo'->x with: 'bar'->(true ifTrue: [ x := 2 ])\x0a",$4);
$ctx1.sendIdx["should:return:"]=2;
$8="foo".__minus_gt((1));
$ctx1.sendIdx["->"]=5;
$9="bar".__minus_gt((2));
$ctx1.sendIdx["->"]=6;
$7=[$8,$9];
self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ Array with: 'foo'->x with: 'bar'->(true ifTrue: [ x := 2 ])\x0a",$7);
$ctx1.sendIdx["should:return:"]=3;
$11="foo".__minus_gt((1));
$ctx1.sendIdx["->"]=7;
$10=[$11,"bar".__minus_gt((2))];
self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { 'foo'->x. 'bar'->(true ifTrue: [ x := 2 ]) }\x0a",$10);
$ctx1.sendIdx["should:return:"]=4;
self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ #{ 'foo'->x. 'bar'->(true ifTrue: [ x := 2 ]) }\x0a",$globals.HashedCollection._newFromPairs_(["foo",(1),"bar",(2)]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testInnerTemporalDependentElementsOrdered",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testInnerTemporalDependentElementsOrdered\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: ''foo''->x with: ''bar''->(x := 2)\x0a' return: {'foo'->Array. 'bar'->2}.\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: ''foo''->x with: ''bar''->(true ifTrue: [ x := 2 ])\x0a' return: {'foo'->Array. 'bar'->2}.\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ Array with: ''foo''->x with: ''bar''->(true ifTrue: [ x := 2 ])\x0a' return: {'foo'->1. 'bar'->2}.\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { ''foo''->x. ''bar''->(true ifTrue: [ x := 2 ]) }\x0a' return: {'foo'->1. 'bar'->2}.\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ #{ ''foo''->x. ''bar''->(true ifTrue: [ x := 2 ]) }\x0a' return: #{'foo'->1. 'bar'->2}.",
referencedClasses: ["Array"],
messageSends: ["should:return:", "->"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testJSStatement",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo <return 2+3>",(5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testJSStatement",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testJSStatement\x0a\x09self should: 'foo <return 2+3>' return: 5",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testLexicalScope",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo | a | a := 1. [ a := 2 ] value. ^ a",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLexicalScope",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testLexicalScope\x0a\x09self should: 'foo | a | a := 1. [ a := 2 ] value. ^ a' return: 2",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testLiterals",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ 1",(1));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ 'hello'","hello");
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo ^ #(1 2 3 4)",[(1), (2), (3), (4)]);
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo ^ {1. [:x | x ] value: 2. 3. [4] value}",[(1), (2), (3), (4)]);
$ctx1.sendIdx["should:return:"]=4;
self._should_return_("foo ^ true",true);
$ctx1.sendIdx["should:return:"]=5;
self._should_return_("foo ^ false",false);
$ctx1.sendIdx["should:return:"]=6;
self._should_return_("foo ^ #{1->2. 3->4}",$globals.HashedCollection._newFromPairs_([(1),(2),(3),(4)]));
$ctx1.sendIdx["should:return:"]=7;
self._should_return_("foo ^ #hello","hello");
$ctx1.sendIdx["should:return:"]=8;
self._should_return_("foo ^ $h","h");
$ctx1.sendIdx["should:return:"]=9;
self._should_return_("foo ^ -123.456",(-123.456));
$ctx1.sendIdx["should:return:"]=10;
self._should_return_("foo ^ -2.5e4",(-25000));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLiterals",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testLiterals\x0a\x09self should: 'foo ^ 1' return: 1.\x0a\x09self should: 'foo ^ ''hello''' return: 'hello'.\x0a\x09self should: 'foo ^ #(1 2 3 4)' return: #(1 2 3 4).\x0a\x09self should: 'foo ^ {1. [:x | x ] value: 2. 3. [4] value}' return: #(1 2 3 4).\x0a\x09self should: 'foo ^ true' return: true.\x0a\x09self should: 'foo ^ false' return: false.\x0a\x09self should: 'foo ^ #{1->2. 3->4}' return: #{1->2. 3->4}.\x0a\x09self should: 'foo ^ #hello' return: #hello.\x0a\x09self should: 'foo ^ $h' return: 'h'.\x0a\x09self should: 'foo ^ -123.456' return: -123.456.\x0a\x09self should: 'foo ^ -2.5e4' return: -25000.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testLocalReturn",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ 1",(1));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ 1 + 1",(2));
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo ",self["@receiver"]);
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo self asString",self["@receiver"]);
$ctx1.sendIdx["should:return:"]=4;
self._should_return_("foo | a b | a := 1. b := 2. ^ a + b",(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLocalReturn",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testLocalReturn\x0a\x09self should: 'foo ^ 1' return: 1.\x0a\x09self should: 'foo ^ 1 + 1' return: 2.\x0a\x09self should: 'foo ' return: receiver.\x0a\x09self should: 'foo self asString' return: receiver.\x0a\x09self should: 'foo | a b | a := 1. b := 2. ^ a + b' return: 3",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testMessageSends",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ 1 asString","1");
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ 1 + 1",(2));
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo ^ 1 + 2 * 3",(9));
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo ^ 1 to: 3",[(1), (2), (3)]);
$ctx1.sendIdx["should:return:"]=4;
self._should_return_("foo ^ 1 to: 5 by: 2",[(1), (3), (5)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMessageSends",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testMessageSends\x0a\x09self should: 'foo ^ 1 asString' return: '1'.\x0a\x0a\x09self should: 'foo ^ 1 + 1' return: 2.\x0a\x09self should: 'foo ^ 1 + 2 * 3' return: 9.\x0a\x0a\x09self should: 'foo ^ 1 to: 3' return: #(1 2 3).\x0a\x09self should: 'foo ^ 1 to: 5 by: 2' return: #(1 3 5)",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testMultipleSequences",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo | a b c | a := 2. b := 3. c := a + b. ^ c * 6",(30));
return self;
}, function($ctx1) {$ctx1.fill(self,"testMultipleSequences",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testMultipleSequences\x0a\x09self should: 'foo | a b c | a := 2. b := 3. c := a + b. ^ c * 6' return: 30",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testMutableLiterals",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ #( 1 2 ) at: 1 put: 3; yourself",[(3), (2)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMutableLiterals",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testMutableLiterals\x0a\x09\x22Mutable literals must be aliased in cascades.\x0a\x09See https://github.com/amber-smalltalk/amber/issues/428\x22\x0a\x09\x0a\x09self \x0a\x09\x09should: 'foo ^ #( 1 2 ) at: 1 put: 3; yourself' \x0a\x09\x09return: #(3 2)",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testNestedIfTrue",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ true ifTrue: [ false ifFalse: [ 1 ] ]",(1));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ true ifTrue: [ false ifTrue: [ 1 ] ]",nil);
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo true ifTrue: [ false ifFalse: [ ^ 1 ] ]",(1));
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo true ifTrue: [ false ifTrue: [ ^ 1 ] ]",self["@receiver"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testNestedIfTrue",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testNestedIfTrue\x0a\x09self should: 'foo ^ true ifTrue: [ false ifFalse: [ 1 ] ]' return: 1.\x0a\x09self should: 'foo ^ true ifTrue: [ false ifTrue: [ 1 ] ]' return: nil.\x0a\x0a\x09self should: 'foo true ifTrue: [ false ifFalse: [ ^ 1 ] ]' return: 1.\x0a\x09self should: 'foo true ifTrue: [ false ifTrue: [ ^ 1 ] ]' return: receiver.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testNestedSends",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ (Point x: (Point x: 2 y: 3) y: 4) asString",$recv($recv($globals.Point)._x_y_((2).__at((3)),(4)))._asString());
return self;
}, function($ctx1) {$ctx1.fill(self,"testNestedSends",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testNestedSends\x0a\x09self should: 'foo ^ (Point x: (Point x: 2 y: 3) y: 4) asString' return: (Point x: (2@3) y: 4) asString",
referencedClasses: ["Point"],
messageSends: ["should:return:", "asString", "x:y:", "@"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testNonLocalReturn",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo [ ^ 1 ] value",(1));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo [ ^ 1 + 1 ] value",(2));
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo | a b | a := 1. b := 2. [ ^ a + b ] value. self halt",(3));
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo [ :x | ^ x + x ] value: 4. ^ 2",(8));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNonLocalReturn",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testNonLocalReturn\x0a\x09self should: 'foo [ ^ 1 ] value' return: 1.\x0a\x09self should: 'foo [ ^ 1 + 1 ] value' return: 2.\x0a\x09self should: 'foo | a b | a := 1. b := 2. [ ^ a + b ] value. self halt' return: 3.\x0a\x09self should: 'foo [ :x | ^ x + x ] value: 4. ^ 2' return: 8",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testPascalCaseGlobal",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^Object",$recv($recv($globals.Smalltalk)._globals())._at_("Object"));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^NonExistent",nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testPascalCaseGlobal",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testPascalCaseGlobal\x0a\x09self should: 'foo ^Object' return: (Smalltalk globals at: 'Object').\x0a\x09self should: 'foo ^NonExistent' return: nil",
referencedClasses: ["Smalltalk"],
messageSends: ["should:return:", "at:", "globals"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testRootSuperSend",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_receiver_raise_("foo ^ super class",$recv($globals.ProtoObject)._new(),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRootSuperSend",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testRootSuperSend\x0a\x09self \x0a\x09\x09should: 'foo ^ super class' \x0a\x09\x09receiver: ProtoObject new\x0a\x09\x09raise: MessageNotUnderstood",
referencedClasses: ["ProtoObject", "MessageNotUnderstood"],
messageSends: ["should:receiver:raise:", "new"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testSendReceiverAndArgumentsOrdered",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ Array with: x with: (true ifTrue: [ x := 2 ])\x0a",[(1), (2)]);
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: x with: (true ifTrue: [ x := 2 ])\x0a",[$globals.Array,(2)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSendReceiverAndArgumentsOrdered",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testSendReceiverAndArgumentsOrdered\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ Array with: x with: (true ifTrue: [ x := 2 ])\x0a' return: #(1 2).\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: x with: (true ifTrue: [ x := 2 ])\x0a' return: {Array. 2}.",
referencedClasses: ["Array"],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testSuperSend",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_receiver_return_("foo ^ super isBoolean",true,false);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSuperSend",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testSuperSend\x0a\x09self \x0a\x09\x09should: 'foo ^ super isBoolean' \x0a\x09\x09receiver: true\x0a\x09\x09return: false",
referencedClasses: [],
messageSends: ["should:receiver:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testTempVariables",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo | a | ^ a",nil);
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo | AVariable | ^ AVariable",nil);
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo | a b c | ^ c",nil);
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo | a | [ | d | ^ d ] value",nil);
$ctx1.sendIdx["should:return:"]=4;
self._should_return_("foo | a | a:= 1. ^ a",(1));
$ctx1.sendIdx["should:return:"]=5;
self._should_return_("foo | AVariable | AVariable := 1. ^ AVariable",(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTempVariables",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testTempVariables\x0a\x09self should: 'foo | a | ^ a' return: nil.\x0a\x09self should: 'foo | AVariable | ^ AVariable' return: nil.\x0a\x09self should: 'foo | a b c | ^ c' return: nil.\x0a\x09self should: 'foo | a | [ | d | ^ d ] value' return: nil.\x0a\x09\x0a\x09self should: 'foo | a | a:= 1. ^ a' return: 1.\x0a\x09self should: 'foo | AVariable | AVariable := 1. ^ AVariable' return: 1.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testThisContext",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ [ thisContext ] value outerContext == thisContext",true);
return self;
}, function($ctx1) {$ctx1.fill(self,"testThisContext",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testThisContext\x0a\x09self should: 'foo ^ [ thisContext ] value outerContext == thisContext' return: true",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testifFalse",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo true ifFalse: [ ^ 1 ]",self["@receiver"]);
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo false ifFalse: [ ^ 2 ]",(2));
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo ^ true ifFalse: [ 1 ]",nil);
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo ^ false ifFalse: [ 2 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifFalse",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testifFalse\x0a\x09self should: 'foo true ifFalse: [ ^ 1 ]' return: receiver.\x0a\x09self should: 'foo false ifFalse: [ ^ 2 ]' return: 2.\x0a\x09\x0a\x09self should: 'foo ^ true ifFalse: [ 1 ]' return: nil.\x0a\x09self should: 'foo ^ false ifFalse: [ 2 ]' return: 2.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testifFalseIfTrue",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo true ifFalse: [ ^ 1 ] ifTrue: [ ^ 2 ]",(2));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo false ifFalse: [ ^ 2 ] ifTrue: [ ^1 ]",(2));
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo ^ true ifFalse: [ 1 ] ifTrue: [ 2 ]",(2));
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo ^ false ifFalse: [ 2 ] ifTrue: [ 1 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifFalseIfTrue",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testifFalseIfTrue\x0a\x09self should: 'foo true ifFalse: [ ^ 1 ] ifTrue: [ ^ 2 ]' return: 2.\x0a\x09self should: 'foo false ifFalse: [ ^ 2 ] ifTrue: [ ^1 ]' return: 2.\x0a\x09\x0a\x09self should: 'foo ^ true ifFalse: [ 1 ] ifTrue: [ 2 ]' return: 2.\x0a\x09self should: 'foo ^ false ifFalse: [ 2 ] ifTrue: [ 1 ]' return: 2.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testifNil",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ 1 ifNil: [ 2 ]",(1));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ nil ifNil: [ 2 ]",(2));
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo 1 ifNil: [ ^ 2 ]",self["@receiver"]);
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo nil ifNil: [ ^ 2 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifNil",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testifNil\x0a\x09self should: 'foo ^ 1 ifNil: [ 2 ]' return: 1.\x0a\x09self should: 'foo ^ nil ifNil: [ 2 ]' return: 2.\x0a\x0a\x09self should: 'foo 1 ifNil: [ ^ 2 ]' return: receiver.\x0a\x09self should: 'foo nil ifNil: [ ^ 2 ]' return: 2.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testifNilIfNotNil",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ 1 ifNil: [ 2 ] ifNotNil: [ 3 ]",(3));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ nil ifNil: [ 2 ] ifNotNil: [ 3 ]",(2));
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo 1 ifNil: [ ^ 2 ] ifNotNil: [ ^3 ]",(3));
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo nil ifNil: [ ^ 2 ] ifNotNil: [ ^3 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifNilIfNotNil",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testifNilIfNotNil\x0a\x09self should: 'foo ^ 1 ifNil: [ 2 ] ifNotNil: [ 3 ]' return: 3.\x0a\x09self should: 'foo ^ nil ifNil: [ 2 ] ifNotNil: [ 3 ]' return: 2.\x0a\x0a\x09self should: 'foo 1 ifNil: [ ^ 2 ] ifNotNil: [ ^3 ]' return: 3.\x0a\x09self should: 'foo nil ifNil: [ ^ 2 ] ifNotNil: [ ^3 ]' return: 2.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testifNotNil",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ 1 ifNotNil: [ 2 ]",(2));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ nil ifNotNil: [ 2 ]",nil);
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo 1 ifNotNil: [ ^ 2 ]",(2));
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo nil ifNotNil: [ ^ 2 ]",self["@receiver"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testifNotNil",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testifNotNil\x0a\x09self should: 'foo ^ 1 ifNotNil: [ 2 ]' return: 2.\x0a\x09self should: 'foo ^ nil ifNotNil: [ 2 ]' return: nil.\x0a\x0a\x09self should: 'foo 1 ifNotNil: [ ^ 2 ]' return: 2.\x0a\x09self should: 'foo nil ifNotNil: [ ^ 2 ]' return: receiver.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testifNotNilWithArgument",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo ^ 1 ifNotNil: [ :val | val + 2 ]",(3));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo ^ nil ifNotNil: [ :val | val + 2 ]",nil);
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo ^ 1 ifNil: [ 5 ] ifNotNil: [ :val | val + 2 ]",(3));
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo ^ nil ifNil: [ 5 ] ifNotNil: [ :val | val + 2 ]",(5));
$ctx1.sendIdx["should:return:"]=4;
self._should_return_("foo ^ 1 ifNotNil: [ :val | val + 2 ] ifNil: [ 5 ]",(3));
$ctx1.sendIdx["should:return:"]=5;
self._should_return_("foo ^ nil ifNotNil: [ :val | val + 2 ] ifNil: [ 5 ]",(5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifNotNilWithArgument",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testifNotNilWithArgument\x0a\x09self should: 'foo ^ 1 ifNotNil: [ :val | val + 2 ]' return: 3.\x0a\x09self should: 'foo ^ nil ifNotNil: [ :val | val + 2 ]' return: nil.\x0a\x09\x0a\x09self should: 'foo ^ 1 ifNil: [ 5 ] ifNotNil: [ :val | val + 2 ]' return: 3.\x0a\x09self should: 'foo ^ nil ifNil: [ 5 ] ifNotNil: [ :val | val + 2 ]' return: 5.\x0a\x09\x0a\x09self should: 'foo ^ 1 ifNotNil: [ :val | val + 2 ] ifNil: [ 5 ]' return: 3.\x0a\x09self should: 'foo ^ nil ifNotNil: [ :val | val + 2 ] ifNil: [ 5 ]' return: 5",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testifTrue",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo false ifTrue: [ ^ 1 ]",self["@receiver"]);
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo true ifTrue: [ ^ 2 ]",(2));
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo ^ false ifTrue: [ 1 ]",nil);
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo ^ true ifTrue: [ 2 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifTrue",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testifTrue\x0a\x09self should: 'foo false ifTrue: [ ^ 1 ]' return: receiver.\x0a\x09self should: 'foo true ifTrue: [ ^ 2 ]' return: 2.\x0a\x09\x0a\x09self should: 'foo ^ false ifTrue: [ 1 ]' return: nil.\x0a\x09self should: 'foo ^ true ifTrue: [ 2 ]' return: 2.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);

$core.addMethod(
$core.method({
selector: "testifTrueIfFalse",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_return_("foo false ifTrue: [ ^ 1 ] ifFalse: [ ^2 ]",(2));
$ctx1.sendIdx["should:return:"]=1;
self._should_return_("foo true ifTrue: [ ^ 1 ] ifFalse: [ ^ 2 ]",(1));
$ctx1.sendIdx["should:return:"]=2;
self._should_return_("foo ^ false ifTrue: [ 2 ] ifFalse: [ 1 ]",(1));
$ctx1.sendIdx["should:return:"]=3;
self._should_return_("foo ^ true ifTrue: [ 2 ] ifFalse: [ 1 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifTrueIfFalse",{},$globals.CodeGeneratorTest)});
},
args: [],
source: "testifTrueIfFalse\x0a\x09self should: 'foo false ifTrue: [ ^ 1 ] ifFalse: [ ^2 ]' return: 2.\x0a\x09self should: 'foo true ifTrue: [ ^ 1 ] ifFalse: [ ^ 2 ]' return: 1.\x0a\x09\x0a\x09self should: 'foo ^ false ifTrue: [ 2 ] ifFalse: [ 1 ]' return: 1.\x0a\x09self should: 'foo ^ true ifTrue: [ 2 ] ifFalse: [ 1 ]' return: 2.",
referencedClasses: [],
messageSends: ["should:return:"]
}),
$globals.CodeGeneratorTest);



$core.addClass('ASTInterpreterTest', $globals.CodeGeneratorTest, [], 'Compiler-Tests');
$core.addMethod(
$core.method({
selector: "analyze:forClass:",
protocol: 'parsing',
fn: function (aNode,aClass){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.SemanticAnalyzer)._on_(aClass))._visit_(aNode);
return aNode;
}, function($ctx1) {$ctx1.fill(self,"analyze:forClass:",{aNode:aNode,aClass:aClass},$globals.ASTInterpreterTest)});
},
args: ["aNode", "aClass"],
source: "analyze: aNode forClass: aClass\x0a\x09(SemanticAnalyzer on: aClass) visit: aNode.\x0a\x09^ aNode",
referencedClasses: ["SemanticAnalyzer"],
messageSends: ["visit:", "on:"]
}),
$globals.ASTInterpreterTest);

$core.addMethod(
$core.method({
selector: "interpret:receiver:withArguments:",
protocol: 'private',
fn: function (aString,anObject,aDictionary){
var self=this;
var ctx,ast,interpreter;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$receiver;
interpreter=$recv($globals.ASTInterpreter)._new();
$ctx1.sendIdx["new"]=1;
ast=self._parse_forClass_(aString,$recv(anObject)._class());
$1=$recv($globals.AIContext)._new();
$recv($1)._receiver_(anObject);
$recv($1)._interpreter_(interpreter);
ctx=$recv($1)._yourself();
$2=$recv(ast)._sequenceNode();
if(($receiver = $2) == null || $receiver.isNil){
$2;
} else {
var sequence;
sequence=$receiver;
$recv($recv(sequence)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(ctx)._defineLocal_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
};
$recv(aDictionary)._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(ctx)._localAt_put_(key,value);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,3)});
}));
$3=interpreter;
$recv($3)._context_(ctx);
$recv($3)._node_(ast);
$recv($3)._enterNode();
$recv($3)._proceed();
return $recv($3)._result();
}, function($ctx1) {$ctx1.fill(self,"interpret:receiver:withArguments:",{aString:aString,anObject:anObject,aDictionary:aDictionary,ctx:ctx,ast:ast,interpreter:interpreter},$globals.ASTInterpreterTest)});
},
args: ["aString", "anObject", "aDictionary"],
source: "interpret: aString receiver: anObject withArguments: aDictionary\x0a\x09\x22The food is a methodNode. Interpret the sequenceNode only\x22\x0a\x09\x0a\x09| ctx ast interpreter |\x0a\x09\x0a\x09interpreter := ASTInterpreter new.\x0a\x09ast := self parse: aString forClass: anObject class.\x0a\x09\x0a\x09ctx := AIContext new\x0a\x09\x09receiver: anObject;\x0a\x09\x09interpreter: interpreter;\x0a\x09\x09yourself.\x0a\x09\x09\x0a\x09\x22Define locals for the context\x22\x0a\x09ast sequenceNode ifNotNil: [ :sequence |\x0a\x09\x09sequence temps do: [ :each |\x0a\x09\x09\x09ctx defineLocal: each ] ].\x0a\x09\x09\x0a\x09aDictionary keysAndValuesDo: [ :key :value |\x0a\x09\x09ctx localAt: key put: value ].\x0a\x09\x0a\x09^ interpreter\x0a\x09\x09context: ctx;\x0a\x09\x09node: ast;\x0a\x09\x09enterNode;\x0a\x09\x09proceed;\x0a\x09\x09result",
referencedClasses: ["ASTInterpreter", "AIContext"],
messageSends: ["new", "parse:forClass:", "class", "receiver:", "interpreter:", "yourself", "ifNotNil:", "sequenceNode", "do:", "temps", "defineLocal:", "keysAndValuesDo:", "localAt:put:", "context:", "node:", "enterNode", "proceed", "result"]
}),
$globals.ASTInterpreterTest);

$core.addMethod(
$core.method({
selector: "parse:",
protocol: 'parsing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._parse_(aString);
}, function($ctx1) {$ctx1.fill(self,"parse:",{aString:aString},$globals.ASTInterpreterTest)});
},
args: ["aString"],
source: "parse: aString\x0a\x09^ Smalltalk parse: aString",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:"]
}),
$globals.ASTInterpreterTest);

$core.addMethod(
$core.method({
selector: "parse:forClass:",
protocol: 'parsing',
fn: function (aString,aClass){
var self=this;
return $core.withContext(function($ctx1) {
return self._analyze_forClass_(self._parse_(aString),aClass);
}, function($ctx1) {$ctx1.fill(self,"parse:forClass:",{aString:aString,aClass:aClass},$globals.ASTInterpreterTest)});
},
args: ["aString", "aClass"],
source: "parse: aString forClass: aClass\x0a\x09^ self analyze: (self parse: aString) forClass: aClass",
referencedClasses: [],
messageSends: ["analyze:forClass:", "parse:"]
}),
$globals.ASTInterpreterTest);

$core.addMethod(
$core.method({
selector: "should:receiver:return:",
protocol: 'testing',
fn: function (aString,anObject,aResult){
var self=this;
return $core.withContext(function($ctx1) {
self["@receiver"]=anObject;
return self._assert_equals_(self._interpret_receiver_withArguments_(aString,self["@receiver"],$globals.HashedCollection._newFromPairs_([])),aResult);
}, function($ctx1) {$ctx1.fill(self,"should:receiver:return:",{aString:aString,anObject:anObject,aResult:aResult},$globals.ASTInterpreterTest)});
},
args: ["aString", "anObject", "aResult"],
source: "should: aString receiver: anObject return: aResult\x0a\x09receiver := anObject.\x0a\x09\x0a\x09^ self \x0a\x09\x09assert: (self interpret: aString receiver: receiver withArguments: #{})\x0a\x09\x09equals: aResult",
referencedClasses: [],
messageSends: ["assert:equals:", "interpret:receiver:withArguments:"]
}),
$globals.ASTInterpreterTest);



$core.addClass('ASTDebuggerTest', $globals.ASTInterpreterTest, [], 'Compiler-Tests');
$core.addMethod(
$core.method({
selector: "interpret:receiver:withArguments:",
protocol: 'private',
fn: function (aString,anObject,aDictionary){
var self=this;
var ctx,ast,debugger_;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$receiver;
$1=$recv($globals.AIContext)._new();
$ctx1.sendIdx["new"]=1;
$recv($1)._receiver_(anObject);
$recv($1)._interpreter_($recv($globals.ASTInterpreter)._new());
ctx=$recv($1)._yourself();
ast=self._parse_forClass_(aString,$recv(anObject)._class());
$2=$recv(ast)._sequenceNode();
if(($receiver = $2) == null || $receiver.isNil){
$2;
} else {
var sequence;
sequence=$receiver;
$recv($recv(sequence)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(ctx)._defineLocal_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
};
$recv(aDictionary)._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(ctx)._localAt_put_(key,value);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,3)});
}));
$3=$recv(ctx)._interpreter();
$ctx1.sendIdx["interpreter"]=1;
$recv($3)._context_(ctx);
$ctx1.sendIdx["context:"]=1;
$4=$recv(ctx)._interpreter();
$recv($4)._node_(ast);
$recv($4)._enterNode();
debugger_=$recv($globals.ASTDebugger)._context_(ctx);
$5=debugger_;
$recv($5)._proceed();
return $recv($5)._result();
}, function($ctx1) {$ctx1.fill(self,"interpret:receiver:withArguments:",{aString:aString,anObject:anObject,aDictionary:aDictionary,ctx:ctx,ast:ast,debugger_:debugger_},$globals.ASTDebuggerTest)});
},
args: ["aString", "anObject", "aDictionary"],
source: "interpret: aString receiver: anObject withArguments: aDictionary\x0a\x09| ctx ast debugger |\x0a\x09\x0a\x09ctx := AIContext new\x0a\x09\x09receiver: anObject;\x0a\x09\x09interpreter: ASTInterpreter new;\x0a\x09\x09yourself.\x0a\x09ast := self parse: aString forClass: anObject class.\x0a\x09\x09\x0a\x09\x22Define locals for the context\x22\x0a\x09ast sequenceNode ifNotNil: [ :sequence |\x0a\x09\x09sequence temps do: [ :each |\x0a\x09\x09\x09ctx defineLocal: each ] ].\x0a\x09\x0a\x09aDictionary keysAndValuesDo: [ :key :value |\x0a\x09\x09ctx localAt: key put: value ].\x0a\x09ctx interpreter context: ctx.\x0a\x09\x0a\x09ctx interpreter node: ast; enterNode.\x0a\x09\x0a\x09debugger := ASTDebugger context: ctx.\x0a\x09\x0a\x09^ debugger \x0a\x09\x09proceed; \x0a\x09\x09result",
referencedClasses: ["AIContext", "ASTInterpreter", "ASTDebugger"],
messageSends: ["receiver:", "new", "interpreter:", "yourself", "parse:forClass:", "class", "ifNotNil:", "sequenceNode", "do:", "temps", "defineLocal:", "keysAndValuesDo:", "localAt:put:", "context:", "interpreter", "node:", "enterNode", "proceed", "result"]
}),
$globals.ASTDebuggerTest);



$core.addClass('InliningCodeGeneratorTest', $globals.CodeGeneratorTest, [], 'Compiler-Tests');
$core.addMethod(
$core.method({
selector: "codeGeneratorClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.InliningCodeGenerator;

},
args: [],
source: "codeGeneratorClass\x0a\x09^ InliningCodeGenerator",
referencedClasses: ["InliningCodeGenerator"],
messageSends: []
}),
$globals.InliningCodeGeneratorTest);



$core.addClass('ScopeVarTest', $globals.TestCase, [], 'Compiler-Tests');
$core.addMethod(
$core.method({
selector: "testClassRefVar",
protocol: 'tests',
fn: function (){
var self=this;
var node;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv($globals.VariableNode)._new();
$ctx1.sendIdx["new"]=1;
$recv($1)._value_("Object");
node=$recv($1)._yourself();
$2=$recv($globals.SemanticAnalyzer)._new();
$ctx1.sendIdx["new"]=2;
$recv($2)._pushScope_($recv($globals.MethodLexicalScope)._new());
$recv($2)._visit_(node);
self._assert_($recv($recv(node)._binding())._isClassRefVar());
return self;
}, function($ctx1) {$ctx1.fill(self,"testClassRefVar",{node:node},$globals.ScopeVarTest)});
},
args: [],
source: "testClassRefVar\x0a\x09| node |\x0a\x09node := VariableNode new\x0a\x09\x09value: 'Object';\x0a\x09\x09yourself.\x0a\x09SemanticAnalyzer new \x0a\x09\x09pushScope: MethodLexicalScope new;\x0a\x09\x09visit: node.\x0a\x09self assert: node binding isClassRefVar",
referencedClasses: ["VariableNode", "SemanticAnalyzer", "MethodLexicalScope"],
messageSends: ["value:", "new", "yourself", "pushScope:", "visit:", "assert:", "isClassRefVar", "binding"]
}),
$globals.ScopeVarTest);

$core.addMethod(
$core.method({
selector: "testInstanceVar",
protocol: 'tests',
fn: function (){
var self=this;
var node,scope;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.VariableNode)._new();
$ctx1.sendIdx["new"]=1;
$recv($1)._value_("bzzz");
node=$recv($1)._yourself();
scope=$recv($globals.MethodLexicalScope)._new();
$recv(scope)._addIVar_("bzzz");
self._assert_($recv($recv(scope)._bindingFor_(node))._isInstanceVar());
return self;
}, function($ctx1) {$ctx1.fill(self,"testInstanceVar",{node:node,scope:scope},$globals.ScopeVarTest)});
},
args: [],
source: "testInstanceVar\x0a\x09| node scope |\x0a\x09node := VariableNode new\x0a\x09\x09value: 'bzzz';\x0a\x09\x09yourself.\x0a\x09scope := MethodLexicalScope new.\x0a\x09scope addIVar: 'bzzz'.\x0a\x09self assert: (scope bindingFor: node) isInstanceVar",
referencedClasses: ["VariableNode", "MethodLexicalScope"],
messageSends: ["value:", "new", "yourself", "addIVar:", "assert:", "isInstanceVar", "bindingFor:"]
}),
$globals.ScopeVarTest);

$core.addMethod(
$core.method({
selector: "testPseudoVar",
protocol: 'tests',
fn: function (){
var self=this;
var node,pseudoVars;
return $core.withContext(function($ctx1) {
var $1;
pseudoVars=["self", "super", "true", "false", "nil"];
$recv(pseudoVars)._do_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv($globals.VariableNode)._new();
$ctx2.sendIdx["new"]=1;
$recv($1)._value_(each);
node=$recv($1)._yourself();
node;
return self._assert_($recv($recv($recv($globals.MethodLexicalScope)._new())._bindingFor_(node))._isPseudoVar());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testPseudoVar",{node:node,pseudoVars:pseudoVars},$globals.ScopeVarTest)});
},
args: [],
source: "testPseudoVar\x0a\x09| node pseudoVars |\x0a\x09pseudoVars := #('self' 'super' 'true' 'false' 'nil').\x0a\x09pseudoVars do: [:each |\x0a\x09\x09node := VariableNode new\x0a\x09\x09value: each;\x0a\x09\x09yourself.\x0a\x09\x09self assert: (MethodLexicalScope new bindingFor: node) isPseudoVar]",
referencedClasses: ["VariableNode", "MethodLexicalScope"],
messageSends: ["do:", "value:", "new", "yourself", "assert:", "isPseudoVar", "bindingFor:"]
}),
$globals.ScopeVarTest);

$core.addMethod(
$core.method({
selector: "testTempVar",
protocol: 'tests',
fn: function (){
var self=this;
var node,scope;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.VariableNode)._new();
$ctx1.sendIdx["new"]=1;
$recv($1)._value_("bzzz");
node=$recv($1)._yourself();
scope=$recv($globals.MethodLexicalScope)._new();
$recv(scope)._addTemp_("bzzz");
self._assert_($recv($recv(scope)._bindingFor_(node))._isTempVar());
return self;
}, function($ctx1) {$ctx1.fill(self,"testTempVar",{node:node,scope:scope},$globals.ScopeVarTest)});
},
args: [],
source: "testTempVar\x0a\x09| node scope |\x0a\x09node := VariableNode new\x0a\x09\x09value: 'bzzz';\x0a\x09\x09yourself.\x0a\x09scope := MethodLexicalScope new.\x0a\x09scope addTemp: 'bzzz'.\x0a\x09self assert: (scope bindingFor: node) isTempVar",
referencedClasses: ["VariableNode", "MethodLexicalScope"],
messageSends: ["value:", "new", "yourself", "addTemp:", "assert:", "isTempVar", "bindingFor:"]
}),
$globals.ScopeVarTest);

$core.addMethod(
$core.method({
selector: "testUnknownVar",
protocol: 'tests',
fn: function (){
var self=this;
var node;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.VariableNode)._new();
$ctx1.sendIdx["new"]=1;
$recv($1)._value_("bzzz");
node=$recv($1)._yourself();
self._assert_($recv($recv($recv($globals.MethodLexicalScope)._new())._bindingFor_(node))._isNil());
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnknownVar",{node:node},$globals.ScopeVarTest)});
},
args: [],
source: "testUnknownVar\x0a\x09| node |\x0a\x09node := VariableNode new\x0a\x09\x09value: 'bzzz';\x0a\x09\x09yourself.\x0a\x09self assert: (MethodLexicalScope new bindingFor: node) isNil",
referencedClasses: ["VariableNode", "MethodLexicalScope"],
messageSends: ["value:", "new", "yourself", "assert:", "isNil", "bindingFor:"]
}),
$globals.ScopeVarTest);



$core.addClass('SemanticAnalyzerTest', $globals.TestCase, ['analyzer'], 'Compiler-Tests');
$core.addMethod(
$core.method({
selector: "setUp",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@analyzer"]=$recv($globals.SemanticAnalyzer)._on_($globals.Object);
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "setUp\x0a\x09analyzer := SemanticAnalyzer on: Object",
referencedClasses: ["SemanticAnalyzer", "Object"],
messageSends: ["on:"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testAssignment",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo self := 1";
ast=$recv($globals.Smalltalk)._parse_(src);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@analyzer"])._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.InvalidAssignmentError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAssignment",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testAssignment\x0a\x09| src ast |\x0a\x0a\x09src := 'foo self := 1'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09self should: [analyzer visit: ast] raise: InvalidAssignmentError",
referencedClasses: ["Smalltalk", "InvalidAssignmentError"],
messageSends: ["parse:", "should:raise:", "visit:"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testNonLocalReturn",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. ^ a";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv(self["@analyzer"])._visit_(ast);
self._deny_($recv($recv(ast)._scope())._hasNonLocalReturn());
return self;
}, function($ctx1) {$ctx1.fill(self,"testNonLocalReturn",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testNonLocalReturn\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. ^ a'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09self deny: ast scope hasNonLocalReturn",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:", "visit:", "deny:", "hasNonLocalReturn", "scope"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testNonLocalReturn2",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ [ ^ a] ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv(self["@analyzer"])._visit_(ast);
self._assert_($recv($recv(ast)._scope())._hasNonLocalReturn());
return self;
}, function($ctx1) {$ctx1.fill(self,"testNonLocalReturn2",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testNonLocalReturn2\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. [ [ ^ a] ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09self assert: ast scope hasNonLocalReturn",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:", "visit:", "assert:", "hasNonLocalReturn", "scope"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testScope",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
var $4,$3,$2,$1;
src="foo | a | a + 1. [ | b | b := a ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv(self["@analyzer"])._visit_(ast);
$4=$recv($recv($recv(ast)._nodes())._first())._nodes();
$ctx1.sendIdx["nodes"]=1;
$3=$recv($4)._last();
$2=$recv($3)._scope();
$ctx1.sendIdx["scope"]=1;
$1=$recv($2).__eq_eq($recv(ast)._scope());
self._deny_($1);
return self;
}, function($ctx1) {$ctx1.fill(self,"testScope",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testScope\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. [ | b | b := a ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09self deny: ast nodes first nodes last scope == ast scope.",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:", "visit:", "deny:", "==", "scope", "last", "nodes", "first"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testScope2",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
var $8,$7,$6,$5,$4,$3,$2,$1;
src="foo | a | a + 1. [ [ | b | b := a ] ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv(self["@analyzer"])._visit_(ast);
$8=$recv($recv($recv(ast)._nodes())._first())._nodes();
$ctx1.sendIdx["nodes"]=3;
$7=$recv($8)._last();
$6=$recv($7)._nodes();
$ctx1.sendIdx["nodes"]=2;
$5=$recv($6)._first();
$ctx1.sendIdx["first"]=2;
$4=$recv($5)._nodes();
$ctx1.sendIdx["nodes"]=1;
$3=$recv($4)._first();
$ctx1.sendIdx["first"]=1;
$2=$recv($3)._scope();
$ctx1.sendIdx["scope"]=1;
$1=$recv($2).__eq_eq($recv(ast)._scope());
self._deny_($1);
return self;
}, function($ctx1) {$ctx1.fill(self,"testScope2",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testScope2\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. [ [ | b | b := a ] ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09self deny: ast nodes first nodes last nodes first nodes first scope == ast scope.",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:", "visit:", "deny:", "==", "scope", "first", "nodes", "last"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testScopeLevel",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
var $2,$1,$10,$9,$8,$7,$6,$5,$4,$3;
src="foo | a | a + 1. [ [ | b | b := a ] ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv(self["@analyzer"])._visit_(ast);
$2=$recv(ast)._scope();
$ctx1.sendIdx["scope"]=1;
$1=$recv($2)._scopeLevel();
$ctx1.sendIdx["scopeLevel"]=1;
self._assert_equals_($1,(1));
$ctx1.sendIdx["assert:equals:"]=1;
$10=$recv($recv($recv(ast)._nodes())._first())._nodes();
$ctx1.sendIdx["nodes"]=3;
$9=$recv($10)._last();
$8=$recv($9)._nodes();
$ctx1.sendIdx["nodes"]=2;
$7=$recv($8)._first();
$ctx1.sendIdx["first"]=2;
$6=$recv($7)._nodes();
$ctx1.sendIdx["nodes"]=1;
$5=$recv($6)._first();
$ctx1.sendIdx["first"]=1;
$4=$recv($5)._scope();
$3=$recv($4)._scopeLevel();
self._assert_equals_($3,(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testScopeLevel",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testScopeLevel\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. [ [ | b | b := a ] ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09self assert: ast scope scopeLevel equals: 1.\x0a\x09self assert: ast nodes first nodes last nodes first nodes first scope scopeLevel equals: 3",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:", "visit:", "assert:equals:", "scopeLevel", "scope", "first", "nodes", "last"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testUnknownVariables",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | b + a";
ast=$recv($globals.Smalltalk)._parse_(src);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@analyzer"])._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.UnknownVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnknownVariables",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testUnknownVariables\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | b + a'.\x0a\x09ast := Smalltalk parse: src.\x0a\x0a\x09self should: [ analyzer visit: ast ] raise: UnknownVariableError",
referencedClasses: ["Smalltalk", "UnknownVariableError"],
messageSends: ["parse:", "should:raise:", "visit:"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testUnknownVariablesWithScope",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a b | [ c + 1. [ a + 1. d + 1 ]]";
ast=$recv($globals.Smalltalk)._parse_(src);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@analyzer"])._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.UnknownVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnknownVariablesWithScope",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testUnknownVariablesWithScope\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a b | [ c + 1. [ a + 1. d + 1 ]]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09\x0a\x09self should: [ analyzer visit: ast ] raise: UnknownVariableError",
referencedClasses: ["Smalltalk", "UnknownVariableError"],
messageSends: ["parse:", "should:raise:", "visit:"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariableShadowing",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv(self["@analyzer"])._visit_(ast);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariableShadowing",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testVariableShadowing\x0a\x09| src ast |\x0a\x09src := 'foo | a | a + 1'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:", "visit:"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariableShadowing2",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ | a | a := 2 ]";
ast=$recv($globals.Smalltalk)._parse_(src);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@analyzer"])._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.ShadowingVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariableShadowing2",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testVariableShadowing2\x0a\x09| src ast |\x0a\x09src := 'foo | a | a + 1. [ | a | a := 2 ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09self should: [analyzer visit: ast] raise: ShadowingVariableError",
referencedClasses: ["Smalltalk", "ShadowingVariableError"],
messageSends: ["parse:", "should:raise:", "visit:"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariableShadowing3",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ | b | b := 2 ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv(self["@analyzer"])._visit_(ast);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariableShadowing3",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testVariableShadowing3\x0a\x09| src ast |\x0a\x09src := 'foo | a | a + 1. [ | b | b := 2 ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:", "visit:"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariableShadowing4",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ [ [ | b | b := 2 ] ] ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv(self["@analyzer"])._visit_(ast);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariableShadowing4",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testVariableShadowing4\x0a\x09| src ast |\x0a\x09src := 'foo | a | a + 1. [ [ [ | b | b := 2 ] ] ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:", "visit:"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariableShadowing5",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ [ [ | a | a := 2 ] ] ]";
ast=$recv($globals.Smalltalk)._parse_(src);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@analyzer"])._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.ShadowingVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariableShadowing5",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testVariableShadowing5\x0a\x09| src ast |\x0a\x09src := 'foo | a | a + 1. [ [ [ | a | a := 2 ] ] ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09self should: [analyzer visit: ast] raise: ShadowingVariableError",
referencedClasses: ["Smalltalk", "ShadowingVariableError"],
messageSends: ["parse:", "should:raise:", "visit:"]
}),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariablesLookup",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
var $7,$6,$5,$4,$3,$2,$1,$15,$14,$13,$12,$11,$10,$9,$16,$8,$27,$26,$25,$24,$23,$22,$21,$20,$19,$18,$17,$39,$38,$37,$36,$35,$34,$33,$32,$31,$30,$29,$42,$41,$40,$28;
src="foo | a | a + 1. [ | b | b := a ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv(self["@analyzer"])._visit_(ast);
$7=$recv(ast)._nodes();
$ctx1.sendIdx["nodes"]=2;
$6=$recv($7)._first();
$ctx1.sendIdx["first"]=2;
$5=$recv($6)._nodes();
$ctx1.sendIdx["nodes"]=1;
$4=$recv($5)._first();
$ctx1.sendIdx["first"]=1;
$3=$recv($4)._receiver();
$ctx1.sendIdx["receiver"]=1;
$2=$recv($3)._binding();
$ctx1.sendIdx["binding"]=1;
$1=$recv($2)._isTempVar();
$ctx1.sendIdx["isTempVar"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$15=$recv(ast)._nodes();
$ctx1.sendIdx["nodes"]=4;
$14=$recv($15)._first();
$ctx1.sendIdx["first"]=4;
$13=$recv($14)._nodes();
$ctx1.sendIdx["nodes"]=3;
$12=$recv($13)._first();
$ctx1.sendIdx["first"]=3;
$11=$recv($12)._receiver();
$10=$recv($11)._binding();
$ctx1.sendIdx["binding"]=2;
$9=$recv($10)._scope();
$ctx1.sendIdx["scope"]=1;
$16=$recv(ast)._scope();
$ctx1.sendIdx["scope"]=2;
$8=$recv($9).__eq_eq($16);
$ctx1.sendIdx["=="]=1;
self._assert_($8);
$ctx1.sendIdx["assert:"]=2;
$27=$recv(ast)._nodes();
$ctx1.sendIdx["nodes"]=8;
$26=$recv($27)._first();
$ctx1.sendIdx["first"]=7;
$25=$recv($26)._nodes();
$ctx1.sendIdx["nodes"]=7;
$24=$recv($25)._last();
$ctx1.sendIdx["last"]=1;
$23=$recv($24)._nodes();
$ctx1.sendIdx["nodes"]=6;
$22=$recv($23)._first();
$ctx1.sendIdx["first"]=6;
$21=$recv($22)._nodes();
$ctx1.sendIdx["nodes"]=5;
$20=$recv($21)._first();
$ctx1.sendIdx["first"]=5;
$19=$recv($20)._left();
$ctx1.sendIdx["left"]=1;
$18=$recv($19)._binding();
$ctx1.sendIdx["binding"]=3;
$17=$recv($18)._isTempVar();
self._assert_($17);
$ctx1.sendIdx["assert:"]=3;
$39=$recv(ast)._nodes();
$ctx1.sendIdx["nodes"]=12;
$38=$recv($39)._first();
$ctx1.sendIdx["first"]=10;
$37=$recv($38)._nodes();
$ctx1.sendIdx["nodes"]=11;
$36=$recv($37)._last();
$ctx1.sendIdx["last"]=2;
$35=$recv($36)._nodes();
$ctx1.sendIdx["nodes"]=10;
$34=$recv($35)._first();
$ctx1.sendIdx["first"]=9;
$33=$recv($34)._nodes();
$ctx1.sendIdx["nodes"]=9;
$32=$recv($33)._first();
$ctx1.sendIdx["first"]=8;
$31=$recv($32)._left();
$30=$recv($31)._binding();
$29=$recv($30)._scope();
$ctx1.sendIdx["scope"]=3;
$42=$recv($recv($recv(ast)._nodes())._first())._nodes();
$ctx1.sendIdx["nodes"]=13;
$41=$recv($42)._last();
$40=$recv($41)._scope();
$28=$recv($29).__eq_eq($40);
self._assert_($28);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariablesLookup",{src:src,ast:ast},$globals.SemanticAnalyzerTest)});
},
args: [],
source: "testVariablesLookup\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. [ | b | b := a ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09\x22Binding for `a` in the message send\x22\x0a\x09self assert: ast nodes first nodes first receiver binding isTempVar.\x0a\x09self assert: ast nodes first nodes first receiver binding scope == ast scope.\x0a\x0a\x09\x22Binding for `b`\x22\x0a\x09self assert: ast nodes first nodes last nodes first nodes first left binding isTempVar.\x0a\x09self assert: ast nodes first nodes last nodes first nodes first left binding scope == ast nodes first nodes last scope.",
referencedClasses: ["Smalltalk"],
messageSends: ["parse:", "visit:", "assert:", "isTempVar", "binding", "receiver", "first", "nodes", "==", "scope", "left", "last"]
}),
$globals.SemanticAnalyzerTest);



$core.addClass('AISemanticAnalyzerTest', $globals.SemanticAnalyzerTest, [], 'Compiler-Tests');
$core.addMethod(
$core.method({
selector: "setUp",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$4,$2;
$1=$recv($globals.AISemanticAnalyzer)._on_($globals.Object);
$3=$recv($globals.AIContext)._new();
$recv($3)._defineLocal_("local");
$recv($3)._localAt_put_("local",(3));
$4=$recv($3)._yourself();
$ctx1.sendIdx["yourself"]=1;
$2=$4;
$recv($1)._context_($2);
self["@analyzer"]=$recv($1)._yourself();
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{},$globals.AISemanticAnalyzerTest)});
},
args: [],
source: "setUp\x0a\x09analyzer := (AISemanticAnalyzer on: Object)\x0a\x09\x09context: (AIContext new\x0a\x09\x09\x09defineLocal: 'local';\x0a\x09\x09\x09localAt: 'local' put: 3;\x0a\x09\x09\x09yourself);\x0a\x09\x09yourself",
referencedClasses: ["AISemanticAnalyzer", "Object", "AIContext"],
messageSends: ["context:", "on:", "defineLocal:", "new", "localAt:put:", "yourself"]
}),
$globals.AISemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testContextVariables",
protocol: 'tests',
fn: function (){
var self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | local + a";
ast=$recv($globals.Smalltalk)._parse_(src);
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@analyzer"])._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.UnknownVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testContextVariables",{src:src,ast:ast},$globals.AISemanticAnalyzerTest)});
},
args: [],
source: "testContextVariables\x0a\x09| src ast |\x0a\x09\x0a\x09src := 'foo | a | local + a'.\x0a\x09ast := Smalltalk parse: src.\x0a\x0a\x09self shouldnt: [ analyzer visit: ast ] raise: UnknownVariableError",
referencedClasses: ["Smalltalk", "UnknownVariableError"],
messageSends: ["parse:", "shouldnt:raise:", "visit:"]
}),
$globals.AISemanticAnalyzerTest);


});

define("amber_core/Kernel-Tests", ["amber/boot", "amber_core/SUnit", "amber_core/Kernel-Objects"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('Kernel-Tests');
$core.packages["Kernel-Tests"].innerEval = function (expr) { return eval(expr); };
$core.packages["Kernel-Tests"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('AnnouncementSubscriptionTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testAddExtensionMethod",
protocol: 'tests',
fn: function (){
var self=this;
var method,dirty;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$5,$8,$7,$6,$9,$10;
$2=self._class();
$ctx1.sendIdx["class"]=1;
$1=$recv($2)._package();
$ctx1.sendIdx["package"]=1;
dirty=$recv($1)._isDirty();
$ctx1.sendIdx["isDirty"]=1;
$4=self._class();
$ctx1.sendIdx["class"]=2;
$3=$recv($4)._package();
$ctx1.sendIdx["package"]=2;
$recv($3)._beClean();
$5=self._class();
$ctx1.sendIdx["class"]=3;
method=$recv($5)._compile_protocol_("doNothing","**not-a-package");
$8=self._class();
$ctx1.sendIdx["class"]=4;
$7=$recv($8)._package();
$ctx1.sendIdx["package"]=3;
$6=$recv($7)._isDirty();
self._deny_($6);
$9=self._class();
$ctx1.sendIdx["class"]=5;
$recv($9)._removeCompiledMethod_(method);
$10=dirty;
if($core.assert($10)){
$recv($recv(self._class())._package())._beDirty();
};
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddExtensionMethod",{method:method,dirty:dirty},$globals.AnnouncementSubscriptionTest)});
},
args: [],
source: "testAddExtensionMethod\x0a\x09| method dirty |\x0a\x09dirty := self class package isDirty.\x0a\x09self class package beClean.\x0a\x09method := self class compile: 'doNothing' protocol: '**not-a-package'.\x0a\x09self deny: self class package isDirty.\x0a\x09\x0a\x09self class removeCompiledMethod: method.\x0a\x09dirty ifTrue: [ self class package beDirty ]",
referencedClasses: [],
messageSends: ["isDirty", "package", "class", "beClean", "compile:protocol:", "deny:", "removeCompiledMethod:", "ifTrue:", "beDirty"]
}),
$globals.AnnouncementSubscriptionTest);

$core.addMethod(
$core.method({
selector: "testHandlesAnnouncement",
protocol: 'tests',
fn: function (){
var self=this;
var subscription,announcementClass1,announcementClass2,classBuilder;
return $core.withContext(function($ctx1) {
var $1,$2;
classBuilder=$recv($globals.ClassBuilder)._new();
$ctx1.sendIdx["new"]=1;
announcementClass1=$recv(classBuilder)._basicAddSubclassOf_named_instanceVariableNames_package_($globals.SystemAnnouncement,"TestAnnouncement1",[],"Kernel-Tests");
subscription=$recv($recv($globals.AnnouncementSubscription)._new())._announcementClass_($globals.SystemAnnouncement);
$1=$recv(subscription)._handlesAnnouncement_($globals.SystemAnnouncement);
$ctx1.sendIdx["handlesAnnouncement:"]=1;
self._assert_equals_($1,true);
$ctx1.sendIdx["assert:equals:"]=1;
$2=$recv(subscription)._handlesAnnouncement_(announcementClass1);
$ctx1.sendIdx["handlesAnnouncement:"]=2;
self._assert_equals_($2,true);
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_($recv(subscription)._handlesAnnouncement_($globals.Object),false);
$recv(classBuilder)._basicRemoveClass_(announcementClass1);
return self;
}, function($ctx1) {$ctx1.fill(self,"testHandlesAnnouncement",{subscription:subscription,announcementClass1:announcementClass1,announcementClass2:announcementClass2,classBuilder:classBuilder},$globals.AnnouncementSubscriptionTest)});
},
args: [],
source: "testHandlesAnnouncement\x0a\x09| subscription announcementClass1 announcementClass2 classBuilder |\x0a\x09\x0a\x09classBuilder := ClassBuilder new.\x0a\x09announcementClass1 := classBuilder basicAddSubclassOf: SystemAnnouncement named: 'TestAnnouncement1' instanceVariableNames: #() package: 'Kernel-Tests'.\x0a\x09\x0a\x09subscription := AnnouncementSubscription new announcementClass: SystemAnnouncement.\x0a\x09\x22Test whether the same class triggers the announcement\x22\x0a\x09self assert: (subscription handlesAnnouncement: SystemAnnouncement) equals: true.\x0a\x09\x22Test whether a subclass triggers the announcement\x22\x0a\x09self assert: (subscription handlesAnnouncement: announcementClass1) equals: true.\x0a\x09\x22Test whether an unrelated class does not trigger the announcement\x22\x0a\x09self assert: (subscription handlesAnnouncement: Object) equals: false.\x0a\x09\x0a\x09classBuilder basicRemoveClass: announcementClass1.",
referencedClasses: ["ClassBuilder", "SystemAnnouncement", "AnnouncementSubscription", "Object"],
messageSends: ["new", "basicAddSubclassOf:named:instanceVariableNames:package:", "announcementClass:", "assert:equals:", "handlesAnnouncement:", "basicRemoveClass:"]
}),
$globals.AnnouncementSubscriptionTest);



$core.addClass('AnnouncerTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testOnDo",
protocol: 'tests',
fn: function (){
var self=this;
var counter,announcer;
return $core.withContext(function($ctx1) {
var $1,$2;
counter=(0);
announcer=$recv($globals.Announcer)._new();
$ctx1.sendIdx["new"]=1;
$recv(announcer)._on_do_($globals.SystemAnnouncement,(function(){
return $core.withContext(function($ctx2) {
counter=$recv(counter).__plus((1));
return counter;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$1=announcer;
$2=$recv($globals.SystemAnnouncement)._new();
$ctx1.sendIdx["new"]=2;
$recv($1)._announce_($2);
$ctx1.sendIdx["announce:"]=1;
self._assert_equals_(counter,(1));
$ctx1.sendIdx["assert:equals:"]=1;
$recv(announcer)._announce_($recv($globals.SystemAnnouncement)._new());
self._assert_equals_(counter,(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOnDo",{counter:counter,announcer:announcer},$globals.AnnouncerTest)});
},
args: [],
source: "testOnDo\x0a\x09| counter announcer |\x0a\x09\x0a\x09counter := 0.\x0a\x09announcer := Announcer new.\x0a\x09announcer on: SystemAnnouncement do: [ counter := counter + 1 ].\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 1.\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 2.",
referencedClasses: ["Announcer", "SystemAnnouncement"],
messageSends: ["new", "on:do:", "+", "announce:", "assert:equals:"]
}),
$globals.AnnouncerTest);

$core.addMethod(
$core.method({
selector: "testOnDoFor",
protocol: 'tests',
fn: function (){
var self=this;
var counter,announcer;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
counter=(0);
announcer=$recv($globals.Announcer)._new();
$ctx1.sendIdx["new"]=1;
$recv(announcer)._on_do_for_($globals.SystemAnnouncement,(function(){
return $core.withContext(function($ctx2) {
counter=$recv(counter).__plus((1));
return counter;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),self);
$1=announcer;
$2=$recv($globals.SystemAnnouncement)._new();
$ctx1.sendIdx["new"]=2;
$recv($1)._announce_($2);
$ctx1.sendIdx["announce:"]=1;
self._assert_equals_(counter,(1));
$ctx1.sendIdx["assert:equals:"]=1;
$3=announcer;
$4=$recv($globals.SystemAnnouncement)._new();
$ctx1.sendIdx["new"]=3;
$recv($3)._announce_($4);
$ctx1.sendIdx["announce:"]=2;
self._assert_equals_(counter,(2));
$ctx1.sendIdx["assert:equals:"]=2;
$recv(announcer)._unsubscribe_(self);
$recv(announcer)._announce_($recv($globals.SystemAnnouncement)._new());
self._assert_equals_(counter,(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOnDoFor",{counter:counter,announcer:announcer},$globals.AnnouncerTest)});
},
args: [],
source: "testOnDoFor\x0a\x09| counter announcer |\x0a\x09\x0a\x09counter := 0.\x0a\x09announcer := Announcer new.\x0a\x09announcer on: SystemAnnouncement do: [ counter := counter + 1 ] for: self.\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 1.\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 2.\x0a\x09\x0a\x09announcer unsubscribe: self.\x0a\x09\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 2.",
referencedClasses: ["Announcer", "SystemAnnouncement"],
messageSends: ["new", "on:do:for:", "+", "announce:", "assert:equals:", "unsubscribe:"]
}),
$globals.AnnouncerTest);

$core.addMethod(
$core.method({
selector: "testOnDoOnce",
protocol: 'tests',
fn: function (){
var self=this;
var counter,announcer;
return $core.withContext(function($ctx1) {
var $1,$2;
counter=(0);
announcer=$recv($globals.Announcer)._new();
$ctx1.sendIdx["new"]=1;
$recv(announcer)._on_doOnce_($globals.SystemAnnouncement,(function(){
return $core.withContext(function($ctx2) {
counter=$recv(counter).__plus((1));
return counter;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$1=announcer;
$2=$recv($globals.SystemAnnouncement)._new();
$ctx1.sendIdx["new"]=2;
$recv($1)._announce_($2);
$ctx1.sendIdx["announce:"]=1;
self._assert_equals_(counter,(1));
$ctx1.sendIdx["assert:equals:"]=1;
$recv(announcer)._announce_($recv($globals.SystemAnnouncement)._new());
self._assert_equals_(counter,(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOnDoOnce",{counter:counter,announcer:announcer},$globals.AnnouncerTest)});
},
args: [],
source: "testOnDoOnce\x0a\x09| counter announcer |\x0a\x09\x0a\x09counter := 0.\x0a\x09announcer := Announcer new.\x0a\x09announcer on: SystemAnnouncement doOnce: [ counter := counter + 1 ].\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 1.\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 1.",
referencedClasses: ["Announcer", "SystemAnnouncement"],
messageSends: ["new", "on:doOnce:", "+", "announce:", "assert:equals:"]
}),
$globals.AnnouncerTest);



$core.addClass('BlockClosureTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "localReturnOnDoCatch",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$recv((function(){
throw $early=[(2)];

}))._on_do_($globals.Error,(function(){

}));
return (3);
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"localReturnOnDoCatch",{},$globals.BlockClosureTest)});
},
args: [],
source: "localReturnOnDoCatch\x0a    [ ^ 2 ] on: Error do: [].\x0a    ^ 3",
referencedClasses: ["Error"],
messageSends: ["on:do:"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "localReturnOnDoMiss",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$recv((function(){
throw $early=[(2)];

}))._on_do_($globals.Class,(function(){

}));
return (3);
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"localReturnOnDoMiss",{},$globals.BlockClosureTest)});
},
args: [],
source: "localReturnOnDoMiss\x0a    [ ^ 2 ] on: Class do: [].\x0a    ^ 3",
referencedClasses: ["Class"],
messageSends: ["on:do:"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testCanClearInterval",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv((function(){
return $core.withContext(function($ctx3) {
return $recv($recv($globals.Error)._new())._signal();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._valueWithInterval_((0)))._clearInterval();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCanClearInterval",{},$globals.BlockClosureTest)});
},
args: [],
source: "testCanClearInterval\x0a\x09self shouldnt: [ ([ Error new signal ] valueWithInterval: 0) clearInterval ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["shouldnt:raise:", "clearInterval", "valueWithInterval:", "signal", "new"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testCanClearTimeout",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv((function(){
return $core.withContext(function($ctx3) {
return $recv($recv($globals.Error)._new())._signal();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._valueWithTimeout_((0)))._clearTimeout();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCanClearTimeout",{},$globals.BlockClosureTest)});
},
args: [],
source: "testCanClearTimeout\x0a\x09self shouldnt: [ ([ Error new signal ] valueWithTimeout: 0) clearTimeout ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["shouldnt:raise:", "clearTimeout", "valueWithTimeout:", "signal", "new"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testCompiledSource",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_($recv($recv((function(){
return $core.withContext(function($ctx2) {
return (1).__plus((1));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._compiledSource())._includesSubString_("function"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCompiledSource",{},$globals.BlockClosureTest)});
},
args: [],
source: "testCompiledSource\x0a\x09self assert: ([ 1+1 ] compiledSource includesSubString: 'function')",
referencedClasses: [],
messageSends: ["assert:", "includesSubString:", "compiledSource", "+"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testCurrySelf",
protocol: 'tests',
fn: function (){
var self=this;
var curriedMethod,array;
return $core.withContext(function($ctx1) {
curriedMethod=$recv($recv((function(selfarg,x){
return $core.withContext(function($ctx2) {
return $recv(selfarg)._at_(x);
}, function($ctx2) {$ctx2.fillBlock({selfarg:selfarg,x:x},$ctx1,1)});
}))._currySelf())._asCompiledMethod_("foo:");
array=[(3), (1), (4)];
$recv($recv($globals.ClassBuilder)._new())._installMethod_forClass_protocol_(curriedMethod,$globals.Array,"**test helper");
$recv((function(){
return $core.withContext(function($ctx2) {
return self._assert_equals_($recv(array)._foo_((2)),(1));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}))._ensure_((function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Array)._removeCompiledMethod_(curriedMethod);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCurrySelf",{curriedMethod:curriedMethod,array:array},$globals.BlockClosureTest)});
},
args: [],
source: "testCurrySelf\x0a\x09| curriedMethod array |\x0a\x09curriedMethod := [ :selfarg :x | selfarg at: x ] currySelf asCompiledMethod: 'foo:'.\x0a\x09array := #(3 1 4).\x0a\x09ClassBuilder new installMethod: curriedMethod forClass: Array protocol: '**test helper'.\x0a\x09[ self assert: (array foo: 2) equals: 1 ]\x0a\x09ensure: [ Array removeCompiledMethod: curriedMethod ]",
referencedClasses: ["ClassBuilder", "Array"],
messageSends: ["asCompiledMethod:", "currySelf", "at:", "installMethod:forClass:protocol:", "new", "ensure:", "assert:equals:", "foo:", "removeCompiledMethod:"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testEnsure",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_($recv((function(){
return (3);

}))._ensure_((function(){
return (4);

})),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEnsure",{},$globals.BlockClosureTest)});
},
args: [],
source: "testEnsure\x0a\x09self assert: ([ 3 ] ensure: [ 4 ]) equals: 3",
referencedClasses: [],
messageSends: ["assert:equals:", "ensure:"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testEnsureRaises",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv((function(){
return $core.withContext(function($ctx3) {
return $recv($recv($globals.Error)._new())._signal();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._ensure_((function(){
return true;

}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testEnsureRaises",{},$globals.BlockClosureTest)});
},
args: [],
source: "testEnsureRaises\x0a\x09self should: [ [Error new signal ] ensure: [ true ]] raise: Error",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "ensure:", "signal", "new"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testExceptionSemantics",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._timeout_((100));
$recv(self._async_((function(){
return $core.withContext(function($ctx2) {
return $recv((function(){
return $core.withContext(function($ctx3) {
self._assert_(true);
$recv($globals.Error)._signal();
self._deny_(true);
return self._finished();
$ctx3.sendIdx["finished"]=1;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx3) {
return self._finished();
}, function($ctx3) {$ctx3.fillBlock({ex:ex},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testExceptionSemantics",{},$globals.BlockClosureTest)});
},
args: [],
source: "testExceptionSemantics\x0a\x09\x22See https://github.com/NicolasPetton/amber/issues/314\x22\x0a\x09self timeout: 100.\x0a\x09\x0a\x09(self async: [\x0a\x09\x09[\x0a\x09\x09\x09self assert: true.\x0a\x09\x09\x09Error signal.\x0a\x09\x09\x09\x22The following should *not* be run\x22\x0a\x09\x09\x09self deny: true.\x0a\x09\x09\x09self finished.\x0a\x09\x09] on: Error do: [ :ex | self finished ]\x0a\x09]) valueWithTimeout: 0",
referencedClasses: ["Error"],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "on:do:", "assert:", "signal", "deny:", "finished"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testLocalReturnOnDoCatch",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_(self._localReturnOnDoCatch(),(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLocalReturnOnDoCatch",{},$globals.BlockClosureTest)});
},
args: [],
source: "testLocalReturnOnDoCatch\x0a\x09self assert: self localReturnOnDoCatch equals: 2",
referencedClasses: [],
messageSends: ["assert:equals:", "localReturnOnDoCatch"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testLocalReturnOnDoMiss",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_(self._localReturnOnDoMiss(),(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLocalReturnOnDoMiss",{},$globals.BlockClosureTest)});
},
args: [],
source: "testLocalReturnOnDoMiss\x0a\x09self assert: self localReturnOnDoMiss equals: 2",
referencedClasses: [],
messageSends: ["assert:equals:", "localReturnOnDoMiss"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testNewWithValues",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

	function TestConstructor(arg1, arg2, arg3) {}
	TestConstructor.prototype.name = 'theTestPrototype';

	var wrappedConstructor = $recv(TestConstructor);
	var result = wrappedConstructor._newWithValues_([1, 2, 3 ]);
	self._assert_(result instanceof TestConstructor);
	self._assert_equals_(result.name, 'theTestPrototype');

	"newWithValues: cannot help if the argument list is wrong, and should warn that a mistake was made."
	self._should_raise_(function () {wrappedConstructor._newWithValues_('single argument');}, $globals.Error);;
return self;
}, function($ctx1) {$ctx1.fill(self,"testNewWithValues",{},$globals.BlockClosureTest)});
},
args: [],
source: "testNewWithValues\x0a<\x0a\x09function TestConstructor(arg1, arg2, arg3) {}\x0a\x09TestConstructor.prototype.name = 'theTestPrototype';\x0a\x0a\x09var wrappedConstructor = $recv(TestConstructor);\x0a\x09var result = wrappedConstructor._newWithValues_([1, 2, 3 ]);\x0a\x09self._assert_(result instanceof TestConstructor);\x0a\x09self._assert_equals_(result.name, 'theTestPrototype');\x0a\x0a\x09\x22newWithValues: cannot help if the argument list is wrong, and should warn that a mistake was made.\x22\x0a\x09self._should_raise_(function () {wrappedConstructor._newWithValues_('single argument');}, $globals.Error);\x0a>",
referencedClasses: [],
messageSends: []
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testNumArgs",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv((function(){

}))._numArgs();
$ctx1.sendIdx["numArgs"]=1;
self._assert_equals_($1,(0));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_($recv((function(a,b){

}))._numArgs(),(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNumArgs",{},$globals.BlockClosureTest)});
},
args: [],
source: "testNumArgs\x0a\x09self assert: [] numArgs equals: 0.\x0a\x09self assert: [ :a :b | ] numArgs equals: 2",
referencedClasses: [],
messageSends: ["assert:equals:", "numArgs"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testOnDo",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_($recv((function(){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.Error)._new())._signal();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(ex){
return true;

})));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOnDo",{},$globals.BlockClosureTest)});
},
args: [],
source: "testOnDo\x0a\x09self assert: ([ Error new signal ] on: Error do: [ :ex | true ])",
referencedClasses: ["Error"],
messageSends: ["assert:", "on:do:", "signal", "new"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testValue",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv((function(){
return $core.withContext(function($ctx2) {
return (1).__plus((1));
$ctx2.sendIdx["+"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._value();
$ctx1.sendIdx["value"]=1;
self._assert_equals_($1,(2));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_($recv((function(x){
return $core.withContext(function($ctx2) {
return $recv(x).__plus((1));
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,2)});
}))._value_((2)),(3));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_($recv((function(x,y){
return $core.withContext(function($ctx2) {
return $recv(x).__star(y);
}, function($ctx2) {$ctx2.fillBlock({x:x,y:y},$ctx1,3)});
}))._value_value_((2),(4)),(8));
$ctx1.sendIdx["assert:equals:"]=3;
self._assert_equals_($recv((function(a,b,c){
return (1);

}))._value(),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testValue",{},$globals.BlockClosureTest)});
},
args: [],
source: "testValue\x0a\x09self assert: ([ 1+1 ] value) equals: 2.\x0a\x09self assert: ([ :x | x +1 ] value: 2) equals: 3.\x0a\x09self assert: ([ :x :y | x*y ] value: 2 value: 4) equals: 8.\x0a\x0a\x09\x22Arguments are optional in Amber. This isn't ANSI compliant.\x22\x0a\x0a\x09self assert: ([ :a :b :c | 1 ] value) equals: 1",
referencedClasses: [],
messageSends: ["assert:equals:", "value", "+", "value:", "value:value:", "*"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testValueWithPossibleArguments",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv((function(){
return (1);

}))._valueWithPossibleArguments_([(3), (4)]);
$ctx1.sendIdx["valueWithPossibleArguments:"]=1;
self._assert_equals_($1,(1));
$ctx1.sendIdx["assert:equals:"]=1;
$2=$recv((function(a){
return $core.withContext(function($ctx2) {
return $recv(a).__plus((4));
$ctx2.sendIdx["+"]=1;
}, function($ctx2) {$ctx2.fillBlock({a:a},$ctx1,2)});
}))._valueWithPossibleArguments_([(3), (4)]);
$ctx1.sendIdx["valueWithPossibleArguments:"]=2;
self._assert_equals_($2,(7));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_($recv((function(a,b){
return $core.withContext(function($ctx2) {
return $recv(a).__plus(b);
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,3)});
}))._valueWithPossibleArguments_([(3), (4), (5)]),(7));
return self;
}, function($ctx1) {$ctx1.fill(self,"testValueWithPossibleArguments",{},$globals.BlockClosureTest)});
},
args: [],
source: "testValueWithPossibleArguments\x0a\x09self assert: ([ 1 ] valueWithPossibleArguments: #(3 4)) equals: 1.\x0a\x09self assert: ([ :a | a + 4 ] valueWithPossibleArguments: #(3 4)) equals: 7.\x0a\x09self assert: ([ :a :b | a + b ] valueWithPossibleArguments: #(3 4 5)) equals: 7.",
referencedClasses: [],
messageSends: ["assert:equals:", "valueWithPossibleArguments:", "+"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testWhileFalse",
protocol: 'tests',
fn: function (){
var self=this;
var i;
return $core.withContext(function($ctx1) {
i=(0);
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(i).__gt((5));
$ctx2.sendIdx[">"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
i=$recv(i).__plus((1));
$ctx2.sendIdx["+"]=1;
return i;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
self._assert_equals_(i,(6));
$ctx1.sendIdx["assert:equals:"]=1;
i=(0);
$recv((function(){
return $core.withContext(function($ctx2) {
i=$recv(i).__plus((1));
i;
return $recv(i).__gt((5));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))._whileFalse();
self._assert_equals_(i,(6));
return self;
}, function($ctx1) {$ctx1.fill(self,"testWhileFalse",{i:i},$globals.BlockClosureTest)});
},
args: [],
source: "testWhileFalse\x0a\x09| i |\x0a\x09i := 0.\x0a\x09[ i > 5 ] whileFalse: [ i := i + 1 ].\x0a\x09self assert: i equals: 6.\x0a\x0a\x09i := 0.\x0a\x09[ i := i + 1. i > 5 ] whileFalse.\x0a\x09self assert: i equals: 6",
referencedClasses: [],
messageSends: ["whileFalse:", ">", "+", "assert:equals:", "whileFalse"]
}),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testWhileTrue",
protocol: 'tests',
fn: function (){
var self=this;
var i;
return $core.withContext(function($ctx1) {
i=(0);
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(i).__lt((5));
$ctx2.sendIdx["<"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
i=$recv(i).__plus((1));
$ctx2.sendIdx["+"]=1;
return i;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
self._assert_equals_(i,(5));
$ctx1.sendIdx["assert:equals:"]=1;
i=(0);
$recv((function(){
return $core.withContext(function($ctx2) {
i=$recv(i).__plus((1));
i;
return $recv(i).__lt((5));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))._whileTrue();
self._assert_equals_(i,(5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testWhileTrue",{i:i},$globals.BlockClosureTest)});
},
args: [],
source: "testWhileTrue\x0a\x09| i |\x0a\x09i := 0.\x0a\x09[ i < 5 ] whileTrue: [ i := i + 1 ].\x0a\x09self assert: i equals: 5.\x0a\x0a\x09i := 0.\x0a\x09[ i := i + 1. i < 5 ] whileTrue.\x0a\x09self assert: i equals: 5",
referencedClasses: [],
messageSends: ["whileTrue:", "<", "+", "assert:equals:", "whileTrue"]
}),
$globals.BlockClosureTest);



$core.addClass('BooleanTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testEquality",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$8,$10,$9,$12,$11;
$1=(0).__eq(false);
$ctx1.sendIdx["="]=1;
self._deny_($1);
$ctx1.sendIdx["deny:"]=1;
$2=false.__eq((0));
$ctx1.sendIdx["="]=2;
self._deny_($2);
$ctx1.sendIdx["deny:"]=2;
$3="".__eq(false);
$ctx1.sendIdx["="]=3;
self._deny_($3);
$ctx1.sendIdx["deny:"]=3;
$4=false.__eq("");
$ctx1.sendIdx["="]=4;
self._deny_($4);
$ctx1.sendIdx["deny:"]=4;
$5=true.__eq(true);
$ctx1.sendIdx["="]=5;
self._assert_($5);
$ctx1.sendIdx["assert:"]=1;
$6=false.__eq(true);
$ctx1.sendIdx["="]=6;
self._deny_($6);
$ctx1.sendIdx["deny:"]=5;
$7=true.__eq(false);
$ctx1.sendIdx["="]=7;
self._deny_($7);
$8=false.__eq(false);
$ctx1.sendIdx["="]=8;
self._assert_($8);
$ctx1.sendIdx["assert:"]=2;
$10=true._yourself();
$ctx1.sendIdx["yourself"]=1;
$9=$recv($10).__eq(true);
$ctx1.sendIdx["="]=9;
self._assert_($9);
$ctx1.sendIdx["assert:"]=3;
$12=true._yourself();
$ctx1.sendIdx["yourself"]=2;
$11=$recv($12).__eq(true._yourself());
self._assert_($11);
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{},$globals.BooleanTest)});
},
args: [],
source: "testEquality\x0a\x09\x22We're on top of JS...just be sure to check the basics!\x22\x0a\x0a\x09self deny: 0 = false.\x0a\x09self deny: false = 0.\x0a\x09self deny: '' = false.\x0a\x09self deny: false = ''.\x0a\x0a\x09self assert: (true = true).\x0a\x09self deny: false = true.\x0a\x09self deny: true = false.\x0a\x09self assert: (false = false).\x0a\x0a\x09\x22JS may do some type coercing after sending a message\x22\x0a\x09self assert: (true yourself = true).\x0a\x09self assert: (true yourself = true yourself)",
referencedClasses: [],
messageSends: ["deny:", "=", "assert:", "yourself"]
}),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testIdentity",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$8,$10,$9,$12,$11;
$1=(0).__eq_eq(false);
$ctx1.sendIdx["=="]=1;
self._deny_($1);
$ctx1.sendIdx["deny:"]=1;
$2=false.__eq_eq((0));
$ctx1.sendIdx["=="]=2;
self._deny_($2);
$ctx1.sendIdx["deny:"]=2;
$3="".__eq_eq(false);
$ctx1.sendIdx["=="]=3;
self._deny_($3);
$ctx1.sendIdx["deny:"]=3;
$4=false.__eq_eq("");
$ctx1.sendIdx["=="]=4;
self._deny_($4);
$ctx1.sendIdx["deny:"]=4;
$5=true.__eq_eq(true);
$ctx1.sendIdx["=="]=5;
self._assert_($5);
$ctx1.sendIdx["assert:"]=1;
$6=false.__eq_eq(true);
$ctx1.sendIdx["=="]=6;
self._deny_($6);
$ctx1.sendIdx["deny:"]=5;
$7=true.__eq_eq(false);
$ctx1.sendIdx["=="]=7;
self._deny_($7);
$8=false.__eq_eq(false);
$ctx1.sendIdx["=="]=8;
self._assert_($8);
$ctx1.sendIdx["assert:"]=2;
$10=true._yourself();
$ctx1.sendIdx["yourself"]=1;
$9=$recv($10).__eq_eq(true);
$ctx1.sendIdx["=="]=9;
self._assert_($9);
$ctx1.sendIdx["assert:"]=3;
$12=true._yourself();
$ctx1.sendIdx["yourself"]=2;
$11=$recv($12).__eq_eq(true._yourself());
self._assert_($11);
return self;
}, function($ctx1) {$ctx1.fill(self,"testIdentity",{},$globals.BooleanTest)});
},
args: [],
source: "testIdentity\x0a\x09\x22We're on top of JS...just be sure to check the basics!\x22\x0a\x0a\x09self deny: 0 == false.\x0a\x09self deny: false == 0.\x0a\x09self deny: '' == false.\x0a\x09self deny: false == ''.\x0a\x0a\x09self assert: true == true.\x0a\x09self deny: false == true.\x0a\x09self deny: true == false.\x0a\x09self assert: false == false.\x0a\x0a\x09\x22JS may do some type coercing after sending a message\x22\x0a\x09self assert: true yourself == true.\x0a\x09self assert: true yourself == true yourself",
referencedClasses: [],
messageSends: ["deny:", "==", "assert:", "yourself"]
}),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testIfTrueIfFalse",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$8;
if($core.assert(true)){
$1="alternative block";
};
self._assert_equals_($1,"alternative block");
$ctx1.sendIdx["assert:equals:"]=1;
if(!$core.assert(true)){
$2="alternative block";
};
self._assert_equals_($2,nil);
$ctx1.sendIdx["assert:equals:"]=2;
if($core.assert(false)){
$3="alternative block";
};
self._assert_equals_($3,nil);
$ctx1.sendIdx["assert:equals:"]=3;
if(!$core.assert(false)){
$4="alternative block";
};
self._assert_equals_($4,"alternative block");
$ctx1.sendIdx["assert:equals:"]=4;
if($core.assert(false)){
$5="alternative block";
} else {
$5="alternative block2";
};
self._assert_equals_($5,"alternative block2");
$ctx1.sendIdx["assert:equals:"]=5;
if($core.assert(false)){
$6="alternative block2";
} else {
$6="alternative block";
};
self._assert_equals_($6,"alternative block");
$ctx1.sendIdx["assert:equals:"]=6;
if($core.assert(true)){
$7="alternative block";
} else {
$7="alternative block2";
};
self._assert_equals_($7,"alternative block");
$ctx1.sendIdx["assert:equals:"]=7;
if($core.assert(true)){
$8="alternative block2";
} else {
$8="alternative block";
};
self._assert_equals_($8,"alternative block2");
return self;
}, function($ctx1) {$ctx1.fill(self,"testIfTrueIfFalse",{},$globals.BooleanTest)});
},
args: [],
source: "testIfTrueIfFalse\x0a\x0a\x09self assert: (true ifTrue: [ 'alternative block' ]) equals: 'alternative block'.\x0a\x09self assert: (true ifFalse: [ 'alternative block' ]) equals: nil.\x0a\x0a\x09self assert: (false ifTrue: [ 'alternative block' ]) equals: nil.\x0a\x09self assert: (false ifFalse: [ 'alternative block' ]) equals: 'alternative block'.\x0a\x0a\x09self assert: (false ifTrue: [ 'alternative block' ] ifFalse: [ 'alternative block2' ]) equals: 'alternative block2'.\x0a\x09self assert: (false ifFalse: [ 'alternative block' ] ifTrue: [ 'alternative block2' ]) equals: 'alternative block'.\x0a\x0a\x09self assert: (true ifTrue: [ 'alternative block' ] ifFalse: [ 'alternative block2' ]) equals: 'alternative block'.\x0a\x09self assert: (true ifFalse: [ 'alternative block' ] ifTrue: [ 'alternative block2' ]) equals: 'alternative block2'.",
referencedClasses: [],
messageSends: ["assert:equals:", "ifTrue:", "ifFalse:", "ifTrue:ifFalse:", "ifFalse:ifTrue:"]
}),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testIfTrueIfFalseWithBoxing",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$6,$5,$8,$7,$10,$9,$12,$11,$14,$13,$16,$15;
$2=true._yourself();
$ctx1.sendIdx["yourself"]=1;
if($core.assert($2)){
$1="alternative block";
};
self._assert_equals_($1,"alternative block");
$ctx1.sendIdx["assert:equals:"]=1;
$4=true._yourself();
$ctx1.sendIdx["yourself"]=2;
if(!$core.assert($4)){
$3="alternative block";
};
self._assert_equals_($3,nil);
$ctx1.sendIdx["assert:equals:"]=2;
$6=false._yourself();
$ctx1.sendIdx["yourself"]=3;
if($core.assert($6)){
$5="alternative block";
};
self._assert_equals_($5,nil);
$ctx1.sendIdx["assert:equals:"]=3;
$8=false._yourself();
$ctx1.sendIdx["yourself"]=4;
if(!$core.assert($8)){
$7="alternative block";
};
self._assert_equals_($7,"alternative block");
$ctx1.sendIdx["assert:equals:"]=4;
$10=false._yourself();
$ctx1.sendIdx["yourself"]=5;
if($core.assert($10)){
$9="alternative block";
} else {
$9="alternative block2";
};
self._assert_equals_($9,"alternative block2");
$ctx1.sendIdx["assert:equals:"]=5;
$12=false._yourself();
$ctx1.sendIdx["yourself"]=6;
if($core.assert($12)){
$11="alternative block2";
} else {
$11="alternative block";
};
self._assert_equals_($11,"alternative block");
$ctx1.sendIdx["assert:equals:"]=6;
$14=true._yourself();
$ctx1.sendIdx["yourself"]=7;
if($core.assert($14)){
$13="alternative block";
} else {
$13="alternative block2";
};
self._assert_equals_($13,"alternative block");
$ctx1.sendIdx["assert:equals:"]=7;
$16=true._yourself();
if($core.assert($16)){
$15="alternative block2";
} else {
$15="alternative block";
};
self._assert_equals_($15,"alternative block2");
return self;
}, function($ctx1) {$ctx1.fill(self,"testIfTrueIfFalseWithBoxing",{},$globals.BooleanTest)});
},
args: [],
source: "testIfTrueIfFalseWithBoxing\x0a\x0a\x09self assert: (true yourself ifTrue: [ 'alternative block' ]) equals: 'alternative block'.\x0a\x09self assert: (true yourself ifFalse: [ 'alternative block' ]) equals: nil.\x0a\x0a\x09self assert: (false yourself ifTrue: [ 'alternative block' ]) equals: nil.\x0a\x09self assert: (false yourself ifFalse: [ 'alternative block' ]) equals: 'alternative block'.\x0a\x0a\x09self assert: (false yourself ifTrue: [ 'alternative block' ] ifFalse: [ 'alternative block2' ]) equals: 'alternative block2'.\x0a\x09self assert: (false yourself ifFalse: [ 'alternative block' ] ifTrue: [ 'alternative block2' ]) equals: 'alternative block'.\x0a\x0a\x09self assert: (true yourself ifTrue: [ 'alternative block' ] ifFalse: [ 'alternative block2' ]) equals: 'alternative block'.\x0a\x09self assert: (true yourself ifFalse: [ 'alternative block' ] ifTrue: [ 'alternative block2' ]) equals: 'alternative block2'.",
referencedClasses: [],
messageSends: ["assert:equals:", "ifTrue:", "yourself", "ifFalse:", "ifTrue:ifFalse:", "ifFalse:ifTrue:"]
}),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testLogic",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$4,$6,$7,$8,$10,$9,$12,$11,$14,$13,$16,$17,$15,$19,$18,$21,$20,$23,$22;
$1=true.__and(true);
$ctx1.sendIdx["&"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$2=true.__and(false);
$ctx1.sendIdx["&"]=2;
self._deny_($2);
$ctx1.sendIdx["deny:"]=1;
$3=false.__and(true);
$ctx1.sendIdx["&"]=3;
self._deny_($3);
$ctx1.sendIdx["deny:"]=2;
$5=false.__and(false);
$ctx1.sendIdx["&"]=4;
$4=self._deny_($5);
$ctx1.sendIdx["deny:"]=3;
$6=true.__or(true);
$ctx1.sendIdx["|"]=1;
self._assert_($6);
$ctx1.sendIdx["assert:"]=2;
$7=true.__or(false);
$ctx1.sendIdx["|"]=2;
self._assert_($7);
$ctx1.sendIdx["assert:"]=3;
$8=false.__or(true);
$ctx1.sendIdx["|"]=3;
self._assert_($8);
$ctx1.sendIdx["assert:"]=4;
$10=false.__or(false);
$ctx1.sendIdx["|"]=4;
$9=self._deny_($10);
$ctx1.sendIdx["deny:"]=4;
$12=(1).__gt((0));
$ctx1.sendIdx[">"]=1;
$11=true.__and($12);
$ctx1.sendIdx["&"]=5;
self._assert_($11);
$ctx1.sendIdx["assert:"]=5;
$14=(1).__gt((0));
$ctx1.sendIdx[">"]=2;
$13=$recv($14).__and(false);
$ctx1.sendIdx["&"]=6;
self._deny_($13);
$ctx1.sendIdx["deny:"]=5;
$16=(1).__gt((0));
$ctx1.sendIdx[">"]=3;
$17=(1).__gt((2));
$ctx1.sendIdx[">"]=4;
$15=$recv($16).__and($17);
self._deny_($15);
$19=(1).__gt((0));
$ctx1.sendIdx[">"]=5;
$18=false.__or($19);
$ctx1.sendIdx["|"]=5;
self._assert_($18);
$ctx1.sendIdx["assert:"]=6;
$21=(1).__gt((0));
$ctx1.sendIdx[">"]=6;
$20=$recv($21).__or(false);
$ctx1.sendIdx["|"]=6;
self._assert_($20);
$ctx1.sendIdx["assert:"]=7;
$23=(1).__gt((0));
$ctx1.sendIdx[">"]=7;
$22=$recv($23).__or((1).__gt((2)));
self._assert_($22);
return self;
}, function($ctx1) {$ctx1.fill(self,"testLogic",{},$globals.BooleanTest)});
},
args: [],
source: "testLogic\x0a\x09\x22Trivial logic table\x22\x0a\x09self assert: (true & true);\x0a\x09\x09deny: (true & false);\x0a\x09\x09deny: (false & true);\x0a\x09\x09deny: (false & false).\x0a\x09self assert: (true | true);\x0a\x09\x09assert: (true | false);\x0a\x09\x09assert: (false | true);\x0a\x09\x09deny: (false | false).\x0a\x09\x22Checking that expressions work fine too\x22\x0a\x09self assert: (true & (1 > 0));\x0a\x09\x09deny: ((1 > 0) & false);\x0a\x09\x09deny: ((1 > 0) & (1 > 2)).\x0a\x09self assert: (false | (1 > 0));\x0a\x09\x09assert: ((1 > 0) | false);\x0a\x09\x09assert: ((1 > 0) | (1 > 2))",
referencedClasses: [],
messageSends: ["assert:", "&", "deny:", "|", ">"]
}),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testLogicKeywords",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$4,$6,$7,$8,$10,$9,$11,$13,$12,$15,$14,$16,$18,$17,$20,$19;
$1=true._and_((function(){
return true;

}));
$ctx1.sendIdx["and:"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$2=true._and_((function(){
return false;

}));
$ctx1.sendIdx["and:"]=2;
self._deny_($2);
$ctx1.sendIdx["deny:"]=1;
$3=false._and_((function(){
return true;

}));
$ctx1.sendIdx["and:"]=3;
self._deny_($3);
$ctx1.sendIdx["deny:"]=2;
$5=false._and_((function(){
return false;

}));
$ctx1.sendIdx["and:"]=4;
$4=self._deny_($5);
$ctx1.sendIdx["deny:"]=3;
$6=true._or_((function(){
return true;

}));
$ctx1.sendIdx["or:"]=1;
self._assert_($6);
$ctx1.sendIdx["assert:"]=2;
$7=true._or_((function(){
return false;

}));
$ctx1.sendIdx["or:"]=2;
self._assert_($7);
$ctx1.sendIdx["assert:"]=3;
$8=false._or_((function(){
return true;

}));
$ctx1.sendIdx["or:"]=3;
self._assert_($8);
$ctx1.sendIdx["assert:"]=4;
$10=false._or_((function(){
return false;

}));
$ctx1.sendIdx["or:"]=4;
$9=self._deny_($10);
$ctx1.sendIdx["deny:"]=4;
$11=true._and_((function(){
return $core.withContext(function($ctx2) {
return (1).__gt((0));
$ctx2.sendIdx[">"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,9)});
}));
$ctx1.sendIdx["and:"]=5;
self._assert_($11);
$ctx1.sendIdx["assert:"]=5;
$13=(1).__gt((0));
$ctx1.sendIdx[">"]=2;
$12=$recv($13)._and_((function(){
return false;

}));
$ctx1.sendIdx["and:"]=6;
self._deny_($12);
$ctx1.sendIdx["deny:"]=5;
$15=(1).__gt((0));
$ctx1.sendIdx[">"]=3;
$14=$recv($15)._and_((function(){
return $core.withContext(function($ctx2) {
return (1).__gt((2));
$ctx2.sendIdx[">"]=4;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,11)});
}));
self._deny_($14);
$16=false._or_((function(){
return $core.withContext(function($ctx2) {
return (1).__gt((0));
$ctx2.sendIdx[">"]=5;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,12)});
}));
$ctx1.sendIdx["or:"]=5;
self._assert_($16);
$ctx1.sendIdx["assert:"]=6;
$18=(1).__gt((0));
$ctx1.sendIdx[">"]=6;
$17=$recv($18)._or_((function(){
return false;

}));
$ctx1.sendIdx["or:"]=6;
self._assert_($17);
$ctx1.sendIdx["assert:"]=7;
$20=(1).__gt((0));
$ctx1.sendIdx[">"]=7;
$19=$recv($20)._or_((function(){
return $core.withContext(function($ctx2) {
return (1).__gt((2));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,14)});
}));
self._assert_($19);
return self;
}, function($ctx1) {$ctx1.fill(self,"testLogicKeywords",{},$globals.BooleanTest)});
},
args: [],
source: "testLogicKeywords\x0a\x09\x22Trivial logic table\x22\x0a\x09self\x0a\x09\x09assert: (true and: [ true ]);\x0a\x09\x09deny: (true and: [ false ]);\x0a\x09\x09deny: (false and: [ true ]);\x0a\x09\x09deny: (false and: [ false ]).\x0a\x09self\x0a\x09\x09assert: (true or: [ true ]);\x0a\x09\x09assert: (true or: [ false ]);\x0a\x09\x09assert: (false or: [ true ]);\x0a\x09\x09deny: (false or: [ false ]).\x0a\x09\x09\x0a\x09\x22Checking that expressions work fine too\x22\x0a\x09self\x0a\x09\x09assert: (true and: [ 1 > 0 ]);\x0a\x09\x09deny: ((1 > 0) and: [ false ]);\x0a\x09\x09deny: ((1 > 0) and: [ 1 > 2 ]).\x0a\x09self\x0a\x09\x09assert: (false or: [ 1 > 0 ]);\x0a\x09\x09assert: ((1 > 0) or: [ false ]);\x0a\x09\x09assert: ((1 > 0) or: [ 1 > 2 ])",
referencedClasses: [],
messageSends: ["assert:", "and:", "deny:", "or:", ">"]
}),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testNonBooleanError",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
if($core.assert("")){
} else {
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.NonBooleanReceiver);
return self;
}, function($ctx1) {$ctx1.fill(self,"testNonBooleanError",{},$globals.BooleanTest)});
},
args: [],
source: "testNonBooleanError\x0a\x09self should: [ '' ifTrue: [] ifFalse: [] ] raise: NonBooleanReceiver",
referencedClasses: ["NonBooleanReceiver"],
messageSends: ["should:raise:", "ifTrue:ifFalse:"]
}),
$globals.BooleanTest);



$core.addClass('ClassBuilderTest', $globals.TestCase, ['builder', 'theClass'], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "setUp",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@builder"]=$recv($globals.ClassBuilder)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{},$globals.ClassBuilderTest)});
},
args: [],
source: "setUp\x0a\x09builder := ClassBuilder new",
referencedClasses: ["ClassBuilder"],
messageSends: ["new"]
}),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@theClass"];
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
$recv($globals.Smalltalk)._removeClass_(self["@theClass"]);
self["@theClass"]=nil;
self["@theClass"];
};
return self;
}, function($ctx1) {$ctx1.fill(self,"tearDown",{},$globals.ClassBuilderTest)});
},
args: [],
source: "tearDown\x0a\x09theClass ifNotNil: [ Smalltalk removeClass: theClass. theClass := nil ]",
referencedClasses: ["Smalltalk"],
messageSends: ["ifNotNil:", "removeClass:"]
}),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testClassCopy",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$6,$5,$8,$7;
self["@theClass"]=$recv(self["@builder"])._copyClass_named_($globals.ObjectMock,"ObjectMock2");
$2=$recv(self["@theClass"])._superclass();
$ctx1.sendIdx["superclass"]=1;
$1=$recv($2).__eq_eq($recv($globals.ObjectMock)._superclass());
$ctx1.sendIdx["=="]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$4=$recv(self["@theClass"])._instanceVariableNames();
$ctx1.sendIdx["instanceVariableNames"]=1;
$3=$recv($4).__eq_eq($recv($globals.ObjectMock)._instanceVariableNames());
$ctx1.sendIdx["=="]=2;
self._assert_($3);
$ctx1.sendIdx["assert:"]=2;
self._assert_equals_($recv(self["@theClass"])._name(),"ObjectMock2");
$ctx1.sendIdx["assert:equals:"]=1;
$6=$recv(self["@theClass"])._package();
$ctx1.sendIdx["package"]=1;
$5=$recv($6).__eq_eq($recv($globals.ObjectMock)._package());
self._assert_($5);
$8=$recv(self["@theClass"])._methodDictionary();
$ctx1.sendIdx["methodDictionary"]=1;
$7=$recv($8)._keys();
$ctx1.sendIdx["keys"]=1;
self._assert_equals_($7,$recv($recv($globals.ObjectMock)._methodDictionary())._keys());
return self;
}, function($ctx1) {$ctx1.fill(self,"testClassCopy",{},$globals.ClassBuilderTest)});
},
args: [],
source: "testClassCopy\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09self assert: theClass superclass == ObjectMock superclass.\x0a\x09self assert: theClass instanceVariableNames == ObjectMock instanceVariableNames.\x0a\x09self assert: theClass name equals: 'ObjectMock2'.\x0a\x09self assert: theClass package == ObjectMock package.\x0a\x09self assert: theClass methodDictionary keys equals: ObjectMock methodDictionary keys",
referencedClasses: ["ObjectMock"],
messageSends: ["copyClass:named:", "assert:", "==", "superclass", "instanceVariableNames", "assert:equals:", "name", "package", "keys", "methodDictionary"]
}),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testClassMigration",
protocol: 'tests',
fn: function (){
var self=this;
var instance,oldClass;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$5,$6,$7,$8,$9,$11,$10;
oldClass=$recv(self["@builder"])._copyClass_named_($globals.ObjectMock,"ObjectMock2");
$2=$recv($globals.Smalltalk)._globals();
$ctx1.sendIdx["globals"]=1;
$1=$recv($2)._at_("ObjectMock2");
$ctx1.sendIdx["at:"]=1;
instance=$recv($1)._new();
$4=$recv($globals.Smalltalk)._globals();
$ctx1.sendIdx["globals"]=2;
$3=$recv($4)._at_("ObjectMock2");
$ctx1.sendIdx["at:"]=2;
$recv($globals.ObjectMock)._subclass_instanceVariableNames_package_($3,"","Kernel-Tests");
$5=$recv(oldClass).__eq_eq($globals.ObjectMock2);
$ctx1.sendIdx["=="]=1;
self._deny_($5);
$ctx1.sendIdx["deny:"]=1;
$6=$recv($recv($globals.ObjectMock2)._superclass()).__eq_eq($globals.ObjectMock);
$ctx1.sendIdx["=="]=2;
self._assert_($6);
$ctx1.sendIdx["assert:"]=1;
self._assert_($recv($recv($globals.ObjectMock2)._instanceVariableNames())._isEmpty());
$ctx1.sendIdx["assert:"]=2;
$7=$recv($globals.ObjectMock2)._selectors();
$ctx1.sendIdx["selectors"]=1;
self._assert_equals_($7,$recv(oldClass)._selectors());
$ctx1.sendIdx["assert:equals:"]=1;
$8=$recv($globals.ObjectMock2)._comment();
$ctx1.sendIdx["comment"]=1;
self._assert_equals_($8,$recv(oldClass)._comment());
$ctx1.sendIdx["assert:equals:"]=2;
$9=$recv($recv($globals.ObjectMock2)._package())._name();
$ctx1.sendIdx["name"]=1;
self._assert_equals_($9,"Kernel-Tests");
$11=$recv(instance)._class();
$ctx1.sendIdx["class"]=1;
$10=$recv($11).__eq_eq($globals.ObjectMock2);
self._deny_($10);
self._assert_($recv($recv($recv($globals.Smalltalk)._globals())._at_($recv($recv(instance)._class())._name()))._isNil());
$recv($globals.Smalltalk)._removeClass_($globals.ObjectMock2);
return self;
}, function($ctx1) {$ctx1.fill(self,"testClassMigration",{instance:instance,oldClass:oldClass},$globals.ClassBuilderTest)});
},
args: [],
source: "testClassMigration\x0a\x09| instance oldClass |\x0a\x09\x0a\x09oldClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09instance := (Smalltalk globals at: 'ObjectMock2') new.\x0a\x09\x0a\x09\x22Change the superclass of ObjectMock2\x22\x0a\x09ObjectMock subclass: (Smalltalk globals at: 'ObjectMock2')\x0a\x09\x09instanceVariableNames: ''\x0a\x09\x09package: 'Kernel-Tests'.\x0a\x09\x0a\x09self deny: oldClass == ObjectMock2.\x0a\x09\x0a\x09self assert: ObjectMock2 superclass == ObjectMock.\x0a\x09self assert: ObjectMock2 instanceVariableNames isEmpty.\x0a\x09self assert: ObjectMock2 selectors equals: oldClass selectors.\x0a\x09self assert: ObjectMock2 comment equals: oldClass comment.\x0a\x09self assert: ObjectMock2 package name equals: 'Kernel-Tests'.\x0a\x09\x0a\x09self deny: instance class == ObjectMock2.\x0a\x09\x22Commeting this out. Tests implementation detail.\x22\x0a\x09\x22self assert: instance class name equals: 'OldObjectMock2'.\x22\x0a\x09\x0a\x09self assert: (Smalltalk globals at: instance class name) isNil.\x0a\x09\x0a\x09Smalltalk removeClass: ObjectMock2",
referencedClasses: ["ObjectMock", "Smalltalk", "ObjectMock2"],
messageSends: ["copyClass:named:", "new", "at:", "globals", "subclass:instanceVariableNames:package:", "deny:", "==", "assert:", "superclass", "isEmpty", "instanceVariableNames", "assert:equals:", "selectors", "comment", "name", "package", "class", "isNil", "removeClass:"]
}),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testClassMigrationWithClassInstanceVariables",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(self["@builder"])._copyClass_named_($globals.ObjectMock,"ObjectMock2");
$1=$recv($globals.ObjectMock2)._class();
$ctx1.sendIdx["class"]=1;
$recv($1)._instanceVariableNames_("foo bar");
$recv($globals.ObjectMock)._subclass_instanceVariableNames_package_($recv($recv($globals.Smalltalk)._globals())._at_("ObjectMock2"),"","Kernel-Tests");
self._assert_equals_($recv($recv($globals.ObjectMock2)._class())._instanceVariableNames(),["foo", "bar"]);
$recv($globals.Smalltalk)._removeClass_($globals.ObjectMock2);
return self;
}, function($ctx1) {$ctx1.fill(self,"testClassMigrationWithClassInstanceVariables",{},$globals.ClassBuilderTest)});
},
args: [],
source: "testClassMigrationWithClassInstanceVariables\x0a\x09\x0a\x09builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09ObjectMock2 class instanceVariableNames: 'foo bar'.\x0a\x09\x0a\x09\x22Change the superclass of ObjectMock2\x22\x0a\x09ObjectMock subclass: (Smalltalk globals at: 'ObjectMock2')\x0a\x09\x09instanceVariableNames: ''\x0a\x09\x09package: 'Kernel-Tests'.\x0a\x09\x0a\x09self assert: ObjectMock2 class instanceVariableNames equals: #('foo' 'bar').\x0a\x09\x0a\x09Smalltalk removeClass: ObjectMock2",
referencedClasses: ["ObjectMock", "ObjectMock2", "Smalltalk"],
messageSends: ["copyClass:named:", "instanceVariableNames:", "class", "subclass:instanceVariableNames:package:", "at:", "globals", "assert:equals:", "instanceVariableNames", "removeClass:"]
}),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testClassMigrationWithSubclasses",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3;
$recv(self["@builder"])._copyClass_named_($globals.ObjectMock,"ObjectMock2");
$recv($globals.ObjectMock2)._subclass_instanceVariableNames_package_("ObjectMock3","","Kernel-Tests");
$ctx1.sendIdx["subclass:instanceVariableNames:package:"]=1;
$recv($globals.ObjectMock3)._subclass_instanceVariableNames_package_("ObjectMock4","","Kernel-Tests");
$ctx1.sendIdx["subclass:instanceVariableNames:package:"]=2;
$recv($globals.ObjectMock)._subclass_instanceVariableNames_package_($recv($recv($globals.Smalltalk)._globals())._at_("ObjectMock2"),"","Kernel-Tests");
$2=$recv($globals.ObjectMock)._subclasses();
$ctx1.sendIdx["subclasses"]=1;
$1=$recv($2)._includes_($globals.ObjectMock2);
$ctx1.sendIdx["includes:"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$4=$recv($globals.ObjectMock2)._subclasses();
$ctx1.sendIdx["subclasses"]=2;
$3=$recv($4)._includes_($globals.ObjectMock3);
$ctx1.sendIdx["includes:"]=2;
self._assert_($3);
$ctx1.sendIdx["assert:"]=2;
self._assert_($recv($recv($globals.ObjectMock3)._subclasses())._includes_($globals.ObjectMock4));
$recv($recv($globals.ObjectMock)._allSubclasses())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv($globals.Smalltalk)._removeClass_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testClassMigrationWithSubclasses",{},$globals.ClassBuilderTest)});
},
args: [],
source: "testClassMigrationWithSubclasses\x0a\x09\x0a\x09builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09ObjectMock2 subclass: 'ObjectMock3' instanceVariableNames: '' package: 'Kernel-Tests'.\x0a\x09ObjectMock3 subclass: 'ObjectMock4' instanceVariableNames: '' package: 'Kernel-Tests'.\x0a\x09\x0a\x09\x22Change the superclass of ObjectMock2\x22\x0a\x09ObjectMock subclass: (Smalltalk globals at: 'ObjectMock2')\x0a\x09\x09instanceVariableNames: ''\x0a\x09\x09package: 'Kernel-Tests'.\x0a\x09\x0a\x09self assert: (ObjectMock subclasses includes: ObjectMock2).\x0a\x09self assert: (ObjectMock2 subclasses includes: ObjectMock3).\x0a\x09self assert: (ObjectMock3 subclasses includes: ObjectMock4).\x0a\x09\x0a\x09ObjectMock allSubclasses do: [ :each | Smalltalk removeClass: each ]",
referencedClasses: ["ObjectMock", "ObjectMock2", "ObjectMock3", "Smalltalk", "ObjectMock4"],
messageSends: ["copyClass:named:", "subclass:instanceVariableNames:package:", "at:", "globals", "assert:", "includes:", "subclasses", "do:", "allSubclasses", "removeClass:"]
}),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testInstanceVariableNames",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_($recv(self["@builder"])._instanceVariableNamesFor_("  hello   world   "),["hello", "world"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testInstanceVariableNames",{},$globals.ClassBuilderTest)});
},
args: [],
source: "testInstanceVariableNames\x0a\x09self assert: (builder instanceVariableNamesFor: '  hello   world   ') equals: #('hello' 'world')",
referencedClasses: [],
messageSends: ["assert:equals:", "instanceVariableNamesFor:"]
}),
$globals.ClassBuilderTest);



$core.addClass('ClassTest', $globals.TestCase, ['builder', 'theClass'], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "jsConstructor",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {

		function Foo(){}
		Foo.prototype.valueOf = function () {return 4;};
		return Foo;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsConstructor",{},$globals.ClassTest)});
},
args: [],
source: "jsConstructor\x0a\x09<\x0a\x09\x09function Foo(){}\x0a\x09\x09Foo.prototype.valueOf = function () {return 4;};\x0a\x09\x09return Foo;\x0a\x09>",
referencedClasses: [],
messageSends: []
}),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "setUp",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@builder"]=$recv($globals.ClassBuilder)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{},$globals.ClassTest)});
},
args: [],
source: "setUp\x0a\x09builder := ClassBuilder new",
referencedClasses: ["ClassBuilder"],
messageSends: ["new"]
}),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@theClass"];
if(($receiver = $1) == null || $receiver.isNil){
$1;
} else {
$recv($globals.Smalltalk)._removeClass_(self["@theClass"]);
self["@theClass"]=nil;
self["@theClass"];
};
return self;
}, function($ctx1) {$ctx1.fill(self,"tearDown",{},$globals.ClassTest)});
},
args: [],
source: "tearDown\x0a\x09theClass ifNotNil: [ Smalltalk removeClass: theClass. theClass := nil ]",
referencedClasses: ["Smalltalk"],
messageSends: ["ifNotNil:", "removeClass:"]
}),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testSetJavaScriptConstructor",
protocol: 'tests',
fn: function (){
var self=this;
var instance;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$6,$5,$8,$7;
self["@theClass"]=$recv(self["@builder"])._copyClass_named_($globals.ObjectMock,"ObjectMock2");
$recv(self["@theClass"])._javascriptConstructor_(self._jsConstructor());
$2=$recv(self["@theClass"])._superclass();
$ctx1.sendIdx["superclass"]=1;
$1=$recv($2).__eq_eq($recv($globals.ObjectMock)._superclass());
$ctx1.sendIdx["=="]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$4=$recv(self["@theClass"])._instanceVariableNames();
$ctx1.sendIdx["instanceVariableNames"]=1;
$3=$recv($4).__eq_eq($recv($globals.ObjectMock)._instanceVariableNames());
$ctx1.sendIdx["=="]=2;
self._assert_($3);
$ctx1.sendIdx["assert:"]=2;
self._assert_equals_($recv(self["@theClass"])._name(),"ObjectMock2");
$ctx1.sendIdx["assert:equals:"]=1;
$6=$recv(self["@theClass"])._package();
$ctx1.sendIdx["package"]=1;
$5=$recv($6).__eq_eq($recv($globals.ObjectMock)._package());
$ctx1.sendIdx["=="]=3;
self._assert_($5);
$ctx1.sendIdx["assert:"]=3;
$8=$recv(self["@theClass"])._methodDictionary();
$ctx1.sendIdx["methodDictionary"]=1;
$7=$recv($8)._keys();
$ctx1.sendIdx["keys"]=1;
self._assert_equals_($7,$recv($recv($globals.ObjectMock)._methodDictionary())._keys());
$ctx1.sendIdx["assert:equals:"]=2;
instance=$recv(self["@theClass"])._new();
self._assert_($recv($recv(instance)._class()).__eq_eq(self["@theClass"]));
self._assert_equals_($recv(instance)._value(),(4));
$ctx1.sendIdx["assert:equals:"]=3;
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(instance)._foo_((9));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
self._assert_equals_($recv(instance)._foo(),(9));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSetJavaScriptConstructor",{instance:instance},$globals.ClassTest)});
},
args: [],
source: "testSetJavaScriptConstructor\x0a\x09| instance |\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09theClass javascriptConstructor: self jsConstructor.\x0a\x09\x22part took from copy class test\x22\x0a\x09self assert: theClass superclass == ObjectMock superclass.\x0a\x09self assert: theClass instanceVariableNames == ObjectMock instanceVariableNames.\x0a\x09self assert: theClass name equals: 'ObjectMock2'.\x0a\x09self assert: theClass package == ObjectMock package.\x0a\x09self assert: theClass methodDictionary keys equals: ObjectMock methodDictionary keys.\x0a\x09\x22testing specific to late-wrapped class\x22\x0a\x09instance := theClass new.\x0a\x09self assert: instance class == theClass.\x0a\x09self assert: instance value equals: 4.\x0a\x09self shouldnt: [ instance foo: 9 ] raise: Error.\x0a\x09self assert: instance foo equals: 9",
referencedClasses: ["ObjectMock", "Error"],
messageSends: ["copyClass:named:", "javascriptConstructor:", "jsConstructor", "assert:", "==", "superclass", "instanceVariableNames", "assert:equals:", "name", "package", "keys", "methodDictionary", "new", "class", "value", "shouldnt:raise:", "foo:", "foo"]
}),
$globals.ClassTest);



$core.addClass('CollectionTest', $globals.TestCase, ['sampleBlock'], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "assertSameContents:as:",
protocol: 'convenience',
fn: function (aCollection,anotherCollection){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3;
$2=$recv(aCollection)._size();
$ctx1.sendIdx["size"]=1;
$1=$recv($2).__eq($recv(anotherCollection)._size());
$ctx1.sendIdx["="]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
$4=$recv(aCollection)._occurrencesOf_(each);
$ctx2.sendIdx["occurrencesOf:"]=1;
$3=$recv($4).__eq($recv(anotherCollection)._occurrencesOf_(each));
return self._assert_($3);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"assertSameContents:as:",{aCollection:aCollection,anotherCollection:anotherCollection},$globals.CollectionTest)});
},
args: ["aCollection", "anotherCollection"],
source: "assertSameContents: aCollection as: anotherCollection\x0a\x09self assert: (aCollection size = anotherCollection size).\x0a\x09aCollection do: [ :each |\x0a\x09\x09self assert: ((aCollection occurrencesOf: each) = (anotherCollection occurrencesOf: each)) ]",
referencedClasses: [],
messageSends: ["assert:", "=", "size", "do:", "occurrencesOf:"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collection",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collection",{},$globals.CollectionTest)});
},
args: [],
source: "collection\x0a\x09\x22Answers pre-filled collection of type tested.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._class())._collectionClass();
}, function($ctx1) {$ctx1.fill(self,"collectionClass",{},$globals.CollectionTest)});
},
args: [],
source: "collectionClass\x0a\x09\x22Answers class of collection type tested\x22\x0a\x0a\x09^ self class collectionClass",
referencedClasses: [],
messageSends: ["collectionClass", "class"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionOfPrintStrings",{},$globals.CollectionTest)});
},
args: [],
source: "collectionOfPrintStrings\x0a\x09\x22Answers self collection but with values\x0a\x09changed to their printStrings\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionSize",{},$globals.CollectionTest)});
},
args: [],
source: "collectionSize\x0a\x09\x22Answers size of self collection.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionWithDuplicates",{},$globals.CollectionTest)});
},
args: [],
source: "collectionWithDuplicates\x0a\x09\x22Answers pre-filled collection of type tested,\x0a\x09with exactly five distinct elements,\x0a\x09some of them appearing multiple times, if possible.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionWithNewValue",{},$globals.CollectionTest)});
},
args: [],
source: "collectionWithNewValue\x0a\x09\x22Answers a collection which shows how\x0a\x09self collection would look after adding\x0a\x09self sampleNewValue\x22\x0a\x09\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.CollectionTest.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@sampleBlock"]=(function(){

});
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.CollectionTest)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x0a\x09sampleBlock := []",
referencedClasses: [],
messageSends: ["initialize"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "isCollectionReadOnly",
protocol: 'testing',
fn: function (){
var self=this;
return false;

},
args: [],
source: "isCollectionReadOnly\x0a\x09^ false",
referencedClasses: [],
messageSends: []
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNewValue",
protocol: 'fixture',
fn: function (){
var self=this;
return "N";

},
args: [],
source: "sampleNewValue\x0a\x09\x22Answers a value that is not yet there\x0a\x09and can be put into a tested collection\x22\x0a\x09\x0a\x09^ 'N'",
referencedClasses: [],
messageSends: []
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNewValueAsCollection",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._collectionClass())._with_(self._sampleNewValue());
}, function($ctx1) {$ctx1.fill(self,"sampleNewValueAsCollection",{},$globals.CollectionTest)});
},
args: [],
source: "sampleNewValueAsCollection\x0a\x09\x22Answers self sampleNewValue\x0a\x09wrapped in single element collection\x0a\x09of tested type\x22\x0a\x09\x0a\x09^ self collectionClass with: self sampleNewValue",
referencedClasses: [],
messageSends: ["with:", "collectionClass", "sampleNewValue"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAddAll",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$4,$3,$5,$1,$6,$9,$8,$10,$11,$7,$12,$15,$14,$17,$16,$18,$13,$20,$21,$22,$19,$23,$25,$24;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$4=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=1;
$3=$recv($4)._new();
$ctx1.sendIdx["new"]=1;
$recv($2)._addAll_($3);
$ctx1.sendIdx["addAll:"]=1;
$5=$recv($2)._yourself();
$ctx1.sendIdx["yourself"]=1;
$1=$5;
$6=self._collection();
$ctx1.sendIdx["collection"]=2;
self._assert_equals_($1,$6);
$ctx1.sendIdx["assert:equals:"]=1;
$9=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=2;
$8=$recv($9)._new();
$ctx1.sendIdx["new"]=2;
$10=self._collection();
$ctx1.sendIdx["collection"]=3;
$recv($8)._addAll_($10);
$ctx1.sendIdx["addAll:"]=2;
$11=$recv($8)._yourself();
$ctx1.sendIdx["yourself"]=2;
$7=$11;
$12=self._collection();
$ctx1.sendIdx["collection"]=4;
self._assert_equals_($7,$12);
$ctx1.sendIdx["assert:equals:"]=2;
$15=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=3;
$14=$recv($15)._new();
$ctx1.sendIdx["new"]=3;
$17=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=4;
$16=$recv($17)._new();
$ctx1.sendIdx["new"]=4;
$recv($14)._addAll_($16);
$ctx1.sendIdx["addAll:"]=3;
$18=$recv($14)._yourself();
$ctx1.sendIdx["yourself"]=3;
$13=$18;
self._assert_equals_($13,$recv(self._collectionClass())._new());
$ctx1.sendIdx["assert:equals:"]=3;
$20=self._collection();
$ctx1.sendIdx["collection"]=5;
$21=self._sampleNewValueAsCollection();
$ctx1.sendIdx["sampleNewValueAsCollection"]=1;
$recv($20)._addAll_($21);
$ctx1.sendIdx["addAll:"]=4;
$22=$recv($20)._yourself();
$ctx1.sendIdx["yourself"]=4;
$19=$22;
$23=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=1;
self._assert_equals_($19,$23);
$25=self._sampleNewValueAsCollection();
$recv($25)._addAll_(self._collection());
$24=$recv($25)._yourself();
self._assertSameContents_as_($24,self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddAll",{},$globals.CollectionTest)});
},
args: [],
source: "testAddAll\x0a\x09self assert: (self collection addAll: self collectionClass new; yourself) equals: self collection.\x0a\x09self assert: (self collectionClass new addAll: self collection; yourself) equals: self collection.\x0a\x09self assert: (self collectionClass new addAll: self collectionClass new; yourself) equals: self collectionClass new.\x0a\x09self assert: (self collection addAll: self sampleNewValueAsCollection; yourself) equals: self collectionWithNewValue.\x0a\x09self assertSameContents: (self sampleNewValueAsCollection addAll: self collection; yourself) as: self collectionWithNewValue",
referencedClasses: [],
messageSends: ["assert:equals:", "addAll:", "collection", "new", "collectionClass", "yourself", "sampleNewValueAsCollection", "collectionWithNewValue", "assertSameContents:as:"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAllSatisfy",
protocol: 'tests',
fn: function (){
var self=this;
var collection,anyOne;
return $core.withContext(function($ctx1) {
var $1;
collection=self._collection();
anyOne=$recv(collection)._anyOne();
$1=$recv(collection)._allSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(collection)._includes_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["allSatisfy:"]=1;
self._assert_($1);
self._deny_($recv(collection)._allSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__tild_eq(anyOne);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
})));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAllSatisfy",{collection:collection,anyOne:anyOne},$globals.CollectionTest)});
},
args: [],
source: "testAllSatisfy\x0a\x09| collection anyOne |\x0a\x09collection := self collection.\x0a\x09anyOne := collection anyOne.\x0a\x09self assert: (collection allSatisfy: [ :each | collection includes: each ]).\x0a\x09self deny: (collection allSatisfy: [ :each | each ~= anyOne ])",
referencedClasses: [],
messageSends: ["collection", "anyOne", "assert:", "allSatisfy:", "includes:", "deny:", "~="]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAnyOne",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv(self._collectionClass())._new())._anyOne();
$ctx2.sendIdx["anyOne"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$1=$recv($2)._includes_($recv(self._collection())._anyOne());
self._assert_($1);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAnyOne",{},$globals.CollectionTest)});
},
args: [],
source: "testAnyOne\x0a\x09self should: [ self collectionClass new anyOne ] raise: Error.\x0a\x09self assert: (self collection includes: self collection anyOne)",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "anyOne", "new", "collectionClass", "assert:", "includes:", "collection"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAnySatisfy",
protocol: 'tests',
fn: function (){
var self=this;
var anyOne;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
$1=self._collection();
$ctx1.sendIdx["collection"]=1;
anyOne=$recv($1)._anyOne();
$3=self._collection();
$ctx1.sendIdx["collection"]=2;
$2=$recv($3)._anySatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq(anyOne);
$ctx2.sendIdx["="]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["anySatisfy:"]=1;
self._assert_($2);
self._deny_($recv(self._collection())._anySatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq($recv($globals.Object)._new());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
})));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAnySatisfy",{anyOne:anyOne},$globals.CollectionTest)});
},
args: [],
source: "testAnySatisfy\x0a\x09| anyOne |\x0a\x09anyOne := self collection anyOne.\x0a\x09self assert: (self collection anySatisfy: [ :each | each = anyOne ]).\x0a\x09self deny: (self collection anySatisfy: [ :each | each = Object new ])",
referencedClasses: ["Object"],
messageSends: ["anyOne", "collection", "assert:", "anySatisfy:", "=", "deny:", "new"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAsArray",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._collection();
$ctx1.sendIdx["collection"]=1;
self._assertSameContents_as_($1,$recv(self._collection())._asArray());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsArray",{},$globals.CollectionTest)});
},
args: [],
source: "testAsArray\x0a\x09self\x0a\x09\x09assertSameContents: self collection\x0a\x09\x09as: self collection asArray",
referencedClasses: [],
messageSends: ["assertSameContents:as:", "collection", "asArray"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAsOrderedCollection",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._collection();
$ctx1.sendIdx["collection"]=1;
self._assertSameContents_as_($1,$recv(self._collection())._asOrderedCollection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsOrderedCollection",{},$globals.CollectionTest)});
},
args: [],
source: "testAsOrderedCollection\x0a\x09self\x0a\x09\x09assertSameContents: self collection\x0a\x09\x09as: self collection asOrderedCollection",
referencedClasses: [],
messageSends: ["assertSameContents:as:", "collection", "asOrderedCollection"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAsSet",
protocol: 'tests',
fn: function (){
var self=this;
var c,set;
return $core.withContext(function($ctx1) {
c=self._collectionWithDuplicates();
set=$recv(c)._asSet();
self._assert_equals_($recv(set)._size(),(6));
$recv(c)._do_((function(each){
return $core.withContext(function($ctx2) {
return self._assert_($recv(set)._includes_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsSet",{c:c,set:set},$globals.CollectionTest)});
},
args: [],
source: "testAsSet\x0a\x09| c set |\x0a\x09c := self collectionWithDuplicates.\x0a\x09set := c asSet.\x0a\x09self assert: set size equals: 6.\x0a\x09c do: [ :each |\x0a\x09\x09self assert: (set includes: each) ]",
referencedClasses: [],
messageSends: ["collectionWithDuplicates", "asSet", "assert:equals:", "size", "do:", "assert:", "includes:"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testCollect",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$5,$4,$8,$7,$6,$11,$10,$9;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$1=$recv($2)._collect_((function(each){
return each;

}));
$ctx1.sendIdx["collect:"]=1;
$3=self._collection();
$ctx1.sendIdx["collection"]=2;
self._assert_equals_($1,$3);
$ctx1.sendIdx["assert:equals:"]=1;
$5=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=1;
$4=$recv($5)._collect_((function(each){
return each;

}));
$ctx1.sendIdx["collect:"]=2;
self._assert_equals_($4,self._collectionWithNewValue());
$ctx1.sendIdx["assert:equals:"]=2;
$8=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=1;
$7=$recv($8)._new();
$ctx1.sendIdx["new"]=1;
$6=$recv($7)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._printString();
$ctx2.sendIdx["printString"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
$ctx1.sendIdx["collect:"]=3;
self._assert_equals_($6,$recv(self._collectionClass())._new());
$ctx1.sendIdx["assert:equals:"]=3;
$11=self._collection();
$ctx1.sendIdx["collection"]=3;
$10=$recv($11)._collect_((function(){
return $core.withContext(function($ctx2) {
return self._sampleNewValue();
$ctx2.sendIdx["sampleNewValue"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}));
$ctx1.sendIdx["collect:"]=4;
$9=$recv($10)._detect_((function(){
return true;

}));
self._assert_equals_($9,self._sampleNewValue());
$ctx1.sendIdx["assert:equals:"]=4;
self._assert_equals_($recv(self._collection())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._printString();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,6)});
})),self._collectionOfPrintStrings());
return self;
}, function($ctx1) {$ctx1.fill(self,"testCollect",{},$globals.CollectionTest)});
},
args: [],
source: "testCollect\x0a\x09self assert: (self collection collect: [ :each | each ]) equals: self collection.\x0a\x09self assert: (self collectionWithNewValue collect: [ :each | each ]) equals: self collectionWithNewValue.\x0a\x09self assert: (self collectionClass new collect: [ :each | each printString ]) equals: self collectionClass new.\x0a\x09self assert: ((self collection collect: [ self sampleNewValue ]) detect: [ true ]) equals: self sampleNewValue.\x0a\x09self assert: (self collection collect: [ :each | each printString ]) equals: self collectionOfPrintStrings",
referencedClasses: [],
messageSends: ["assert:equals:", "collect:", "collection", "collectionWithNewValue", "new", "collectionClass", "printString", "detect:", "sampleNewValue", "collectionOfPrintStrings"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testComma",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$4,$3,$1,$5,$8,$7,$9,$6,$10,$13,$12,$15,$14,$11,$17,$18,$16,$19;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$4=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=1;
$3=$recv($4)._new();
$ctx1.sendIdx["new"]=1;
$1=$recv($2).__comma($3);
$ctx1.sendIdx[","]=1;
$5=self._collection();
$ctx1.sendIdx["collection"]=2;
self._assert_equals_($1,$5);
$ctx1.sendIdx["assert:equals:"]=1;
$8=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=2;
$7=$recv($8)._new();
$ctx1.sendIdx["new"]=2;
$9=self._collection();
$ctx1.sendIdx["collection"]=3;
$6=$recv($7).__comma($9);
$ctx1.sendIdx[","]=2;
$10=self._collection();
$ctx1.sendIdx["collection"]=4;
self._assert_equals_($6,$10);
$ctx1.sendIdx["assert:equals:"]=2;
$13=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=3;
$12=$recv($13)._new();
$ctx1.sendIdx["new"]=3;
$15=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=4;
$14=$recv($15)._new();
$ctx1.sendIdx["new"]=4;
$11=$recv($12).__comma($14);
$ctx1.sendIdx[","]=3;
self._assert_equals_($11,$recv(self._collectionClass())._new());
$ctx1.sendIdx["assert:equals:"]=3;
$17=self._collection();
$ctx1.sendIdx["collection"]=5;
$18=self._sampleNewValueAsCollection();
$ctx1.sendIdx["sampleNewValueAsCollection"]=1;
$16=$recv($17).__comma($18);
$ctx1.sendIdx[","]=4;
$19=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=1;
self._assert_equals_($16,$19);
self._assertSameContents_as_($recv(self._sampleNewValueAsCollection()).__comma(self._collection()),self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testComma",{},$globals.CollectionTest)});
},
args: [],
source: "testComma\x0a\x09self assert: self collection, self collectionClass new equals: self collection.\x0a\x09self assert: self collectionClass new, self collection equals: self collection.\x0a\x09self assert: self collectionClass new, self collectionClass new equals: self collectionClass new.\x0a\x09self assert: self collection, self sampleNewValueAsCollection equals: self collectionWithNewValue.\x0a\x09self assertSameContents: self sampleNewValueAsCollection, self collection as: self collectionWithNewValue",
referencedClasses: [],
messageSends: ["assert:equals:", ",", "collection", "new", "collectionClass", "sampleNewValueAsCollection", "collectionWithNewValue", "assertSameContents:as:"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testCopy",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$5,$4,$7,$6,$8,$10,$9,$11,$15,$14,$13,$16,$12,$19,$18,$17;
$3=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=1;
$2=$recv($3)._new();
$ctx1.sendIdx["new"]=1;
$1=$recv($2)._copy();
$ctx1.sendIdx["copy"]=1;
$5=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=2;
$4=$recv($5)._new();
$ctx1.sendIdx["new"]=2;
self._assert_equals_($1,$4);
$ctx1.sendIdx["assert:equals:"]=1;
$7=self._collection();
$ctx1.sendIdx["collection"]=1;
$6=$recv($7)._copy();
$ctx1.sendIdx["copy"]=2;
$8=self._collection();
$ctx1.sendIdx["collection"]=2;
self._assert_equals_($6,$8);
$ctx1.sendIdx["assert:equals:"]=2;
$10=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=1;
$9=$recv($10)._copy();
$ctx1.sendIdx["copy"]=3;
$11=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=2;
self._assert_equals_($9,$11);
$15=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=3;
$14=$recv($15)._new();
$ctx1.sendIdx["new"]=3;
$13=$recv($14)._copy();
$ctx1.sendIdx["copy"]=4;
$16=self._collection();
$ctx1.sendIdx["collection"]=3;
$12=$recv($13).__eq($16);
$ctx1.sendIdx["="]=1;
self._deny_($12);
$ctx1.sendIdx["deny:"]=1;
$19=self._collection();
$ctx1.sendIdx["collection"]=4;
$18=$recv($19)._copy();
$ctx1.sendIdx["copy"]=5;
$17=$recv($18).__eq($recv(self._collectionClass())._new());
$ctx1.sendIdx["="]=2;
self._deny_($17);
$ctx1.sendIdx["deny:"]=2;
self._deny_($recv($recv(self._collection())._copy()).__eq(self._collectionWithNewValue()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopy",{},$globals.CollectionTest)});
},
args: [],
source: "testCopy\x0a\x09self assert: self collectionClass new copy equals: self collectionClass new.\x0a\x09self assert: self collection copy equals: self collection.\x0a\x09self assert: self collectionWithNewValue copy equals: self collectionWithNewValue.\x0a\x09\x0a\x09self deny: self collectionClass new copy = self collection.\x0a\x09self deny: self collection copy = self collectionClass new.\x0a\x09self deny: self collection copy = self collectionWithNewValue",
referencedClasses: [],
messageSends: ["assert:equals:", "copy", "new", "collectionClass", "collection", "collectionWithNewValue", "deny:", "="]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testCopySeparates",
protocol: 'tests',
fn: function (){
var self=this;
var original,copy;
return $core.withContext(function($ctx1) {
original=self._collection();
$ctx1.sendIdx["collection"]=1;
copy=$recv(original)._copy();
$recv(copy)._addAll_(self._sampleNewValueAsCollection());
self._assert_($recv(original).__eq(self._collection()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopySeparates",{original:original,copy:copy},$globals.CollectionTest)});
},
args: [],
source: "testCopySeparates\x0a\x09| original copy |\x0a\x09original := self collection.\x0a\x09copy := original copy.\x0a\x09copy addAll: self sampleNewValueAsCollection.\x0a\x09self assert: original = self collection",
referencedClasses: [],
messageSends: ["collection", "copy", "addAll:", "sampleNewValueAsCollection", "assert:", "="]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testDetect",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$6,$5,$7;
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
$1=self._collection();
$ctx2.sendIdx["collection"]=1;
return $recv($1)._detect_((function(){
return true;

}));
$ctx2.sendIdx["detect:"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
$2=self._collection();
$ctx2.sendIdx["collection"]=2;
return $recv($2)._detect_((function(){
return false;

}));
$ctx2.sendIdx["detect:"]=2;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}),$globals.Error);
$ctx1.sendIdx["should:raise:"]=1;
$3=$recv(self._sampleNewValueAsCollection())._detect_((function(){
return true;

}));
$ctx1.sendIdx["detect:"]=3;
$4=self._sampleNewValue();
$ctx1.sendIdx["sampleNewValue"]=1;
self._assert_equals_($3,$4);
$ctx1.sendIdx["assert:equals:"]=1;
$5=$recv(self._collectionWithNewValue())._detect_((function(each){
return $core.withContext(function($ctx2) {
$6=self._sampleNewValue();
$ctx2.sendIdx["sampleNewValue"]=2;
return $recv(each).__eq($6);
$ctx2.sendIdx["="]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,6)});
}));
$ctx1.sendIdx["detect:"]=4;
$7=self._sampleNewValue();
$ctx1.sendIdx["sampleNewValue"]=3;
self._assert_equals_($5,$7);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._collection())._detect_((function(each){
return $core.withContext(function($ctx3) {
return $recv(each).__eq(self._sampleNewValue());
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,8)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,7)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDetect",{},$globals.CollectionTest)});
},
args: [],
source: "testDetect\x0a\x09self\x0a\x09\x09shouldnt: [ self collection detect: [ true ] ]\x0a\x09\x09raise: Error.\x0a\x09self\x0a\x09\x09should: [ self collection detect: [ false ] ]\x0a\x09\x09raise: Error.\x0a\x09self assert: (self sampleNewValueAsCollection detect: [ true ]) equals: self sampleNewValue.\x0a\x09self assert: (self collectionWithNewValue detect: [ :each | each = self sampleNewValue ]) equals: self sampleNewValue.\x0a\x09self\x0a\x09\x09should: [ self collection detect: [ :each | each = self sampleNewValue ] ]\x0a\x09\x09raise: Error",
referencedClasses: ["Error"],
messageSends: ["shouldnt:raise:", "detect:", "collection", "should:raise:", "assert:equals:", "sampleNewValueAsCollection", "sampleNewValue", "collectionWithNewValue", "="]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testDetectIfNone",
protocol: 'tests',
fn: function (){
var self=this;
var sentinel;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$5,$4,$6,$7,$9,$8,$10;
sentinel=$recv($globals.Object)._new();
$3=self._collection();
$ctx1.sendIdx["collection"]=1;
$2=$recv($3)._detect_ifNone_((function(){
return true;

}),(function(){
return sentinel;

}));
$ctx1.sendIdx["detect:ifNone:"]=1;
$1=$recv($2).__tild_eq(sentinel);
self._assert_($1);
$5=self._collection();
$ctx1.sendIdx["collection"]=2;
$4=$recv($5)._detect_ifNone_((function(){
return false;

}),(function(){
return sentinel;

}));
$ctx1.sendIdx["detect:ifNone:"]=2;
self._assert_equals_($4,sentinel);
$ctx1.sendIdx["assert:equals:"]=1;
$6=$recv(self._sampleNewValueAsCollection())._detect_ifNone_((function(){
return true;

}),(function(){
return sentinel;

}));
$ctx1.sendIdx["detect:ifNone:"]=3;
$7=self._sampleNewValue();
$ctx1.sendIdx["sampleNewValue"]=1;
self._assert_equals_($6,$7);
$ctx1.sendIdx["assert:equals:"]=2;
$8=$recv(self._collectionWithNewValue())._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
$9=self._sampleNewValue();
$ctx2.sendIdx["sampleNewValue"]=2;
return $recv(each).__eq($9);
$ctx2.sendIdx["="]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,7)});
}),(function(){
return sentinel;

}));
$ctx1.sendIdx["detect:ifNone:"]=4;
$10=self._sampleNewValue();
$ctx1.sendIdx["sampleNewValue"]=3;
self._assert_equals_($8,$10);
$ctx1.sendIdx["assert:equals:"]=3;
self._assert_equals_($recv(self._collection())._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq(self._sampleNewValue());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,9)});
}),(function(){
return sentinel;

})),sentinel);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDetectIfNone",{sentinel:sentinel},$globals.CollectionTest)});
},
args: [],
source: "testDetectIfNone\x0a\x09| sentinel |\x0a\x09sentinel := Object new.\x0a\x09self assert: (self collection detect: [ true ] ifNone: [ sentinel ]) ~= sentinel.\x0a\x09self assert: (self collection detect: [ false ] ifNone: [ sentinel ]) equals: sentinel.\x0a\x09self assert: (self sampleNewValueAsCollection detect: [ true ] ifNone: [ sentinel ]) equals: self sampleNewValue.\x0a\x09self assert: (self collectionWithNewValue detect: [ :each | each = self sampleNewValue ] ifNone: [ sentinel ]) equals: self sampleNewValue.\x0a\x09self assert: (self collection detect: [ :each | each = self sampleNewValue ] ifNone: [ sentinel ]) equals: sentinel",
referencedClasses: ["Object"],
messageSends: ["new", "assert:", "~=", "detect:ifNone:", "collection", "assert:equals:", "sampleNewValueAsCollection", "sampleNewValue", "collectionWithNewValue", "="]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testDo",
protocol: 'tests',
fn: function (){
var self=this;
var newCollection;
return $core.withContext(function($ctx1) {
var $1,$2;
newCollection=$recv($globals.OrderedCollection)._new();
$ctx1.sendIdx["new"]=1;
$1=self._collection();
$ctx1.sendIdx["collection"]=1;
$recv($1)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(newCollection)._add_(each);
$ctx2.sendIdx["add:"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["do:"]=1;
self._assertSameContents_as_(self._collection(),newCollection);
$ctx1.sendIdx["assertSameContents:as:"]=1;
newCollection=$recv($globals.OrderedCollection)._new();
$2=self._collectionWithDuplicates();
$ctx1.sendIdx["collectionWithDuplicates"]=1;
$recv($2)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(newCollection)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
self._assertSameContents_as_(self._collectionWithDuplicates(),newCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDo",{newCollection:newCollection},$globals.CollectionTest)});
},
args: [],
source: "testDo\x0a\x09| newCollection |\x0a\x09newCollection := OrderedCollection new.\x0a\x09self collection do: [ :each |\x0a\x09\x09newCollection add: each ].\x0a\x09self\x0a\x09\x09assertSameContents: self collection\x0a\x09\x09as: newCollection.\x0a\x09newCollection := OrderedCollection new.\x0a\x09self collectionWithDuplicates do: [ :each |\x0a\x09\x09newCollection add: each ].\x0a\x09self\x0a\x09\x09assertSameContents: self collectionWithDuplicates\x0a\x09\x09as: newCollection",
referencedClasses: ["OrderedCollection"],
messageSends: ["new", "do:", "collection", "add:", "assertSameContents:as:", "collectionWithDuplicates"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testEquality",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$5,$6,$7,$8,$11,$10,$12,$9,$14,$13;
$2=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=1;
$1=$recv($2)._new();
$ctx1.sendIdx["new"]=1;
$4=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=2;
$3=$recv($4)._new();
$ctx1.sendIdx["new"]=2;
self._assert_equals_($1,$3);
$ctx1.sendIdx["assert:equals:"]=1;
$5=self._collection();
$ctx1.sendIdx["collection"]=1;
$6=self._collection();
$ctx1.sendIdx["collection"]=2;
self._assert_equals_($5,$6);
$ctx1.sendIdx["assert:equals:"]=2;
$7=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=1;
$8=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=2;
self._assert_equals_($7,$8);
$11=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=3;
$10=$recv($11)._new();
$ctx1.sendIdx["new"]=3;
$12=self._collection();
$ctx1.sendIdx["collection"]=3;
$9=$recv($10).__eq($12);
$ctx1.sendIdx["="]=1;
self._deny_($9);
$ctx1.sendIdx["deny:"]=1;
$14=self._collection();
$ctx1.sendIdx["collection"]=4;
$13=$recv($14).__eq($recv(self._collectionClass())._new());
$ctx1.sendIdx["="]=2;
self._deny_($13);
$ctx1.sendIdx["deny:"]=2;
self._deny_($recv(self._collection()).__eq(self._collectionWithNewValue()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{},$globals.CollectionTest)});
},
args: [],
source: "testEquality\x0a\x09self assert: self collectionClass new equals: self collectionClass new.\x0a\x09self assert: self collection equals: self collection.\x0a\x09self assert: self collectionWithNewValue equals: self collectionWithNewValue.\x0a\x09\x0a\x09self deny: self collectionClass new = self collection.\x0a\x09self deny: self collection = self collectionClass new.\x0a\x09self deny: self collection = self collectionWithNewValue",
referencedClasses: [],
messageSends: ["assert:equals:", "new", "collectionClass", "collection", "collectionWithNewValue", "deny:", "="]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testIfEmptyFamily",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$5,$4,$6,$9,$8,$7,$11,$10,$13,$12,$15,$14,$16,$19,$18,$17,$21,$20,$23,$22,$24,$25,$27,$26,$29,$28;
$3=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=1;
$2=$recv($3)._new();
$ctx1.sendIdx["new"]=1;
$1=$recv($2)._ifEmpty_((function(){
return (42);

}));
$ctx1.sendIdx["ifEmpty:"]=1;
self._assert_equals_($1,(42));
$ctx1.sendIdx["assert:equals:"]=1;
$5=self._collection();
$ctx1.sendIdx["collection"]=1;
$4=$recv($5)._ifEmpty_((function(){
return (42);

}));
$6=self._collection();
$ctx1.sendIdx["collection"]=2;
self._assert_equals_($4,$6);
$ctx1.sendIdx["assert:equals:"]=2;
$9=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=2;
$8=$recv($9)._new();
$ctx1.sendIdx["new"]=2;
$7=$recv($8)._ifNotEmpty_((function(){
return (42);

}));
$ctx1.sendIdx["ifNotEmpty:"]=1;
$11=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=3;
$10=$recv($11)._new();
$ctx1.sendIdx["new"]=3;
self._assert_equals_($7,$10);
$ctx1.sendIdx["assert:equals:"]=3;
$13=self._collection();
$ctx1.sendIdx["collection"]=3;
$12=$recv($13)._ifNotEmpty_((function(){
return (42);

}));
$ctx1.sendIdx["ifNotEmpty:"]=2;
self._assert_equals_($12,(42));
$ctx1.sendIdx["assert:equals:"]=4;
$15=self._collection();
$ctx1.sendIdx["collection"]=4;
$14=$recv($15)._ifNotEmpty_((function(col){
return col;

}));
$16=self._collection();
$ctx1.sendIdx["collection"]=5;
self._assert_equals_($14,$16);
$ctx1.sendIdx["assert:equals:"]=5;
$19=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=4;
$18=$recv($19)._new();
$ctx1.sendIdx["new"]=4;
$17=$recv($18)._ifEmpty_ifNotEmpty_((function(){
return (42);

}),(function(){
return (999);

}));
$ctx1.sendIdx["ifEmpty:ifNotEmpty:"]=1;
self._assert_equals_($17,(42));
$ctx1.sendIdx["assert:equals:"]=6;
$21=self._collection();
$ctx1.sendIdx["collection"]=6;
$20=$recv($21)._ifEmpty_ifNotEmpty_((function(){
return (42);

}),(function(){
return (999);

}));
$ctx1.sendIdx["ifEmpty:ifNotEmpty:"]=2;
self._assert_equals_($20,(999));
$ctx1.sendIdx["assert:equals:"]=7;
$23=self._collection();
$ctx1.sendIdx["collection"]=7;
$22=$recv($23)._ifEmpty_ifNotEmpty_((function(){
return (42);

}),(function(col){
return col;

}));
$24=self._collection();
$ctx1.sendIdx["collection"]=8;
self._assert_equals_($22,$24);
$ctx1.sendIdx["assert:equals:"]=8;
$25=$recv($recv(self._collectionClass())._new())._ifNotEmpty_ifEmpty_((function(){
return (42);

}),(function(){
return (999);

}));
$ctx1.sendIdx["ifNotEmpty:ifEmpty:"]=1;
self._assert_equals_($25,(999));
$ctx1.sendIdx["assert:equals:"]=9;
$27=self._collection();
$ctx1.sendIdx["collection"]=9;
$26=$recv($27)._ifNotEmpty_ifEmpty_((function(){
return (42);

}),(function(){
return (999);

}));
$ctx1.sendIdx["ifNotEmpty:ifEmpty:"]=2;
self._assert_equals_($26,(42));
$ctx1.sendIdx["assert:equals:"]=10;
$29=self._collection();
$ctx1.sendIdx["collection"]=10;
$28=$recv($29)._ifNotEmpty_ifEmpty_((function(col){
return col;

}),(function(){
return (999);

}));
self._assert_equals_($28,self._collection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testIfEmptyFamily",{},$globals.CollectionTest)});
},
args: [],
source: "testIfEmptyFamily\x0a\x09self assert: (self collectionClass new ifEmpty: [ 42 ]) equals: 42.\x0a\x09self assert: (self collection ifEmpty: [ 42 ]) equals: self collection.\x0a\x0a\x09self assert: (self collectionClass new ifNotEmpty: [ 42 ]) equals: self collectionClass new.\x0a\x09self assert: (self collection ifNotEmpty: [ 42 ]) equals: 42.\x0a\x09self assert: (self collection ifNotEmpty: [ :col | col ]) equals: self collection.\x0a\x09\x0a\x09self assert: (self collectionClass new ifEmpty: [ 42 ] ifNotEmpty: [ 999 ]) equals: 42.\x0a\x09self assert: (self collection ifEmpty: [ 42 ] ifNotEmpty: [ 999 ]) equals: 999.\x0a\x09self assert: (self collection ifEmpty: [ 42 ] ifNotEmpty: [ :col | col ]) equals: self collection.\x0a\x0a\x09self assert: (self collectionClass new ifNotEmpty: [ 42 ] ifEmpty: [ 999 ]) equals: 999.\x0a\x09self assert: (self collection ifNotEmpty: [ 42 ] ifEmpty: [ 999 ]) equals: 42.\x0a\x09self assert: (self collection ifNotEmpty: [ :col | col ] ifEmpty: [ 999 ]) equals: self collection.",
referencedClasses: [],
messageSends: ["assert:equals:", "ifEmpty:", "new", "collectionClass", "collection", "ifNotEmpty:", "ifEmpty:ifNotEmpty:", "ifNotEmpty:ifEmpty:"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testIsEmpty",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv(self._collectionClass())._new())._isEmpty();
$ctx1.sendIdx["isEmpty"]=1;
self._assert_($1);
self._deny_($recv(self._collection())._isEmpty());
return self;
}, function($ctx1) {$ctx1.fill(self,"testIsEmpty",{},$globals.CollectionTest)});
},
args: [],
source: "testIsEmpty\x0a\x09self assert: self collectionClass new isEmpty.\x0a\x09self deny: self collection isEmpty",
referencedClasses: [],
messageSends: ["assert:", "isEmpty", "new", "collectionClass", "deny:", "collection"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testNoneSatisfy",
protocol: 'tests',
fn: function (){
var self=this;
var anyOne;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
$1=self._collection();
$ctx1.sendIdx["collection"]=1;
anyOne=$recv($1)._anyOne();
$3=self._collection();
$ctx1.sendIdx["collection"]=2;
$2=$recv($3)._noneSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq(anyOne);
$ctx2.sendIdx["="]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["noneSatisfy:"]=1;
self._deny_($2);
self._assert_($recv(self._collection())._noneSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq($recv($globals.Object)._new());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
})));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNoneSatisfy",{anyOne:anyOne},$globals.CollectionTest)});
},
args: [],
source: "testNoneSatisfy\x0a\x09| anyOne |\x0a\x09anyOne := self collection anyOne.\x0a\x09self deny: (self collection noneSatisfy: [ :each | each = anyOne ]).\x0a\x09self assert: (self collection noneSatisfy: [ :each | each = Object new ])",
referencedClasses: ["Object"],
messageSends: ["anyOne", "collection", "deny:", "noneSatisfy:", "=", "assert:", "new"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testRemoveAll",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=self._collection();
$recv($2)._removeAll();
$1=$recv($2)._yourself();
self._assert_equals_($1,$recv(self._collectionClass())._new());
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveAll",{},$globals.CollectionTest)});
},
args: [],
source: "testRemoveAll\x0a\x09self assert: (self collection removeAll; yourself) equals: self collectionClass new",
referencedClasses: [],
messageSends: ["assert:equals:", "removeAll", "collection", "yourself", "new", "collectionClass"]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testSelect",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$6,$5,$7,$9,$10,$8,$12,$13,$11,$14,$16,$17,$15;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$1=$recv($2)._select_((function(){
return false;

}));
$ctx1.sendIdx["select:"]=1;
$4=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=1;
$3=$recv($4)._new();
$ctx1.sendIdx["new"]=1;
self._assert_equals_($1,$3);
$ctx1.sendIdx["assert:equals:"]=1;
$6=self._collection();
$ctx1.sendIdx["collection"]=2;
$5=$recv($6)._select_((function(){
return true;

}));
$ctx1.sendIdx["select:"]=2;
$7=self._collection();
$ctx1.sendIdx["collection"]=3;
self._assert_equals_($5,$7);
$ctx1.sendIdx["assert:equals:"]=2;
$9=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=1;
$8=$recv($9)._select_((function(each){
return $core.withContext(function($ctx2) {
$10=self._sampleNewValue();
$ctx2.sendIdx["sampleNewValue"]=1;
return $recv(each).__eq($10);
$ctx2.sendIdx["="]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
$ctx1.sendIdx["select:"]=3;
self._assert_equals_($8,self._sampleNewValueAsCollection());
$ctx1.sendIdx["assert:equals:"]=3;
$12=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=2;
$11=$recv($12)._select_((function(each){
return $core.withContext(function($ctx2) {
$13=self._sampleNewValue();
$ctx2.sendIdx["sampleNewValue"]=2;
return $recv(each).__tild_eq($13);
$ctx2.sendIdx["~="]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}));
$ctx1.sendIdx["select:"]=4;
$14=self._collection();
$ctx1.sendIdx["collection"]=4;
self._assert_equals_($11,$14);
$ctx1.sendIdx["assert:equals:"]=4;
$16=self._collection();
$ctx1.sendIdx["collection"]=5;
$15=$recv($16)._select_((function(each){
return $core.withContext(function($ctx2) {
$17=self._sampleNewValue();
$ctx2.sendIdx["sampleNewValue"]=3;
return $recv(each).__eq($17);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,5)});
}));
$ctx1.sendIdx["select:"]=5;
self._assert_equals_($15,$recv(self._collectionClass())._new());
$ctx1.sendIdx["assert:equals:"]=5;
self._assert_equals_($recv(self._collectionWithNewValue())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__tild_eq(self._sampleNewValue());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,6)});
})),self._collection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testSelect",{},$globals.CollectionTest)});
},
args: [],
source: "testSelect\x0a\x09self assert: (self collection select: [ false ]) equals: self collectionClass new.\x0a\x09self assert: (self collection select: [ true ]) equals: self collection.\x0a\x09self assert: (self collectionWithNewValue select: [ :each | each = self sampleNewValue ]) equals: self sampleNewValueAsCollection.\x0a\x09self assert: (self collectionWithNewValue select: [ :each | each ~= self sampleNewValue ]) equals: self collection.\x0a\x09self assert: (self collection select: [ :each | each = self sampleNewValue ]) equals: self collectionClass new.\x0a\x09self assert: (self collectionWithNewValue select: [ :each | each ~= self sampleNewValue ]) equals: self collection",
referencedClasses: [],
messageSends: ["assert:equals:", "select:", "collection", "new", "collectionClass", "collectionWithNewValue", "=", "sampleNewValue", "sampleNewValueAsCollection", "~="]
}),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testSize",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv($recv(self._collectionClass())._new())._size();
$ctx1.sendIdx["size"]=1;
self._assert_equals_($1,(0));
$ctx1.sendIdx["assert:equals:"]=1;
$2=$recv(self._sampleNewValueAsCollection())._size();
$ctx1.sendIdx["size"]=2;
self._assert_equals_($2,(1));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_($recv(self._collection())._size(),self._collectionSize());
return self;
}, function($ctx1) {$ctx1.fill(self,"testSize",{},$globals.CollectionTest)});
},
args: [],
source: "testSize\x0a\x09self assert: self collectionClass new size equals: 0.\x0a\x09self assert: self sampleNewValueAsCollection size equals: 1.\x0a\x09self assert: self collection size equals: self collectionSize",
referencedClasses: [],
messageSends: ["assert:equals:", "size", "new", "collectionClass", "sampleNewValueAsCollection", "collection", "collectionSize"]
}),
$globals.CollectionTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'fixture',
fn: function (){
var self=this;
return nil;

},
args: [],
source: "collectionClass\x0a\x09\x22Answers class of collection type tested,\x0a\x09or nil if test is abstract\x22\x0a\x0a\x09^ nil",
referencedClasses: [],
messageSends: []
}),
$globals.CollectionTest.klass);

$core.addMethod(
$core.method({
selector: "isAbstract",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._collectionClass())._isNil();
}, function($ctx1) {$ctx1.fill(self,"isAbstract",{},$globals.CollectionTest.klass)});
},
args: [],
source: "isAbstract\x0a\x09^ self collectionClass isNil",
referencedClasses: [],
messageSends: ["isNil", "collectionClass"]
}),
$globals.CollectionTest.klass);


$core.addClass('IndexableCollectionTest', $globals.CollectionTest, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionWithNewValue",{},$globals.IndexableCollectionTest)});
},
args: [],
source: "collectionWithNewValue\x0a\x09\x22Answers a collection which shows how\x0a\x09self collection would look after adding\x0a\x09self sampleNewValue at self sampleNewIndex\x22\x0a\x09\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNewIndex",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"sampleNewIndex",{},$globals.IndexableCollectionTest)});
},
args: [],
source: "sampleNewIndex\x0a\x09\x22Answers a value that can be used as index in at:put: or at:ifAbsentPut:\x22\x0a\x09\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNonIndexesDo:",
protocol: 'fixture',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"sampleNonIndexesDo:",{aBlock:aBlock},$globals.IndexableCollectionTest)});
},
args: ["aBlock"],
source: "sampleNonIndexesDo: aBlock\x0a\x09\x22Executes block a few times,\x0a\x09each time passing value that is known\x0a\x09not to be an index, as the first parameter\x22\x0a\x09\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: 'fixture',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock},$globals.IndexableCollectionTest)});
},
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09\x22Executes block a few times,\x0a\x09each time passing known index and value stored\x0a\x09under that index as the parameters\x22\x0a\x09\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "testAt",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
self._nonIndexesDo_((function(each){
return $core.withContext(function($ctx2) {
return self._should_raise_((function(){
return $core.withContext(function($ctx3) {
$1=self._collection();
$ctx3.sendIdx["collection"]=1;
return $recv($1)._at_(each);
$ctx3.sendIdx["at:"]=1;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),$globals.Error);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
return self._assert_equals_($recv(self._collection())._at_(index),value);
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAt",{},$globals.IndexableCollectionTest)});
},
args: [],
source: "testAt\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09self should: [ self collection at: each ] raise: Error ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (self collection at: index) equals: value ]",
referencedClasses: ["Error"],
messageSends: ["nonIndexesDo:", "should:raise:", "at:", "collection", "samplesDo:", "assert:equals:"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "testAtIfAbsent",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3;
self._nonIndexesDo_((function(each){
return $core.withContext(function($ctx2) {
$2=self._collection();
$ctx2.sendIdx["collection"]=1;
$1=$recv($2)._at_ifAbsent_(each,(function(){
return $core.withContext(function($ctx3) {
return self._sampleNewValue();
$ctx3.sendIdx["sampleNewValue"]=1;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
$ctx2.sendIdx["at:ifAbsent:"]=1;
$3=self._sampleNewValue();
$ctx2.sendIdx["sampleNewValue"]=2;
return self._assert_equals_($1,$3);
$ctx2.sendIdx["assert:equals:"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
return self._assert_equals_($recv(self._collection())._at_ifAbsent_(index,(function(){
return $core.withContext(function($ctx3) {
return self._sampleNewValue();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,4)});
})),value);
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfAbsent",{},$globals.IndexableCollectionTest)});
},
args: [],
source: "testAtIfAbsent\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09self assert: (self collection at: each ifAbsent: [ self sampleNewValue ]) equals: self sampleNewValue ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (self collection at: index ifAbsent: [ self sampleNewValue ]) equals: value ].",
referencedClasses: [],
messageSends: ["nonIndexesDo:", "assert:equals:", "at:ifAbsent:", "collection", "sampleNewValue", "samplesDo:"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "testAtIfAbsentPut",
protocol: 'tests',
fn: function (){
var self=this;
var newCollection;
return $core.withContext(function($ctx1) {
var $1;
newCollection=self._collection();
$ctx1.sendIdx["collection"]=1;
self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
$1=$recv(newCollection)._at_ifAbsentPut_(index,(function(){
return $core.withContext(function($ctx3) {
return self._sampleNewValue();
$ctx3.sendIdx["sampleNewValue"]=1;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
$ctx2.sendIdx["at:ifAbsentPut:"]=1;
return self._assert_equals_($1,value);
$ctx2.sendIdx["assert:equals:"]=1;
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,1)});
}));
self._assert_equals_(newCollection,self._collection());
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_($recv(newCollection)._at_ifAbsentPut_(self._sampleNewIndex(),(function(){
return $core.withContext(function($ctx2) {
return self._sampleNewValue();
$ctx2.sendIdx["sampleNewValue"]=2;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
})),self._sampleNewValue());
$ctx1.sendIdx["assert:equals:"]=3;
self._assert_equals_(newCollection,self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfAbsentPut",{newCollection:newCollection},$globals.IndexableCollectionTest)});
},
args: [],
source: "testAtIfAbsentPut\x0a\x09| newCollection |\x0a\x09newCollection := self collection.\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (newCollection at: index ifAbsentPut: [ self sampleNewValue ]) equals: value ].\x0a\x09self assert: newCollection equals: self collection.\x0a\x09self assert: (newCollection at: self sampleNewIndex ifAbsentPut: [ self sampleNewValue ]) equals: self sampleNewValue.\x0a\x09self assert: newCollection equals: self collectionWithNewValue",
referencedClasses: [],
messageSends: ["collection", "samplesDo:", "assert:equals:", "at:ifAbsentPut:", "sampleNewValue", "sampleNewIndex", "collectionWithNewValue"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "testAtIfPresent",
protocol: 'tests',
fn: function (){
var self=this;
var visited,sentinel;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3;
sentinel=$recv($globals.Object)._new();
self._nonIndexesDo_((function(each){
return $core.withContext(function($ctx2) {
visited=nil;
visited;
$2=self._collection();
$ctx2.sendIdx["collection"]=1;
$1=$recv($2)._at_ifPresent_(each,(function(value1){
visited=value1;
visited;
return sentinel;

}));
$ctx2.sendIdx["at:ifPresent:"]=1;
self._assert_equals_($1,nil);
$ctx2.sendIdx["assert:equals:"]=1;
return self._assert_($recv(visited)._isNil());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
visited=nil;
visited;
$4=self._collection();
$ctx2.sendIdx["collection"]=2;
$3=$recv($4)._at_ifPresent_(index,(function(value2){
visited=value2;
visited;
return sentinel;

}));
self._assert_equals_($3,sentinel);
$ctx2.sendIdx["assert:equals:"]=2;
return self._assert_equals_(visited,$recv(self._collection())._at_(index));
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfPresent",{visited:visited,sentinel:sentinel},$globals.IndexableCollectionTest)});
},
args: [],
source: "testAtIfPresent\x0a\x09| visited sentinel |\x0a\x09sentinel := Object new.\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09visited := nil.\x0a\x09\x09self assert: (self collection at: each ifPresent: [ :value1 | visited := value1. sentinel ]) equals: nil.\x0a\x09\x09self assert: visited isNil ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09visited := nil.\x0a\x09\x09self assert: (self collection at: index ifPresent: [ :value2 | visited := value2. sentinel ]) equals: sentinel.\x0a\x09\x09self assert: visited equals: (self collection at: index) ]",
referencedClasses: ["Object"],
messageSends: ["new", "nonIndexesDo:", "assert:equals:", "at:ifPresent:", "collection", "assert:", "isNil", "samplesDo:", "at:"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "testAtIfPresentIfAbsent",
protocol: 'tests',
fn: function (){
var self=this;
var visited,sentinel;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$5,$4;
sentinel=$recv($globals.Object)._new();
self._nonIndexesDo_((function(each){
return $core.withContext(function($ctx2) {
visited=nil;
visited;
$2=self._collection();
$ctx2.sendIdx["collection"]=1;
$1=$recv($2)._at_ifPresent_ifAbsent_(each,(function(value1){
visited=value1;
visited;
return sentinel;

}),(function(){
return $core.withContext(function($ctx3) {
return self._sampleNewValue();
$ctx3.sendIdx["sampleNewValue"]=1;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
$ctx2.sendIdx["at:ifPresent:ifAbsent:"]=1;
$3=self._sampleNewValue();
$ctx2.sendIdx["sampleNewValue"]=2;
self._assert_equals_($1,$3);
$ctx2.sendIdx["assert:equals:"]=1;
return self._assert_($recv(visited)._isNil());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
visited=nil;
visited;
$5=self._collection();
$ctx2.sendIdx["collection"]=2;
$4=$recv($5)._at_ifPresent_ifAbsent_(index,(function(value2){
visited=value2;
visited;
return sentinel;

}),(function(){
return $core.withContext(function($ctx3) {
return self._sampleNewValue();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,6)});
}));
self._assert_equals_($4,sentinel);
$ctx2.sendIdx["assert:equals:"]=2;
return self._assert_equals_(visited,$recv(self._collection())._at_(index));
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,4)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfPresentIfAbsent",{visited:visited,sentinel:sentinel},$globals.IndexableCollectionTest)});
},
args: [],
source: "testAtIfPresentIfAbsent\x0a\x09| visited sentinel |\x0a\x09sentinel := Object new.\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09visited := nil.\x0a\x09\x09self assert: (self collection at: each ifPresent: [ :value1 | visited := value1. sentinel ] ifAbsent: [ self sampleNewValue ] ) equals: self sampleNewValue.\x0a\x09\x09self assert: visited isNil ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09visited := nil.\x0a\x09\x09self assert: (self collection at: index ifPresent: [ :value2 | visited := value2. sentinel ] ifAbsent: [ self sampleNewValue ]) equals: sentinel.\x0a\x09\x09self assert: visited equals: (self collection at: index) ]",
referencedClasses: ["Object"],
messageSends: ["new", "nonIndexesDo:", "assert:equals:", "at:ifPresent:ifAbsent:", "collection", "sampleNewValue", "assert:", "isNil", "samplesDo:", "at:"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "testAtPut",
protocol: 'tests',
fn: function (){
var self=this;
var newCollection;
return $core.withContext(function($ctx1) {
newCollection=self._collection();
$ctx1.sendIdx["collection"]=1;
self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
return $recv(newCollection)._at_put_(index,value);
$ctx2.sendIdx["at:put:"]=1;
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,1)});
}));
self._assert_equals_(newCollection,self._collection());
$ctx1.sendIdx["assert:equals:"]=1;
$recv(newCollection)._at_put_(self._sampleNewIndex(),self._sampleNewValue());
self._assert_equals_(newCollection,self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtPut",{newCollection:newCollection},$globals.IndexableCollectionTest)});
},
args: [],
source: "testAtPut\x0a\x09| newCollection |\x0a\x09newCollection := self collection.\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09newCollection at: index put: value ].\x0a\x09self assert: newCollection equals: self collection.\x0a\x09newCollection at: self sampleNewIndex put: self sampleNewValue.\x0a\x09self assert: newCollection equals: self collectionWithNewValue",
referencedClasses: [],
messageSends: ["collection", "samplesDo:", "at:put:", "assert:equals:", "sampleNewIndex", "sampleNewValue", "collectionWithNewValue"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "testIndexOf",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
$1=self._collection();
$ctx2.sendIdx["collection"]=1;
return $recv($1)._indexOf_(self._sampleNewValue());
$ctx2.sendIdx["indexOf:"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
return self._assert_equals_($recv(self._collection())._indexOf_(value),index);
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIndexOf",{},$globals.IndexableCollectionTest)});
},
args: [],
source: "testIndexOf\x0a\x09self should: [ self collection indexOf: self sampleNewValue ] raise: Error.\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (self collection indexOf: value) equals: index ]",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "indexOf:", "collection", "sampleNewValue", "samplesDo:", "assert:equals:"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "testIndexOfWithNull",
protocol: 'tests',
fn: function (){
var self=this;
var jsNull;
return $core.withContext(function($ctx1) {
var $2,$1;
jsNull=$recv($globals.JSON)._parse_("null");
self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
$2=self._collection();
$recv($2)._at_put_(index,jsNull);
$1=$recv($2)._indexOf_(jsNull);
return self._assert_equals_($1,index);
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIndexOfWithNull",{jsNull:jsNull},$globals.IndexableCollectionTest)});
},
args: [],
source: "testIndexOfWithNull\x0a\x09| jsNull |\x0a\x09jsNull := JSON parse: 'null'.\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (self collection at: index put: jsNull; indexOf: jsNull) equals: index ]",
referencedClasses: ["JSON"],
messageSends: ["parse:", "samplesDo:", "assert:equals:", "at:put:", "collection", "indexOf:"]
}),
$globals.IndexableCollectionTest);

$core.addMethod(
$core.method({
selector: "testWithIndexDo",
protocol: 'tests',
fn: function (){
var self=this;
var collection;
return $core.withContext(function($ctx1) {
collection=self._collection();
$ctx1.sendIdx["collection"]=1;
$recv(self._collection())._withIndexDo_((function(each,index){
return $core.withContext(function($ctx2) {
return self._assert_equals_($recv(collection)._at_(index),each);
}, function($ctx2) {$ctx2.fillBlock({each:each,index:index},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testWithIndexDo",{collection:collection},$globals.IndexableCollectionTest)});
},
args: [],
source: "testWithIndexDo\x0a\x09| collection |\x0a\x09collection := self collection.\x0a\x09\x0a\x09self collection withIndexDo: [ :each :index |\x0a\x09\x09self assert: (collection at: index) equals: each ]",
referencedClasses: [],
messageSends: ["collection", "withIndexDo:", "assert:equals:", "at:"]
}),
$globals.IndexableCollectionTest);



$core.addClass('AssociativeCollectionTest', $globals.IndexableCollectionTest, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "collectionKeys",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionKeys",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "collectionKeys\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionValues",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionValues",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "collectionValues\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "nonIndexesDo:",
protocol: 'fixture',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aBlock)._value_((5));
$ctx1.sendIdx["value:"]=1;
$recv(aBlock)._value_((function(){

}));
$ctx1.sendIdx["value:"]=2;
$recv(aBlock)._value_($recv($globals.Object)._new());
$ctx1.sendIdx["value:"]=3;
$recv(aBlock)._value_("z");
return self;
}, function($ctx1) {$ctx1.fill(self,"nonIndexesDo:",{aBlock:aBlock},$globals.AssociativeCollectionTest)});
},
args: ["aBlock"],
source: "nonIndexesDo: aBlock\x0a\x09aBlock value: 5.\x0a\x09aBlock value: [].\x0a\x09aBlock value: Object new.\x0a\x09aBlock value: 'z'",
referencedClasses: ["Object"],
messageSends: ["value:", "new"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNewIndex",
protocol: 'fixture',
fn: function (){
var self=this;
return "new";

},
args: [],
source: "sampleNewIndex\x0a\x09^ 'new'",
referencedClasses: [],
messageSends: []
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: 'fixture',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aBlock)._value_value_("a",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock},$globals.AssociativeCollectionTest)});
},
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09aBlock value: 'a' value: 2",
referencedClasses: [],
messageSends: ["value:value:"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testAddAll",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$4,$1,$5,$7,$8,$9,$6,$10,$12,$11;
(
$ctx1.supercall = true,
($globals.AssociativeCollectionTest.superclass||$boot.dnu).fn.prototype._testAddAll.apply($recv(self), []));
$ctx1.supercall = false;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$3=self._collection();
$ctx1.sendIdx["collection"]=2;
$recv($2)._addAll_($3);
$ctx1.sendIdx["addAll:"]=1;
$4=$recv($2)._yourself();
$ctx1.sendIdx["yourself"]=1;
$1=$4;
$5=self._collection();
$ctx1.sendIdx["collection"]=3;
self._assert_equals_($1,$5);
$ctx1.sendIdx["assert:equals:"]=1;
$7=self._collection();
$ctx1.sendIdx["collection"]=4;
$8=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=1;
$recv($7)._addAll_($8);
$ctx1.sendIdx["addAll:"]=2;
$9=$recv($7)._yourself();
$ctx1.sendIdx["yourself"]=2;
$6=$9;
$10=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=2;
self._assert_equals_($6,$10);
$ctx1.sendIdx["assert:equals:"]=2;
$12=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=3;
$recv($12)._addAll_(self._collection());
$11=$recv($12)._yourself();
self._assert_equals_($11,self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddAll",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testAddAll\x0a\x09super testAddAll.\x0a\x09self assert: (self collection addAll: self collection; yourself) equals: self collection.\x0a\x09self assert: (self collection addAll: self collectionWithNewValue; yourself) equals: self collectionWithNewValue.\x0a\x09self assert: (self collectionWithNewValue addAll: self collection; yourself) equals: self collectionWithNewValue",
referencedClasses: [],
messageSends: ["testAddAll", "assert:equals:", "addAll:", "collection", "yourself", "collectionWithNewValue"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testAsDictionary",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_($recv($recv($recv(self._collectionClass())._new())._asDictionary())._isMemberOf_($globals.Dictionary));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsDictionary",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testAsDictionary\x0aself assert: ( self collectionClass new asDictionary isMemberOf: Dictionary ).",
referencedClasses: ["Dictionary"],
messageSends: ["assert:", "isMemberOf:", "asDictionary", "new", "collectionClass"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testAsHashedCollection",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_($recv($recv($recv(self._collectionClass())._new())._asHashedCollection())._isMemberOf_($globals.HashedCollection));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsHashedCollection",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testAsHashedCollection\x0aself assert: ( self collectionClass new asHashedCollection isMemberOf: HashedCollection ).",
referencedClasses: ["HashedCollection"],
messageSends: ["assert:", "isMemberOf:", "asHashedCollection", "new", "collectionClass"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testComma",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$4,$6,$7,$5,$8,$10,$9;
(
$ctx1.supercall = true,
($globals.AssociativeCollectionTest.superclass||$boot.dnu).fn.prototype._testComma.apply($recv(self), []));
$ctx1.supercall = false;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$3=self._collection();
$ctx1.sendIdx["collection"]=2;
$1=$recv($2).__comma($3);
$ctx1.sendIdx[","]=1;
$4=self._collection();
$ctx1.sendIdx["collection"]=3;
self._assert_equals_($1,$4);
$ctx1.sendIdx["assert:equals:"]=1;
$6=self._collection();
$ctx1.sendIdx["collection"]=4;
$7=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=1;
$5=$recv($6).__comma($7);
$ctx1.sendIdx[","]=2;
$8=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=2;
self._assert_equals_($5,$8);
$ctx1.sendIdx["assert:equals:"]=2;
$10=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=3;
$9=$recv($10).__comma(self._collection());
self._assert_equals_($9,self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testComma",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testComma\x0a\x09super testComma.\x0a\x09self assert: self collection, self collection equals: self collection.\x0a\x09self assert: self collection, self collectionWithNewValue equals: self collectionWithNewValue.\x0a\x09self assert: self collectionWithNewValue, self collection equals: self collectionWithNewValue",
referencedClasses: [],
messageSends: ["testComma", "assert:equals:", ",", "collection", "collectionWithNewValue"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testFrom",
protocol: 'tests',
fn: function (){
var self=this;
var associations;
return $core.withContext(function($ctx1) {
var $1;
$1="a".__minus_gt((1));
$ctx1.sendIdx["->"]=1;
associations=[$1,"b".__minus_gt((2))];
self._assertSameContents_as_($recv($recv(self._class())._collectionClass())._from_(associations),$globals.HashedCollection._newFromPairs_(["a",(1),"b",(2)]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testFrom",{associations:associations},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testFrom\x0a\x22Accept a collection of associations.\x22\x0a| associations |\x0aassociations := { 'a' -> 1. 'b' -> 2 }.\x0aself assertSameContents: ( self class collectionClass from: associations ) as: #{ 'a' -> 1. 'b' -> 2 }.",
referencedClasses: [],
messageSends: ["->", "assertSameContents:as:", "from:", "collectionClass", "class"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testKeys",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$4;
$2=$recv($recv(self._collectionClass())._new())._keys();
$ctx1.sendIdx["keys"]=1;
$1=$recv($2)._isEmpty();
self._assert_($1);
$3=$recv(self._collection())._keys();
$ctx1.sendIdx["keys"]=2;
$4=self._collectionKeys();
$ctx1.sendIdx["collectionKeys"]=1;
self._assertSameContents_as_($3,$4);
$ctx1.sendIdx["assertSameContents:as:"]=1;
self._assertSameContents_as_($recv(self._collectionWithNewValue())._keys(),$recv(self._collectionKeys()).__comma([self._sampleNewIndex()]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testKeys",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testKeys\x0a\x09self assert:self collectionClass new keys isEmpty.\x0a\x09self assertSameContents:self collection keys as: self collectionKeys.\x0a\x09self assertSameContents:self collectionWithNewValue keys as: self collectionKeys, { self sampleNewIndex }",
referencedClasses: [],
messageSends: ["assert:", "isEmpty", "keys", "new", "collectionClass", "assertSameContents:as:", "collection", "collectionKeys", "collectionWithNewValue", ",", "sampleNewIndex"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testNewFromPairs",
protocol: 'tests',
fn: function (){
var self=this;
var flattenedAssociations;
return $core.withContext(function($ctx1) {
flattenedAssociations=["a",(1),"b",(2)];
self._assertSameContents_as_($recv($recv(self._class())._collectionClass())._newFromPairs_(flattenedAssociations),$globals.HashedCollection._newFromPairs_(["a",(1),"b",(2)]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNewFromPairs",{flattenedAssociations:flattenedAssociations},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testNewFromPairs\x0a\x22Accept an array in which all odd indexes are keys and evens are values.\x22\x0a| flattenedAssociations |\x0aflattenedAssociations := { 'a'. 1. 'b'. 2 }.\x0aself assertSameContents: ( self class collectionClass newFromPairs: flattenedAssociations ) as: #{ 'a' -> 1. 'b' -> 2 }.",
referencedClasses: [],
messageSends: ["assertSameContents:as:", "newFromPairs:", "collectionClass", "class"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testPrintString",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$4;
$3=self._collectionClass();
$ctx1.sendIdx["collectionClass"]=1;
$2=$recv($3)._new();
$recv($2)._at_put_("firstname","James");
$ctx1.sendIdx["at:put:"]=1;
$recv($2)._at_put_("lastname","Bond");
$1=$recv($2)._printString();
$4=$recv("a ".__comma($recv(self._collectionClass())._name())).__comma(" ('firstname' -> 'James' , 'lastname' -> 'Bond')");
$ctx1.sendIdx[","]=1;
self._assert_equals_($1,$4);
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrintString",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testPrintString\x0a\x09self\x0a\x09\x09assert: (self collectionClass new\x0a\x09\x09\x09\x09\x09\x09\x09at:'firstname' put: 'James';\x0a\x09\x09\x09\x09\x09\x09\x09at:'lastname' put: 'Bond';\x0a\x09\x09\x09\x09\x09\x09\x09printString)\x0a\x09\x09equals: 'a ', self collectionClass name, ' (''firstname'' -> ''James'' , ''lastname'' -> ''Bond'')'",
referencedClasses: [],
messageSends: ["assert:equals:", "at:put:", "new", "collectionClass", "printString", ",", "name"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testRemoveKey",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$6,$4,$8,$7;
self._nonIndexesDo_((function(each){
var collection;
return $core.withContext(function($ctx2) {
collection=self._collection();
$ctx2.sendIdx["collection"]=1;
collection;
self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv(collection)._removeKey_(each);
$ctx3.sendIdx["removeKey:"]=1;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),$globals.Error);
$1=collection;
$2=self._collection();
$ctx2.sendIdx["collection"]=2;
return self._assert_equals_($1,$2);
$ctx2.sendIdx["assert:equals:"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each,collection:collection},$ctx1,1)});
}));
self._samplesDo_((function(index,value){
var collection;
return $core.withContext(function($ctx2) {
collection=self._collection();
$ctx2.sendIdx["collection"]=3;
collection;
$3=$recv(collection)._removeKey_(index);
$ctx2.sendIdx["removeKey:"]=2;
self._assert_equals_($3,value);
$ctx2.sendIdx["assert:equals:"]=2;
$5=collection;
$6=self._collection();
$ctx2.sendIdx["collection"]=4;
$4=$recv($5).__eq($6);
return self._deny_($4);
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value,collection:collection},$ctx1,3)});
}));
$8=self._collectionWithNewValue();
$recv($8)._removeKey_(self._sampleNewIndex());
$7=$recv($8)._yourself();
self._assert_equals_($7,self._collection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveKey",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testRemoveKey\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09| collection |\x0a\x09\x09collection := self collection.\x0a\x09\x09self should: [ collection removeKey: each ] raise: Error.\x0a\x09\x09self assert: collection equals: self collection ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09| collection |\x0a\x09\x09collection := self collection.\x0a\x09\x09self assert: (collection removeKey: index) equals: value.\x0a\x09\x09self deny: collection = self collection ].\x0a\x09self\x0a\x09\x09assert: (self collectionWithNewValue removeKey: self sampleNewIndex; yourself)\x0a\x09\x09equals: self collection",
referencedClasses: ["Error"],
messageSends: ["nonIndexesDo:", "collection", "should:raise:", "removeKey:", "assert:equals:", "samplesDo:", "deny:", "=", "collectionWithNewValue", "sampleNewIndex", "yourself"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testRemoveKeyIfAbsent",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$7,$8,$6,$10,$9;
self._nonIndexesDo_((function(each){
var collection;
return $core.withContext(function($ctx2) {
collection=self._collection();
$ctx2.sendIdx["collection"]=1;
collection;
$1=$recv(collection)._removeKey_ifAbsent_(each,(function(){
return $core.withContext(function($ctx3) {
return self._sampleNewValue();
$ctx3.sendIdx["sampleNewValue"]=1;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
$ctx2.sendIdx["removeKey:ifAbsent:"]=1;
$2=self._sampleNewValue();
$ctx2.sendIdx["sampleNewValue"]=2;
self._assert_equals_($1,$2);
$ctx2.sendIdx["assert:equals:"]=1;
$3=collection;
$4=self._collection();
$ctx2.sendIdx["collection"]=2;
return self._assert_equals_($3,$4);
$ctx2.sendIdx["assert:equals:"]=2;
}, function($ctx2) {$ctx2.fillBlock({each:each,collection:collection},$ctx1,1)});
}));
self._samplesDo_((function(index,value){
var collection;
return $core.withContext(function($ctx2) {
collection=self._collection();
$ctx2.sendIdx["collection"]=3;
collection;
$5=$recv(collection)._removeKey_ifAbsent_(index,(function(){
return $core.withContext(function($ctx3) {
return self._sampleNewValue();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,4)});
}));
$ctx2.sendIdx["removeKey:ifAbsent:"]=2;
self._assert_equals_($5,value);
$ctx2.sendIdx["assert:equals:"]=3;
$7=collection;
$8=self._collection();
$ctx2.sendIdx["collection"]=4;
$6=$recv($7).__eq($8);
return self._deny_($6);
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value,collection:collection},$ctx1,3)});
}));
$10=self._collectionWithNewValue();
$recv($10)._removeKey_ifAbsent_(self._sampleNewIndex(),(function(){
return $core.withContext(function($ctx2) {
return self._assert_(false);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}));
$9=$recv($10)._yourself();
self._assert_equals_($9,self._collection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveKeyIfAbsent",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testRemoveKeyIfAbsent\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09| collection |\x0a\x09\x09collection := self collection.\x0a\x09\x09self assert: (collection removeKey: each ifAbsent: [ self sampleNewValue ]) equals: self sampleNewValue.\x0a\x09\x09self assert: collection equals: self collection ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09| collection |\x0a\x09\x09collection := self collection.\x0a\x09\x09self assert: (collection removeKey: index ifAbsent: [ self sampleNewValue ]) equals: value.\x0a\x09\x09self deny: collection = self collection ].\x0a\x09self\x0a\x09\x09assert: (self collectionWithNewValue removeKey: self sampleNewIndex ifAbsent: [ self assert: false ]; yourself)\x0a\x09\x09equals: self collection",
referencedClasses: [],
messageSends: ["nonIndexesDo:", "collection", "assert:equals:", "removeKey:ifAbsent:", "sampleNewValue", "samplesDo:", "deny:", "=", "collectionWithNewValue", "sampleNewIndex", "assert:", "yourself"]
}),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testValues",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$4;
$2=$recv($recv(self._collectionClass())._new())._values();
$ctx1.sendIdx["values"]=1;
$1=$recv($2)._isEmpty();
self._assert_($1);
$3=$recv(self._collection())._values();
$ctx1.sendIdx["values"]=2;
$4=self._collectionValues();
$ctx1.sendIdx["collectionValues"]=1;
self._assertSameContents_as_($3,$4);
$ctx1.sendIdx["assertSameContents:as:"]=1;
self._assertSameContents_as_($recv(self._collectionWithNewValue())._values(),$recv(self._collectionValues()).__comma([self._sampleNewValue()]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testValues",{},$globals.AssociativeCollectionTest)});
},
args: [],
source: "testValues\x0a\x09self assert:self collectionClass new values isEmpty.\x0a\x09self assertSameContents:self collection values as: self collectionValues.\x0a\x09self assertSameContents:self collectionWithNewValue values as: self collectionValues, { self sampleNewValue }",
referencedClasses: [],
messageSends: ["assert:", "isEmpty", "values", "new", "collectionClass", "assertSameContents:as:", "collection", "collectionValues", "collectionWithNewValue", ",", "sampleNewValue"]
}),
$globals.AssociativeCollectionTest);



$core.addClass('DictionaryTest', $globals.AssociativeCollectionTest, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "collection",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Dictionary)._new();
$recv($1)._at_put_((1),(1));
$ctx1.sendIdx["at:put:"]=1;
$recv($1)._at_put_("a",(2));
$ctx1.sendIdx["at:put:"]=2;
$recv($1)._at_put_(true,(3));
$ctx1.sendIdx["at:put:"]=3;
$recv($1)._at_put_((1).__at((3)),(-4));
$ctx1.sendIdx["at:put:"]=4;
$recv($1)._at_put_(self["@sampleBlock"],(9));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collection",{},$globals.DictionaryTest)});
},
args: [],
source: "collection\x0a\x09^ Dictionary new\x0a\x09\x09at: 1 put: 1;\x0a\x09\x09at: 'a' put: 2;\x0a\x09\x09at: true put: 3;\x0a\x09\x09at: 1@3 put: -4;\x0a\x09\x09at: sampleBlock put: 9;\x0a\x09\x09yourself",
referencedClasses: ["Dictionary"],
messageSends: ["at:put:", "new", "@", "yourself"]
}),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionKeys",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return [(1),"a",true,(1).__at((3)),self["@sampleBlock"]];
}, function($ctx1) {$ctx1.fill(self,"collectionKeys",{},$globals.DictionaryTest)});
},
args: [],
source: "collectionKeys\x0a\x09^ {1. 'a'. true. 1@3. sampleBlock}",
referencedClasses: [],
messageSends: ["@"]
}),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Dictionary)._new();
$recv($1)._at_put_((1),"1");
$ctx1.sendIdx["at:put:"]=1;
$recv($1)._at_put_("a","2");
$ctx1.sendIdx["at:put:"]=2;
$recv($1)._at_put_(true,"3");
$ctx1.sendIdx["at:put:"]=3;
$recv($1)._at_put_((1).__at((3)),"-4");
$ctx1.sendIdx["at:put:"]=4;
$recv($1)._at_put_(self["@sampleBlock"],"9");
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionOfPrintStrings",{},$globals.DictionaryTest)});
},
args: [],
source: "collectionOfPrintStrings\x0a\x09^ Dictionary new\x0a\x09\x09at: 1 put: '1';\x0a\x09\x09at: 'a' put: '2';\x0a\x09\x09at: true put: '3';\x0a\x09\x09at: 1@3 put: '-4';\x0a\x09\x09at: sampleBlock put: '9';\x0a\x09\x09yourself",
referencedClasses: ["Dictionary"],
messageSends: ["at:put:", "new", "@", "yourself"]
}),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: 'fixture',
fn: function (){
var self=this;
return (5);

},
args: [],
source: "collectionSize\x0a\x09^ 5",
referencedClasses: [],
messageSends: []
}),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionValues",
protocol: 'fixture',
fn: function (){
var self=this;
return [(1),(2),(3),(-4),(9)];

},
args: [],
source: "collectionValues\x0a\x09^ {1. 2. 3. -4. 9}",
referencedClasses: [],
messageSends: []
}),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Dictionary)._new();
$recv($1)._at_put_((1),(1));
$ctx1.sendIdx["at:put:"]=1;
$recv($1)._at_put_("a",(2));
$ctx1.sendIdx["at:put:"]=2;
$recv($1)._at_put_(true,(3));
$ctx1.sendIdx["at:put:"]=3;
$recv($1)._at_put_((4),(-4));
$ctx1.sendIdx["at:put:"]=4;
$recv($1)._at_put_(self["@sampleBlock"],(9));
$ctx1.sendIdx["at:put:"]=5;
$recv($1)._at_put_("b",(1));
$ctx1.sendIdx["at:put:"]=6;
$recv($1)._at_put_((3),(3));
$ctx1.sendIdx["at:put:"]=7;
$recv($1)._at_put_(false,(12));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionWithDuplicates",{},$globals.DictionaryTest)});
},
args: [],
source: "collectionWithDuplicates\x0a\x09^ Dictionary new\x0a\x09\x09at: 1 put: 1;\x0a\x09\x09at: 'a' put: 2;\x0a\x09\x09at: true put: 3;\x0a\x09\x09at: 4 put: -4;\x0a\x09\x09at: sampleBlock put: 9;\x0a\x09\x09at: 'b' put: 1;\x0a\x09\x09at: 3 put: 3;\x0a\x09\x09at: false put: 12;\x0a\x09\x09yourself",
referencedClasses: ["Dictionary"],
messageSends: ["at:put:", "new", "yourself"]
}),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Dictionary)._new();
$recv($1)._at_put_((1),(1));
$ctx1.sendIdx["at:put:"]=1;
$recv($1)._at_put_("a",(2));
$ctx1.sendIdx["at:put:"]=2;
$recv($1)._at_put_(true,(3));
$ctx1.sendIdx["at:put:"]=3;
$recv($1)._at_put_((1).__at((3)),(-4));
$ctx1.sendIdx["at:put:"]=4;
$recv($1)._at_put_(self["@sampleBlock"],(9));
$ctx1.sendIdx["at:put:"]=5;
$recv($1)._at_put_("new","N");
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionWithNewValue",{},$globals.DictionaryTest)});
},
args: [],
source: "collectionWithNewValue\x0a\x09^ Dictionary new\x0a\x09\x09at: 1 put: 1;\x0a\x09\x09at: 'a' put: 2;\x0a\x09\x09at: true put: 3;\x0a\x09\x09at: 1@3 put: -4;\x0a\x09\x09at: sampleBlock put: 9;\x0a\x09\x09at: 'new' put: 'N';\x0a\x09\x09yourself",
referencedClasses: ["Dictionary"],
messageSends: ["at:put:", "new", "@", "yourself"]
}),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "sampleNewValueAsCollection",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Dictionary)._new();
$recv($1)._at_put_("new","N");
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"sampleNewValueAsCollection",{},$globals.DictionaryTest)});
},
args: [],
source: "sampleNewValueAsCollection\x0a\x09^ Dictionary new\x0a\x09\x09at: 'new' put: 'N';\x0a\x09\x09yourself",
referencedClasses: ["Dictionary"],
messageSends: ["at:put:", "new", "yourself"]
}),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: 'fixture',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.DictionaryTest.superclass||$boot.dnu).fn.prototype._samplesDo_.apply($recv(self), [aBlock]));
$ctx1.supercall = false;
$recv(aBlock)._value_value_(true,(3));
$ctx1.sendIdx["value:value:"]=1;
$recv(aBlock)._value_value_((1).__at((3)),(-4));
$ctx1.sendIdx["value:value:"]=2;
$recv(aBlock)._value_value_(self["@sampleBlock"],(9));
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock},$globals.DictionaryTest)});
},
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09super samplesDo: aBlock.\x0a\x09aBlock value: true value: 3.\x0a\x09aBlock value: 1@3 value: -4.\x0a\x09aBlock value: sampleBlock value: 9",
referencedClasses: [],
messageSends: ["samplesDo:", "value:value:", "@"]
}),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "testAccessing",
protocol: 'tests',
fn: function (){
var self=this;
var d;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$9,$10,$8,$12,$13,$11;
d=$recv($globals.Dictionary)._new();
$recv(d)._at_put_("hello","world");
$ctx1.sendIdx["at:put:"]=1;
$1=$recv(d)._at_("hello");
$ctx1.sendIdx["at:"]=1;
self._assert_equals_($1,"world");
$ctx1.sendIdx["assert:equals:"]=1;
$2=$recv(d)._at_ifAbsent_("hello",(function(){
return nil;

}));
$ctx1.sendIdx["at:ifAbsent:"]=1;
self._assert_equals_($2,"world");
$ctx1.sendIdx["assert:equals:"]=2;
self._deny_($recv($recv(d)._at_ifAbsent_("foo",(function(){
return nil;

}))).__eq("world"));
$ctx1.sendIdx["deny:"]=1;
$3=$recv(d)._includesKey_("hello");
$ctx1.sendIdx["includesKey:"]=1;
self._assert_($3);
$ctx1.sendIdx["assert:"]=1;
$4=$recv(d)._includesKey_("foo");
$ctx1.sendIdx["includesKey:"]=2;
self._deny_($4);
$ctx1.sendIdx["deny:"]=2;
$recv(d)._at_put_((1),(2));
$ctx1.sendIdx["at:put:"]=2;
$5=$recv(d)._at_((1));
$ctx1.sendIdx["at:"]=2;
self._assert_equals_($5,(2));
$ctx1.sendIdx["assert:equals:"]=3;
$6=d;
$7=(1).__at((3));
$ctx1.sendIdx["@"]=1;
$recv($6)._at_put_($7,(3));
$9=d;
$10=(1).__at((3));
$ctx1.sendIdx["@"]=2;
$8=$recv($9)._at_($10);
self._assert_equals_($8,(3));
$12=d;
$13=(1).__at((3));
$ctx1.sendIdx["@"]=3;
$11=$recv($12)._includesKey_($13);
$ctx1.sendIdx["includesKey:"]=3;
self._assert_($11);
self._deny_($recv(d)._includesKey_((3).__at((1))));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAccessing",{d:d},$globals.DictionaryTest)});
},
args: [],
source: "testAccessing\x0a\x09| d |\x0a\x0a\x09d := Dictionary new.\x0a\x0a\x09d at: 'hello' put: 'world'.\x0a\x09self assert: (d at: 'hello') equals: 'world'.\x0a\x09self assert: (d at: 'hello' ifAbsent: [ nil ]) equals: 'world'.\x0a\x09self deny: (d at: 'foo' ifAbsent: [ nil ]) = 'world'.\x0a\x0a\x09self assert: (d includesKey: 'hello').\x0a\x09self deny: (d includesKey: 'foo').\x0a\x0a\x09d at: 1 put: 2.\x0a\x09self assert: (d at: 1) equals: 2.\x0a\x0a\x09d at: 1@3 put: 3.\x0a\x09self assert: (d at: 1@3) equals: 3.\x0a\x0a\x09self assert: (d includesKey: 1@3).\x0a\x09self deny: (d includesKey: 3@1)",
referencedClasses: ["Dictionary"],
messageSends: ["new", "at:put:", "assert:equals:", "at:", "at:ifAbsent:", "deny:", "=", "assert:", "includesKey:", "@"]
}),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "testDynamicDictionaries",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_($recv($globals.HashedCollection._newFromPairs_(["hello",(1)]))._asDictionary(),$recv($globals.Dictionary)._with_("hello".__minus_gt((1))));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDynamicDictionaries",{},$globals.DictionaryTest)});
},
args: [],
source: "testDynamicDictionaries\x0a\x09self assert: #{'hello' -> 1} asDictionary equals: (Dictionary with: 'hello' -> 1)",
referencedClasses: ["Dictionary"],
messageSends: ["assert:equals:", "asDictionary", "with:", "->"]
}),
$globals.DictionaryTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'fixture',
fn: function (){
var self=this;
return $globals.Dictionary;

},
args: [],
source: "collectionClass\x0a\x09^ Dictionary",
referencedClasses: ["Dictionary"],
messageSends: []
}),
$globals.DictionaryTest.klass);


$core.addClass('HashedCollectionTest', $globals.AssociativeCollectionTest, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "collection",
protocol: 'fixture',
fn: function (){
var self=this;
return $globals.HashedCollection._newFromPairs_(["b",(1),"a",(2),"c",(3),"d",(-4)]);

},
args: [],
source: "collection\x0a\x09^ #{ 'b' -> 1. 'a' -> 2. 'c' -> 3. 'd' -> -4 }",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionKeys",
protocol: 'fixture',
fn: function (){
var self=this;
return ["b","a","c","d"];

},
args: [],
source: "collectionKeys\x0a\x09^ { 'b'. 'a'. 'c'. 'd' }",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: 'fixture',
fn: function (){
var self=this;
return $globals.HashedCollection._newFromPairs_(["b","1","a","2","c","3","d","-4"]);

},
args: [],
source: "collectionOfPrintStrings\x0a\x09^ #{ 'b' -> '1'. 'a' -> '2'. 'c' -> '3'. 'd' -> '-4' }",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: 'fixture',
fn: function (){
var self=this;
return (4);

},
args: [],
source: "collectionSize\x0a\x09^ 4",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionValues",
protocol: 'fixture',
fn: function (){
var self=this;
return [(1),(2),(3),(-4)];

},
args: [],
source: "collectionValues\x0a\x09^ { 1. 2. 3. -4 }",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: 'fixture',
fn: function (){
var self=this;
return $globals.HashedCollection._newFromPairs_(["b",(1),"a",(2),"c",(3),"d",(-4),"e",(1),"f",(2),"g",(10),"h",(0)]);

},
args: [],
source: "collectionWithDuplicates\x0a\x09^ #{ 'b' -> 1. 'a' -> 2. 'c' -> 3. 'd' -> -4. 'e' -> 1. 'f' -> 2. 'g' -> 10. 'h' -> 0 }",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: 'fixture',
fn: function (){
var self=this;
return $globals.HashedCollection._newFromPairs_(["b",(1),"a",(2),"c",(3),"d",(-4),"new","N"]);

},
args: [],
source: "collectionWithNewValue\x0a\x09^ #{ 'b' -> 1. 'a' -> 2. 'c' -> 3. 'd' -> -4. 'new' -> 'N' }",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNewValueAsCollection",
protocol: 'fixture',
fn: function (){
var self=this;
return $globals.HashedCollection._newFromPairs_(["new","N"]);

},
args: [],
source: "sampleNewValueAsCollection\x0a\x09^ #{ 'new' -> 'N' }",
referencedClasses: [],
messageSends: []
}),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "testDynamicDictionaries",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_($recv($globals.HashedCollection._newFromPairs_(["hello",(1)]))._asHashedCollection(),$recv($globals.HashedCollection)._with_("hello".__minus_gt((1))));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDynamicDictionaries",{},$globals.HashedCollectionTest)});
},
args: [],
source: "testDynamicDictionaries\x0a\x09self assert: #{'hello' -> 1} asHashedCollection equals: (HashedCollection with: 'hello' -> 1)",
referencedClasses: ["HashedCollection"],
messageSends: ["assert:equals:", "asHashedCollection", "with:", "->"]
}),
$globals.HashedCollectionTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'fixture',
fn: function (){
var self=this;
return $globals.HashedCollection;

},
args: [],
source: "collectionClass\x0a\x09^ HashedCollection",
referencedClasses: ["HashedCollection"],
messageSends: []
}),
$globals.HashedCollectionTest.klass);


$core.addClass('SequenceableCollectionTest', $globals.IndexableCollectionTest, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "collectionFirst",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionFirst",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "collectionFirst\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionFirstTwo",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionFirstTwo",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "collectionFirstTwo\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionLast",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionLast",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "collectionLast\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionLastTwo",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionLastTwo",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "collectionLastTwo\x0a\x09self subclassResponsibility",
referencedClasses: [],
messageSends: ["subclassResponsibility"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "nonIndexesDo:",
protocol: 'fixture',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aBlock)._value_((0));
$ctx1.sendIdx["value:"]=1;
$recv(aBlock)._value_($recv(self._collectionSize()).__plus((1)));
$ctx1.sendIdx["value:"]=2;
$recv(aBlock)._value_("z");
return self;
}, function($ctx1) {$ctx1.fill(self,"nonIndexesDo:",{aBlock:aBlock},$globals.SequenceableCollectionTest)});
},
args: ["aBlock"],
source: "nonIndexesDo: aBlock\x0a\x09aBlock value: 0.\x0a\x09aBlock value: self collectionSize + 1.\x0a\x09aBlock value: 'z'",
referencedClasses: [],
messageSends: ["value:", "+", "collectionSize"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: 'fixture',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aBlock)._value_value_((1),self._collectionFirst());
$ctx1.sendIdx["value:value:"]=1;
$recv(aBlock)._value_value_(self._collectionSize(),self._collectionLast());
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock},$globals.SequenceableCollectionTest)});
},
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09aBlock value: 1 value: self collectionFirst.\x0a\x09aBlock value: self collectionSize value: self collectionLast",
referencedClasses: [],
messageSends: ["value:value:", "collectionFirst", "collectionSize", "collectionLast"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testBeginsWith",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$5,$3,$7,$6;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$1=$recv($2)._beginsWith_($recv(self._collectionClass())._new());
$ctx1.sendIdx["beginsWith:"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$4=self._collection();
$ctx1.sendIdx["collection"]=2;
$5=self._collection();
$ctx1.sendIdx["collection"]=3;
$3=$recv($4)._beginsWith_($5);
$ctx1.sendIdx["beginsWith:"]=2;
self._assert_($3);
$ctx1.sendIdx["assert:"]=2;
$7=self._collection();
$ctx1.sendIdx["collection"]=4;
$6=$recv($7)._beginsWith_(self._collectionFirstTwo());
$ctx1.sendIdx["beginsWith:"]=3;
self._assert_($6);
self._deny_($recv(self._collection())._beginsWith_(self._collectionLastTwo()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBeginsWith",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testBeginsWith\x0a\x09self assert: (self collection beginsWith: self collectionClass new).\x0a\x09self assert: (self collection beginsWith: self collection).\x0a\x09self assert: (self collection beginsWith: self collectionFirstTwo).\x0a\x09self deny: (self collection beginsWith: self collectionLastTwo)",
referencedClasses: [],
messageSends: ["assert:", "beginsWith:", "collection", "new", "collectionClass", "collectionFirstTwo", "deny:", "collectionLastTwo"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testEndsWith",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$5,$3,$7,$6;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$1=$recv($2)._endsWith_($recv(self._collectionClass())._new());
$ctx1.sendIdx["endsWith:"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$4=self._collection();
$ctx1.sendIdx["collection"]=2;
$5=self._collection();
$ctx1.sendIdx["collection"]=3;
$3=$recv($4)._endsWith_($5);
$ctx1.sendIdx["endsWith:"]=2;
self._assert_($3);
$ctx1.sendIdx["assert:"]=2;
$7=self._collection();
$ctx1.sendIdx["collection"]=4;
$6=$recv($7)._endsWith_(self._collectionLastTwo());
$ctx1.sendIdx["endsWith:"]=3;
self._assert_($6);
self._deny_($recv(self._collection())._endsWith_(self._collectionFirstTwo()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEndsWith",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testEndsWith\x0a\x09self assert: (self collection endsWith: self collectionClass new).\x0a\x09self assert: (self collection endsWith: self collection).\x0a\x09self assert: (self collection endsWith: self collectionLastTwo).\x0a\x09self deny: (self collection endsWith: self collectionFirstTwo)",
referencedClasses: [],
messageSends: ["assert:", "endsWith:", "collection", "new", "collectionClass", "collectionLastTwo", "deny:", "collectionFirstTwo"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testFirst",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_($recv(self._collection())._first(),self._collectionFirst());
return self;
}, function($ctx1) {$ctx1.fill(self,"testFirst",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testFirst\x0a\x09self assert: self collection first equals: self collectionFirst",
referencedClasses: [],
messageSends: ["assert:equals:", "first", "collection", "collectionFirst"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testFirstN",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$6,$5,$7;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$1=$recv($2)._first_((2));
$ctx1.sendIdx["first:"]=1;
self._assert_equals_($1,self._collectionFirstTwo());
$ctx1.sendIdx["assert:equals:"]=1;
$4=self._collection();
$ctx1.sendIdx["collection"]=2;
$3=$recv($4)._first_((0));
$ctx1.sendIdx["first:"]=2;
self._assert_equals_($3,$recv(self._collectionClass())._new());
$ctx1.sendIdx["assert:equals:"]=2;
$6=self._collection();
$ctx1.sendIdx["collection"]=3;
$5=$recv($6)._first_(self._collectionSize());
$ctx1.sendIdx["first:"]=3;
$7=self._collection();
$ctx1.sendIdx["collection"]=4;
self._assert_equals_($5,$7);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._collection())._first_((33));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testFirstN",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testFirstN\x0a\x09self \x0a\x09\x09assert: (self collection first: 2)\x0a\x09\x09equals: self collectionFirstTwo.\x0a\x09\x09\x0a\x09self\x0a\x09\x09assert: (self collection first: 0)\x0a\x09\x09equals: self collectionClass new.\x0a\x09\x09\x0a\x09self\x0a\x09\x09assert: (self collection first: self collectionSize)\x0a\x09\x09equals: self collection.\x0a\x09\x09\x0a\x09self should: [ self collection first: 33 ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["assert:equals:", "first:", "collection", "collectionFirstTwo", "new", "collectionClass", "collectionSize", "should:raise:"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testFourth",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$1=$recv($2)._fourth();
self._assert_equals_($1,$recv(self._collection())._at_((4)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testFourth",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testFourth\x0a\x09self assert: (self collection fourth) equals: (self collection at: 4)",
referencedClasses: [],
messageSends: ["assert:equals:", "fourth", "collection", "at:"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testIndexOfStartingAt",
protocol: 'tests',
fn: function (){
var self=this;
var jsNull;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3;
jsNull=$recv($globals.JSON)._parse_("null");
self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
$2=self._collection();
$ctx2.sendIdx["collection"]=1;
$1=$recv($2)._indexOf_startingAt_(value,(1));
$ctx2.sendIdx["indexOf:startingAt:"]=1;
self._assert_equals_($1,index);
$ctx2.sendIdx["assert:equals:"]=1;
$4=self._collection();
$ctx2.sendIdx["collection"]=2;
$3=$recv($4)._indexOf_startingAt_(value,index);
$ctx2.sendIdx["indexOf:startingAt:"]=2;
self._assert_equals_($3,index);
$ctx2.sendIdx["assert:equals:"]=2;
return self._assert_equals_($recv(self._collection())._indexOf_startingAt_(value,$recv(index).__plus((1))),(0));
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIndexOfStartingAt",{jsNull:jsNull},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testIndexOfStartingAt\x0a\x09| jsNull |\x0a\x09jsNull := JSON parse: 'null'.\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (self collection indexOf: value startingAt: 1) equals: index.\x0a\x09\x09self assert: (self collection indexOf: value startingAt: index) equals: index.\x0a\x09\x09self assert: (self collection indexOf: value startingAt: index+1) equals: 0 ]",
referencedClasses: ["JSON"],
messageSends: ["parse:", "samplesDo:", "assert:equals:", "indexOf:startingAt:", "collection", "+"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testIndexOfStartingAtWithNull",
protocol: 'tests',
fn: function (){
var self=this;
var jsNull;
return $core.withContext(function($ctx1) {
var $1,$2;
jsNull=$recv($globals.JSON)._parse_("null");
self._samplesDo_((function(index,value){
var collection;
return $core.withContext(function($ctx2) {
collection=self._collection();
collection;
$recv(collection)._at_put_(index,jsNull);
$1=$recv(collection)._indexOf_startingAt_(jsNull,(1));
$ctx2.sendIdx["indexOf:startingAt:"]=1;
self._assert_equals_($1,index);
$ctx2.sendIdx["assert:equals:"]=1;
$2=$recv(collection)._indexOf_startingAt_(jsNull,index);
$ctx2.sendIdx["indexOf:startingAt:"]=2;
self._assert_equals_($2,index);
$ctx2.sendIdx["assert:equals:"]=2;
return self._assert_equals_($recv(collection)._indexOf_startingAt_(jsNull,$recv(index).__plus((1))),(0));
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value,collection:collection},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIndexOfStartingAtWithNull",{jsNull:jsNull},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testIndexOfStartingAtWithNull\x0a\x09| jsNull |\x0a\x09jsNull := JSON parse: 'null'.\x0a\x09self samplesDo: [ :index :value | | collection |\x0a\x09\x09collection := self collection.\x0a\x09\x09collection at: index put: jsNull.\x0a\x09\x09self assert: (collection indexOf: jsNull startingAt: 1) equals: index.\x0a\x09\x09self assert: (collection indexOf: jsNull startingAt: index) equals: index.\x0a\x09\x09self assert: (collection indexOf: jsNull startingAt: index+1) equals: 0 ]",
referencedClasses: ["JSON"],
messageSends: ["parse:", "samplesDo:", "collection", "at:put:", "assert:equals:", "indexOf:startingAt:", "+"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testLast",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_($recv(self._collection())._last(),self._collectionLast());
return self;
}, function($ctx1) {$ctx1.fill(self,"testLast",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testLast\x0a\x09self assert: self collection last equals: self collectionLast",
referencedClasses: [],
messageSends: ["assert:equals:", "last", "collection", "collectionLast"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testLastN",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$6,$5,$7;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$1=$recv($2)._last_((2));
$ctx1.sendIdx["last:"]=1;
self._assert_equals_($1,self._collectionLastTwo());
$ctx1.sendIdx["assert:equals:"]=1;
$4=self._collection();
$ctx1.sendIdx["collection"]=2;
$3=$recv($4)._last_((0));
$ctx1.sendIdx["last:"]=2;
self._assert_equals_($3,$recv(self._collectionClass())._new());
$ctx1.sendIdx["assert:equals:"]=2;
$6=self._collection();
$ctx1.sendIdx["collection"]=3;
$5=$recv($6)._last_(self._collectionSize());
$ctx1.sendIdx["last:"]=3;
$7=self._collection();
$ctx1.sendIdx["collection"]=4;
self._assert_equals_($5,$7);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._collection())._last_((33));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testLastN",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testLastN\x0a\x09self \x0a\x09\x09assert: (self collection last: 2) \x0a\x09\x09equals: self collectionLastTwo.\x0a\x09\x09\x0a\x09self\x0a\x09\x09assert: (self collection last: 0)\x0a\x09\x09equals: self collectionClass new.\x0a\x0a\x09self\x0a\x09\x09assert: (self collection last: self collectionSize)\x0a\x09\x09equals: self collection.\x0a\x0a\x09self should: [ self collection last: 33 ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["assert:equals:", "last:", "collection", "collectionLastTwo", "new", "collectionClass", "collectionSize", "should:raise:"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testSecond",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$1=$recv($2)._second();
self._assert_equals_($1,$recv(self._collection())._at_((2)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSecond",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testSecond\x0a\x09self assert: (self collection second) equals: (self collection at: 2)",
referencedClasses: [],
messageSends: ["assert:equals:", "second", "collection", "at:"]
}),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testThird",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$1=$recv($2)._third();
self._assert_equals_($1,$recv(self._collection())._at_((3)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testThird",{},$globals.SequenceableCollectionTest)});
},
args: [],
source: "testThird\x0a\x09self assert: (self collection third) equals: (self collection at: 3)",
referencedClasses: [],
messageSends: ["assert:equals:", "third", "collection", "at:"]
}),
$globals.SequenceableCollectionTest);



$core.addClass('ArrayTest', $globals.SequenceableCollectionTest, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "collection",
protocol: 'fixture',
fn: function (){
var self=this;
return [(1), (2), (3), (-4)];

},
args: [],
source: "collection\x0a\x09^ #(1 2 3 -4)",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionFirst",
protocol: 'fixture',
fn: function (){
var self=this;
return (1);

},
args: [],
source: "collectionFirst\x0a\x09^ 1",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionFirstTwo",
protocol: 'fixture',
fn: function (){
var self=this;
return [(1), (2)];

},
args: [],
source: "collectionFirstTwo\x0a\x09^ #(1 2)",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionLast",
protocol: 'fixture',
fn: function (){
var self=this;
return (-4);

},
args: [],
source: "collectionLast\x0a\x09^ -4",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionLastTwo",
protocol: 'fixture',
fn: function (){
var self=this;
return [(3), (-4)];

},
args: [],
source: "collectionLastTwo\x0a\x09^ #(3 -4)",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: 'fixture',
fn: function (){
var self=this;
return ["1", "2", "3", "-4"];

},
args: [],
source: "collectionOfPrintStrings\x0a\x09^ #('1' '2' '3' '-4')",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: 'fixture',
fn: function (){
var self=this;
return (4);

},
args: [],
source: "collectionSize\x0a\x09^ 4",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: 'fixture',
fn: function (){
var self=this;
return ["a", "b", "c", (1), (2), (1), "a", []];

},
args: [],
source: "collectionWithDuplicates\x0a\x09^ #('a' 'b' 'c' 1 2 1 'a' ())",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: 'fixture',
fn: function (){
var self=this;
return [(1), (2), (3), (-4), "N"];

},
args: [],
source: "collectionWithNewValue\x0a\x09^ #(1 2 3 -4 'N')",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "sampleNewIndex",
protocol: 'fixture',
fn: function (){
var self=this;
return (5);

},
args: [],
source: "sampleNewIndex\x0a\x09^ 5",
referencedClasses: [],
messageSends: []
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: 'fixture',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.ArrayTest.superclass||$boot.dnu).fn.prototype._samplesDo_.apply($recv(self), [aBlock]));
$ctx1.supercall = false;
$recv(aBlock)._value_value_((3),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock},$globals.ArrayTest)});
},
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09super samplesDo: aBlock.\x0a\x09aBlock value: 3 value: 3.",
referencedClasses: [],
messageSends: ["samplesDo:", "value:value:"]
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testAdd",
protocol: 'tests',
fn: function (){
var self=this;
var array;
return $core.withContext(function($ctx1) {
array=self._collection();
$recv(array)._add_((6));
self._assert_equals_($recv(array)._last(),(6));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAdd",{array:array},$globals.ArrayTest)});
},
args: [],
source: "testAdd \x0a\x09| array | \x0a\x09array := self collection. \x0a\x09array add: 6.\x0a\x09\x0a\x09self assert: array last equals: 6",
referencedClasses: [],
messageSends: ["collection", "add:", "assert:equals:", "last"]
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testAddFirst",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
$3=self._collection();
$recv($3)._addFirst_((0));
$2=$recv($3)._yourself();
$1=$recv($2)._first();
self._assert_equals_($1,(0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddFirst",{},$globals.ArrayTest)});
},
args: [],
source: "testAddFirst\x0a\x09self assert: (self collection addFirst: 0; yourself) first equals: 0",
referencedClasses: [],
messageSends: ["assert:equals:", "first", "addFirst:", "collection", "yourself"]
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testPrintString",
protocol: 'tests',
fn: function (){
var self=this;
var array;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$8;
array=$recv($globals.Array)._new();
$1=$recv(array)._printString();
$ctx1.sendIdx["printString"]=1;
self._assert_equals_($1,"an Array ()");
$ctx1.sendIdx["assert:equals:"]=1;
$2=array;
$recv($2)._add_((1));
$ctx1.sendIdx["add:"]=1;
$3=$recv($2)._add_((3));
$ctx1.sendIdx["add:"]=2;
$4=$recv(array)._printString();
$ctx1.sendIdx["printString"]=2;
self._assert_equals_($4,"an Array (1 3)");
$ctx1.sendIdx["assert:equals:"]=2;
$recv(array)._add_("foo");
$5=$recv(array)._printString();
$ctx1.sendIdx["printString"]=3;
self._assert_equals_($5,"an Array (1 3 'foo')");
$ctx1.sendIdx["assert:equals:"]=3;
$6=array;
$recv($6)._remove_((1));
$ctx1.sendIdx["remove:"]=1;
$recv($6)._remove_((3));
$7=$recv(array)._printString();
$ctx1.sendIdx["printString"]=4;
self._assert_equals_($7,"an Array ('foo')");
$ctx1.sendIdx["assert:equals:"]=4;
$recv(array)._addLast_((3));
$ctx1.sendIdx["addLast:"]=1;
$8=$recv(array)._printString();
$ctx1.sendIdx["printString"]=5;
self._assert_equals_($8,"an Array ('foo' 3)");
$ctx1.sendIdx["assert:equals:"]=5;
$recv(array)._addLast_((3));
self._assert_equals_($recv(array)._printString(),"an Array ('foo' 3 3)");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrintString",{array:array},$globals.ArrayTest)});
},
args: [],
source: "testPrintString\x0a\x09| array |\x0a\x09array := Array new.\x0a\x09self assert: array printString equals: 'an Array ()'.\x0a\x09array add: 1; add: 3.\x0a\x09self assert: array printString equals: 'an Array (1 3)'.\x0a\x09array add: 'foo'.\x0a\x09self assert: array printString equals: 'an Array (1 3 ''foo'')'.\x0a\x09array remove: 1; remove: 3.\x0a\x09self assert: array printString equals: 'an Array (''foo'')'.\x0a\x09array addLast: 3.\x0a\x09self assert: array printString equals: 'an Array (''foo'' 3)'.\x0a\x09array addLast: 3.\x0a\x09self assert: array printString equals: 'an Array (''foo'' 3 3)'.",
referencedClasses: ["Array"],
messageSends: ["new", "assert:equals:", "printString", "add:", "remove:", "addLast:"]
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testRemove",
protocol: 'tests',
fn: function (){
var self=this;
var array;
return $core.withContext(function($ctx1) {
array=[(1), (2), (3), (4), (5)];
$recv(array)._remove_((3));
$ctx1.sendIdx["remove:"]=1;
self._assert_equals_(array,[(1), (2), (4), (5)]);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(array)._remove_((3));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemove",{array:array},$globals.ArrayTest)});
},
args: [],
source: "testRemove \x0a\x09| array |\x0a\x09array := #(1 2 3 4 5). \x0a\x09array remove: 3.\x0a\x0a\x09self assert: array equals: #(1 2 4 5).\x0a\x09self should: [ array remove: 3 ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["remove:", "assert:equals:", "should:raise:"]
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testRemoveFromTo",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=[(1), (2), (3), (4)]._removeFrom_to_((1),(3));
$ctx1.sendIdx["removeFrom:to:"]=1;
self._assert_equals_($1,[(4)]);
$ctx1.sendIdx["assert:equals:"]=1;
$2=[(1), (2), (3), (4)]._removeFrom_to_((2),(3));
$ctx1.sendIdx["removeFrom:to:"]=2;
self._assert_equals_($2,[(1), (4)]);
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_([(1), (2), (3), (4)]._removeFrom_to_((2),(4)),[(1)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveFromTo",{},$globals.ArrayTest)});
},
args: [],
source: "testRemoveFromTo\x0a\x09\x0a\x09self assert: (#(1 2 3 4) removeFrom: 1 to: 3) equals: #(4).\x0a\x09self assert: (#(1 2 3 4) removeFrom: 2 to: 3) equals: #(1 4).\x0a\x09self assert: (#(1 2 3 4) removeFrom: 2 to: 4) equals: #(1)",
referencedClasses: [],
messageSends: ["assert:equals:", "removeFrom:to:"]
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testRemoveIndex",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=[(1), (2), (3), (4)]._removeIndex_((2));
$ctx1.sendIdx["removeIndex:"]=1;
self._assert_equals_($1,[(1), (3), (4)]);
$ctx1.sendIdx["assert:equals:"]=1;
$2=[(1), (2), (3), (4)]._removeIndex_((1));
$ctx1.sendIdx["removeIndex:"]=2;
self._assert_equals_($2,[(2), (3), (4)]);
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_(["hello"]._removeIndex_((1)),[]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveIndex",{},$globals.ArrayTest)});
},
args: [],
source: "testRemoveIndex\x0a\x09\x0a\x09self assert: (#(1 2 3 4) removeIndex: 2) equals: #(1 3 4).\x0a\x09self assert: (#(1 2 3 4) removeIndex: 1) equals: #(2 3 4).\x0a\x09self assert: (#('hello') removeIndex: 1) equals: #()",
referencedClasses: [],
messageSends: ["assert:equals:", "removeIndex:"]
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testRemoveLast",
protocol: 'tests',
fn: function (){
var self=this;
var array;
return $core.withContext(function($ctx1) {
array=[(1), (2)];
$recv(array)._removeLast();
self._assert_equals_($recv(array)._last(),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveLast",{array:array},$globals.ArrayTest)});
},
args: [],
source: "testRemoveLast \x0a\x09| array |\x0a\x09array := #(1 2). \x0a\x09array removeLast.\x0a\x09\x0a\x09self assert: array last equals: 1",
referencedClasses: [],
messageSends: ["removeLast", "assert:equals:", "last"]
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testReversed",
protocol: 'tests',
fn: function (){
var self=this;
var array;
return $core.withContext(function($ctx1) {
array=[(5), (4), (3), (2), (1)];
self._assert_equals_($recv(array)._reversed(),[(1), (2), (3), (4), (5)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testReversed",{array:array},$globals.ArrayTest)});
},
args: [],
source: "testReversed\x0a\x09|array|\x0a\x09array := #(5 4 3 2 1). \x0a\x09self assert: (array reversed) equals: #(1 2 3 4 5)",
referencedClasses: [],
messageSends: ["assert:equals:", "reversed"]
}),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testSort",
protocol: 'tests',
fn: function (){
var self=this;
var array;
return $core.withContext(function($ctx1) {
array=[(10), (1), (5)];
$recv(array)._sort();
self._assert_equals_(array,[(1), (5), (10)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSort",{array:array},$globals.ArrayTest)});
},
args: [],
source: "testSort\x0a\x09| array |\x0a\x09array := #(10 1 5). \x0a\x09array sort.\x0a\x09self assert: array equals: #(1 5 10)",
referencedClasses: [],
messageSends: ["sort", "assert:equals:"]
}),
$globals.ArrayTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'fixture',
fn: function (){
var self=this;
return $globals.Array;

},
args: [],
source: "collectionClass\x0a\x09^ Array",
referencedClasses: ["Array"],
messageSends: []
}),
$globals.ArrayTest.klass);


$core.addClass('StringTest', $globals.SequenceableCollectionTest, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "collection",
protocol: 'fixture',
fn: function (){
var self=this;
return "helLo";

},
args: [],
source: "collection\x0a\x09^ 'helLo'",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionFirst",
protocol: 'fixture',
fn: function (){
var self=this;
return "h";

},
args: [],
source: "collectionFirst\x0a\x09^ 'h'",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionFirstTwo",
protocol: 'fixture',
fn: function (){
var self=this;
return "he";

},
args: [],
source: "collectionFirstTwo\x0a\x09^ 'he'",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionLast",
protocol: 'fixture',
fn: function (){
var self=this;
return "o";

},
args: [],
source: "collectionLast\x0a\x09^ 'o'",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionLastTwo",
protocol: 'fixture',
fn: function (){
var self=this;
return "Lo";

},
args: [],
source: "collectionLastTwo\x0a\x09^ 'Lo'",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: 'fixture',
fn: function (){
var self=this;
return "'h''e''l''L''o'";

},
args: [],
source: "collectionOfPrintStrings\x0a\x09^ '''h''''e''''l''''L''''o'''",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: 'fixture',
fn: function (){
var self=this;
return (5);

},
args: [],
source: "collectionSize\x0a\x09^ 5",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: 'fixture',
fn: function (){
var self=this;
return "abbaerten";

},
args: [],
source: "collectionWithDuplicates\x0a\x09^ 'abbaerten'",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: 'fixture',
fn: function (){
var self=this;
return "helLoN";

},
args: [],
source: "collectionWithNewValue\x0a\x09^ 'helLoN'",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "sampleNewValueAsCollection",
protocol: 'fixture',
fn: function (){
var self=this;
return "N";

},
args: [],
source: "sampleNewValueAsCollection\x0a\x09^ 'N'",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: 'fixture',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.StringTest.superclass||$boot.dnu).fn.prototype._samplesDo_.apply($recv(self), [aBlock]));
$ctx1.supercall = false;
$recv(aBlock)._value_value_((3),"l");
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock},$globals.StringTest)});
},
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09super samplesDo: aBlock.\x0a\x09aBlock value: 3 value: 'l'",
referencedClasses: [],
messageSends: ["samplesDo:", "value:value:"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAddAll",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
$1=self._collection();
$ctx2.sendIdx["collection"]=1;
return $recv($1)._addAll_(self._collection());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddAll",{},$globals.StringTest)});
},
args: [],
source: "testAddAll\x0a\x09\x22String instances are read-only\x22\x0a\x09self should: [ self collection addAll: self collection ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "addAll:", "collection"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAddRemove",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return "hello"._add_("a");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$ctx1.sendIdx["should:raise:"]=1;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return "hello"._remove_("h");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddRemove",{},$globals.StringTest)});
},
args: [],
source: "testAddRemove\x0a\x09self should: [ 'hello' add: 'a' ] raise: Error.\x0a\x09self should: [ 'hello' remove: 'h' ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "add:", "remove:"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAsArray",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_("hello"._asArray(),["h", "e", "l", "l", "o"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsArray",{},$globals.StringTest)});
},
args: [],
source: "testAsArray\x0a\x09self assert: 'hello' asArray equals: #('h' 'e' 'l' 'l' 'o').",
referencedClasses: [],
messageSends: ["assert:equals:", "asArray"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAsLowerCase",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_("JACKIE"._asLowercase(),"jackie");
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsLowerCase",{},$globals.StringTest)});
},
args: [],
source: "testAsLowerCase\x0a\x09self assert: 'JACKIE' asLowercase equals: 'jackie'.",
referencedClasses: [],
messageSends: ["assert:equals:", "asLowercase"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAsNumber",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1="3"._asNumber();
$ctx1.sendIdx["asNumber"]=1;
self._assert_equals_($1,(3));
$ctx1.sendIdx["assert:equals:"]=1;
$2="-3"._asNumber();
$ctx1.sendIdx["asNumber"]=2;
self._assert_equals_($2,(-3));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_("-1.5"._asNumber(),(-1.5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsNumber",{},$globals.StringTest)});
},
args: [],
source: "testAsNumber\x0a\x09self assert: '3' asNumber equals: 3.\x0a\x09self assert: '-3' asNumber equals: -3.\x0a\x09self assert: '-1.5' asNumber equals: -1.5.",
referencedClasses: [],
messageSends: ["assert:equals:", "asNumber"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAsUpperCase",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_("jackie"._asUppercase(),"JACKIE");
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsUpperCase",{},$globals.StringTest)});
},
args: [],
source: "testAsUpperCase\x0a\x09self assert: 'jackie' asUppercase equals: 'JACKIE'.",
referencedClasses: [],
messageSends: ["assert:equals:", "asUppercase"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAsciiValue",
protocol: 'tests',
fn: function (){
var self=this;
var characterA,characterU;
return $core.withContext(function($ctx1) {
var $1;
characterA="A";
characterU="U";
$1=$recv(characterA)._asciiValue();
$ctx1.sendIdx["asciiValue"]=1;
self._assert_equals_($1,(65));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_($recv(characterU)._asciiValue(),(85));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsciiValue",{characterA:characterA,characterU:characterU},$globals.StringTest)});
},
args: [],
source: "testAsciiValue\x0a    | characterA characterU |\x0a    characterA := 'A'.\x0a    characterU := 'U'.\x0a    self assert: (characterA asciiValue) equals:65.\x0a    self assert: (characterU asciiValue) equals:85",
referencedClasses: [],
messageSends: ["assert:equals:", "asciiValue"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAtIfAbsentPut",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return "hello"._at_ifAbsentPut_((6),(function(){
return "a";

}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfAbsentPut",{},$globals.StringTest)});
},
args: [],
source: "testAtIfAbsentPut\x0a\x09\x22String instances are read-only\x22\x0a\x09self should: [ 'hello' at: 6 ifAbsentPut: [ 'a' ] ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "at:ifAbsentPut:"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAtPut",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return "hello"._at_put_((1),"a");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtPut",{},$globals.StringTest)});
},
args: [],
source: "testAtPut\x0a\x09\x22String instances are read-only\x22\x0a\x09self should: [ 'hello' at: 1 put: 'a' ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "at:put:"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testCapitalized",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$1="test"._capitalized();
$ctx1.sendIdx["capitalized"]=1;
self._assert_equals_($1,"Test");
$ctx1.sendIdx["assert:equals:"]=1;
$2="Test"._capitalized();
$ctx1.sendIdx["capitalized"]=2;
self._assert_equals_($2,"Test");
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_(""._capitalized(),"");
$ctx1.sendIdx["assert:equals:"]=3;
$3="Test"._isCapitalized();
$ctx1.sendIdx["isCapitalized"]=1;
self._assert_equals_($3,true);
$ctx1.sendIdx["assert:equals:"]=4;
self._assert_equals_("test"._isCapitalized(),false);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCapitalized",{},$globals.StringTest)});
},
args: [],
source: "testCapitalized\x0a\x09self assert: 'test' capitalized equals: 'Test'.\x0a\x09self assert: 'Test' capitalized equals: 'Test'.\x0a\x09self assert: '' capitalized equals: ''.\x0a\x09self assert: 'Test' isCapitalized equals: true.\x0a\x09self assert: 'test' isCapitalized equals: false.",
referencedClasses: [],
messageSends: ["assert:equals:", "capitalized", "isCapitalized"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testCharCodeAt",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5;
$1="jackie"._charCodeAt_((1));
$ctx1.sendIdx["charCodeAt:"]=1;
self._assert_equals_($1,(106));
$ctx1.sendIdx["assert:equals:"]=1;
$2="jackie"._charCodeAt_((2));
$ctx1.sendIdx["charCodeAt:"]=2;
self._assert_equals_($2,(97));
$ctx1.sendIdx["assert:equals:"]=2;
$3="jackie"._charCodeAt_((3));
$ctx1.sendIdx["charCodeAt:"]=3;
self._assert_equals_($3,(99));
$ctx1.sendIdx["assert:equals:"]=3;
$4="jackie"._charCodeAt_((4));
$ctx1.sendIdx["charCodeAt:"]=4;
self._assert_equals_($4,(107));
$ctx1.sendIdx["assert:equals:"]=4;
$5="jackie"._charCodeAt_((5));
$ctx1.sendIdx["charCodeAt:"]=5;
self._assert_equals_($5,(105));
$ctx1.sendIdx["assert:equals:"]=5;
self._assert_equals_("jackie"._charCodeAt_((6)),(101));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCharCodeAt",{},$globals.StringTest)});
},
args: [],
source: "testCharCodeAt\x0a\x09self assert: ('jackie' charCodeAt:1) equals: 106.\x0a\x09self assert: ('jackie' charCodeAt:2) equals: 97.\x0a\x09self assert: ('jackie' charCodeAt:3) equals: 99.\x0a\x09self assert: ('jackie' charCodeAt:4) equals: 107.\x0a\x09self assert: ('jackie' charCodeAt:5) equals: 105.\x0a\x09self assert: ('jackie' charCodeAt:6) equals: 101",
referencedClasses: [],
messageSends: ["assert:equals:", "charCodeAt:"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testCopyFromTo",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1="jackie"._copyFrom_to_((1),(3));
$ctx1.sendIdx["copyFrom:to:"]=1;
self._assert_equals_($1,"jac");
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_("jackie"._copyFrom_to_((4),(6)),"kie");
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopyFromTo",{},$globals.StringTest)});
},
args: [],
source: "testCopyFromTo\x0a\x09self assert: ('jackie' copyFrom: 1 to: 3) equals: 'jac'.\x0a\x09self assert: ('jackie' copyFrom: 4 to: 6) equals: 'kie'.",
referencedClasses: [],
messageSends: ["assert:equals:", "copyFrom:to:"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testCopySeparates",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
$3=self._collection();
$ctx1.sendIdx["collection"]=1;
$2=$recv($3)._copy();
$1=$recv($2).__eq_eq(self._collection());
self._assert_($1);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopySeparates",{},$globals.StringTest)});
},
args: [],
source: "testCopySeparates\x0a\x09\x22String instances are immutable\x22\x0a\x09self assert: self collection copy == self collection",
referencedClasses: [],
messageSends: ["assert:", "==", "copy", "collection"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testCopyWithoutAll",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_("*hello* *world*"._copyWithoutAll_("*"),"hello world");
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopyWithoutAll",{},$globals.StringTest)});
},
args: [],
source: "testCopyWithoutAll\x0a\x09self\x0a\x09\x09assert: ('*hello* *world*' copyWithoutAll: '*')\x0a\x09\x09equals: 'hello world'",
referencedClasses: [],
messageSends: ["assert:equals:", "copyWithoutAll:"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testEquality",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
self._assert_equals_("hello","hello");
$ctx1.sendIdx["assert:equals:"]=1;
$1="hello".__eq("world");
$ctx1.sendIdx["="]=1;
self._deny_($1);
$ctx1.sendIdx["deny:"]=1;
$2="hello".__eq([]._at_ifAbsent_((1),(function(){

})));
$ctx1.sendIdx["="]=2;
self._deny_($2);
$ctx1.sendIdx["deny:"]=2;
$3="hello"._yourself();
$ctx1.sendIdx["yourself"]=1;
self._assert_equals_("hello",$3);
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_("hello"._yourself(),"hello");
self._deny_("".__eq((0)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{},$globals.StringTest)});
},
args: [],
source: "testEquality\x0a\x09self assert: 'hello' equals: 'hello'.\x0a\x09self deny: 'hello' = 'world'.\x0a\x09\x0a\x09\x22Test for issue 459\x22\x0a\x09self deny: 'hello' = (#() at: 1 ifAbsent: [ ]).\x0a\x0a\x09self assert: 'hello' equals: 'hello' yourself.\x0a\x09self assert: 'hello' yourself equals: 'hello'.\x0a\x0a\x09\x22test JS falsy value\x22\x0a\x09self deny: '' = 0",
referencedClasses: [],
messageSends: ["assert:equals:", "deny:", "=", "at:ifAbsent:", "yourself"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testIdentity",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3,$5;
$1="hello".__eq_eq("hello");
$ctx1.sendIdx["=="]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$2="hello".__eq_eq("world");
$ctx1.sendIdx["=="]=2;
self._deny_($2);
$ctx1.sendIdx["deny:"]=1;
$4="hello"._yourself();
$ctx1.sendIdx["yourself"]=1;
$3="hello".__eq_eq($4);
$ctx1.sendIdx["=="]=3;
self._assert_($3);
$ctx1.sendIdx["assert:"]=2;
$5=$recv("hello"._yourself()).__eq_eq("hello");
$ctx1.sendIdx["=="]=4;
self._assert_($5);
self._deny_("".__eq_eq((0)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIdentity",{},$globals.StringTest)});
},
args: [],
source: "testIdentity\x0a\x09self assert: 'hello' == 'hello'.\x0a\x09self deny: 'hello' == 'world'.\x0a\x0a\x09self assert: 'hello' == 'hello' yourself.\x0a\x09self assert: 'hello' yourself == 'hello'.\x0a\x0a\x09\x22test JS falsy value\x22\x0a\x09self deny: '' == 0",
referencedClasses: [],
messageSends: ["assert:", "==", "deny:", "yourself"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testIncludesSubString",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1="amber"._includesSubString_("ber");
$ctx1.sendIdx["includesSubString:"]=1;
self._assert_($1);
self._deny_("amber"._includesSubString_("zork"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIncludesSubString",{},$globals.StringTest)});
},
args: [],
source: "testIncludesSubString\x0a\x09self assert: ('amber' includesSubString: 'ber').\x0a\x09self deny: ('amber' includesSubString: 'zork').",
referencedClasses: [],
messageSends: ["assert:", "includesSubString:", "deny:"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testIndexOfStartingAtWithNull",
protocol: 'tests',
fn: function (){
var self=this;
return self;

},
args: [],
source: "testIndexOfStartingAtWithNull\x0a\x09\x22String cannot hold JS null\x22",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testIndexOfWithNull",
protocol: 'tests',
fn: function (){
var self=this;
return self;

},
args: [],
source: "testIndexOfWithNull\x0a\x09\x22String cannot hold JS null\x22",
referencedClasses: [],
messageSends: []
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testIsVowel",
protocol: 'tests',
fn: function (){
var self=this;
var vowel,consonant;
return $core.withContext(function($ctx1) {
var $1;
vowel="u";
consonant="z";
$1=$recv(vowel)._isVowel();
$ctx1.sendIdx["isVowel"]=1;
self._assert_equals_($1,true);
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_($recv(consonant)._isVowel(),false);
return self;
}, function($ctx1) {$ctx1.fill(self,"testIsVowel",{vowel:vowel,consonant:consonant},$globals.StringTest)});
},
args: [],
source: "testIsVowel\x0a    |vowel consonant|\x0a    vowel := 'u'.\x0a    consonant := 'z'.\x0a    self assert: vowel isVowel equals: true.\x0a    self assert: consonant isVowel equals: false",
referencedClasses: [],
messageSends: ["assert:equals:", "isVowel"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testJoin",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_(","._join_(["hello", "world"]),"hello,world");
return self;
}, function($ctx1) {$ctx1.fill(self,"testJoin",{},$globals.StringTest)});
},
args: [],
source: "testJoin\x0a\x09self assert: (',' join: #('hello' 'world')) equals: 'hello,world'",
referencedClasses: [],
messageSends: ["assert:equals:", "join:"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testRemoveAll",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._collection())._removeAll();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveAll",{},$globals.StringTest)});
},
args: [],
source: "testRemoveAll\x0a\x09self should: [ self collection removeAll ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "removeAll", "collection"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testReversed",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_("jackiechan"._reversed(),"nahceikcaj");
return self;
}, function($ctx1) {$ctx1.fill(self,"testReversed",{},$globals.StringTest)});
},
args: [],
source: "testReversed\x0a\x09self assert: 'jackiechan' reversed equals: 'nahceikcaj'.",
referencedClasses: [],
messageSends: ["assert:equals:", "reversed"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testStreamContents",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_($recv($globals.String)._streamContents_((function(aStream){
return $core.withContext(function($ctx2) {
$recv(aStream)._nextPutAll_("hello");
$ctx2.sendIdx["nextPutAll:"]=1;
$recv(aStream)._space();
return $recv(aStream)._nextPutAll_("world");
}, function($ctx2) {$ctx2.fillBlock({aStream:aStream},$ctx1,1)});
})),"hello world");
return self;
}, function($ctx1) {$ctx1.fill(self,"testStreamContents",{},$globals.StringTest)});
},
args: [],
source: "testStreamContents\x0a\x09self\x0a\x09\x09assert: (String streamContents: [ :aStream |\x0a\x09\x09\x09aStream\x0a\x09\x09\x09\x09nextPutAll: 'hello'; space;\x0a\x09\x09\x09\x09nextPutAll: 'world' ])\x0a\x09\x09equals: 'hello world'",
referencedClasses: ["String"],
messageSends: ["assert:equals:", "streamContents:", "nextPutAll:", "space"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testSubStrings",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_("jackiechan"._subStrings_("ie"),["jack", "chan"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSubStrings",{},$globals.StringTest)});
},
args: [],
source: "testSubStrings\x0a\x09self assert: ('jackiechan' subStrings: 'ie') equals: #( 'jack' 'chan' ).",
referencedClasses: [],
messageSends: ["assert:equals:", "subStrings:"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testTrim",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_("       jackie"._trimLeft(),"jackie");
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_("jackie               "._trimRight(),"jackie");
return self;
}, function($ctx1) {$ctx1.fill(self,"testTrim",{},$globals.StringTest)});
},
args: [],
source: "testTrim\x0a\x09self assert: '       jackie' trimLeft equals: 'jackie'.\x0a\x09self assert: 'jackie               ' trimRight equals: 'jackie'.",
referencedClasses: [],
messageSends: ["assert:equals:", "trimLeft", "trimRight"]
}),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testValue",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_("asString"._value_((1)),"1");
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_([(1), (2), (3)]._collect_("asString"),["1", "2", "3"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testValue",{},$globals.StringTest)});
},
args: [],
source: "testValue\x0a\x0a\x09self assert: (#asString value: 1) equals: '1'.\x0a\x0a\x09\x22Which (since String and BlockClosure are now polymorphic) enables the nice idiom...\x22\x0a\x09self assert: (#(1 2 3) collect: #asString) equals: #('1' '2' '3')",
referencedClasses: [],
messageSends: ["assert:equals:", "value:", "collect:"]
}),
$globals.StringTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'fixture',
fn: function (){
var self=this;
return $globals.String;

},
args: [],
source: "collectionClass\x0a\x09^ String",
referencedClasses: ["String"],
messageSends: []
}),
$globals.StringTest.klass);


$core.addClass('SetTest', $globals.CollectionTest, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "collection",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Set)._new();
$recv($1)._add_($globals.Smalltalk);
$ctx1.sendIdx["add:"]=1;
$recv($1)._add_(nil);
$ctx1.sendIdx["add:"]=2;
$recv($1)._add_((3).__at((3)));
$ctx1.sendIdx["add:"]=3;
$recv($1)._add_(false);
$ctx1.sendIdx["add:"]=4;
$recv($1)._add_(self["@sampleBlock"]);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collection",{},$globals.SetTest)});
},
args: [],
source: "collection\x0a\x09^ Set new\x0a\x09\x09add: Smalltalk;\x0a\x09\x09add: nil;\x0a\x09\x09add: 3@3;\x0a\x09\x09add: false;\x0a\x09\x09add: sampleBlock;\x0a\x09\x09yourself",
referencedClasses: ["Set", "Smalltalk"],
messageSends: ["add:", "new", "@", "yourself"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Set)._new();
$recv($1)._add_("a SmalltalkImage");
$ctx1.sendIdx["add:"]=1;
$recv($1)._add_("nil");
$ctx1.sendIdx["add:"]=2;
$recv($1)._add_("3@3");
$ctx1.sendIdx["add:"]=3;
$recv($1)._add_("false");
$ctx1.sendIdx["add:"]=4;
$recv($1)._add_("a BlockClosure");
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionOfPrintStrings",{},$globals.SetTest)});
},
args: [],
source: "collectionOfPrintStrings\x0a\x09^ Set new\x0a\x09\x09add: 'a SmalltalkImage';\x0a\x09\x09add: 'nil';\x0a\x09\x09add: '3@3';\x0a\x09\x09add: 'false';\x0a\x09\x09add: 'a BlockClosure';\x0a\x09\x09yourself",
referencedClasses: ["Set"],
messageSends: ["add:", "new", "yourself"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: 'fixture',
fn: function (){
var self=this;
return (5);

},
args: [],
source: "collectionSize\x0a\x09^ 5",
referencedClasses: [],
messageSends: []
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=self._collection();
$recv($1)._add_((0));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionWithDuplicates",{},$globals.SetTest)});
},
args: [],
source: "collectionWithDuplicates\x0a\x09\x22Set has no duplicates\x22\x0a\x09^ self collection add: 0; yourself",
referencedClasses: [],
messageSends: ["add:", "collection", "yourself"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: 'fixture',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Set)._new();
$recv($1)._add_($globals.Smalltalk);
$ctx1.sendIdx["add:"]=1;
$recv($1)._add_(nil);
$ctx1.sendIdx["add:"]=2;
$recv($1)._add_((3).__at((3)));
$ctx1.sendIdx["add:"]=3;
$recv($1)._add_("N");
$ctx1.sendIdx["add:"]=4;
$recv($1)._add_(false);
$ctx1.sendIdx["add:"]=5;
$recv($1)._add_(self["@sampleBlock"]);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionWithNewValue",{},$globals.SetTest)});
},
args: [],
source: "collectionWithNewValue\x0a\x09^ Set new\x0a\x09\x09add: Smalltalk;\x0a\x09\x09add: nil;\x0a\x09\x09add: 3@3;\x0a\x09\x09add: 'N';\x0a\x09\x09add: false;\x0a\x09\x09add: sampleBlock;\x0a\x09\x09yourself",
referencedClasses: ["Set", "Smalltalk"],
messageSends: ["add:", "new", "@", "yourself"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testAddAll",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$4,$1,$5,$7,$8,$9,$6,$10,$12,$11;
(
$ctx1.supercall = true,
($globals.SetTest.superclass||$boot.dnu).fn.prototype._testAddAll.apply($recv(self), []));
$ctx1.supercall = false;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$3=self._collection();
$ctx1.sendIdx["collection"]=2;
$recv($2)._addAll_($3);
$ctx1.sendIdx["addAll:"]=1;
$4=$recv($2)._yourself();
$ctx1.sendIdx["yourself"]=1;
$1=$4;
$5=self._collection();
$ctx1.sendIdx["collection"]=3;
self._assert_equals_($1,$5);
$ctx1.sendIdx["assert:equals:"]=1;
$7=self._collection();
$ctx1.sendIdx["collection"]=4;
$8=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=1;
$recv($7)._addAll_($8);
$ctx1.sendIdx["addAll:"]=2;
$9=$recv($7)._yourself();
$ctx1.sendIdx["yourself"]=2;
$6=$9;
$10=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=2;
self._assert_equals_($6,$10);
$ctx1.sendIdx["assert:equals:"]=2;
$12=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=3;
$recv($12)._addAll_(self._collection());
$11=$recv($12)._yourself();
self._assert_equals_($11,self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddAll",{},$globals.SetTest)});
},
args: [],
source: "testAddAll\x0a\x09super testAddAll.\x0a\x09self assert: (self collection addAll: self collection; yourself) equals: self collection.\x0a\x09self assert: (self collection addAll: self collectionWithNewValue; yourself) equals: self collectionWithNewValue.\x0a\x09self assert: (self collectionWithNewValue addAll: self collection; yourself) equals: self collectionWithNewValue",
referencedClasses: [],
messageSends: ["testAddAll", "assert:equals:", "addAll:", "collection", "yourself", "collectionWithNewValue"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testAddRemove",
protocol: 'tests',
fn: function (){
var self=this;
var set;
return $core.withContext(function($ctx1) {
var $1,$2;
set=$recv($globals.Set)._new();
self._assert_($recv(set)._isEmpty());
$ctx1.sendIdx["assert:"]=1;
$recv(set)._add_((3));
$ctx1.sendIdx["add:"]=1;
$1=$recv(set)._includes_((3));
$ctx1.sendIdx["includes:"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=2;
$recv(set)._add_((5));
$2=$recv(set)._includes_((5));
$ctx1.sendIdx["includes:"]=2;
self._assert_($2);
$recv(set)._remove_((3));
self._deny_($recv(set)._includes_((3)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddRemove",{set:set},$globals.SetTest)});
},
args: [],
source: "testAddRemove\x0a\x09| set |\x0a\x09set := Set new.\x0a\x09\x0a\x09self assert: set isEmpty.\x0a\x0a\x09set add: 3.\x0a\x09self assert: (set includes: 3).\x0a\x0a\x09set add: 5.\x0a\x09self assert: (set includes: 5).\x0a\x0a\x09set remove: 3.\x0a\x09self deny: (set includes: 3)",
referencedClasses: ["Set"],
messageSends: ["new", "assert:", "isEmpty", "add:", "includes:", "remove:", "deny:"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testAt",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.Set)._new())._at_put_((1),(2));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAt",{},$globals.SetTest)});
},
args: [],
source: "testAt\x0a\x09self should: [ Set new at: 1 put: 2 ] raise: Error",
referencedClasses: ["Set", "Error"],
messageSends: ["should:raise:", "at:put:", "new"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testCollect",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
(
$ctx1.supercall = true,
($globals.SetTest.superclass||$boot.dnu).fn.prototype._testCollect.apply($recv(self), []));
$ctx1.supercall = false;
$2=[(5), (6), (8)]._asSet();
$ctx1.sendIdx["asSet"]=1;
$1=$recv($2)._collect_((function(x){
return $core.withContext(function($ctx2) {
return $recv(x).__backslash_backslash((3));
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
}));
self._assert_equals_($1,[(0), (2)]._asSet());
return self;
}, function($ctx1) {$ctx1.fill(self,"testCollect",{},$globals.SetTest)});
},
args: [],
source: "testCollect\x0a\x09super testCollect.\x0a\x09self assert: (#(5 6 8) asSet collect: [ :x | x \x5c\x5c 3 ]) equals: #(0 2) asSet",
referencedClasses: [],
messageSends: ["testCollect", "assert:equals:", "collect:", "asSet", "\x5c\x5c"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testComma",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$4,$6,$7,$5,$8,$10,$9;
(
$ctx1.supercall = true,
($globals.SetTest.superclass||$boot.dnu).fn.prototype._testComma.apply($recv(self), []));
$ctx1.supercall = false;
$2=self._collection();
$ctx1.sendIdx["collection"]=1;
$3=self._collection();
$ctx1.sendIdx["collection"]=2;
$1=$recv($2).__comma($3);
$ctx1.sendIdx[","]=1;
$4=self._collection();
$ctx1.sendIdx["collection"]=3;
self._assert_equals_($1,$4);
$ctx1.sendIdx["assert:equals:"]=1;
$6=self._collection();
$ctx1.sendIdx["collection"]=4;
$7=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=1;
$5=$recv($6).__comma($7);
$ctx1.sendIdx[","]=2;
$8=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=2;
self._assert_equals_($5,$8);
$ctx1.sendIdx["assert:equals:"]=2;
$10=self._collectionWithNewValue();
$ctx1.sendIdx["collectionWithNewValue"]=3;
$9=$recv($10).__comma(self._collection());
self._assert_equals_($9,self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testComma",{},$globals.SetTest)});
},
args: [],
source: "testComma\x0a\x09super testComma.\x0a\x09self assert: self collection, self collection equals: self collection.\x0a\x09self assert: self collection, self collectionWithNewValue equals: self collectionWithNewValue.\x0a\x09self assert: self collectionWithNewValue, self collection equals: self collectionWithNewValue",
referencedClasses: [],
messageSends: ["testComma", "assert:equals:", ",", "collection", "collectionWithNewValue"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testComparing",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$6,$7,$5,$9,$8;
$1=[(0), (2)]._asSet();
$ctx1.sendIdx["asSet"]=1;
$2=[(0), (2)]._asSet();
$ctx1.sendIdx["asSet"]=2;
self._assert_equals_($1,$2);
$ctx1.sendIdx["assert:equals:"]=1;
$3=[(2), (0)]._asSet();
$ctx1.sendIdx["asSet"]=3;
$4=[(0), (2)]._asSet();
$ctx1.sendIdx["asSet"]=4;
self._assert_equals_($3,$4);
$6=[(0), (2), (3)]._asSet();
$ctx1.sendIdx["asSet"]=5;
$7=[(0), (2)]._asSet();
$ctx1.sendIdx["asSet"]=6;
$5=$recv($6).__eq($7);
$ctx1.sendIdx["="]=1;
self._deny_($5);
$ctx1.sendIdx["deny:"]=1;
$9=[(1), (2)]._asSet();
$ctx1.sendIdx["asSet"]=7;
$8=$recv($9).__eq([(0), (2)]._asSet());
self._deny_($8);
return self;
}, function($ctx1) {$ctx1.fill(self,"testComparing",{},$globals.SetTest)});
},
args: [],
source: "testComparing\x0a\x09self assert: #(0 2) asSet equals: #(0 2) asSet.\x0a\x09self assert: #(2 0) asSet equals: #(0 2) asSet.\x0a\x09self deny: #(0 2 3) asSet = #(0 2) asSet.\x0a\x09self deny: #(1 2) asSet = #(0 2) asSet",
referencedClasses: [],
messageSends: ["assert:equals:", "asSet", "deny:", "="]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testPrintString",
protocol: 'tests',
fn: function (){
var self=this;
var set;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$8;
set=$recv($globals.Set)._new();
$1=$recv(set)._printString();
$ctx1.sendIdx["printString"]=1;
self._assert_equals_($1,"a Set ()");
$ctx1.sendIdx["assert:equals:"]=1;
$2=set;
$recv($2)._add_((1));
$ctx1.sendIdx["add:"]=1;
$3=$recv($2)._add_((3));
$ctx1.sendIdx["add:"]=2;
$4=$recv(set)._printString();
$ctx1.sendIdx["printString"]=2;
self._assert_equals_($4,"a Set (1 3)");
$ctx1.sendIdx["assert:equals:"]=2;
$recv(set)._add_("foo");
$ctx1.sendIdx["add:"]=3;
$5=$recv(set)._printString();
$ctx1.sendIdx["printString"]=3;
self._assert_equals_($5,"a Set (1 3 'foo')");
$ctx1.sendIdx["assert:equals:"]=3;
$6=set;
$recv($6)._remove_((1));
$ctx1.sendIdx["remove:"]=1;
$recv($6)._remove_((3));
$7=$recv(set)._printString();
$ctx1.sendIdx["printString"]=4;
self._assert_equals_($7,"a Set ('foo')");
$ctx1.sendIdx["assert:equals:"]=4;
$recv(set)._add_((3));
$ctx1.sendIdx["add:"]=4;
$8=$recv(set)._printString();
$ctx1.sendIdx["printString"]=5;
self._assert_equals_($8,"a Set (3 'foo')");
$ctx1.sendIdx["assert:equals:"]=5;
$recv(set)._add_((3));
self._assert_equals_($recv(set)._printString(),"a Set (3 'foo')");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrintString",{set:set},$globals.SetTest)});
},
args: [],
source: "testPrintString\x0a\x09| set |\x0a\x09set := Set new.\x0a\x09self assert: set printString equals: 'a Set ()'.\x0a\x09set add: 1; add: 3.\x0a\x09self assert: set printString equals: 'a Set (1 3)'.\x0a\x09set add: 'foo'.\x0a\x09self assert: set printString equals: 'a Set (1 3 ''foo'')'.\x0a\x09set remove: 1; remove: 3.\x0a\x09self assert: set printString equals: 'a Set (''foo'')'.\x0a\x09set add: 3.\x0a\x09self assert: set printString equals: 'a Set (3 ''foo'')'.\x0a\x09set add: 3.\x0a\x09self assert: set printString equals: 'a Set (3 ''foo'')'",
referencedClasses: ["Set"],
messageSends: ["new", "assert:equals:", "printString", "add:", "remove:"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testUnboxedObjects",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $4,$3,$2,$1;
$4="foo"._yourself();
$ctx1.sendIdx["yourself"]=1;
$3=[$4,"foo"._yourself()];
$2=$recv($3)._asSet();
$1=$recv($2)._asArray();
self._assert_equals_($1,["foo"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnboxedObjects",{},$globals.SetTest)});
},
args: [],
source: "testUnboxedObjects\x0a\x09self assert: {'foo' yourself. 'foo' yourself} asSet asArray equals: #('foo')",
referencedClasses: [],
messageSends: ["assert:equals:", "asArray", "asSet", "yourself"]
}),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testUnicity",
protocol: 'tests',
fn: function (){
var self=this;
var set;
return $core.withContext(function($ctx1) {
var $1;
set=$recv($globals.Set)._new();
$recv(set)._add_((21));
$ctx1.sendIdx["add:"]=1;
$recv(set)._add_("hello");
$ctx1.sendIdx["add:"]=2;
$recv(set)._add_((21));
$ctx1.sendIdx["add:"]=3;
$1=$recv(set)._size();
$ctx1.sendIdx["size"]=1;
self._assert_equals_($1,(2));
$ctx1.sendIdx["assert:equals:"]=1;
$recv(set)._add_("hello");
self._assert_equals_($recv(set)._size(),(2));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_($recv(set)._asArray(),[(21), "hello"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnicity",{set:set},$globals.SetTest)});
},
args: [],
source: "testUnicity\x0a\x09| set |\x0a\x09set := Set new.\x0a\x09set add: 21.\x0a\x09set add: 'hello'.\x0a\x0a\x09set add: 21.\x0a\x09self assert: set size equals: 2.\x0a\x09\x0a\x09set add: 'hello'.\x0a\x09self assert: set size equals: 2.\x0a\x0a\x09self assert: set asArray equals: #(21 'hello')",
referencedClasses: ["Set"],
messageSends: ["new", "add:", "assert:equals:", "size", "asArray"]
}),
$globals.SetTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'fixture',
fn: function (){
var self=this;
return $globals.Set;

},
args: [],
source: "collectionClass\x0a\x09^ Set",
referencedClasses: ["Set"],
messageSends: []
}),
$globals.SetTest.klass);


$core.addClass('ConsoleTranscriptTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testShow",
protocol: 'tests',
fn: function (){
var self=this;
var originalTranscript;
return $core.withContext(function($ctx1) {
originalTranscript=$recv($globals.Transcript)._current();
$recv($globals.Transcript)._register_($recv($globals.ConsoleTranscript)._new());
$ctx1.sendIdx["register:"]=1;
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Transcript)._show_("Hello console!");
$ctx2.sendIdx["show:"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$ctx1.sendIdx["shouldnt:raise:"]=1;
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Transcript)._show_(console);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
$recv($globals.Transcript)._register_(originalTranscript);
return self;
}, function($ctx1) {$ctx1.fill(self,"testShow",{originalTranscript:originalTranscript},$globals.ConsoleTranscriptTest)});
},
args: [],
source: "testShow\x0a| originalTranscript |\x0aoriginalTranscript := Transcript current.\x0aTranscript register: ConsoleTranscript new.\x0a\x0aself shouldnt: [ Transcript show: 'Hello console!' ] raise: Error.\x0aself shouldnt: [ Transcript show: console ] raise: Error.\x0a\x0aTranscript register: originalTranscript.",
referencedClasses: ["Transcript", "ConsoleTranscript", "Error"],
messageSends: ["current", "register:", "new", "shouldnt:raise:", "show:"]
}),
$globals.ConsoleTranscriptTest);



$core.addClass('DateTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testEquality",
protocol: 'tests',
fn: function (){
var self=this;
var now;
return $core.withContext(function($ctx1) {
var $1,$3,$4,$2,$6,$7,$5,$9,$11,$10,$8;
now=$recv($globals.Date)._new();
$1=$recv(now).__eq(now);
$ctx1.sendIdx["="]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$3=now;
$4=$recv($globals.Date)._fromMilliseconds_((0));
$ctx1.sendIdx["fromMilliseconds:"]=1;
$2=$recv($3).__eq($4);
$ctx1.sendIdx["="]=2;
self._deny_($2);
$6=$recv($globals.Date)._fromMilliseconds_((12345678));
$ctx1.sendIdx["fromMilliseconds:"]=2;
$7=$recv($globals.Date)._fromMilliseconds_((12345678));
$ctx1.sendIdx["fromMilliseconds:"]=3;
$5=$recv($6).__eq($7);
$ctx1.sendIdx["="]=3;
self._assert_($5);
$ctx1.sendIdx["assert:"]=2;
$9=now;
$11=$recv(now)._asMilliseconds();
$ctx1.sendIdx["asMilliseconds"]=1;
$10=$recv($globals.Date)._fromMilliseconds_($11);
$ctx1.sendIdx["fromMilliseconds:"]=4;
$8=$recv($9).__eq($10);
$ctx1.sendIdx["="]=4;
self._assert_($8);
$ctx1.sendIdx["assert:"]=3;
self._assert_($recv($recv($globals.Date)._fromMilliseconds_($recv(now)._asMilliseconds())).__eq(now));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{now:now},$globals.DateTest)});
},
args: [],
source: "testEquality\x0a\x09| now |\x0a\x09now := Date new.\x0a\x0a\x09self assert: now = now.\x0a\x0a\x09self deny: now = (Date fromMilliseconds: 0).\x0a\x0a\x09self assert: (Date fromMilliseconds: 12345678) = (Date fromMilliseconds: 12345678).\x0a\x09self assert: now = (Date fromMilliseconds: now asMilliseconds).\x0a\x09self assert: (Date fromMilliseconds: now asMilliseconds) = now",
referencedClasses: ["Date"],
messageSends: ["new", "assert:", "=", "deny:", "fromMilliseconds:", "asMilliseconds"]
}),
$globals.DateTest);

$core.addMethod(
$core.method({
selector: "testIdentity",
protocol: 'tests',
fn: function (){
var self=this;
var now;
return $core.withContext(function($ctx1) {
var $1,$3,$4,$2,$6,$7,$5,$9,$11,$10,$8;
now=$recv($globals.Date)._new();
$1=$recv(now).__eq_eq(now);
$ctx1.sendIdx["=="]=1;
self._assert_($1);
$3=now;
$4=$recv($globals.Date)._fromMilliseconds_((0));
$ctx1.sendIdx["fromMilliseconds:"]=1;
$2=$recv($3).__eq_eq($4);
$ctx1.sendIdx["=="]=2;
self._deny_($2);
$ctx1.sendIdx["deny:"]=1;
$6=$recv($globals.Date)._fromMilliseconds_((12345678));
$ctx1.sendIdx["fromMilliseconds:"]=2;
$7=$recv($globals.Date)._fromMilliseconds_((12345678));
$ctx1.sendIdx["fromMilliseconds:"]=3;
$5=$recv($6).__eq_eq($7);
$ctx1.sendIdx["=="]=3;
self._deny_($5);
$ctx1.sendIdx["deny:"]=2;
$9=now;
$11=$recv(now)._asMilliseconds();
$ctx1.sendIdx["asMilliseconds"]=1;
$10=$recv($globals.Date)._fromMilliseconds_($11);
$ctx1.sendIdx["fromMilliseconds:"]=4;
$8=$recv($9).__eq_eq($10);
$ctx1.sendIdx["=="]=4;
self._deny_($8);
$ctx1.sendIdx["deny:"]=3;
self._deny_($recv($recv($globals.Date)._fromMilliseconds_($recv(now)._asMilliseconds())).__eq_eq(now));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIdentity",{now:now},$globals.DateTest)});
},
args: [],
source: "testIdentity\x0a\x09| now |\x0a\x09now := Date new.\x0a\x0a\x09self assert: now == now.\x0a\x0a\x09self deny: now == (Date fromMilliseconds: 0).\x0a\x0a\x09self deny: (Date fromMilliseconds: 12345678) == (Date fromMilliseconds: 12345678).\x0a\x09self deny: now == (Date fromMilliseconds: now asMilliseconds).\x0a\x09self deny: (Date fromMilliseconds: now asMilliseconds) == now",
referencedClasses: ["Date"],
messageSends: ["new", "assert:", "==", "deny:", "fromMilliseconds:", "asMilliseconds"]
}),
$globals.DateTest);



$core.addClass('JSObjectProxyTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "jsNull",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return null;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsNull",{},$globals.JSObjectProxyTest)});
},
args: [],
source: "jsNull\x0a\x09<return null>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "jsObject",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return {a: 1, b: function() {return 2;}, c: function(object) {return object;}, d: '', 'e': null, 'f': void 0};
return self;
}, function($ctx1) {$ctx1.fill(self,"jsObject",{},$globals.JSObjectProxyTest)});
},
args: [],
source: "jsObject\x0a\x09<return {a: 1, b: function() {return 2;}, c: function(object) {return object;}, d: '', 'e': null, 'f': void 0}>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "jsUndefined",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsUndefined",{},$globals.JSObjectProxyTest)});
},
args: [],
source: "jsUndefined\x0a\x09<return>",
referencedClasses: [],
messageSends: []
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testAtIfAbsent",
protocol: 'tests',
fn: function (){
var self=this;
var testObject;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
testObject=self._jsObject();
$1=$recv(testObject)._at_ifAbsent_("abc",(function(){
return "Property does not exist";

}));
$ctx1.sendIdx["at:ifAbsent:"]=1;
self._assert_equals_($1,"Property does not exist");
$ctx1.sendIdx["assert:equals:"]=1;
$2=$recv(testObject)._at_ifAbsent_("e",(function(){
return "Property does not exist";

}));
$ctx1.sendIdx["at:ifAbsent:"]=2;
self._assert_equals_($2,nil);
$ctx1.sendIdx["assert:equals:"]=2;
$3=$recv(testObject)._at_ifAbsent_("a",(function(){
return "Property does not exist";

}));
$ctx1.sendIdx["at:ifAbsent:"]=3;
self._assert_equals_($3,(1));
$ctx1.sendIdx["assert:equals:"]=3;
self._assert_equals_($recv(testObject)._at_ifAbsent_("f",(function(){
return "Property does not exist";

})),nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfAbsent",{testObject:testObject},$globals.JSObjectProxyTest)});
},
args: [],
source: "testAtIfAbsent\x0a\x09| testObject |\x0a\x09testObject := self jsObject.\x0a\x09self assert: (testObject at: 'abc' ifAbsent: [ 'Property does not exist' ]) equals: 'Property does not exist'.\x0a\x09self assert: (testObject at: 'e' ifAbsent: [ 'Property does not exist' ]) equals: nil.\x0a\x09self assert: (testObject at: 'a' ifAbsent: [ 'Property does not exist' ]) equals: 1.\x0a\x09self assert: (testObject at: 'f' ifAbsent: [ 'Property does not exist' ]) equals: nil.",
referencedClasses: [],
messageSends: ["jsObject", "assert:equals:", "at:ifAbsent:"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testAtIfPresent",
protocol: 'tests',
fn: function (){
var self=this;
var testObject;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$6,$5;
testObject=self._jsObject();
$1=$recv(testObject)._at_ifPresent_("abc",(function(x){
return $core.withContext(function($ctx2) {
$2=$recv(x)._asString();
$ctx2.sendIdx["asString"]=1;
return "hello ".__comma($2);
$ctx2.sendIdx[","]=1;
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
}));
$ctx1.sendIdx["at:ifPresent:"]=1;
self._assert_equals_($1,nil);
$ctx1.sendIdx["assert:equals:"]=1;
$3=$recv(testObject)._at_ifPresent_("e",(function(x){
return $core.withContext(function($ctx2) {
$4=$recv(x)._asString();
$ctx2.sendIdx["asString"]=2;
return "hello ".__comma($4);
$ctx2.sendIdx[","]=2;
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,2)});
}));
$ctx1.sendIdx["at:ifPresent:"]=2;
self._assert_equals_($3,"hello nil");
$ctx1.sendIdx["assert:equals:"]=2;
$5=$recv(testObject)._at_ifPresent_("a",(function(x){
return $core.withContext(function($ctx2) {
$6=$recv(x)._asString();
$ctx2.sendIdx["asString"]=3;
return "hello ".__comma($6);
$ctx2.sendIdx[","]=3;
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,3)});
}));
$ctx1.sendIdx["at:ifPresent:"]=3;
self._assert_equals_($5,"hello 1");
$ctx1.sendIdx["assert:equals:"]=3;
self._assert_equals_($recv(testObject)._at_ifPresent_("f",(function(x){
return $core.withContext(function($ctx2) {
return "hello ".__comma($recv(x)._asString());
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,4)});
})),"hello nil");
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfPresent",{testObject:testObject},$globals.JSObjectProxyTest)});
},
args: [],
source: "testAtIfPresent\x0a\x09| testObject |\x0a\x09\x0a\x09testObject := self jsObject.\x0a\x09\x0a\x09self assert: (testObject at: 'abc' ifPresent: [ :x | 'hello ',x asString ]) equals: nil.\x0a\x09self assert: (testObject at: 'e' ifPresent: [ :x | 'hello ',x asString ]) equals: 'hello nil'.\x0a\x09self assert: (testObject at: 'a' ifPresent: [ :x | 'hello ',x asString ]) equals: 'hello 1'.\x0a\x09self assert: (testObject at: 'f' ifPresent: [ :x | 'hello ',x asString ]) equals: 'hello nil'.",
referencedClasses: [],
messageSends: ["jsObject", "assert:equals:", "at:ifPresent:", ",", "asString"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testAtIfPresentIfAbsent",
protocol: 'tests',
fn: function (){
var self=this;
var testObject;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$6,$5;
testObject=self._jsObject();
$1=$recv(testObject)._at_ifPresent_ifAbsent_("abc",(function(x){
return $core.withContext(function($ctx2) {
$2=$recv(x)._asString();
$ctx2.sendIdx["asString"]=1;
return "hello ".__comma($2);
$ctx2.sendIdx[","]=1;
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
}),(function(){
return "not present";

}));
$ctx1.sendIdx["at:ifPresent:ifAbsent:"]=1;
self._assert_equals_($1,"not present");
$ctx1.sendIdx["assert:equals:"]=1;
$3=$recv(testObject)._at_ifPresent_ifAbsent_("e",(function(x){
return $core.withContext(function($ctx2) {
$4=$recv(x)._asString();
$ctx2.sendIdx["asString"]=2;
return "hello ".__comma($4);
$ctx2.sendIdx[","]=2;
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,3)});
}),(function(){
return "not present";

}));
$ctx1.sendIdx["at:ifPresent:ifAbsent:"]=2;
self._assert_equals_($3,"hello nil");
$ctx1.sendIdx["assert:equals:"]=2;
$5=$recv(testObject)._at_ifPresent_ifAbsent_("a",(function(x){
return $core.withContext(function($ctx2) {
$6=$recv(x)._asString();
$ctx2.sendIdx["asString"]=3;
return "hello ".__comma($6);
$ctx2.sendIdx[","]=3;
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,5)});
}),(function(){
return "not present";

}));
$ctx1.sendIdx["at:ifPresent:ifAbsent:"]=3;
self._assert_equals_($5,"hello 1");
$ctx1.sendIdx["assert:equals:"]=3;
self._assert_equals_($recv(testObject)._at_ifPresent_ifAbsent_("f",(function(x){
return $core.withContext(function($ctx2) {
return "hello ".__comma($recv(x)._asString());
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,7)});
}),(function(){
return "not present";

})),"hello nil");
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfPresentIfAbsent",{testObject:testObject},$globals.JSObjectProxyTest)});
},
args: [],
source: "testAtIfPresentIfAbsent\x0a\x09| testObject |\x0a\x09testObject := self jsObject.\x0a\x09self assert: (testObject at: 'abc' ifPresent: [ :x|'hello ',x asString ] ifAbsent: [ 'not present' ]) equals: 'not present'.\x0a\x09self assert: (testObject at: 'e' ifPresent: [ :x|'hello ',x asString ] ifAbsent: [ 'not present' ]) equals: 'hello nil'.\x0a\x09self assert: (testObject at: 'a' ifPresent: [ :x|'hello ',x asString ] ifAbsent: [ 'not present' ]) equals: 'hello 1'.\x0a\x09self assert: (testObject at: 'f' ifPresent: [ :x|'hello ',x asString ] ifAbsent: [ 'not present' ]) equals: 'hello nil'.",
referencedClasses: [],
messageSends: ["jsObject", "assert:equals:", "at:ifPresent:ifAbsent:", ",", "asString"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testAtPut",
protocol: 'tests',
fn: function (){
var self=this;
var testObject;
return $core.withContext(function($ctx1) {
var $2,$1;
testObject=self._jsObject();
$2=$recv(testObject)._at_("abc");
$ctx1.sendIdx["at:"]=1;
$1=$recv($2).__tild_eq("xyz");
self._assert_($1);
self._assert_equals_($recv(testObject)._at_put_("abc","xyz"),"xyz");
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_($recv(testObject)._at_("abc"),"xyz");
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtPut",{testObject:testObject},$globals.JSObjectProxyTest)});
},
args: [],
source: "testAtPut\x0a\x09| testObject |\x0a\x09testObject := self jsObject.\x0a\x09\x0a\x09self assert: (testObject at: 'abc') ~= 'xyz'.\x0a\x09self assert: (testObject at: 'abc' put: 'xyz') equals: 'xyz'.\x0a\x09self assert: (testObject at: 'abc') equals: 'xyz'",
referencedClasses: [],
messageSends: ["jsObject", "assert:", "~=", "at:", "assert:equals:", "at:put:"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testComparison",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
self._assert_equals_($recv([console,(2)])._indexOf_(console),(1));
$1=$recv(console).__eq(console);
$ctx1.sendIdx["="]=1;
self._assert_($1);
$2=$recv(console).__eq($recv($globals.Object)._new());
$ctx1.sendIdx["="]=2;
self._deny_($2);
$ctx1.sendIdx["deny:"]=1;
self._deny_($recv(console).__eq(self._jsObject()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testComparison",{},$globals.JSObjectProxyTest)});
},
args: [],
source: "testComparison\x0a\x09self assert: ({ console. 2 } indexOf: console) equals: 1.\x0a\x09self assert: console = console.\x0a\x09self deny: console = Object new.\x0a\x09self deny: console = self jsObject",
referencedClasses: ["Object"],
messageSends: ["assert:equals:", "indexOf:", "assert:", "=", "deny:", "new", "jsObject"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testDNU",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self._jsObject())._foo();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDNU",{},$globals.JSObjectProxyTest)});
},
args: [],
source: "testDNU\x0a\x09self should: [ self jsObject foo ] raise: MessageNotUnderstood",
referencedClasses: ["MessageNotUnderstood"],
messageSends: ["should:raise:", "foo", "jsObject"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testDNURegression1057",
protocol: 'tests',
fn: function (){
var self=this;
var jsObject;
return $core.withContext(function($ctx1) {
var $1;
jsObject=[];
$recv(jsObject)._basicAt_put_("allowJavaScriptCalls",true);
$ctx1.sendIdx["basicAt:put:"]=1;
$recv(jsObject)._basicAt_put_("foo",(3));
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(jsObject)._foo();
$ctx2.sendIdx["foo"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$ctx1.sendIdx["shouldnt:raise:"]=1;
$1=$recv(jsObject)._foo();
$ctx1.sendIdx["foo"]=2;
self._assert_equals_($1,(3));
$ctx1.sendIdx["assert:equals:"]=1;
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(jsObject)._foo_((4));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
self._assert_equals_($recv(jsObject)._foo(),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDNURegression1057",{jsObject:jsObject},$globals.JSObjectProxyTest)});
},
args: [],
source: "testDNURegression1057\x0a\x09| jsObject |\x0a\x09jsObject := #().\x0a\x09jsObject basicAt: 'allowJavaScriptCalls' put: true.\x0a\x09jsObject basicAt: 'foo' put: 3.\x0a\x09self shouldnt: [ jsObject foo ] raise: Error.\x0a\x09self assert: jsObject foo equals: 3.\x0a\x09self shouldnt: [ jsObject foo: 4 ] raise: Error.\x0a\x09self assert: jsObject foo equals: 4",
referencedClasses: ["Error"],
messageSends: ["basicAt:put:", "shouldnt:raise:", "foo", "assert:equals:", "foo:"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testDNURegression1059",
protocol: 'tests',
fn: function (){
var self=this;
var jsObject;
return $core.withContext(function($ctx1) {
jsObject=[];
$recv(jsObject)._basicAt_put_("allowJavaScriptCalls",true);
$ctx1.sendIdx["basicAt:put:"]=1;
$recv(jsObject)._basicAt_put_("x",(3));
$ctx1.sendIdx["basicAt:put:"]=2;
$recv(jsObject)._basicAt_put_("x:",(function(){
return $core.withContext(function($ctx2) {
return self._error();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(jsObject)._x_((4));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
self._assert_equals_($recv(jsObject)._x(),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDNURegression1059",{jsObject:jsObject},$globals.JSObjectProxyTest)});
},
args: [],
source: "testDNURegression1059\x0a\x09| jsObject |\x0a\x09jsObject := #().\x0a\x09jsObject basicAt: 'allowJavaScriptCalls' put: true.\x0a\x09jsObject basicAt: 'x' put: 3.\x0a\x09jsObject basicAt: 'x:' put: [ self error ].\x0a\x09self shouldnt: [ jsObject x: 4 ] raise: Error.\x0a\x09self assert: jsObject x equals: 4",
referencedClasses: ["Error"],
messageSends: ["basicAt:put:", "error", "shouldnt:raise:", "x:", "assert:equals:", "x"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testDNURegression1062",
protocol: 'tests',
fn: function (){
var self=this;
var jsObject,stored;
return $core.withContext(function($ctx1) {
jsObject=[];
$recv(jsObject)._basicAt_put_("allowJavaScriptCalls",true);
$ctx1.sendIdx["basicAt:put:"]=1;
$recv(jsObject)._basicAt_put_("x",(function(v){
stored=v;
return stored;

}));
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(jsObject)._x_((4));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
self._assert_equals_(stored,(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDNURegression1062",{jsObject:jsObject,stored:stored},$globals.JSObjectProxyTest)});
},
args: [],
source: "testDNURegression1062\x0a\x09| jsObject stored |\x0a\x09jsObject := #().\x0a\x09jsObject basicAt: 'allowJavaScriptCalls' put: true.\x0a\x09jsObject basicAt: 'x' put: [ :v | stored := v ].\x0a\x09self shouldnt: [ jsObject x: 4 ] raise: Error.\x0a\x09self assert: stored equals: 4",
referencedClasses: ["Error"],
messageSends: ["basicAt:put:", "shouldnt:raise:", "x:", "assert:equals:"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testDNUWithAllowJavaScriptCalls",
protocol: 'tests',
fn: function (){
var self=this;
var jsObject;
return $core.withContext(function($ctx1) {
jsObject=[];
$recv(jsObject)._basicAt_put_("allowJavaScriptCalls",true);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(jsObject)._foo();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDNUWithAllowJavaScriptCalls",{jsObject:jsObject},$globals.JSObjectProxyTest)});
},
args: [],
source: "testDNUWithAllowJavaScriptCalls\x0a\x09| jsObject |\x0a\x09jsObject := #().\x0a\x09jsObject basicAt: 'allowJavaScriptCalls' put: true.\x0a\x09self should: [ jsObject foo ] raise: MessageNotUnderstood",
referencedClasses: ["MessageNotUnderstood"],
messageSends: ["basicAt:put:", "should:raise:", "foo"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testMessageSend",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3;
$2=self._jsObject();
$ctx1.sendIdx["jsObject"]=1;
$1=$recv($2)._a();
self._assert_equals_($1,(1));
$ctx1.sendIdx["assert:equals:"]=1;
$4=self._jsObject();
$ctx1.sendIdx["jsObject"]=2;
$3=$recv($4)._b();
self._assert_equals_($3,(2));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_($recv(self._jsObject())._c_((3)),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testMessageSend",{},$globals.JSObjectProxyTest)});
},
args: [],
source: "testMessageSend\x0a\x0a\x09self assert: self jsObject a equals: 1.\x0a\x09self assert: self jsObject b equals: 2.\x0a\x09self assert: (self jsObject c: 3) equals: 3",
referencedClasses: [],
messageSends: ["assert:equals:", "a", "jsObject", "b", "c:"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testMethodWithArguments",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_($recv(self._jsObject())._c_((1)),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testMethodWithArguments",{},$globals.JSObjectProxyTest)});
},
args: [],
source: "testMethodWithArguments\x0a\x09self assert: (self jsObject c: 1) equals: 1",
referencedClasses: [],
messageSends: ["assert:equals:", "c:", "jsObject"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testPrinting",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_($recv(self._jsObject())._printString(),"[object Object]");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrinting",{},$globals.JSObjectProxyTest)});
},
args: [],
source: "testPrinting\x0a\x09self assert: self jsObject printString equals: '[object Object]'",
referencedClasses: [],
messageSends: ["assert:equals:", "printString", "jsObject"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testPropertyThatReturnsEmptyString",
protocol: 'tests',
fn: function (){
var self=this;
var object;
return $core.withContext(function($ctx1) {
var $1;
object=self._jsObject();
$1=$recv(object)._d();
$ctx1.sendIdx["d"]=1;
self._assert_equals_($1,"");
$ctx1.sendIdx["assert:equals:"]=1;
$recv(object)._d_("hello");
self._assert_equals_($recv(object)._d(),"hello");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPropertyThatReturnsEmptyString",{object:object},$globals.JSObjectProxyTest)});
},
args: [],
source: "testPropertyThatReturnsEmptyString\x0a\x09| object |\x0a\x0a\x09object := self jsObject.\x0a\x09self assert: object d equals: ''.\x0a\x0a\x09object d: 'hello'.\x0a\x09self assert: object d equals: 'hello'",
referencedClasses: [],
messageSends: ["jsObject", "assert:equals:", "d", "d:"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testPropertyThatReturnsUndefined",
protocol: 'tests',
fn: function (){
var self=this;
var object;
return $core.withContext(function($ctx1) {
object=self._jsObject();
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(object)._e();
$ctx2.sendIdx["e"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
self._assert_($recv($recv(object)._e())._isNil());
return self;
}, function($ctx1) {$ctx1.fill(self,"testPropertyThatReturnsUndefined",{object:object},$globals.JSObjectProxyTest)});
},
args: [],
source: "testPropertyThatReturnsUndefined\x0a\x09| object |\x0a\x0a\x09object := self jsObject.\x0a\x09self shouldnt: [ object e ] raise: MessageNotUnderstood.\x0a\x09self assert: object e isNil",
referencedClasses: ["MessageNotUnderstood"],
messageSends: ["jsObject", "shouldnt:raise:", "e", "assert:", "isNil"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testSetPropertyWithFalsyValue",
protocol: 'tests',
fn: function (){
var self=this;
var jsObject;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5;
jsObject=self._jsObject();
$1=$recv(jsObject)._a();
$ctx1.sendIdx["a"]=1;
self._assert_equals_($1,(1));
$ctx1.sendIdx["assert:equals:"]=1;
$recv(jsObject)._a_(self._jsNull());
$ctx1.sendIdx["a:"]=1;
$2=$recv(jsObject)._a();
$ctx1.sendIdx["a"]=2;
self._assert_equals_($2,nil);
$ctx1.sendIdx["assert:equals:"]=2;
$recv(jsObject)._a_((0));
$ctx1.sendIdx["a:"]=2;
$3=$recv(jsObject)._a();
$ctx1.sendIdx["a"]=3;
self._assert_equals_($3,(0));
$ctx1.sendIdx["assert:equals:"]=3;
$recv(jsObject)._a_(self._jsUndefined());
$ctx1.sendIdx["a:"]=3;
$4=$recv(jsObject)._a();
$ctx1.sendIdx["a"]=4;
self._assert_equals_($4,nil);
$ctx1.sendIdx["assert:equals:"]=4;
$recv(jsObject)._a_("");
$ctx1.sendIdx["a:"]=4;
$5=$recv(jsObject)._a();
$ctx1.sendIdx["a"]=5;
self._assert_equals_($5,"");
$ctx1.sendIdx["assert:equals:"]=5;
$recv(jsObject)._a_(false);
self._assert_equals_($recv(jsObject)._a(),false);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSetPropertyWithFalsyValue",{jsObject:jsObject},$globals.JSObjectProxyTest)});
},
args: [],
source: "testSetPropertyWithFalsyValue\x0a\x09| jsObject |\x0a\x09jsObject := self jsObject.\x0a\x09self assert: (jsObject a) equals: 1.\x0a\x0a\x09jsObject a: self jsNull.\x0a\x09self assert: (jsObject a) equals: nil.\x0a\x09jsObject a: 0.\x0a\x09self assert: (jsObject a) equals: 0.\x0a\x09jsObject a: self jsUndefined.\x0a\x09self assert: (jsObject a) equals: nil.\x0a\x09jsObject a: ''.\x0a\x09self assert: (jsObject a) equals: ''.\x0a\x09jsObject a: false.\x0a\x09self assert: (jsObject a) equals: false",
referencedClasses: [],
messageSends: ["jsObject", "assert:equals:", "a", "a:", "jsNull", "jsUndefined"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testValue",
protocol: 'tests',
fn: function (){
var self=this;
var testObject;
return $core.withContext(function($ctx1) {
testObject=self._jsObject();
$recv(testObject)._at_put_("value","aValue");
self._assert_equals_($recv(testObject)._value(),"aValue");
return self;
}, function($ctx1) {$ctx1.fill(self,"testValue",{testObject:testObject},$globals.JSObjectProxyTest)});
},
args: [],
source: "testValue\x0a\x09| testObject |\x0a\x09testObject := self jsObject.\x0a\x09testObject at: 'value' put: 'aValue'.\x0a\x09self assert: testObject value equals: 'aValue'",
referencedClasses: [],
messageSends: ["jsObject", "at:put:", "assert:equals:", "value"]
}),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testYourself",
protocol: 'tests',
fn: function (){
var self=this;
var object;
return $core.withContext(function($ctx1) {
var $1;
$1=self._jsObject();
$recv($1)._d_("test");
object=$recv($1)._yourself();
self._assert_equals_($recv(object)._d(),"test");
return self;
}, function($ctx1) {$ctx1.fill(self,"testYourself",{object:object},$globals.JSObjectProxyTest)});
},
args: [],
source: "testYourself\x0a\x09| object |\x0a\x09object := self jsObject\x0a\x09\x09d: 'test';\x0a\x09\x09yourself.\x0a\x0a\x09self assert: object d equals: 'test'",
referencedClasses: [],
messageSends: ["d:", "jsObject", "yourself", "assert:equals:", "d"]
}),
$globals.JSObjectProxyTest);



$core.addClass('JavaScriptExceptionTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testCatchingException",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return self._throwException();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(error){
return $core.withContext(function($ctx2) {
return self._assert_($recv($recv(error)._exception()).__eq("test"));
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCatchingException",{},$globals.JavaScriptExceptionTest)});
},
args: [],
source: "testCatchingException\x0a\x09[ self throwException ]\x0a\x09\x09on: Error\x0a\x09\x09do: [ :error |\x0a\x09\x09\x09self assert: error exception = 'test' ]",
referencedClasses: ["Error"],
messageSends: ["on:do:", "throwException", "assert:", "=", "exception"]
}),
$globals.JavaScriptExceptionTest);

$core.addMethod(
$core.method({
selector: "testRaisingException",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return self._throwException();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.JavaScriptException);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRaisingException",{},$globals.JavaScriptExceptionTest)});
},
args: [],
source: "testRaisingException\x0a\x09self should: [ self throwException ] raise: JavaScriptException",
referencedClasses: ["JavaScriptException"],
messageSends: ["should:raise:", "throwException"]
}),
$globals.JavaScriptExceptionTest);

$core.addMethod(
$core.method({
selector: "throwException",
protocol: 'helpers',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
throw 'test';
return self;
}, function($ctx1) {$ctx1.fill(self,"throwException",{},$globals.JavaScriptExceptionTest)});
},
args: [],
source: "throwException\x0a\x09<throw 'test'>",
referencedClasses: [],
messageSends: []
}),
$globals.JavaScriptExceptionTest);



$core.addClass('MessageSendTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testValue",
protocol: 'tests',
fn: function (){
var self=this;
var messageSend;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.MessageSend)._new();
$ctx1.sendIdx["new"]=1;
$recv($1)._receiver_($recv($globals.Object)._new());
$recv($1)._selector_("asString");
messageSend=$recv($1)._yourself();
self._assert_equals_($recv(messageSend)._value(),"an Object");
return self;
}, function($ctx1) {$ctx1.fill(self,"testValue",{messageSend:messageSend},$globals.MessageSendTest)});
},
args: [],
source: "testValue\x0a\x09| messageSend |\x0a\x09\x0a\x09messageSend := MessageSend new\x0a\x09\x09receiver: Object new;\x0a\x09\x09selector: #asString;\x0a\x09\x09yourself.\x0a\x09\x09\x0a\x09self assert: messageSend value equals: 'an Object'",
referencedClasses: ["MessageSend", "Object"],
messageSends: ["receiver:", "new", "selector:", "yourself", "assert:equals:", "value"]
}),
$globals.MessageSendTest);

$core.addMethod(
$core.method({
selector: "testValueWithArguments",
protocol: 'tests',
fn: function (){
var self=this;
var messageSend;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.MessageSend)._new();
$recv($1)._receiver_((2));
$recv($1)._selector_("+");
messageSend=$recv($1)._yourself();
self._assert_equals_($recv(messageSend)._value_((3)),(5));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_($recv(messageSend)._valueWithPossibleArguments_([(4)]),(6));
return self;
}, function($ctx1) {$ctx1.fill(self,"testValueWithArguments",{messageSend:messageSend},$globals.MessageSendTest)});
},
args: [],
source: "testValueWithArguments\x0a\x09| messageSend |\x0a\x09\x0a\x09messageSend := MessageSend new\x0a\x09\x09receiver: 2;\x0a\x09\x09selector: '+';\x0a\x09\x09yourself.\x0a\x09\x09\x0a\x09self assert: (messageSend value: 3) equals: 5.\x0a\x09\x0a\x09self assert: (messageSend valueWithPossibleArguments: #(4)) equals: 6",
referencedClasses: ["MessageSend"],
messageSends: ["receiver:", "new", "selector:", "yourself", "assert:equals:", "value:", "valueWithPossibleArguments:"]
}),
$globals.MessageSendTest);



$core.addClass('MethodInheritanceTest', $globals.TestCase, ['receiverTop', 'receiverMiddle', 'receiverBottom', 'method', 'performBlock'], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "codeGeneratorClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.CodeGenerator;

},
args: [],
source: "codeGeneratorClass\x0a\x09^ CodeGenerator",
referencedClasses: ["CodeGenerator"],
messageSends: []
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "compiler",
protocol: 'factory',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Compiler)._new();
$recv($1)._codeGeneratorClass_(self._codeGeneratorClass());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"compiler",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "compiler\x0a\x09^ Compiler new\x0a\x09\x09codeGeneratorClass: self codeGeneratorClass;\x0a\x09\x09yourself",
referencedClasses: ["Compiler"],
messageSends: ["codeGeneratorClass:", "new", "codeGeneratorClass", "yourself"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "deinstallBottom",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._targetClassBottom())._removeCompiledMethod_(self["@method"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"deinstallBottom",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "deinstallBottom\x0a\x09self targetClassBottom removeCompiledMethod: method",
referencedClasses: [],
messageSends: ["removeCompiledMethod:", "targetClassBottom"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "deinstallMiddle",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._targetClassMiddle())._removeCompiledMethod_(self["@method"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"deinstallMiddle",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "deinstallMiddle\x0a\x09self targetClassMiddle removeCompiledMethod: method",
referencedClasses: [],
messageSends: ["removeCompiledMethod:", "targetClassMiddle"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "deinstallTop",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._targetClassTop())._removeCompiledMethod_(self["@method"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"deinstallTop",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "deinstallTop\x0a\x09self targetClassTop removeCompiledMethod: method",
referencedClasses: [],
messageSends: ["removeCompiledMethod:", "targetClassTop"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "installBottom:",
protocol: 'testing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self["@method"]=$recv(self._compiler())._install_forClass_protocol_(aString,self._targetClassBottom(),"tests");
return self;
}, function($ctx1) {$ctx1.fill(self,"installBottom:",{aString:aString},$globals.MethodInheritanceTest)});
},
args: ["aString"],
source: "installBottom: aString\x0a\x09method := self compiler install: aString forClass: self targetClassBottom protocol: 'tests'",
referencedClasses: [],
messageSends: ["install:forClass:protocol:", "compiler", "targetClassBottom"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "installMiddle:",
protocol: 'testing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self["@method"]=$recv(self._compiler())._install_forClass_protocol_(aString,self._targetClassMiddle(),"tests");
return self;
}, function($ctx1) {$ctx1.fill(self,"installMiddle:",{aString:aString},$globals.MethodInheritanceTest)});
},
args: ["aString"],
source: "installMiddle: aString\x0a\x09method := self compiler install: aString forClass: self targetClassMiddle protocol: 'tests'",
referencedClasses: [],
messageSends: ["install:forClass:protocol:", "compiler", "targetClassMiddle"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "installTop:",
protocol: 'testing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self["@method"]=$recv(self._compiler())._install_forClass_protocol_(aString,self._targetClassTop(),"tests");
return self;
}, function($ctx1) {$ctx1.fill(self,"installTop:",{aString:aString},$globals.MethodInheritanceTest)});
},
args: ["aString"],
source: "installTop: aString\x0a\x09method := self compiler install: aString forClass: self targetClassTop protocol: 'tests'",
referencedClasses: [],
messageSends: ["install:forClass:protocol:", "compiler", "targetClassTop"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "setUp",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@receiverTop"]=$recv(self._targetClassTop())._new();
$ctx1.sendIdx["new"]=1;
self["@receiverMiddle"]=$recv(self._targetClassMiddle())._new();
$ctx1.sendIdx["new"]=2;
self["@receiverBottom"]=$recv(self._targetClassBottom())._new();
self["@method"]=nil;
self["@performBlock"]=(function(){
return $core.withContext(function($ctx2) {
return self._error_("performBlock not initialized");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
});
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "setUp\x0a\x09receiverTop := self targetClassTop new.\x0a\x09receiverMiddle := self targetClassMiddle new.\x0a\x09receiverBottom := self targetClassBottom new.\x0a\x09method := nil.\x0a\x09performBlock := [ self error: 'performBlock not initialized' ]",
referencedClasses: [],
messageSends: ["new", "targetClassTop", "targetClassMiddle", "targetClassBottom", "error:"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldMNU",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._shouldMNUTop();
self._shouldMNUMiddle();
self._shouldMNUBottom();
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldMNU",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "shouldMNU\x0a\x09self shouldMNUTop.\x0a\x09self shouldMNUMiddle.\x0a\x09self shouldMNUBottom",
referencedClasses: [],
messageSends: ["shouldMNUTop", "shouldMNUMiddle", "shouldMNUBottom"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldMNUBottom",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@performBlock"])._value_(self["@receiverBottom"]);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldMNUBottom",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "shouldMNUBottom\x0a\x09self should: [ performBlock value: receiverBottom ] raise: MessageNotUnderstood",
referencedClasses: ["MessageNotUnderstood"],
messageSends: ["should:raise:", "value:"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldMNUMiddle",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@performBlock"])._value_(self["@receiverMiddle"]);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldMNUMiddle",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "shouldMNUMiddle\x0a\x09self should: [ performBlock value: receiverMiddle ] raise: MessageNotUnderstood",
referencedClasses: ["MessageNotUnderstood"],
messageSends: ["should:raise:", "value:"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldMNUTop",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@performBlock"])._value_(self["@receiverTop"]);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldMNUTop",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "shouldMNUTop\x0a\x09self should: [ performBlock value: receiverTop ] raise: MessageNotUnderstood",
referencedClasses: ["MessageNotUnderstood"],
messageSends: ["should:raise:", "value:"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldReturn:",
protocol: 'testing',
fn: function (anObject){
var self=this;
var result;
return $core.withContext(function($ctx1) {
result=$recv(self["@performBlock"])._value_(self["@receiverTop"]);
$ctx1.sendIdx["value:"]=1;
self._assert_equals_(["top",anObject],["top",result]);
$ctx1.sendIdx["assert:equals:"]=1;
result=$recv(self["@performBlock"])._value_(self["@receiverMiddle"]);
$ctx1.sendIdx["value:"]=2;
self._assert_equals_(["middle",anObject],["middle",result]);
$ctx1.sendIdx["assert:equals:"]=2;
result=$recv(self["@performBlock"])._value_(self["@receiverBottom"]);
self._assert_equals_(["bottom",anObject],["bottom",result]);
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldReturn:",{anObject:anObject,result:result},$globals.MethodInheritanceTest)});
},
args: ["anObject"],
source: "shouldReturn: anObject\x0a\x09| result |\x0a\x0a\x09result := performBlock value: receiverTop.\x0a\x09self assert: { 'top'. anObject } equals: { 'top'. result }.\x0a\x09result := performBlock value: receiverMiddle.\x0a\x09self assert: { 'middle'. anObject } equals: { 'middle'. result }.\x0a\x09result := performBlock value: receiverBottom.\x0a\x09self assert: { 'bottom'. anObject } equals: { 'bottom'. result }",
referencedClasses: [],
messageSends: ["value:", "assert:equals:"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldReturn:and:and:",
protocol: 'testing',
fn: function (anObject,anObject2,anObject3){
var self=this;
var result;
return $core.withContext(function($ctx1) {
result=$recv(self["@performBlock"])._value_(self["@receiverTop"]);
$ctx1.sendIdx["value:"]=1;
self._assert_equals_(["top",anObject],["top",result]);
$ctx1.sendIdx["assert:equals:"]=1;
result=$recv(self["@performBlock"])._value_(self["@receiverMiddle"]);
$ctx1.sendIdx["value:"]=2;
self._assert_equals_(["middle",anObject2],["middle",result]);
$ctx1.sendIdx["assert:equals:"]=2;
result=$recv(self["@performBlock"])._value_(self["@receiverBottom"]);
self._assert_equals_(["bottom",anObject3],["bottom",result]);
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldReturn:and:and:",{anObject:anObject,anObject2:anObject2,anObject3:anObject3,result:result},$globals.MethodInheritanceTest)});
},
args: ["anObject", "anObject2", "anObject3"],
source: "shouldReturn: anObject and: anObject2 and: anObject3\x0a\x09| result |\x0a\x0a\x09result := performBlock value: receiverTop.\x0a\x09self assert: { 'top'. anObject } equals: { 'top'. result }.\x0a\x09result := performBlock value: receiverMiddle.\x0a\x09self assert: { 'middle'. anObject2 } equals: { 'middle'. result }.\x0a\x09result := performBlock value: receiverBottom.\x0a\x09self assert: { 'bottom'. anObject3 } equals: { 'bottom'. result }",
referencedClasses: [],
messageSends: ["value:", "assert:equals:"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "targetClassBottom",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.JavaScriptException;

},
args: [],
source: "targetClassBottom\x0a\x09^ JavaScriptException",
referencedClasses: ["JavaScriptException"],
messageSends: []
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "targetClassMiddle",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.Error;

},
args: [],
source: "targetClassMiddle\x0a\x09^ Error",
referencedClasses: ["Error"],
messageSends: []
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "targetClassTop",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.Object;

},
args: [],
source: "targetClassTop\x0a\x09^ Object",
referencedClasses: ["Object"],
messageSends: []
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return self._deinstallTop();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(){

}));
$ctx1.sendIdx["on:do:"]=1;
$recv((function(){
return $core.withContext(function($ctx2) {
return self._deinstallMiddle();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))._on_do_($globals.Error,(function(){

}));
$ctx1.sendIdx["on:do:"]=2;
$recv((function(){
return $core.withContext(function($ctx2) {
return self._deinstallBottom();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}))._on_do_($globals.Error,(function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"tearDown",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "tearDown\x0a\x09[ self deinstallTop ] on: Error do: [ ].\x0a\x09[ self deinstallMiddle ] on: Error do: [ ].\x0a\x09[ self deinstallBottom ] on: Error do: [ ]",
referencedClasses: ["Error"],
messageSends: ["on:do:", "deinstallTop", "deinstallMiddle", "deinstallBottom"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "testMNU11",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@performBlock"]=(function(x){
return $core.withContext(function($ctx2) {
return $recv(x)._foo();
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
});
self._shouldMNU();
$ctx1.sendIdx["shouldMNU"]=1;
self._installTop_("foo ^ false");
$ctx1.sendIdx["installTop:"]=1;
self._installTop_("foo ^ true");
self._deinstallTop();
self._shouldMNU();
return self;
}, function($ctx1) {$ctx1.fill(self,"testMNU11",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "testMNU11\x0a\x09performBlock := [ :x | x foo ].\x0a\x09self shouldMNU.\x0a\x09self installTop: 'foo ^ false'.\x0a\x09self installTop: 'foo ^ true'.\x0a\x09self deinstallTop.\x0a\x09self shouldMNU",
referencedClasses: [],
messageSends: ["foo", "shouldMNU", "installTop:", "deinstallTop"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "testMNU22",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@performBlock"]=(function(x){
return $core.withContext(function($ctx2) {
return $recv(x)._foo();
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
});
self._shouldMNU();
$ctx1.sendIdx["shouldMNU"]=1;
self._installMiddle_("foo ^ false");
$ctx1.sendIdx["installMiddle:"]=1;
self._installMiddle_("foo ^ true");
self._deinstallMiddle();
self._shouldMNU();
return self;
}, function($ctx1) {$ctx1.fill(self,"testMNU22",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "testMNU22\x0a\x09performBlock := [ :x | x foo ].\x0a\x09self shouldMNU.\x0a\x09self installMiddle: 'foo ^ false'.\x0a\x09self installMiddle: 'foo ^ true'.\x0a\x09self deinstallMiddle.\x0a\x09self shouldMNU",
referencedClasses: [],
messageSends: ["foo", "shouldMNU", "installMiddle:", "deinstallMiddle"]
}),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "testReturns1",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@performBlock"]=(function(x){
return $core.withContext(function($ctx2) {
return $recv(x)._foo();
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
});
self._installTop_("foo ^ false");
$ctx1.sendIdx["installTop:"]=1;
self._shouldReturn_(false);
$ctx1.sendIdx["shouldReturn:"]=1;
self._installTop_("foo ^ true");
self._shouldReturn_(true);
return self;
}, function($ctx1) {$ctx1.fill(self,"testReturns1",{},$globals.MethodInheritanceTest)});
},
args: [],
source: "testReturns1\x0a\x09performBlock := [ :x | x foo ].\x0a\x09self installTop: 'foo ^ false'.\x0a\x09self shouldReturn: false.\x0a\x09self installTop: 'foo ^ true'.\x0a\x09self shouldReturn: true",
referencedClasses: [],
messageSends: ["foo", "installTop:", "shouldReturn:"]
}),
$globals.MethodInheritanceTest);



$core.addClass('NumberTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testAbs",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=(4)._abs();
$ctx1.sendIdx["abs"]=1;
self._assert_equals_($1,(4));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_((-4)._abs(),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAbs",{},$globals.NumberTest)});
},
args: [],
source: "testAbs\x0a\x09self assert: 4 abs equals: 4.\x0a\x09self assert: -4 abs equals: 4",
referencedClasses: [],
messageSends: ["assert:equals:", "abs"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testArithmetic",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$4;
$1=(1.5).__plus((1));
$ctx1.sendIdx["+"]=1;
self._assert_equals_($1,(2.5));
$ctx1.sendIdx["assert:equals:"]=1;
$2=(2).__minus((1));
$ctx1.sendIdx["-"]=1;
self._assert_equals_($2,(1));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_((-2).__minus((1)),(-3));
$ctx1.sendIdx["assert:equals:"]=3;
self._assert_equals_((12).__slash((2)),(6));
$ctx1.sendIdx["assert:equals:"]=4;
$3=(3).__star((4));
$ctx1.sendIdx["*"]=1;
self._assert_equals_($3,(12));
$ctx1.sendIdx["assert:equals:"]=5;
self._assert_equals_((7).__slash_slash((2)),(3));
$ctx1.sendIdx["assert:equals:"]=6;
self._assert_equals_((7).__backslash_backslash((2)),(1));
$ctx1.sendIdx["assert:equals:"]=7;
$5=(1).__plus((2));
$ctx1.sendIdx["+"]=2;
$4=$recv($5).__star((3));
$ctx1.sendIdx["*"]=2;
self._assert_equals_($4,(9));
$ctx1.sendIdx["assert:equals:"]=8;
self._assert_equals_((1).__plus((2).__star((3))),(7));
return self;
}, function($ctx1) {$ctx1.fill(self,"testArithmetic",{},$globals.NumberTest)});
},
args: [],
source: "testArithmetic\x0a\x09\x0a\x09\x22We rely on JS here, so we won't test complex behavior, just check if\x0a\x09message sends are corrects\x22\x0a\x0a\x09self assert: 1.5 + 1 equals: 2.5.\x0a\x09self assert: 2 - 1 equals: 1.\x0a\x09self assert: -2 - 1 equals: -3.\x0a\x09self assert: 12 / 2 equals: 6.\x0a\x09self assert: 3 * 4 equals: 12.\x0a\x09self assert: 7 // 2 equals: 3.\x0a\x09self assert: 7 \x5c\x5c 2 equals: 1.\x0a\x0a\x09\x22Simple parenthesis and execution order\x22\x0a\x09self assert: 1 + 2 * 3 equals: 9.\x0a\x09self assert: 1 + (2 * 3) equals: 7",
referencedClasses: [],
messageSends: ["assert:equals:", "+", "-", "/", "*", "//", "\x5c\x5c"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testAsNumber",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_((3)._asNumber(),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsNumber",{},$globals.NumberTest)});
},
args: [],
source: "testAsNumber\x0a\x09self assert: 3 asNumber equals: 3.",
referencedClasses: [],
messageSends: ["assert:equals:", "asNumber"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testCeiling",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=(1.2)._ceiling();
$ctx1.sendIdx["ceiling"]=1;
self._assert_equals_($1,(2));
$ctx1.sendIdx["assert:equals:"]=1;
$2=(-1.2)._ceiling();
$ctx1.sendIdx["ceiling"]=2;
self._assert_equals_($2,(-1));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_((1)._ceiling(),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCeiling",{},$globals.NumberTest)});
},
args: [],
source: "testCeiling\x0a\x09self assert: 1.2 ceiling equals: 2.\x0a\x09self assert: -1.2 ceiling equals: -1.\x0a\x09self assert: 1.0 ceiling equals: 1.",
referencedClasses: [],
messageSends: ["assert:equals:", "ceiling"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testComparison",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
$1=(3).__gt((2));
$ctx1.sendIdx[">"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$2=(2).__lt((3));
$ctx1.sendIdx["<"]=1;
self._assert_($2);
$ctx1.sendIdx["assert:"]=2;
self._deny_((3).__lt((2)));
$ctx1.sendIdx["deny:"]=1;
self._deny_((2).__gt((3)));
$3=(3).__gt_eq((3));
$ctx1.sendIdx[">="]=1;
self._assert_($3);
$ctx1.sendIdx["assert:"]=3;
self._assert_((3.1).__gt_eq((3)));
$ctx1.sendIdx["assert:"]=4;
$4=(3).__lt_eq((3));
$ctx1.sendIdx["<="]=1;
self._assert_($4);
$ctx1.sendIdx["assert:"]=5;
self._assert_((3).__lt_eq((3.1)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testComparison",{},$globals.NumberTest)});
},
args: [],
source: "testComparison\x0a\x0a\x09self assert: 3 > 2.\x0a\x09self assert: 2 < 3.\x0a\x09\x0a\x09self deny: 3 < 2.\x0a\x09self deny: 2 > 3.\x0a\x0a\x09self assert: 3 >= 3.\x0a\x09self assert: 3.1 >= 3.\x0a\x09self assert: 3 <= 3.\x0a\x09self assert: 3 <= 3.1",
referencedClasses: [],
messageSends: ["assert:", ">", "<", "deny:", ">=", "<="]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testCopying",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv((1)._copy()).__eq_eq((1));
$ctx1.sendIdx["=="]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
self._assert_($recv((1)._deepCopy()).__eq_eq((1)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopying",{},$globals.NumberTest)});
},
args: [],
source: "testCopying\x0a\x09self assert: 1 copy == 1.\x0a\x09self assert: 1 deepCopy == 1",
referencedClasses: [],
messageSends: ["assert:", "==", "copy", "deepCopy"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testEquality",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$4,$7,$6,$9,$8,$10,$11,$12;
$1=(1).__eq((1));
$ctx1.sendIdx["="]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$2=(0).__eq((0));
$ctx1.sendIdx["="]=2;
self._assert_($2);
$ctx1.sendIdx["assert:"]=2;
$3=(1).__eq((0));
$ctx1.sendIdx["="]=3;
self._deny_($3);
$ctx1.sendIdx["deny:"]=1;
$5=(1)._yourself();
$ctx1.sendIdx["yourself"]=1;
$4=$recv($5).__eq((1));
$ctx1.sendIdx["="]=4;
self._assert_($4);
$ctx1.sendIdx["assert:"]=3;
$7=(1)._yourself();
$ctx1.sendIdx["yourself"]=2;
$6=(1).__eq($7);
$ctx1.sendIdx["="]=5;
self._assert_($6);
$ctx1.sendIdx["assert:"]=4;
$9=(1)._yourself();
$ctx1.sendIdx["yourself"]=3;
$8=$recv($9).__eq((1)._yourself());
$ctx1.sendIdx["="]=6;
self._assert_($8);
$10=(0).__eq(false);
$ctx1.sendIdx["="]=7;
self._deny_($10);
$ctx1.sendIdx["deny:"]=2;
$11=false.__eq((0));
$ctx1.sendIdx["="]=8;
self._deny_($11);
$ctx1.sendIdx["deny:"]=3;
$12="".__eq((0));
$ctx1.sendIdx["="]=9;
self._deny_($12);
$ctx1.sendIdx["deny:"]=4;
self._deny_((0).__eq(""));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{},$globals.NumberTest)});
},
args: [],
source: "testEquality\x0a\x09self assert: (1 = 1).\x0a\x09self assert: (0 = 0).\x0a\x09self deny: (1 = 0).\x0a\x0a\x09self assert: (1 yourself = 1).\x0a\x09self assert: (1 = 1 yourself).\x0a\x09self assert: (1 yourself = 1 yourself).\x0a\x09\x0a\x09self deny: 0 = false.\x0a\x09self deny: false = 0.\x0a\x09self deny: '' = 0.\x0a\x09self deny: 0 = ''",
referencedClasses: [],
messageSends: ["assert:", "=", "deny:", "yourself"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testFloor",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=(1.2)._floor();
$ctx1.sendIdx["floor"]=1;
self._assert_equals_($1,(1));
$ctx1.sendIdx["assert:equals:"]=1;
$2=(-1.2)._floor();
$ctx1.sendIdx["floor"]=2;
self._assert_equals_($2,(-2));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_((1)._floor(),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testFloor",{},$globals.NumberTest)});
},
args: [],
source: "testFloor\x0a\x09self assert: 1.2 floor equals: 1.\x0a\x09self assert: -1.2 floor equals: -2.\x0a\x09self assert: 1.0 floor equals: 1.",
referencedClasses: [],
messageSends: ["assert:equals:", "floor"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testHexNumbers",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5;
self._assert_equals_((9),(9));
$ctx1.sendIdx["assert:equals:"]=1;
$1=(10)._truncated();
$ctx1.sendIdx["truncated"]=1;
self._assert_equals_($1,(10));
$ctx1.sendIdx["assert:equals:"]=2;
$2=(11)._truncated();
$ctx1.sendIdx["truncated"]=2;
self._assert_equals_($2,(11));
$ctx1.sendIdx["assert:equals:"]=3;
$3=(12)._truncated();
$ctx1.sendIdx["truncated"]=3;
self._assert_equals_($3,(12));
$ctx1.sendIdx["assert:equals:"]=4;
$4=(13)._truncated();
$ctx1.sendIdx["truncated"]=4;
self._assert_equals_($4,(13));
$ctx1.sendIdx["assert:equals:"]=5;
$5=(14)._truncated();
$ctx1.sendIdx["truncated"]=5;
self._assert_equals_($5,(14));
$ctx1.sendIdx["assert:equals:"]=6;
self._assert_equals_((15)._truncated(),(15));
return self;
}, function($ctx1) {$ctx1.fill(self,"testHexNumbers",{},$globals.NumberTest)});
},
args: [],
source: "testHexNumbers\x0a\x0a\x09self assert: 16r9 equals: 9.\x0a\x09self assert: 16rA truncated equals: 10.\x0a\x09self assert: 16rB truncated equals: 11.\x0a\x09self assert: 16rC truncated equals: 12.\x0a\x09self assert: 16rD truncated equals: 13.\x0a\x09self assert: 16rE truncated equals: 14.\x0a\x09self assert: 16rF truncated equals: 15",
referencedClasses: [],
messageSends: ["assert:equals:", "truncated"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testIdentity",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$5,$4,$7,$6,$9,$8;
$1=(1).__eq_eq((1));
$ctx1.sendIdx["=="]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$2=(0).__eq_eq((0));
$ctx1.sendIdx["=="]=2;
self._assert_($2);
$ctx1.sendIdx["assert:"]=2;
$3=(1).__eq_eq((0));
$ctx1.sendIdx["=="]=3;
self._deny_($3);
$ctx1.sendIdx["deny:"]=1;
$5=(1)._yourself();
$ctx1.sendIdx["yourself"]=1;
$4=$recv($5).__eq_eq((1));
$ctx1.sendIdx["=="]=4;
self._assert_($4);
$ctx1.sendIdx["assert:"]=3;
$7=(1)._yourself();
$ctx1.sendIdx["yourself"]=2;
$6=(1).__eq_eq($7);
$ctx1.sendIdx["=="]=5;
self._assert_($6);
$ctx1.sendIdx["assert:"]=4;
$9=(1)._yourself();
$ctx1.sendIdx["yourself"]=3;
$8=$recv($9).__eq_eq((1)._yourself());
$ctx1.sendIdx["=="]=6;
self._assert_($8);
self._deny_((1).__eq_eq((2)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIdentity",{},$globals.NumberTest)});
},
args: [],
source: "testIdentity\x0a\x09self assert: 1 == 1.\x0a\x09self assert: 0 == 0.\x0a\x09self deny: 1 == 0.\x0a\x0a\x09self assert: 1 yourself == 1.\x0a\x09self assert: 1 == 1 yourself.\x0a\x09self assert: 1 yourself == 1 yourself.\x0a\x09\x0a\x09self deny: 1 == 2",
referencedClasses: [],
messageSends: ["assert:", "==", "deny:", "yourself"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testInvalidHexNumbers",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rG();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=1;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rg();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=2;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rH();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=3;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rh();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=4;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rI();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=5;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._ri();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,6)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=6;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rJ();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,7)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=7;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rj();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,8)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=8;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rK();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,9)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=9;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rk();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,10)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=10;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rL();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,11)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=11;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rl();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,12)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=12;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rM();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,13)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=13;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rm();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,14)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=14;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rN();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,15)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=15;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rn();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,16)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=16;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rO();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,17)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=17;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._ro();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,18)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=18;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rP();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,19)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=19;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rp();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,20)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=20;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rQ();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,21)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=21;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rq();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,22)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=22;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rR();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,23)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=23;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rr();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,24)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=24;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rS();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,25)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=25;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rs();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,26)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=26;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rT();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,27)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=27;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rt();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,28)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=28;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rU();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,29)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=29;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._ru();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,30)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=30;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rV();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,31)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=31;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rv();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,32)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=32;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rW();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,33)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=33;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rw();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,34)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=34;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rX();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,35)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=35;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rx();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,36)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=36;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rY();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,37)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=37;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._ry();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,38)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=38;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rZ();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,39)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=39;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rz();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,40)});
}),$globals.MessageNotUnderstood);
$ctx1.sendIdx["should:raise:"]=40;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (11259375)._Z();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,41)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"testInvalidHexNumbers",{},$globals.NumberTest)});
},
args: [],
source: "testInvalidHexNumbers\x0a\x0a\x09self should: [ 16rG ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rg ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rH ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rh ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rI ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16ri ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rJ ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rj ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rK ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rk ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rL ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rl ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rM ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rm ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rN ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rn ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rO ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16ro ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rP ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rp ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rQ ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rq ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rR ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rr ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rS ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rs ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rT ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rt ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rU ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16ru ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rV ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rv ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rW ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rw ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rX ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rx ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rY ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16ry ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rZ ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rz ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rABcdEfZ ] raise: MessageNotUnderstood.",
referencedClasses: ["MessageNotUnderstood"],
messageSends: ["should:raise:", "rG", "rg", "rH", "rh", "rI", "ri", "rJ", "rj", "rK", "rk", "rL", "rl", "rM", "rm", "rN", "rn", "rO", "ro", "rP", "rp", "rQ", "rq", "rR", "rr", "rS", "rs", "rT", "rt", "rU", "ru", "rV", "rv", "rW", "rw", "rX", "rx", "rY", "ry", "rZ", "rz", "Z"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testLog",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_((10000)._log(),(4));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_((512)._log_((2)),(9));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_($recv($recv($globals.Number)._e())._ln(),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLog",{},$globals.NumberTest)});
},
args: [],
source: "testLog\x0a\x09self assert: 10000 log equals: 4.\x0a\x09self assert: (512 log: 2) equals: 9.\x0a\x09self assert: Number e ln equals: 1.",
referencedClasses: ["Number"],
messageSends: ["assert:equals:", "log", "log:", "ln", "e"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testMinMax",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_((2)._max_((5)),(5));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_((2)._min_((5)),(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testMinMax",{},$globals.NumberTest)});
},
args: [],
source: "testMinMax\x0a\x09\x0a\x09self assert: (2 max: 5) equals: 5.\x0a\x09self assert: (2 min: 5) equals: 2",
referencedClasses: [],
messageSends: ["assert:equals:", "max:", "min:"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testNegated",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=(3)._negated();
$ctx1.sendIdx["negated"]=1;
self._assert_equals_($1,(-3));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_((-3)._negated(),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNegated",{},$globals.NumberTest)});
},
args: [],
source: "testNegated\x0a\x09self assert: 3 negated equals: -3.\x0a\x09self assert: -3 negated equals: 3",
referencedClasses: [],
messageSends: ["assert:equals:", "negated"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testPrintShowingDecimalPlaces",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3,$5,$6,$8,$7,$10,$9,$11,$12,$13,$14,$15;
$1=(23)._printShowingDecimalPlaces_((2));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=1;
self._assert_equals_($1,"23.00");
$ctx1.sendIdx["assert:equals:"]=1;
$2=(23.5698)._printShowingDecimalPlaces_((2));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=2;
self._assert_equals_($2,"23.57");
$ctx1.sendIdx["assert:equals:"]=2;
$4=(234.567)._negated();
$ctx1.sendIdx["negated"]=1;
$3=$recv($4)._printShowingDecimalPlaces_((5));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=3;
self._assert_equals_($3,"-234.56700");
$ctx1.sendIdx["assert:equals:"]=3;
$5=(23.4567)._printShowingDecimalPlaces_((0));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=4;
self._assert_equals_($5,"23");
$ctx1.sendIdx["assert:equals:"]=4;
$6=(23.5567)._printShowingDecimalPlaces_((0));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=5;
self._assert_equals_($6,"24");
$ctx1.sendIdx["assert:equals:"]=5;
$8=(23.4567)._negated();
$ctx1.sendIdx["negated"]=2;
$7=$recv($8)._printShowingDecimalPlaces_((0));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=6;
self._assert_equals_($7,"-23");
$ctx1.sendIdx["assert:equals:"]=6;
$10=(23.5567)._negated();
$ctx1.sendIdx["negated"]=3;
$9=$recv($10)._printShowingDecimalPlaces_((0));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=7;
self._assert_equals_($9,"-24");
$ctx1.sendIdx["assert:equals:"]=7;
$11=(100000000)._printShowingDecimalPlaces_((1));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=8;
self._assert_equals_($11,"100000000.0");
$ctx1.sendIdx["assert:equals:"]=8;
$12=(0.98)._printShowingDecimalPlaces_((5));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=9;
self._assert_equals_($12,"0.98000");
$ctx1.sendIdx["assert:equals:"]=9;
$13=$recv((0.98)._negated())._printShowingDecimalPlaces_((2));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=10;
self._assert_equals_($13,"-0.98");
$ctx1.sendIdx["assert:equals:"]=10;
$14=(2.567)._printShowingDecimalPlaces_((2));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=11;
self._assert_equals_($14,"2.57");
$ctx1.sendIdx["assert:equals:"]=11;
$15=(-2.567)._printShowingDecimalPlaces_((2));
$ctx1.sendIdx["printShowingDecimalPlaces:"]=12;
self._assert_equals_($15,"-2.57");
$ctx1.sendIdx["assert:equals:"]=12;
self._assert_equals_((0)._printShowingDecimalPlaces_((2)),"0.00");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrintShowingDecimalPlaces",{},$globals.NumberTest)});
},
args: [],
source: "testPrintShowingDecimalPlaces\x0a\x09self assert: (23 printShowingDecimalPlaces: 2) equals: '23.00'.\x0a\x09self assert: (23.5698 printShowingDecimalPlaces: 2) equals: '23.57'.\x0a\x09self assert: (234.567 negated printShowingDecimalPlaces: 5) equals: '-234.56700'.\x0a\x09self assert: (23.4567 printShowingDecimalPlaces: 0) equals: '23'.\x0a\x09self assert: (23.5567 printShowingDecimalPlaces: 0) equals: '24'.\x0a\x09self assert: (23.4567 negated printShowingDecimalPlaces: 0) equals: '-23'.\x0a\x09self assert: (23.5567 negated printShowingDecimalPlaces: 0) equals: '-24'.\x0a\x09self assert: (100000000 printShowingDecimalPlaces: 1) equals: '100000000.0'.\x0a\x09self assert: (0.98 printShowingDecimalPlaces: 5) equals: '0.98000'.\x0a\x09self assert: (0.98 negated printShowingDecimalPlaces: 2) equals: '-0.98'.\x0a\x09self assert: (2.567 printShowingDecimalPlaces: 2) equals: '2.57'.\x0a\x09self assert: (-2.567 printShowingDecimalPlaces: 2) equals: '-2.57'.\x0a\x09self assert: (0 printShowingDecimalPlaces: 2) equals: '0.00'.",
referencedClasses: [],
messageSends: ["assert:equals:", "printShowingDecimalPlaces:", "negated"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testRaisedTo",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$1=(2)._raisedTo_((4));
$ctx1.sendIdx["raisedTo:"]=1;
self._assert_equals_($1,(16));
$ctx1.sendIdx["assert:equals:"]=1;
$2=(2)._raisedTo_((0));
$ctx1.sendIdx["raisedTo:"]=2;
self._assert_equals_($2,(1));
$ctx1.sendIdx["assert:equals:"]=2;
$3=(2)._raisedTo_((-3));
$ctx1.sendIdx["raisedTo:"]=3;
self._assert_equals_($3,(0.125));
$ctx1.sendIdx["assert:equals:"]=3;
self._assert_equals_((4)._raisedTo_((0.5)),(2));
$ctx1.sendIdx["assert:equals:"]=4;
self._assert_equals_((2).__star_star((4)),(16));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRaisedTo",{},$globals.NumberTest)});
},
args: [],
source: "testRaisedTo\x0a\x09self assert: (2 raisedTo: 4) equals: 16.\x0a\x09self assert: (2 raisedTo: 0) equals: 1.\x0a\x09self assert: (2 raisedTo: -3) equals: 0.125.\x0a\x09self assert: (4 raisedTo: 0.5) equals: 2.\x0a\x09\x0a\x09self assert: 2 ** 4 equals: 16.",
referencedClasses: [],
messageSends: ["assert:equals:", "raisedTo:", "**"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testRounded",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=(3)._rounded();
$ctx1.sendIdx["rounded"]=1;
self._assert_equals_($1,(3));
$ctx1.sendIdx["assert:equals:"]=1;
$2=(3.212)._rounded();
$ctx1.sendIdx["rounded"]=2;
self._assert_equals_($2,(3));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_((3.51)._rounded(),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRounded",{},$globals.NumberTest)});
},
args: [],
source: "testRounded\x0a\x09\x0a\x09self assert: 3 rounded equals: 3.\x0a\x09self assert: 3.212 rounded equals: 3.\x0a\x09self assert: 3.51 rounded equals: 4",
referencedClasses: [],
messageSends: ["assert:equals:", "rounded"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testSign",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=(5)._sign();
$ctx1.sendIdx["sign"]=1;
self._assert_equals_($1,(1));
$ctx1.sendIdx["assert:equals:"]=1;
$2=(0)._sign();
$ctx1.sendIdx["sign"]=2;
self._assert_equals_($2,(0));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_((-1.4)._sign(),(-1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSign",{},$globals.NumberTest)});
},
args: [],
source: "testSign\x0a\x09self assert: 5 sign equals: 1.\x0a\x09self assert: 0 sign equals: 0.\x0a\x09self assert: -1.4 sign equals: -1.",
referencedClasses: [],
messageSends: ["assert:equals:", "sign"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testSqrt",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=(4)._sqrt();
$ctx1.sendIdx["sqrt"]=1;
self._assert_equals_($1,(2));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_((16)._sqrt(),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSqrt",{},$globals.NumberTest)});
},
args: [],
source: "testSqrt\x0a\x09\x0a\x09self assert: 4 sqrt equals: 2.\x0a\x09self assert: 16 sqrt equals: 4",
referencedClasses: [],
messageSends: ["assert:equals:", "sqrt"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testSquared",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_((4)._squared(),(16));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSquared",{},$globals.NumberTest)});
},
args: [],
source: "testSquared\x0a\x09\x0a\x09self assert: 4 squared equals: 16",
referencedClasses: [],
messageSends: ["assert:equals:", "squared"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testTimesRepeat",
protocol: 'tests',
fn: function (){
var self=this;
var i;
return $core.withContext(function($ctx1) {
i=(0);
(0)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
i=$recv(i).__plus((1));
$ctx2.sendIdx["+"]=1;
return i;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["timesRepeat:"]=1;
self._assert_equals_(i,(0));
$ctx1.sendIdx["assert:equals:"]=1;
(5)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
i=$recv(i).__plus((1));
return i;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
self._assert_equals_(i,(5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTimesRepeat",{i:i},$globals.NumberTest)});
},
args: [],
source: "testTimesRepeat\x0a\x09| i |\x0a\x0a\x09i := 0.\x0a\x090 timesRepeat: [ i := i + 1 ].\x0a\x09self assert: i equals: 0.\x0a\x0a\x095 timesRepeat: [ i := i + 1 ].\x0a\x09self assert: i equals: 5",
referencedClasses: [],
messageSends: ["timesRepeat:", "+", "assert:equals:"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testTo",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_((1)._to_((5)),[(1), (2), (3), (4), (5)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testTo",{},$globals.NumberTest)});
},
args: [],
source: "testTo\x0a\x09self assert: (1 to: 5) equals: #(1 2 3 4 5)",
referencedClasses: [],
messageSends: ["assert:equals:", "to:"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testToBy",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=(0)._to_by_((6),(2));
$ctx1.sendIdx["to:by:"]=1;
self._assert_equals_($1,[(0), (2), (4), (6)]);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (1)._to_by_((4),(0));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testToBy",{},$globals.NumberTest)});
},
args: [],
source: "testToBy\x0a\x09self assert: (0 to: 6 by: 2) equals: #(0 2 4 6).\x0a\x0a\x09self should: [ 1 to: 4 by: 0 ] raise: Error",
referencedClasses: ["Error"],
messageSends: ["assert:equals:", "to:by:", "should:raise:"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testTrigonometry",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_((0)._cos(),(1));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_((0)._sin(),(0));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_((0)._tan(),(0));
$ctx1.sendIdx["assert:equals:"]=3;
self._assert_equals_((1)._arcCos(),(0));
$ctx1.sendIdx["assert:equals:"]=4;
self._assert_equals_((0)._arcSin(),(0));
$ctx1.sendIdx["assert:equals:"]=5;
self._assert_equals_((0)._arcTan(),(0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTrigonometry",{},$globals.NumberTest)});
},
args: [],
source: "testTrigonometry\x0a\x09self assert: 0 cos equals: 1.\x0a\x09self assert: 0 sin equals: 0.\x0a\x09self assert: 0 tan equals: 0.\x0a\x09self assert: 1 arcCos equals: 0.\x0a\x09self assert: 0 arcSin equals: 0.\x0a\x09self assert: 0 arcTan equals: 0.",
referencedClasses: [],
messageSends: ["assert:equals:", "cos", "sin", "tan", "arcCos", "arcSin", "arcTan"]
}),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testTruncated",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=(3)._truncated();
$ctx1.sendIdx["truncated"]=1;
self._assert_equals_($1,(3));
$ctx1.sendIdx["assert:equals:"]=1;
$2=(3.212)._truncated();
$ctx1.sendIdx["truncated"]=2;
self._assert_equals_($2,(3));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_((3.51)._truncated(),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTruncated",{},$globals.NumberTest)});
},
args: [],
source: "testTruncated\x0a\x09\x0a\x09self assert: 3 truncated equals: 3.\x0a\x09self assert: 3.212 truncated equals: 3.\x0a\x09self assert: 3.51 truncated equals: 3",
referencedClasses: [],
messageSends: ["assert:equals:", "truncated"]
}),
$globals.NumberTest);



$core.addClass('ObjectMock', $globals.Object, ['foo', 'bar'], 'Kernel-Tests');
$globals.ObjectMock.comment="ObjectMock is there only to perform tests on classes.";
$core.addMethod(
$core.method({
selector: "foo",
protocol: 'not yet classified',
fn: function (){
var self=this;
return self["@foo"];

},
args: [],
source: "foo\x0a\x09^ foo",
referencedClasses: [],
messageSends: []
}),
$globals.ObjectMock);

$core.addMethod(
$core.method({
selector: "foo:",
protocol: 'not yet classified',
fn: function (anObject){
var self=this;
self["@foo"]=anObject;
return self;

},
args: ["anObject"],
source: "foo: anObject\x0a\x09foo := anObject",
referencedClasses: [],
messageSends: []
}),
$globals.ObjectMock);



$core.addClass('ObjectTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "notDefined",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return void 0;;
return self;
}, function($ctx1) {$ctx1.fill(self,"notDefined",{},$globals.ObjectTest)});
},
args: [],
source: "notDefined\x0a\x09<return void 0;>",
referencedClasses: [],
messageSends: []
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testBasicAccess",
protocol: 'tests',
fn: function (){
var self=this;
var o;
return $core.withContext(function($ctx1) {
var $1;
o=$recv($globals.Object)._new();
$recv(o)._basicAt_put_("a",(1));
$1=$recv(o)._basicAt_("a");
$ctx1.sendIdx["basicAt:"]=1;
self._assert_equals_($1,(1));
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_($recv(o)._basicAt_("b"),nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testBasicAccess",{o:o},$globals.ObjectTest)});
},
args: [],
source: "testBasicAccess\x0a\x09| o |\x0a\x09o := Object new.\x0a\x09o basicAt: 'a' put: 1.\x0a\x09self assert: (o basicAt: 'a') equals: 1.\x0a\x09self assert: (o basicAt: 'b') equals: nil",
referencedClasses: ["Object"],
messageSends: ["new", "basicAt:put:", "assert:equals:", "basicAt:"]
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testBasicPerform",
protocol: 'tests',
fn: function (){
var self=this;
var o;
return $core.withContext(function($ctx1) {
o=$recv($globals.Object)._new();
$recv(o)._basicAt_put_("func",(function(){
return "hello";

}));
$ctx1.sendIdx["basicAt:put:"]=1;
$recv(o)._basicAt_put_("func2",(function(a){
return $core.withContext(function($ctx2) {
return $recv(a).__plus((1));
}, function($ctx2) {$ctx2.fillBlock({a:a},$ctx1,2)});
}));
self._assert_equals_($recv(o)._basicPerform_("func"),"hello");
$ctx1.sendIdx["assert:equals:"]=1;
self._assert_equals_($recv(o)._basicPerform_withArguments_("func2",[(3)]),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBasicPerform",{o:o},$globals.ObjectTest)});
},
args: [],
source: "testBasicPerform\x0a\x09| o |\x0a\x09o := Object new.\x0a\x09o basicAt: 'func' put: [ 'hello' ].\x0a\x09o basicAt: 'func2' put: [ :a | a + 1 ].\x0a\x0a\x09self assert: (o basicPerform: 'func') equals: 'hello'.\x0a\x09self assert: (o basicPerform: 'func2' withArguments: #(3)) equals: 4",
referencedClasses: ["Object"],
messageSends: ["new", "basicAt:put:", "+", "assert:equals:", "basicPerform:", "basicPerform:withArguments:"]
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testDNU",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.Object)._new())._foo();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDNU",{},$globals.ObjectTest)});
},
args: [],
source: "testDNU\x0a\x09self should: [ Object new foo ] raise: MessageNotUnderstood",
referencedClasses: ["Object", "MessageNotUnderstood"],
messageSends: ["should:raise:", "foo", "new"]
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testEquality",
protocol: 'tests',
fn: function (){
var self=this;
var o;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3;
o=$recv($globals.Object)._new();
$ctx1.sendIdx["new"]=1;
$1=$recv(o).__eq($recv($globals.Object)._new());
$ctx1.sendIdx["="]=1;
self._deny_($1);
$2=$recv(o).__eq(o);
$ctx1.sendIdx["="]=2;
self._assert_($2);
$ctx1.sendIdx["assert:"]=1;
$4=$recv(o)._yourself();
$ctx1.sendIdx["yourself"]=1;
$3=$recv($4).__eq(o);
$ctx1.sendIdx["="]=3;
self._assert_($3);
$ctx1.sendIdx["assert:"]=2;
self._assert_($recv(o).__eq($recv(o)._yourself()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{o:o},$globals.ObjectTest)});
},
args: [],
source: "testEquality\x0a\x09| o |\x0a\x09o := Object new.\x0a\x09self deny: o = Object new.\x0a\x09self assert: (o = o).\x0a\x09self assert: (o yourself = o).\x0a\x09self assert: (o = o yourself)",
referencedClasses: ["Object"],
messageSends: ["new", "deny:", "=", "assert:", "yourself"]
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testHalt",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.Object)._new())._halt();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testHalt",{},$globals.ObjectTest)});
},
args: [],
source: "testHalt\x0a\x09self should: [ Object new halt ] raise: Error",
referencedClasses: ["Object", "Error"],
messageSends: ["should:raise:", "halt", "new"]
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testIdentity",
protocol: 'tests',
fn: function (){
var self=this;
var o;
return $core.withContext(function($ctx1) {
var $1,$2,$4,$3;
o=$recv($globals.Object)._new();
$ctx1.sendIdx["new"]=1;
$1=$recv(o).__eq_eq($recv($globals.Object)._new());
$ctx1.sendIdx["=="]=1;
self._deny_($1);
$2=$recv(o).__eq_eq(o);
$ctx1.sendIdx["=="]=2;
self._assert_($2);
$ctx1.sendIdx["assert:"]=1;
$4=$recv(o)._yourself();
$ctx1.sendIdx["yourself"]=1;
$3=$recv($4).__eq_eq(o);
$ctx1.sendIdx["=="]=3;
self._assert_($3);
$ctx1.sendIdx["assert:"]=2;
self._assert_($recv(o).__eq_eq($recv(o)._yourself()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIdentity",{o:o},$globals.ObjectTest)});
},
args: [],
source: "testIdentity\x0a\x09| o |\x0a\x09o := Object new.\x0a\x09self deny: o == Object new.\x0a\x09self assert: o == o.\x0a\x09self assert: o yourself == o.\x0a\x09self assert: o == o yourself",
referencedClasses: ["Object"],
messageSends: ["new", "deny:", "==", "assert:", "yourself"]
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testIfNil",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$5,$4,$3,$7,$6,$9,$8,$11,$10,$receiver;
$2=$recv($globals.Object)._new();
$ctx1.sendIdx["new"]=1;
$1=$recv($2)._isNil();
self._deny_($1);
$ctx1.sendIdx["deny:"]=1;
$5=$recv($globals.Object)._new();
$ctx1.sendIdx["new"]=2;
if(($receiver = $5) == null || $receiver.isNil){
$4=true;
} else {
$4=$5;
};
$3=$recv($4).__eq(true);
self._deny_($3);
$7=$recv($globals.Object)._new();
$ctx1.sendIdx["new"]=3;
if(($receiver = $7) == null || $receiver.isNil){
$6=$7;
} else {
$6=true;
};
self._assert_equals_($6,true);
$ctx1.sendIdx["assert:equals:"]=1;
$9=$recv($globals.Object)._new();
$ctx1.sendIdx["new"]=4;
if(($receiver = $9) == null || $receiver.isNil){
$8=false;
} else {
$8=true;
};
self._assert_equals_($8,true);
$ctx1.sendIdx["assert:equals:"]=2;
$11=$recv($globals.Object)._new();
if(($receiver = $11) == null || $receiver.isNil){
$10=false;
} else {
$10=true;
};
self._assert_equals_($10,true);
return self;
}, function($ctx1) {$ctx1.fill(self,"testIfNil",{},$globals.ObjectTest)});
},
args: [],
source: "testIfNil\x0a\x09self deny: Object new isNil.\x0a\x09self deny: (Object new ifNil: [ true ]) = true.\x0a\x09self assert: (Object new ifNotNil: [ true ]) equals: true.\x0a\x0a\x09self assert: (Object new ifNil: [ false ] ifNotNil: [ true ]) equals: true.\x0a\x09self assert: (Object new ifNotNil: [ true ] ifNil: [ false ]) equals: true",
referencedClasses: ["Object"],
messageSends: ["deny:", "isNil", "new", "=", "ifNil:", "assert:equals:", "ifNotNil:", "ifNil:ifNotNil:", "ifNotNil:ifNil:"]
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testInstVars",
protocol: 'tests',
fn: function (){
var self=this;
var o;
return $core.withContext(function($ctx1) {
var $1,$2;
o=$recv($globals.ObjectMock)._new();
$1=$recv(o)._instVarAt_("foo");
$ctx1.sendIdx["instVarAt:"]=1;
self._assert_equals_($1,nil);
$ctx1.sendIdx["assert:equals:"]=1;
$recv(o)._instVarAt_put_("foo",(1));
$2=$recv(o)._instVarAt_("foo");
$ctx1.sendIdx["instVarAt:"]=2;
self._assert_equals_($2,(1));
$ctx1.sendIdx["assert:equals:"]=2;
self._assert_equals_($recv(o)._instVarAt_("foo"),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testInstVars",{o:o},$globals.ObjectTest)});
},
args: [],
source: "testInstVars\x0a\x09| o |\x0a\x09o := ObjectMock new.\x0a\x09self assert: (o instVarAt: #foo) equals: nil.\x0a\x0a\x09o instVarAt: #foo put: 1.\x0a\x09self assert: (o instVarAt: #foo) equals: 1.\x0a\x09self assert: (o instVarAt: 'foo') equals: 1",
referencedClasses: ["ObjectMock"],
messageSends: ["new", "assert:equals:", "instVarAt:", "instVarAt:put:"]
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testNilUndefined",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_(self._notDefined(),nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testNilUndefined",{},$globals.ObjectTest)});
},
args: [],
source: "testNilUndefined\x0a\x09\x22nil in Smalltalk is the undefined object in JS\x22\x0a\x0a\x09self assert: self notDefined equals: nil",
referencedClasses: [],
messageSends: ["assert:equals:", "notDefined"]
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testYourself",
protocol: 'tests',
fn: function (){
var self=this;
var o;
return $core.withContext(function($ctx1) {
o=$recv($globals.ObjectMock)._new();
self._assert_($recv($recv(o)._yourself()).__eq_eq(o));
return self;
}, function($ctx1) {$ctx1.fill(self,"testYourself",{o:o},$globals.ObjectTest)});
},
args: [],
source: "testYourself\x0a\x09| o |\x0a\x09o := ObjectMock new.\x0a\x09self assert: o yourself == o",
referencedClasses: ["ObjectMock"],
messageSends: ["new", "assert:", "==", "yourself"]
}),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testidentityHash",
protocol: 'tests',
fn: function (){
var self=this;
var o1,o2;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$5,$4;
o1=$recv($globals.Object)._new();
$ctx1.sendIdx["new"]=1;
o2=$recv($globals.Object)._new();
$2=$recv(o1)._identityHash();
$ctx1.sendIdx["identityHash"]=1;
$3=$recv(o1)._identityHash();
$ctx1.sendIdx["identityHash"]=2;
$1=$recv($2).__eq_eq($3);
$ctx1.sendIdx["=="]=1;
self._assert_($1);
$5=$recv(o1)._identityHash();
$ctx1.sendIdx["identityHash"]=3;
$4=$recv($5).__eq_eq($recv(o2)._identityHash());
self._deny_($4);
return self;
}, function($ctx1) {$ctx1.fill(self,"testidentityHash",{o1:o1,o2:o2},$globals.ObjectTest)});
},
args: [],
source: "testidentityHash\x0a\x09| o1 o2 |\x0a\x09\x0a\x09o1 := Object new.\x0a\x09o2 := Object new.\x0a\x0a\x09self assert: o1 identityHash == o1 identityHash.\x0a\x09self deny: o1 identityHash == o2 identityHash",
referencedClasses: ["Object"],
messageSends: ["new", "assert:", "==", "identityHash", "deny:"]
}),
$globals.ObjectTest);



$core.addClass('PointTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testAccessing",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$6,$5,$4;
$2=$recv($globals.Point)._x_y_((3),(4));
$ctx1.sendIdx["x:y:"]=1;
$1=$recv($2)._x();
$ctx1.sendIdx["x"]=1;
self._assert_equals_($1,(3));
$ctx1.sendIdx["assert:equals:"]=1;
$3=$recv($recv($globals.Point)._x_y_((3),(4)))._y();
$ctx1.sendIdx["y"]=1;
self._assert_equals_($3,(4));
$ctx1.sendIdx["assert:equals:"]=2;
$6=$recv($globals.Point)._new();
$ctx1.sendIdx["new"]=1;
$5=$recv($6)._x_((3));
$4=$recv($5)._x();
self._assert_equals_($4,(3));
$ctx1.sendIdx["assert:equals:"]=3;
self._assert_equals_($recv($recv($recv($globals.Point)._new())._y_((4)))._y(),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAccessing",{},$globals.PointTest)});
},
args: [],
source: "testAccessing\x0a\x09self assert: (Point x: 3 y: 4) x equals: 3.\x0a\x09self assert: (Point x: 3 y: 4) y equals: 4.\x0a\x09self assert: (Point new x: 3) x equals: 3.\x0a\x09self assert: (Point new y: 4) y equals: 4",
referencedClasses: ["Point"],
messageSends: ["assert:equals:", "x", "x:y:", "y", "x:", "new", "y:"]
}),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testArithmetic",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$4,$6,$7,$5,$8,$10,$11,$9,$12,$14,$13;
$2=(3).__at((4));
$ctx1.sendIdx["@"]=1;
$3=(3).__at((4));
$ctx1.sendIdx["@"]=2;
$1=$recv($2).__star($3);
$4=$recv($globals.Point)._x_y_((9),(16));
$ctx1.sendIdx["x:y:"]=1;
self._assert_equals_($1,$4);
$ctx1.sendIdx["assert:equals:"]=1;
$6=(3).__at((4));
$ctx1.sendIdx["@"]=3;
$7=(3).__at((4));
$ctx1.sendIdx["@"]=4;
$5=$recv($6).__plus($7);
$8=$recv($globals.Point)._x_y_((6),(8));
$ctx1.sendIdx["x:y:"]=2;
self._assert_equals_($5,$8);
$ctx1.sendIdx["assert:equals:"]=2;
$10=(3).__at((4));
$ctx1.sendIdx["@"]=5;
$11=(3).__at((4));
$ctx1.sendIdx["@"]=6;
$9=$recv($10).__minus($11);
$12=$recv($globals.Point)._x_y_((0),(0));
$ctx1.sendIdx["x:y:"]=3;
self._assert_equals_($9,$12);
$ctx1.sendIdx["assert:equals:"]=3;
$14=(6).__at((8));
$ctx1.sendIdx["@"]=7;
$13=$recv($14).__slash((3).__at((4)));
self._assert_equals_($13,$recv($globals.Point)._x_y_((2),(2)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testArithmetic",{},$globals.PointTest)});
},
args: [],
source: "testArithmetic\x0a\x09self assert: 3@4 * (3@4 ) equals: (Point x: 9 y: 16).\x0a\x09self assert: 3@4 + (3@4 ) equals: (Point x: 6 y: 8).\x0a\x09self assert: 3@4 - (3@4 ) equals: (Point x: 0 y: 0).\x0a\x09self assert: 6@8 / (3@4 ) equals: (Point x: 2 y: 2)",
referencedClasses: ["Point"],
messageSends: ["assert:equals:", "*", "@", "x:y:", "+", "-", "/"]
}),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testAt",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_((3).__at((4)),$recv($globals.Point)._x_y_((3),(4)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAt",{},$globals.PointTest)});
},
args: [],
source: "testAt\x0a\x09self assert: 3@4 equals: (Point x: 3 y: 4)",
referencedClasses: ["Point"],
messageSends: ["assert:equals:", "@", "x:y:"]
}),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testComparison",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$5,$6,$4,$8,$9,$7,$11,$12,$10,$14,$15,$13,$17,$18,$16,$20,$21,$19,$23,$22;
$2=(3).__at((4));
$ctx1.sendIdx["@"]=1;
$3=(4).__at((5));
$ctx1.sendIdx["@"]=2;
$1=$recv($2).__lt($3);
$ctx1.sendIdx["<"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$5=(3).__at((4));
$ctx1.sendIdx["@"]=3;
$6=(4).__at((4));
$ctx1.sendIdx["@"]=4;
$4=$recv($5).__lt($6);
self._deny_($4);
$ctx1.sendIdx["deny:"]=1;
$8=(4).__at((5));
$ctx1.sendIdx["@"]=5;
$9=(4).__at((5));
$ctx1.sendIdx["@"]=6;
$7=$recv($8).__lt_eq($9);
$ctx1.sendIdx["<="]=1;
self._assert_($7);
$ctx1.sendIdx["assert:"]=2;
$11=(4).__at((5));
$ctx1.sendIdx["@"]=7;
$12=(3).__at((5));
$ctx1.sendIdx["@"]=8;
$10=$recv($11).__lt_eq($12);
self._deny_($10);
$ctx1.sendIdx["deny:"]=2;
$14=(5).__at((6));
$ctx1.sendIdx["@"]=9;
$15=(4).__at((5));
$ctx1.sendIdx["@"]=10;
$13=$recv($14).__gt($15);
$ctx1.sendIdx[">"]=1;
self._assert_($13);
$ctx1.sendIdx["assert:"]=3;
$17=(5).__at((6));
$ctx1.sendIdx["@"]=11;
$18=(6).__at((6));
$ctx1.sendIdx["@"]=12;
$16=$recv($17).__gt($18);
self._deny_($16);
$ctx1.sendIdx["deny:"]=3;
$20=(4).__at((5));
$ctx1.sendIdx["@"]=13;
$21=(4).__at((5));
$ctx1.sendIdx["@"]=14;
$19=$recv($20).__gt_eq($21);
$ctx1.sendIdx[">="]=1;
self._assert_($19);
$23=(4).__at((5));
$ctx1.sendIdx["@"]=15;
$22=$recv($23).__gt_eq((5).__at((5)));
self._deny_($22);
return self;
}, function($ctx1) {$ctx1.fill(self,"testComparison",{},$globals.PointTest)});
},
args: [],
source: "testComparison\x0a\x09self assert: 3@4 < (4@5).\x0a\x09self deny: 3@4 < (4@4).\x0a\x09\x0a\x09self assert: 4@5 <= (4@5).\x0a\x09self deny: 4@5 <= (3@5).\x0a\x09\x0a\x09self assert: 5@6 > (4@5).\x0a\x09self deny: 5@6 > (6@6).\x0a\x09\x0a\x09self assert: 4@5 >= (4@5).\x0a\x09self deny: 4@5 >= (5@5)",
referencedClasses: [],
messageSends: ["assert:", "<", "@", "deny:", "<=", ">", ">="]
}),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testEgality",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$5,$4;
$2=(3).__at((4));
$ctx1.sendIdx["@"]=1;
$3=(3).__at((4));
$ctx1.sendIdx["@"]=2;
$1=$recv($2).__eq($3);
$ctx1.sendIdx["="]=1;
self._assert_($1);
$5=(3).__at((5));
$ctx1.sendIdx["@"]=3;
$4=$recv($5).__eq((3).__at((6)));
self._deny_($4);
return self;
}, function($ctx1) {$ctx1.fill(self,"testEgality",{},$globals.PointTest)});
},
args: [],
source: "testEgality\x0a\x09self assert: (3@4 = (3@4)).\x0a\x09self deny: 3@5 = (3@6)",
referencedClasses: [],
messageSends: ["assert:", "=", "@", "deny:"]
}),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testNew",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$7,$6,$5,$4,$10,$9,$8;
$3=$recv($globals.Point)._new();
$ctx1.sendIdx["new"]=1;
$2=$recv($3)._x_((3));
$ctx1.sendIdx["x:"]=1;
$1=$recv($2)._y();
$ctx1.sendIdx["y"]=1;
self._assert_equals_($1,nil);
$ctx1.sendIdx["assert:equals:"]=1;
$7=$recv($globals.Point)._new();
$ctx1.sendIdx["new"]=2;
$6=$recv($7)._x_((3));
$5=$recv($6)._x();
$ctx1.sendIdx["x"]=1;
$4=$recv($5).__eq((0));
$ctx1.sendIdx["="]=1;
self._deny_($4);
$ctx1.sendIdx["deny:"]=1;
$10=$recv($globals.Point)._new();
$ctx1.sendIdx["new"]=3;
$9=$recv($10)._y_((4));
$ctx1.sendIdx["y:"]=1;
$8=$recv($9)._x();
self._assert_equals_($8,nil);
self._deny_($recv($recv($recv($recv($globals.Point)._new())._y_((4)))._y()).__eq((0)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNew",{},$globals.PointTest)});
},
args: [],
source: "testNew\x0a\x0a\x09self assert: (Point new x: 3) y equals: nil.\x0a\x09self deny: (Point new x: 3) x = 0.\x0a\x09self assert: (Point new y: 4) x equals: nil.\x0a\x09self deny: (Point new y: 4) y = 0",
referencedClasses: ["Point"],
messageSends: ["assert:equals:", "y", "x:", "new", "deny:", "=", "x", "y:"]
}),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testTranslateBy",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$4,$6,$8,$7,$5,$9,$11,$12,$10,$13,$15,$16,$14;
$2=(3).__at((3));
$ctx1.sendIdx["@"]=1;
$3=(0).__at((1));
$ctx1.sendIdx["@"]=2;
$1=$recv($2)._translateBy_($3);
$ctx1.sendIdx["translateBy:"]=1;
$4=(3).__at((4));
$ctx1.sendIdx["@"]=3;
self._assert_equals_($1,$4);
$ctx1.sendIdx["assert:equals:"]=1;
$6=(3).__at((3));
$ctx1.sendIdx["@"]=4;
$8=(1)._negated();
$ctx1.sendIdx["negated"]=1;
$7=(0).__at($8);
$ctx1.sendIdx["@"]=5;
$5=$recv($6)._translateBy_($7);
$ctx1.sendIdx["translateBy:"]=2;
$9=(3).__at((2));
$ctx1.sendIdx["@"]=6;
self._assert_equals_($5,$9);
$ctx1.sendIdx["assert:equals:"]=2;
$11=(3).__at((3));
$ctx1.sendIdx["@"]=7;
$12=(2).__at((3));
$ctx1.sendIdx["@"]=8;
$10=$recv($11)._translateBy_($12);
$ctx1.sendIdx["translateBy:"]=3;
$13=(5).__at((6));
$ctx1.sendIdx["@"]=9;
self._assert_equals_($10,$13);
$ctx1.sendIdx["assert:equals:"]=3;
$15=(3).__at((3));
$ctx1.sendIdx["@"]=10;
$16=$recv((3)._negated()).__at((0));
$ctx1.sendIdx["@"]=11;
$14=$recv($15)._translateBy_($16);
self._assert_equals_($14,(0).__at((3)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTranslateBy",{},$globals.PointTest)});
},
args: [],
source: "testTranslateBy\x0a\x09self assert: (3@3 translateBy: 0@1) equals: 3@4.\x0a\x09self assert: (3@3 translateBy: 0@1 negated) equals: 3@2.\x0a\x09self assert: (3@3 translateBy: 2@3) equals: 5@6.\x0a\x09self assert: (3@3 translateBy: 3 negated @0) equals: 0@3.",
referencedClasses: [],
messageSends: ["assert:equals:", "translateBy:", "@", "negated"]
}),
$globals.PointTest);



$core.addClass('QueueTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testNextIfAbsent",
protocol: 'tests',
fn: function (){
var self=this;
var queue;
return $core.withContext(function($ctx1) {
var $2,$1;
queue=$recv($globals.Queue)._new();
$recv(queue)._nextPut_("index1");
$2=$recv(queue)._nextIfAbsent_("empty");
$ctx1.sendIdx["nextIfAbsent:"]=1;
$1=$recv($2).__eq("index1");
$ctx1.sendIdx["="]=1;
self._assert_($1);
self._deny_($recv($recv(queue)._nextIfAbsent_("empty")).__eq("index1"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNextIfAbsent",{queue:queue},$globals.QueueTest)});
},
args: [],
source: "testNextIfAbsent\x0a\x09| queue |\x0a\x09queue := Queue new.\x0a\x09queue nextPut: 'index1'. \x0a\x0a\x09self assert: (queue  nextIfAbsent: 'empty') = 'index1'.\x0a\x09self deny: (queue  nextIfAbsent: 'empty') = 'index1'",
referencedClasses: ["Queue"],
messageSends: ["new", "nextPut:", "assert:", "=", "nextIfAbsent:", "deny:"]
}),
$globals.QueueTest);

$core.addMethod(
$core.method({
selector: "testQueueNext",
protocol: 'tests',
fn: function (){
var self=this;
var queue;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$5,$4;
queue=$recv($globals.Queue)._new();
$1=queue;
$recv($1)._nextPut_("index1");
$ctx1.sendIdx["nextPut:"]=1;
$recv($1)._nextPut_("index2");
$3=$recv(queue)._next();
$ctx1.sendIdx["next"]=1;
$2=$recv($3).__eq("index1");
$ctx1.sendIdx["="]=1;
self._assert_($2);
$5=$recv(queue)._next();
$ctx1.sendIdx["next"]=2;
$4=$recv($5).__eq("index");
self._deny_($4);
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(queue)._next();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testQueueNext",{queue:queue},$globals.QueueTest)});
},
args: [],
source: "testQueueNext\x0a\x09| queue |               \x0a\x09queue := Queue new.\x0a\x09queue \x0a\x09\x09nextPut: 'index1';\x0a\x09\x09nextPut: 'index2'.\x0a\x0a\x09self assert: queue next = 'index1'.\x0a\x09self deny: queue next = 'index'.\x0a\x09self should: [ queue next ] raise: Error",
referencedClasses: ["Queue", "Error"],
messageSends: ["new", "nextPut:", "assert:", "=", "next", "deny:", "should:raise:"]
}),
$globals.QueueTest);



$core.addClass('RandomTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testAtRandomNumber",
protocol: 'tests',
fn: function (){
var self=this;
var val;
return $core.withContext(function($ctx1) {
(100)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
val=(10)._atRandom();
val;
self._assert_($recv(val).__gt((0)));
$ctx2.sendIdx["assert:"]=1;
return self._assert_($recv(val).__lt((11)));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtRandomNumber",{val:val},$globals.RandomTest)});
},
args: [],
source: "testAtRandomNumber\x0a\x09|val|\x09\x0a\x0a\x09100 timesRepeat: [\x0a\x09\x09val := 10 atRandom.\x09\x0a\x09\x09self assert: (val > 0).\x0a\x09\x09self assert: (val <11)\x0a\x09]",
referencedClasses: [],
messageSends: ["timesRepeat:", "atRandom", "assert:", ">", "<"]
}),
$globals.RandomTest);

$core.addMethod(
$core.method({
selector: "testAtRandomSequenceableCollection",
protocol: 'tests',
fn: function (){
var self=this;
var val;
return $core.withContext(function($ctx1) {
var $3,$4,$2,$1;
(100)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
val="abc"._atRandom();
val;
$3=$recv(val).__eq("a");
$ctx2.sendIdx["="]=1;
$4=$recv(val).__eq("b");
$ctx2.sendIdx["="]=2;
$2=$recv($3).__or($4);
$1=$recv($2).__or($recv(val).__eq("c"));
$ctx2.sendIdx["|"]=1;
return self._assert_($1);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtRandomSequenceableCollection",{val:val},$globals.RandomTest)});
},
args: [],
source: "testAtRandomSequenceableCollection\x0a\x09|val|\x0a\x09\x0a\x09100 timesRepeat: [\x0a\x09\x09val := 'abc' atRandom.\x0a\x09\x09self assert: ((val = 'a') | (val = 'b') | (val = 'c' )).\x0a\x09].",
referencedClasses: [],
messageSends: ["timesRepeat:", "atRandom", "assert:", "|", "="]
}),
$globals.RandomTest);

$core.addMethod(
$core.method({
selector: "textNext",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
(10000)._timesRepeat_((function(){
var current,next;
return $core.withContext(function($ctx2) {
next=$recv($recv($globals.Random)._new())._next();
next;
self._assert_($recv(next).__gt_eq((0)));
$ctx2.sendIdx["assert:"]=1;
self._assert_($recv(next).__lt((1)));
$1=$recv(current).__eq(next);
$ctx2.sendIdx["="]=1;
self._deny_($1);
return $recv(next).__eq(current);
}, function($ctx2) {$ctx2.fillBlock({current:current,next:next},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"textNext",{},$globals.RandomTest)});
},
args: [],
source: "textNext\x0a\x0a\x0910000 timesRepeat: [\x0a\x09\x09\x09| current next |\x0a\x09\x09\x09next := Random new next.\x0a\x09\x09\x09self assert: (next >= 0).\x0a\x09\x09\x09self assert: (next < 1).\x0a\x09\x09\x09self deny: current = next.\x0a\x09\x09\x09next = current ]",
referencedClasses: ["Random"],
messageSends: ["timesRepeat:", "next", "new", "assert:", ">=", "<", "deny:", "="]
}),
$globals.RandomTest);



$core.addClass('StreamTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._class())._collectionClass();
}, function($ctx1) {$ctx1.fill(self,"collectionClass",{},$globals.StreamTest)});
},
args: [],
source: "collectionClass\x0a\x09^ self class collectionClass",
referencedClasses: [],
messageSends: ["collectionClass", "class"]
}),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "newCollection",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._collectionClass())._new();
}, function($ctx1) {$ctx1.fill(self,"newCollection",{},$globals.StreamTest)});
},
args: [],
source: "newCollection\x0a\x09^ self collectionClass new",
referencedClasses: [],
messageSends: ["new", "collectionClass"]
}),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "newStream",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(self._collectionClass())._new())._stream();
}, function($ctx1) {$ctx1.fill(self,"newStream",{},$globals.StreamTest)});
},
args: [],
source: "newStream\x0a\x09^ self collectionClass new stream",
referencedClasses: [],
messageSends: ["stream", "new", "collectionClass"]
}),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testAtStartAtEnd",
protocol: 'tests',
fn: function (){
var self=this;
var stream;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
stream=self._newStream();
$1=$recv(stream)._atStart();
$ctx1.sendIdx["atStart"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
$2=$recv(stream)._atEnd();
$ctx1.sendIdx["atEnd"]=1;
self._assert_($2);
$ctx1.sendIdx["assert:"]=2;
$recv(stream)._nextPutAll_(self._newCollection());
$3=$recv(stream)._atEnd();
$ctx1.sendIdx["atEnd"]=2;
self._assert_($3);
$4=$recv(stream)._atStart();
$ctx1.sendIdx["atStart"]=2;
self._deny_($4);
$ctx1.sendIdx["deny:"]=1;
$recv(stream)._position_((1));
self._deny_($recv(stream)._atEnd());
$ctx1.sendIdx["deny:"]=2;
self._deny_($recv(stream)._atStart());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtStartAtEnd",{stream:stream},$globals.StreamTest)});
},
args: [],
source: "testAtStartAtEnd\x0a\x09| stream |\x0a\x09\x0a\x09stream := self newStream.\x0a\x09self assert: stream atStart.\x0a\x09self assert: stream atEnd.\x0a\x09\x0a\x09stream nextPutAll: self newCollection.\x0a\x09self assert: stream atEnd.\x0a\x09self deny: stream atStart.\x0a\x09\x0a\x09stream position: 1.\x0a\x09self deny: stream atEnd.\x0a\x09self deny: stream atStart",
referencedClasses: [],
messageSends: ["newStream", "assert:", "atStart", "atEnd", "nextPutAll:", "newCollection", "deny:", "position:"]
}),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testContents",
protocol: 'tests',
fn: function (){
var self=this;
var stream;
return $core.withContext(function($ctx1) {
var $1,$2;
stream=self._newStream();
$1=stream;
$2=self._newCollection();
$ctx1.sendIdx["newCollection"]=1;
$recv($1)._nextPutAll_($2);
self._assert_equals_($recv(stream)._contents(),self._newCollection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testContents",{stream:stream},$globals.StreamTest)});
},
args: [],
source: "testContents\x0a\x09| stream |\x0a\x09\x0a\x09stream := self newStream.\x0a\x09stream nextPutAll: self newCollection.\x0a\x09\x0a\x09self assert: stream contents equals: self newCollection",
referencedClasses: [],
messageSends: ["newStream", "nextPutAll:", "newCollection", "assert:equals:", "contents"]
}),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testIsEmpty",
protocol: 'tests',
fn: function (){
var self=this;
var stream;
return $core.withContext(function($ctx1) {
var $1;
stream=self._newStream();
$1=$recv(stream)._isEmpty();
$ctx1.sendIdx["isEmpty"]=1;
self._assert_($1);
$recv(stream)._nextPutAll_(self._newCollection());
self._deny_($recv(stream)._isEmpty());
return self;
}, function($ctx1) {$ctx1.fill(self,"testIsEmpty",{stream:stream},$globals.StreamTest)});
},
args: [],
source: "testIsEmpty\x0a\x09| stream |\x0a\x09\x0a\x09stream := self newStream.\x0a\x09self assert: stream isEmpty.\x0a\x09\x0a\x09stream nextPutAll: self newCollection.\x0a\x09self deny: stream isEmpty",
referencedClasses: [],
messageSends: ["newStream", "assert:", "isEmpty", "nextPutAll:", "newCollection", "deny:"]
}),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testPosition",
protocol: 'tests',
fn: function (){
var self=this;
var collection,stream;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
collection=self._newCollection();
stream=self._newStream();
$recv(stream)._nextPutAll_(collection);
$1=$recv(stream)._position();
$ctx1.sendIdx["position"]=1;
self._assert_equals_($1,$recv(collection)._size());
$ctx1.sendIdx["assert:equals:"]=1;
$recv(stream)._position_((0));
$2=$recv(stream)._position();
$ctx1.sendIdx["position"]=2;
self._assert_equals_($2,(0));
$ctx1.sendIdx["assert:equals:"]=2;
$recv(stream)._next();
$ctx1.sendIdx["next"]=1;
$3=$recv(stream)._position();
$ctx1.sendIdx["position"]=3;
self._assert_equals_($3,(1));
$ctx1.sendIdx["assert:equals:"]=3;
$recv(stream)._next();
self._assert_equals_($recv(stream)._position(),(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testPosition",{collection:collection,stream:stream},$globals.StreamTest)});
},
args: [],
source: "testPosition\x0a\x09| collection stream |\x0a\x09\x0a\x09collection := self newCollection.\x0a\x09stream := self newStream.\x0a\x09\x0a\x09stream nextPutAll: collection.\x0a\x09self assert: stream position equals: collection size.\x0a\x09\x0a\x09stream position: 0.\x0a\x09self assert: stream position equals: 0.\x0a\x09\x0a\x09stream next.\x0a\x09self assert: stream position equals: 1.\x0a\x09\x0a\x09stream next.\x0a\x09self assert: stream position equals: 2",
referencedClasses: [],
messageSends: ["newCollection", "newStream", "nextPutAll:", "assert:equals:", "position", "size", "position:", "next"]
}),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testReading",
protocol: 'tests',
fn: function (){
var self=this;
var stream,collection;
return $core.withContext(function($ctx1) {
var $1,$2;
collection=self._newCollection();
stream=self._newStream();
$1=stream;
$recv($1)._nextPutAll_(collection);
$recv($1)._position_((0));
$recv(collection)._do_((function(each){
return $core.withContext(function($ctx2) {
$2=$recv(stream)._next();
$ctx2.sendIdx["next"]=1;
return self._assert_equals_($2,each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
self._assert_($recv($recv(stream)._next())._isNil());
return self;
}, function($ctx1) {$ctx1.fill(self,"testReading",{stream:stream,collection:collection},$globals.StreamTest)});
},
args: [],
source: "testReading\x0a\x09| stream collection |\x0a\x09\x0a\x09collection := self newCollection.\x0a\x09stream := self newStream.\x0a\x09\x0a\x09stream \x0a\x09\x09nextPutAll: collection;\x0a\x09\x09position: 0.\x0a\x09\x0a\x09collection do: [ :each |\x0a\x09\x09self assert: stream next equals: each ].\x0a\x09\x09\x0a\x09self assert: stream next isNil",
referencedClasses: [],
messageSends: ["newCollection", "newStream", "nextPutAll:", "position:", "do:", "assert:equals:", "next", "assert:", "isNil"]
}),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testStreamContents",
protocol: 'tests',
fn: function (){
var self=this;
return self;

},
args: [],
source: "testStreamContents",
referencedClasses: [],
messageSends: []
}),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testWrite",
protocol: 'tests',
fn: function (){
var self=this;
var stream,collection;
return $core.withContext(function($ctx1) {
collection=self._newCollection();
stream=self._newStream();
$recv(collection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(stream).__lt_lt(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
self._assert_equals_($recv(stream)._contents(),collection);
return self;
}, function($ctx1) {$ctx1.fill(self,"testWrite",{stream:stream,collection:collection},$globals.StreamTest)});
},
args: [],
source: "testWrite\x0a\x09| stream collection |\x0a\x09\x0a\x09collection := self newCollection.\x0a\x09stream := self newStream.\x0a\x09\x0a\x09collection do: [ :each | stream << each ].\x0a\x09self assert: stream contents equals: collection",
referencedClasses: [],
messageSends: ["newCollection", "newStream", "do:", "<<", "assert:equals:", "contents"]
}),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testWriting",
protocol: 'tests',
fn: function (){
var self=this;
var stream,collection;
return $core.withContext(function($ctx1) {
var $1;
collection=self._newCollection();
stream=self._newStream();
$ctx1.sendIdx["newStream"]=1;
$recv(collection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(stream)._nextPut_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$1=$recv(stream)._contents();
$ctx1.sendIdx["contents"]=1;
self._assert_equals_($1,collection);
$ctx1.sendIdx["assert:equals:"]=1;
stream=self._newStream();
$recv(stream)._nextPutAll_(collection);
self._assert_equals_($recv(stream)._contents(),collection);
return self;
}, function($ctx1) {$ctx1.fill(self,"testWriting",{stream:stream,collection:collection},$globals.StreamTest)});
},
args: [],
source: "testWriting\x0a\x09| stream collection |\x0a\x09\x0a\x09collection := self newCollection.\x0a\x09stream := self newStream.\x0a\x09\x0a\x09collection do: [ :each | stream nextPut: each ].\x0a\x09self assert: stream contents equals: collection.\x0a\x09\x0a\x09stream := self newStream.\x0a\x09stream nextPutAll: collection.\x0a\x09self assert: stream contents equals: collection",
referencedClasses: [],
messageSends: ["newCollection", "newStream", "do:", "nextPut:", "assert:equals:", "contents", "nextPutAll:"]
}),
$globals.StreamTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'accessing',
fn: function (){
var self=this;
return nil;

},
args: [],
source: "collectionClass\x0a\x09^ nil",
referencedClasses: [],
messageSends: []
}),
$globals.StreamTest.klass);

$core.addMethod(
$core.method({
selector: "isAbstract",
protocol: 'testing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._collectionClass())._isNil();
}, function($ctx1) {$ctx1.fill(self,"isAbstract",{},$globals.StreamTest.klass)});
},
args: [],
source: "isAbstract\x0a\x09^ self collectionClass isNil",
referencedClasses: [],
messageSends: ["isNil", "collectionClass"]
}),
$globals.StreamTest.klass);


$core.addClass('ArrayStreamTest', $globals.StreamTest, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "newCollection",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return [true,(1),(3).__at((4)),"foo"];
}, function($ctx1) {$ctx1.fill(self,"newCollection",{},$globals.ArrayStreamTest)});
},
args: [],
source: "newCollection\x0a\x09^ { true. 1. 3@4. 'foo' }",
referencedClasses: [],
messageSends: ["@"]
}),
$globals.ArrayStreamTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.Array;

},
args: [],
source: "collectionClass\x0a\x09^ Array",
referencedClasses: ["Array"],
messageSends: []
}),
$globals.ArrayStreamTest.klass);


$core.addClass('StringStreamTest', $globals.StreamTest, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "newCollection",
protocol: 'accessing',
fn: function (){
var self=this;
return "hello world";

},
args: [],
source: "newCollection\x0a\x09^ 'hello world'",
referencedClasses: [],
messageSends: []
}),
$globals.StringStreamTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.String;

},
args: [],
source: "collectionClass\x0a\x09^ String",
referencedClasses: ["String"],
messageSends: []
}),
$globals.StringStreamTest.klass);


$core.addClass('UndefinedTest', $globals.TestCase, [], 'Kernel-Tests');
$core.addMethod(
$core.method({
selector: "testCopying",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_(nil._copy(),nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopying",{},$globals.UndefinedTest)});
},
args: [],
source: "testCopying\x0a\x09self assert: nil copy equals: nil",
referencedClasses: [],
messageSends: ["assert:equals:", "copy"]
}),
$globals.UndefinedTest);

$core.addMethod(
$core.method({
selector: "testDeepCopy",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_($recv(nil._deepCopy()).__eq(nil));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDeepCopy",{},$globals.UndefinedTest)});
},
args: [],
source: "testDeepCopy\x0a\x09self assert: nil deepCopy = nil",
referencedClasses: [],
messageSends: ["assert:", "=", "deepCopy"]
}),
$globals.UndefinedTest);

$core.addMethod(
$core.method({
selector: "testIfNil",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$3,$2,$4,$6,$5,$receiver;
if(($receiver = nil) == null || $receiver.isNil){
$1=true;
} else {
$1=nil;
};
self._assert_equals_($1,true);
$ctx1.sendIdx["assert:equals:"]=1;
if(($receiver = nil) == null || $receiver.isNil){
$3=nil;
} else {
$3=true;
};
$2=$recv($3).__eq(true);
$ctx1.sendIdx["="]=1;
self._deny_($2);
$ctx1.sendIdx["deny:"]=1;
if(($receiver = nil) == null || $receiver.isNil){
$4=true;
} else {
$4=false;
};
self._assert_equals_($4,true);
if(($receiver = nil) == null || $receiver.isNil){
$6=false;
} else {
$6=true;
};
$5=$recv($6).__eq(true);
self._deny_($5);
return self;
}, function($ctx1) {$ctx1.fill(self,"testIfNil",{},$globals.UndefinedTest)});
},
args: [],
source: "testIfNil\x0a\x09self assert: (nil ifNil: [ true ]) equals: true.\x0a\x09self deny: (nil ifNotNil: [ true ]) = true.\x0a\x09self assert: (nil ifNil: [ true ] ifNotNil: [ false ]) equals: true.\x0a\x09self deny: (nil ifNotNil: [ true ] ifNil: [ false ]) = true",
referencedClasses: [],
messageSends: ["assert:equals:", "ifNil:", "deny:", "=", "ifNotNil:", "ifNil:ifNotNil:", "ifNotNil:ifNil:"]
}),
$globals.UndefinedTest);

$core.addMethod(
$core.method({
selector: "testIsNil",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_(nil._isNil());
self._deny_(nil._notNil());
return self;
}, function($ctx1) {$ctx1.fill(self,"testIsNil",{},$globals.UndefinedTest)});
},
args: [],
source: "testIsNil\x0a\x09self assert: nil isNil.\x0a\x09self deny: nil notNil.",
referencedClasses: [],
messageSends: ["assert:", "isNil", "deny:", "notNil"]
}),
$globals.UndefinedTest);


});

define("amber_core/SUnit-Tests", ["amber/boot", "amber_core/SUnit"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('SUnit-Tests');
$core.packages["SUnit-Tests"].innerEval = function (expr) { return eval(expr); };
$core.packages["SUnit-Tests"].transport = {"type":"amd","amdNamespace":"amber_core"};

$core.addClass('ExampleSetTest', $globals.TestCase, ['empty', 'full'], 'SUnit-Tests');
$globals.ExampleSetTest.comment="ExampleSetTest is taken from Pharo 1.4.\x0a\x0aTHe purpose of this class is to demonstrate a simple use case of the test framework.";
$core.addMethod(
$core.method({
selector: "setUp",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@empty"]=$recv($globals.Set)._new();
self["@full"]=$recv($globals.Set)._with_with_((5),"abc");
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{},$globals.ExampleSetTest)});
},
args: [],
source: "setUp\x0a\x09empty := Set new.\x0a\x09full := Set with: 5 with: #abc",
referencedClasses: ["Set"],
messageSends: ["new", "with:with:"]
}),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testAdd",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@empty"])._add_((5));
self._assert_($recv(self["@empty"])._includes_((5)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAdd",{},$globals.ExampleSetTest)});
},
args: [],
source: "testAdd\x0a\x09empty add: 5.\x0a\x09self assert: (empty includes: 5)",
referencedClasses: [],
messageSends: ["add:", "assert:", "includes:"]
}),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testGrow",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@empty"])._addAll_((1)._to_((100)));
self._assert_equals_($recv(self["@empty"])._size(),(100));
return self;
}, function($ctx1) {$ctx1.fill(self,"testGrow",{},$globals.ExampleSetTest)});
},
args: [],
source: "testGrow\x0a\x09empty addAll: (1 to: 100).\x0a\x09self assert: empty size equals: 100",
referencedClasses: [],
messageSends: ["addAll:", "to:", "assert:equals:", "size"]
}),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testIllegal",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@empty"])._at_((5));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$ctx1.sendIdx["should:raise:"]=1;
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@empty"])._at_put_((5),"abc");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testIllegal",{},$globals.ExampleSetTest)});
},
args: [],
source: "testIllegal\x0a\x09self\x0a\x09\x09should: [ empty at: 5 ]\x0a\x09\x09raise: Error.\x0a\x09self\x0a\x09\x09should: [ empty at: 5 put: #abc ]\x0a\x09\x09raise: Error",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "at:", "at:put:"]
}),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testIncludes",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self["@full"])._includes_((5));
$ctx1.sendIdx["includes:"]=1;
self._assert_($1);
$ctx1.sendIdx["assert:"]=1;
self._assert_($recv(self["@full"])._includes_("abc"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIncludes",{},$globals.ExampleSetTest)});
},
args: [],
source: "testIncludes\x0a\x09self assert: (full includes: 5).\x0a\x09self assert: (full includes: #abc)",
referencedClasses: [],
messageSends: ["assert:", "includes:"]
}),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testOccurrences",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv(self["@empty"])._occurrencesOf_((0));
$ctx1.sendIdx["occurrencesOf:"]=1;
self._assert_equals_($1,(0));
$ctx1.sendIdx["assert:equals:"]=1;
$2=$recv(self["@full"])._occurrencesOf_((5));
$ctx1.sendIdx["occurrencesOf:"]=2;
self._assert_equals_($2,(1));
$ctx1.sendIdx["assert:equals:"]=2;
$recv(self["@full"])._add_((5));
self._assert_equals_($recv(self["@full"])._occurrencesOf_((5)),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOccurrences",{},$globals.ExampleSetTest)});
},
args: [],
source: "testOccurrences\x0a\x09self assert: (empty occurrencesOf: 0) equals: 0.\x0a\x09self assert: (full occurrencesOf: 5) equals: 1.\x0a\x09full add: 5.\x0a\x09self assert: (full occurrencesOf: 5) equals: 1",
referencedClasses: [],
messageSends: ["assert:equals:", "occurrencesOf:", "add:"]
}),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testRemove",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(self["@full"])._remove_((5));
$1=$recv(self["@full"])._includes_("abc");
$ctx1.sendIdx["includes:"]=1;
self._assert_($1);
self._deny_($recv(self["@full"])._includes_((5)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemove",{},$globals.ExampleSetTest)});
},
args: [],
source: "testRemove\x0a\x09full remove: 5.\x0a\x09self assert: (full includes: #abc).\x0a\x09self deny: (full includes: 5)",
referencedClasses: [],
messageSends: ["remove:", "assert:", "includes:", "deny:"]
}),
$globals.ExampleSetTest);



$core.addClass('SUnitAsyncTest', $globals.TestCase, ['flag'], 'SUnit-Tests');
$core.addMethod(
$core.method({
selector: "fakeError",
protocol: 'helpers',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@flag"]="bad";
self._timeout_((30));
self["@flag"]=$recv(self._async_((function(){
return $core.withContext(function($ctx2) {
self["@flag"]="ok";
self["@flag"];
return self._error_("Intentional");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((20));
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeError",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "fakeError\x0a\x09flag := 'bad'.\x0a\x09self timeout: 30.\x0a\x09flag := (self async: [ flag := 'ok'. self error: 'Intentional' ]) valueWithTimeout: 20",
referencedClasses: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "error:"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "fakeErrorFailingInTearDown",
protocol: 'helpers',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@flag"]="bad";
self._timeout_((30));
self["@flag"]=$recv(self._async_((function(){
return $core.withContext(function($ctx2) {
return self._error_("Intentional");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((20));
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeErrorFailingInTearDown",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "fakeErrorFailingInTearDown\x0a\x09flag := 'bad'.\x0a\x09self timeout: 30.\x0a\x09flag := (self async: [ self error: 'Intentional' ]) valueWithTimeout: 20",
referencedClasses: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "error:"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "fakeFailure",
protocol: 'helpers',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@flag"]="bad";
self._timeout_((30));
self["@flag"]=$recv(self._async_((function(){
return $core.withContext(function($ctx2) {
self["@flag"]="ok";
self["@flag"];
return self._assert_(false);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((20));
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeFailure",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "fakeFailure\x0a\x09flag := 'bad'.\x0a\x09self timeout: 30.\x0a\x09flag := (self async: [ flag := 'ok'. self assert: false ]) valueWithTimeout: 20",
referencedClasses: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "assert:"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "fakeMultipleTimeoutFailing",
protocol: 'helpers',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
self._timeout_((100));
$ctx1.sendIdx["timeout:"]=1;
$1=self._async_((function(){
return $core.withContext(function($ctx2) {
self._timeout_((20));
return $recv(self._async_((function(){
return $core.withContext(function($ctx3) {
return self._finished();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
})))._valueWithTimeout_((30));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["async:"]=1;
$recv($1)._valueWithTimeout_((20));
$ctx1.sendIdx["valueWithTimeout:"]=1;
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeMultipleTimeoutFailing",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "fakeMultipleTimeoutFailing\x0a\x09self timeout: 100.\x0a\x09(self async: [ \x0a\x09\x09self timeout: 20.\x0a\x09\x09(self async: [ self finished ]) valueWithTimeout: 30\x0a\x09]) valueWithTimeout: 20",
referencedClasses: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "finished"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "fakeMultipleTimeoutPassing",
protocol: 'helpers',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
self._timeout_((20));
$ctx1.sendIdx["timeout:"]=1;
$1=self._async_((function(){
return $core.withContext(function($ctx2) {
self._timeout_((40));
return $recv(self._async_((function(){
return $core.withContext(function($ctx3) {
return self._finished();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
})))._valueWithTimeout_((20));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["async:"]=1;
$recv($1)._valueWithTimeout_((10));
$ctx1.sendIdx["valueWithTimeout:"]=1;
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeMultipleTimeoutPassing",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "fakeMultipleTimeoutPassing\x0a\x09self timeout: 20.\x0a\x09(self async: [\x0a\x09\x09self timeout: 40.\x0a\x09\x09(self async: [ self finished ]) valueWithTimeout: 20\x0a\x09]) valueWithTimeout: 10",
referencedClasses: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "finished"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "fakeTimeout",
protocol: 'helpers',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._timeout_((10));
$recv(self._async_((function(){
return $core.withContext(function($ctx2) {
return self._finished();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((20));
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeTimeout",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "fakeTimeout\x0a\x09self timeout: 10.\x0a\x09(self async: [ self finished ]) valueWithTimeout: 20",
referencedClasses: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "finished"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "selectorSetOf:",
protocol: 'private',
fn: function (aCollection){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aCollection)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._selector();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._asSet();
}, function($ctx1) {$ctx1.fill(self,"selectorSetOf:",{aCollection:aCollection},$globals.SUnitAsyncTest)});
},
args: ["aCollection"],
source: "selectorSetOf: aCollection\x0a\x09^ (aCollection collect: [ :each | each selector ]) asSet",
referencedClasses: [],
messageSends: ["asSet", "collect:", "selector"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "setUp",
protocol: 'running',
fn: function (){
var self=this;
self["@flag"]="ok";
return self;

},
args: [],
source: "setUp\x0a\x09flag := 'ok'",
referencedClasses: [],
messageSends: []
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: 'running',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._assert_equals_("ok",self["@flag"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"tearDown",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "tearDown\x0a\x09self assert: 'ok' equals: flag",
referencedClasses: [],
messageSends: ["assert:equals:"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testAsyncErrorsAndFailures",
protocol: 'tests',
fn: function (){
var self=this;
var suite,runner,result,assertBlock;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
suite=["fakeError", "fakeErrorFailingInTearDown", "fakeFailure", "testPass"]._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(self._class())._selector_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
runner=$recv($globals.TestSuiteRunner)._on_(suite);
self._timeout_((200));
result=$recv(runner)._result();
$ctx1.sendIdx["result"]=1;
assertBlock=self._async_((function(){
return $core.withContext(function($ctx2) {
$1=self._selectorSetOf_($recv(result)._errors());
$ctx2.sendIdx["selectorSetOf:"]=1;
$2=["fakeError"]._asSet();
$ctx2.sendIdx["asSet"]=1;
self._assert_equals_($1,$2);
$ctx2.sendIdx["assert:equals:"]=1;
self._assert_equals_(self._selectorSetOf_($recv(result)._failures()),["fakeErrorFailingInTearDown", "fakeFailure"]._asSet());
return self._finished();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv($recv(runner)._announcer())._on_do_($globals.ResultAnnouncement,(function(ann){
return $core.withContext(function($ctx2) {
$3=$recv($recv(ann)._result()).__eq_eq(result);
if($core.assert($3)){
$4=$recv($recv(result)._runs()).__eq($recv(result)._total());
return $recv($4)._ifTrue_(assertBlock);
};
}, function($ctx2) {$ctx2.fillBlock({ann:ann},$ctx1,3)});
}));
$recv(runner)._run();
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsyncErrorsAndFailures",{suite:suite,runner:runner,result:result,assertBlock:assertBlock},$globals.SUnitAsyncTest)});
},
args: [],
source: "testAsyncErrorsAndFailures\x0a\x09| suite runner result assertBlock |\x0a\x09suite := #('fakeError' 'fakeErrorFailingInTearDown' 'fakeFailure' 'testPass') collect: [ :each | self class selector: each ].\x0a\x09runner := TestSuiteRunner on: suite.\x0a\x09self timeout: 200.\x0a\x09result := runner result.\x0a\x09assertBlock := self async: [\x0a\x09\x09self assert: (self selectorSetOf: result errors) equals: #('fakeError') asSet.\x0a\x09\x09self assert: (self selectorSetOf: result failures) equals: #('fakeErrorFailingInTearDown' 'fakeFailure') asSet.\x0a\x09\x09self finished\x0a\x09].\x0a\x09runner announcer on: ResultAnnouncement do: [ :ann |\x0a\x09\x09ann result == result ifTrue: [ result runs = result total ifTrue: assertBlock ] ].\x0a\x09runner run",
referencedClasses: ["TestSuiteRunner", "ResultAnnouncement"],
messageSends: ["collect:", "selector:", "class", "on:", "timeout:", "result", "async:", "assert:equals:", "selectorSetOf:", "errors", "asSet", "failures", "finished", "on:do:", "announcer", "ifTrue:", "==", "=", "runs", "total", "run"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testAsyncNeedsTimeout",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return self._async_((function(){

}));
$ctx2.sendIdx["async:"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
self._timeout_((0));
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return self._async_((function(){

}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}),$globals.Error);
self._finished();
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsyncNeedsTimeout",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "testAsyncNeedsTimeout\x0a\x09self should: [ self async: [ ] ] raise: Error.\x0a\x09self timeout: 0.\x0a\x09self shouldnt: [ self async: [ ] ] raise: Error.\x0a\x09self finished",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "async:", "timeout:", "shouldnt:raise:", "finished"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testFinishedNeedsTimeout",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return self._finished();
$ctx2.sendIdx["finished"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
self._timeout_((0));
self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return self._finished();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testFinishedNeedsTimeout",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "testFinishedNeedsTimeout\x0a\x09self should: [ self finished ] raise: Error.\x0a\x09self timeout: 0.\x0a\x09self shouldnt: [ self finished ] raise: Error.",
referencedClasses: ["Error"],
messageSends: ["should:raise:", "finished", "timeout:", "shouldnt:raise:"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testIsAsyncReturnsCorrectValues",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=self._isAsync();
$ctx1.sendIdx["isAsync"]=1;
self._deny_($1);
$ctx1.sendIdx["deny:"]=1;
self._timeout_((0));
$2=self._isAsync();
$ctx1.sendIdx["isAsync"]=2;
self._assert_($2);
self._finished();
self._deny_(self._isAsync());
return self;
}, function($ctx1) {$ctx1.fill(self,"testIsAsyncReturnsCorrectValues",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "testIsAsyncReturnsCorrectValues\x0a\x09self deny: self isAsync.\x0a\x09self timeout: 0.\x0a\x09self assert: self isAsync.\x0a\x09self finished.\x0a\x09self deny: self isAsync",
referencedClasses: [],
messageSends: ["deny:", "isAsync", "timeout:", "assert:", "finished"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testPass",
protocol: 'tests',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@flag"]="bad";
self._timeout_((10));
self["@flag"]=$recv(self._async_((function(){
return $core.withContext(function($ctx2) {
self._assert_(true);
self._finished();
self["@flag"]="ok";
return self["@flag"];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testPass",{},$globals.SUnitAsyncTest)});
},
args: [],
source: "testPass\x0a\x09flag := 'bad'.\x0a\x09self timeout: 10.\x0a\x09flag := (self async: [ self assert: true. self finished. flag := 'ok' ]) valueWithTimeout: 5",
referencedClasses: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "assert:", "finished"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testTimeouts",
protocol: 'tests',
fn: function (){
var self=this;
var suite,runner,result,assertBlock;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
suite=["fakeTimeout", "fakeMultipleTimeoutFailing", "fakeMultipleTimeoutPassing", "testPass"]._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(self._class())._selector_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
runner=$recv($globals.TestSuiteRunner)._on_(suite);
self._timeout_((200));
result=$recv(runner)._result();
$ctx1.sendIdx["result"]=1;
assertBlock=self._async_((function(){
return $core.withContext(function($ctx2) {
$1=self._selectorSetOf_($recv(result)._errors());
$ctx2.sendIdx["selectorSetOf:"]=1;
self._assert_equals_($1,$recv($globals.Set)._new());
$ctx2.sendIdx["assert:equals:"]=1;
self._assert_equals_(self._selectorSetOf_($recv(result)._failures()),["fakeMultipleTimeoutFailing", "fakeTimeout"]._asSet());
return self._finished();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv($recv(runner)._announcer())._on_do_($globals.ResultAnnouncement,(function(ann){
return $core.withContext(function($ctx2) {
$2=$recv($recv(ann)._result()).__eq_eq(result);
if($core.assert($2)){
$3=$recv($recv(result)._runs()).__eq($recv(result)._total());
return $recv($3)._ifTrue_(assertBlock);
};
}, function($ctx2) {$ctx2.fillBlock({ann:ann},$ctx1,3)});
}));
$recv(runner)._run();
return self;
}, function($ctx1) {$ctx1.fill(self,"testTimeouts",{suite:suite,runner:runner,result:result,assertBlock:assertBlock},$globals.SUnitAsyncTest)});
},
args: [],
source: "testTimeouts\x0a\x09| suite runner result assertBlock |\x0a\x09suite := #('fakeTimeout' 'fakeMultipleTimeoutFailing' 'fakeMultipleTimeoutPassing' 'testPass') collect: [ :each | self class selector: each ].\x0a\x09runner := TestSuiteRunner on: suite.\x0a\x09self timeout: 200.\x0a\x09result := runner result.\x0a\x09assertBlock := self async: [\x0a\x09\x09self assert: (self selectorSetOf: result errors) equals: Set new.\x0a\x09\x09self assert: (self selectorSetOf: result failures) equals: #('fakeMultipleTimeoutFailing' 'fakeTimeout') asSet.\x0a\x09\x09self finished\x0a\x09].\x0a\x09runner announcer on: ResultAnnouncement do: [ :ann |\x0a\x09\x09ann result == result ifTrue: [ result runs = result total ifTrue: assertBlock ] ].\x0a\x09runner run",
referencedClasses: ["TestSuiteRunner", "Set", "ResultAnnouncement"],
messageSends: ["collect:", "selector:", "class", "on:", "timeout:", "result", "async:", "assert:equals:", "selectorSetOf:", "errors", "new", "failures", "asSet", "finished", "on:do:", "announcer", "ifTrue:", "==", "=", "runs", "total", "run"]
}),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testTwoAsyncPassesWithFinishedOnlyOneIsRun",
protocol: 'tests',
fn: function (){
var self=this;
var x;
return $core.withContext(function($ctx1) {
var $1;
self["@flag"]="bad";
self._timeout_((10));
x=(0);
$1=self._async_((function(){
return $core.withContext(function($ctx2) {
self._finished();
$ctx2.sendIdx["finished"]=1;
self["@flag"]="ok";
self["@flag"];
x=$recv(x).__plus((1));
$ctx2.sendIdx["+"]=1;
x;
return self._assert_equals_(x,(1));
$ctx2.sendIdx["assert:equals:"]=1;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["async:"]=1;
self["@flag"]=$recv($1)._valueWithTimeout_((0));
$ctx1.sendIdx["valueWithTimeout:"]=1;
self["@flag"]=$recv(self._async_((function(){
return $core.withContext(function($ctx2) {
self._finished();
self["@flag"]="ok";
self["@flag"];
x=$recv(x).__plus((1));
x;
return self._assert_equals_(x,(1));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
})))._valueWithTimeout_((0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTwoAsyncPassesWithFinishedOnlyOneIsRun",{x:x},$globals.SUnitAsyncTest)});
},
args: [],
source: "testTwoAsyncPassesWithFinishedOnlyOneIsRun\x0a\x09| x |\x0a\x09flag := 'bad'.\x0a\x09self timeout: 10.\x0a\x09x := 0.\x0a\x09flag := (self async: [ self finished. flag := 'ok'. x := x+1. self assert: x equals: 1 ]) valueWithTimeout: 0.\x0a\x09flag := (self async: [ self finished. flag := 'ok'. x := x+1. self assert: x equals: 1 ]) valueWithTimeout: 0.",
referencedClasses: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "finished", "+", "assert:equals:"]
}),
$globals.SUnitAsyncTest);


});

define('amber/devel',[
    './helpers', // pre-fetch, dep of ./deploy
    './deploy', // pre-fetch, dep of ./lang
    './lang',
    // --- packages of the development only Amber begin here ---
    'amber_core/SUnit',
    'amber_core/Compiler-Tests',
    'amber_core/Kernel-Tests',
    'amber_core/SUnit-Tests'
    // --- packages of the development only Amber end here ---
], function (amber) { return amber; });

define("amber_cli/AmberCli", ["amber/boot", "amber_core/Kernel-Objects"], function($boot){"use strict";
var $core=$boot.api,nil=$boot.nil,$recv=$boot.asReceiver,$globals=$boot.globals;
$core.addPackage('AmberCli');
$core.packages["AmberCli"].innerEval = function (expr) { return eval(expr); };
$core.packages["AmberCli"].transport = {"type":"amd","amdNamespace":"amber_cli"};

$core.addClass('AmberCli', $globals.Object, [], 'AmberCli');
$globals.AmberCli.comment="I am the Amber CLI (CommandLine Interface) tool which runs on Node.js.\x0a\x0aMy responsibility is to start different Amber programs like the FileServer or the Repl.\x0aWhich program to start is determined by the first commandline parameters passed to the AmberCli executable.\x0aUse `help` to get a list of all available options.\x0aAny further commandline parameters are passed to the specific program.\x0a\x0a## Commands\x0a\x0aNew commands can be added by creating a class side method in the `commands` protocol which takes one parameter.\x0aThis parameter is an array of all commandline options + values passed on to the program.\x0aAny `camelCaseCommand` is transformed into a commandline parameter of the form `camel-case-command` and vice versa.";

$core.addMethod(
$core.method({
selector: "commandLineSwitches",
protocol: 'commandline',
fn: function (){
var self=this;
var switches;
return $core.withContext(function($ctx1) {
switches=$recv($recv(self._class())._methodsInProtocol_("commands"))._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._selector();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["collect:"]=1;
switches=$recv(switches)._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._match_("^[^:]*:$");
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
switches=$recv(switches)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv($recv(each)._allButLast())._replace_with_("([A-Z])","-$1"))._asLowercase();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
return switches;
}, function($ctx1) {$ctx1.fill(self,"commandLineSwitches",{switches:switches},$globals.AmberCli.klass)});
},
args: [],
source: "commandLineSwitches\x0a\x09\x22Collect all methodnames from the 'commands' protocol of the class\x0a\x09 and select the ones with only one parameter.\x0a\x09 Then remove the ':' at the end of the name.\x0a\x09 Additionally all uppercase letters are made lowercase and preceded by a '-'.\x0a\x09 Example: fallbackPage: becomes --fallback-page.\x0a\x09 Return the Array containing the commandline switches.\x22\x0a\x09| switches |\x0a\x09switches := ((self class methodsInProtocol: 'commands') collect: [ :each | each selector]).\x0a\x09switches := switches select: [ :each | each match: '^[^:]*:$'].\x0a\x09switches :=switches collect: [ :each |\x0a\x09\x09(each allButLast replace: '([A-Z])' with: '-$1') asLowercase].\x0a\x09^ switches",
referencedClasses: [],
messageSends: ["collect:", "methodsInProtocol:", "class", "selector", "select:", "match:", "asLowercase", "replace:with:", "allButLast"]
}),
$globals.AmberCli.klass);

$core.addMethod(
$core.method({
selector: "config:",
protocol: 'commands',
fn: function (args){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Configurator)._new())._start();
return self;
}, function($ctx1) {$ctx1.fill(self,"config:",{args:args},$globals.AmberCli.klass)});
},
args: ["args"],
source: "config: args\x0a\x09Configurator new start",
referencedClasses: ["Configurator"],
messageSends: ["start", "new"]
}),
$globals.AmberCli.klass);

$core.addMethod(
$core.method({
selector: "handleArguments:",
protocol: 'commandline',
fn: function (args){
var self=this;
var selector;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(args)._first();
$ctx1.sendIdx["first"]=1;
selector=self._selectorForCommandLineSwitch_($1);
$recv(args)._remove_($recv(args)._first());
self._perform_withArguments_(selector,$recv($globals.Array)._with_(args));
return self;
}, function($ctx1) {$ctx1.fill(self,"handleArguments:",{args:args,selector:selector},$globals.AmberCli.klass)});
},
args: ["args"],
source: "handleArguments: args\x0a\x09| selector |\x0a\x0a\x09selector := self selectorForCommandLineSwitch: (args first).\x0a\x09args remove: args first.\x0a\x09self perform: selector  withArguments: (Array with: args)",
referencedClasses: ["Array"],
messageSends: ["selectorForCommandLineSwitch:", "first", "remove:", "perform:withArguments:", "with:"]
}),
$globals.AmberCli.klass);

$core.addMethod(
$core.method({
selector: "help:",
protocol: 'commands',
fn: function (args){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Transcript)._show_("Available commands");
$recv(self._commandLineSwitches())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(console)._log_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"help:",{args:args},$globals.AmberCli.klass)});
},
args: ["args"],
source: "help: args\x0a\x09Transcript show: 'Available commands'.\x0a\x09self commandLineSwitches do: [ :each | console log: each ]",
referencedClasses: ["Transcript"],
messageSends: ["show:", "do:", "commandLineSwitches", "log:"]
}),
$globals.AmberCli.klass);

$core.addMethod(
$core.method({
selector: "init:",
protocol: 'commands',
fn: function (args){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Initer)._new())._start();
return self;
}, function($ctx1) {$ctx1.fill(self,"init:",{args:args},$globals.AmberCli.klass)});
},
args: ["args"],
source: "init: args\x0a\x09Initer new start",
referencedClasses: ["Initer"],
messageSends: ["start", "new"]
}),
$globals.AmberCli.klass);

$core.addMethod(
$core.method({
selector: "main",
protocol: 'startup',
fn: function (){
var self=this;
var args;
return $core.withContext(function($ctx1) {
var $3,$2,$1,$4;
$3=$recv("Welcome to Amber version ".__comma($recv($globals.Smalltalk)._version())).__comma(" (NodeJS ");
$ctx1.sendIdx[","]=3;
$2=$recv($3).__comma($recv($recv(process)._versions())._node());
$ctx1.sendIdx[","]=2;
$1=$recv($2).__comma(").");
$ctx1.sendIdx[","]=1;
$recv($globals.Transcript)._show_($1);
args=$recv(process)._argv();
$recv(args)._removeFrom_to_((1),(2));
$4=$recv(args)._isEmpty();
if($core.assert($4)){
self._help_(nil);
} else {
return self._handleArguments_(args);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"main",{args:args},$globals.AmberCli.klass)});
},
args: [],
source: "main\x0a\x09\x22Main entry point for Amber applications.\x0a\x09Parses commandline arguments and starts the according subprogram.\x22\x0a\x09| args |\x0a\x09\x0a\x09Transcript show: 'Welcome to Amber version ', Smalltalk version, ' (NodeJS ', process versions node, ').'.\x0a\x0a\x09args := process argv.\x0a\x09\x22Remove the first args which contain the path to the node executable and the script file.\x22\x0a\x09args removeFrom: 1 to: 2.\x0a\x09\x0a\x09(args isEmpty)\x0a\x09\x09ifTrue: [self help: nil]\x0a\x09\x09ifFalse: [^self handleArguments: args]",
referencedClasses: ["Transcript", "Smalltalk"],
messageSends: ["show:", ",", "version", "node", "versions", "argv", "removeFrom:to:", "ifTrue:ifFalse:", "isEmpty", "help:", "handleArguments:"]
}),
$globals.AmberCli.klass);

$core.addMethod(
$core.method({
selector: "repl:",
protocol: 'commands',
fn: function (args){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Repl)._new())._createInterface();
}, function($ctx1) {$ctx1.fill(self,"repl:",{args:args},$globals.AmberCli.klass)});
},
args: ["args"],
source: "repl: args\x0a\x09^ Repl new createInterface",
referencedClasses: ["Repl"],
messageSends: ["createInterface", "new"]
}),
$globals.AmberCli.klass);

$core.addMethod(
$core.method({
selector: "selectorForCommandLineSwitch:",
protocol: 'commandline',
fn: function (aSwitch){
var self=this;
var command,selector;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self._commandLineSwitches())._includes_(aSwitch);
if($core.assert($1)){
selector=$recv($recv(aSwitch)._replace_with_("-[a-z]",(function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._second())._asUppercase();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}))).__comma(":");
selector;
} else {
selector="help:";
selector;
};
return selector;
}, function($ctx1) {$ctx1.fill(self,"selectorForCommandLineSwitch:",{aSwitch:aSwitch,command:command,selector:selector},$globals.AmberCli.klass)});
},
args: ["aSwitch"],
source: "selectorForCommandLineSwitch: aSwitch\x0a\x09\x22Add ':' at the end and replace all occurences of a lowercase letter preceded by a '-' with the Uppercase letter.\x0a\x09 Example: fallback-page becomes fallbackPage:.\x0a\x09 If no correct selector is found return 'help:'\x22\x0a\x09 | command selector |\x0a\x0a\x09 (self commandLineSwitches includes: aSwitch)\x0a\x09 ifTrue: [ selector := (aSwitch replace: '-[a-z]' with: [ :each | each second asUppercase ]), ':']\x0a\x09 ifFalse: [ selector := 'help:' ].\x0a\x09^ selector",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "includes:", "commandLineSwitches", ",", "replace:with:", "asUppercase", "second"]
}),
$globals.AmberCli.klass);

$core.addMethod(
$core.method({
selector: "serve:",
protocol: 'commands',
fn: function (args){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.FileServer)._createServerWithArguments_(args))._start();
}, function($ctx1) {$ctx1.fill(self,"serve:",{args:args},$globals.AmberCli.klass)});
},
args: ["args"],
source: "serve: args\x0a\x09^ (FileServer createServerWithArguments: args) start",
referencedClasses: ["FileServer"],
messageSends: ["start", "createServerWithArguments:"]
}),
$globals.AmberCli.klass);

$core.addMethod(
$core.method({
selector: "version:",
protocol: 'commands',
fn: function (arguments_){
var self=this;
return self;

},
args: ["arguments"],
source: "version: arguments",
referencedClasses: [],
messageSends: []
}),
$globals.AmberCli.klass);


$core.addClass('BaseFileManipulator', $globals.Object, ['path', 'fs'], 'AmberCli');
$core.addMethod(
$core.method({
selector: "dirname",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return __dirname;
return self;
}, function($ctx1) {$ctx1.fill(self,"dirname",{},$globals.BaseFileManipulator)});
},
args: [],
source: "dirname\x0a\x09<return __dirname>",
referencedClasses: [],
messageSends: []
}),
$globals.BaseFileManipulator);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.BaseFileManipulator.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@path"]=$recv(require)._value_("path");
$ctx1.sendIdx["value:"]=1;
self["@fs"]=$recv(require)._value_("fs");
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.BaseFileManipulator)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09path := require value: 'path'.\x0a\x09fs := require value: 'fs'",
referencedClasses: [],
messageSends: ["initialize", "value:"]
}),
$globals.BaseFileManipulator);

$core.addMethod(
$core.method({
selector: "rootDirname",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@path"])._join_with_(self._dirname(),"..");
}, function($ctx1) {$ctx1.fill(self,"rootDirname",{},$globals.BaseFileManipulator)});
},
args: [],
source: "rootDirname\x0a\x09^ path join: self dirname with: '..'",
referencedClasses: [],
messageSends: ["join:with:", "dirname"]
}),
$globals.BaseFileManipulator);



$core.addClass('Configurator', $globals.BaseFileManipulator, [], 'AmberCli');
$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Configurator.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.Configurator)});
},
args: [],
source: "initialize\x0a\x09super initialize",
referencedClasses: [],
messageSends: ["initialize"]
}),
$globals.Configurator);

$core.addMethod(
$core.method({
selector: "start",
protocol: 'action',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $receiver;
self._writeConfigThenDo_((function(err){
return $core.withContext(function($ctx2) {
if(($receiver = err) == null || $receiver.isNil){
return $recv(process)._exit();
} else {
return $recv(process)._exit_((111));
};
}, function($ctx2) {$ctx2.fillBlock({err:err},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"start",{},$globals.Configurator)});
},
args: [],
source: "start\x0a\x09self writeConfigThenDo: [ :err | err\x0a\x09\x09ifNotNil: [ process exit: 111 ]\x0a\x09\x09ifNil: [ process exit ]]",
referencedClasses: [],
messageSends: ["writeConfigThenDo:", "ifNotNil:ifNil:", "exit:", "exit"]
}),
$globals.Configurator);

$core.addMethod(
$core.method({
selector: "writeConfigThenDo:",
protocol: 'action',
fn: function (aBlock){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv($recv(require)._value_("amber-dev"))._configBuilder())._writeConfig_toFile_thenDo_($recv(process)._cwd(),"config.js",aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"writeConfigThenDo:",{aBlock:aBlock},$globals.Configurator)});
},
args: ["aBlock"],
source: "writeConfigThenDo: aBlock\x0a\x09(require value: 'amber-dev') configBuilder\x0a\x09\x09writeConfig: process cwd\x0a\x09\x09toFile: 'config.js'\x0a\x09\x09thenDo: aBlock",
referencedClasses: [],
messageSends: ["writeConfig:toFile:thenDo:", "configBuilder", "value:", "cwd"]
}),
$globals.Configurator);



$core.addClass('FileServer', $globals.BaseFileManipulator, ['http', 'url', 'host', 'port', 'basePath', 'util', 'username', 'password', 'fallbackPage'], 'AmberCli');
$globals.FileServer.comment="I am the Amber Smalltalk FileServer.\x0aMy runtime requirement is a functional Node.js executable.\x0a\x0aTo start a FileServer instance on port `4000` use the following code:\x0a\x0a    FileServer new start\x0a\x0aA parameterized instance can be created with the following code:\x0a\x0a    FileServer createServerWithArguments: options\x0a\x0aHere, `options` is an array of commandline style strings each followed by a value e.g. `#('--port', '6000', '--host', '0.0.0.0')`.\x0aA list of all available parameters can be printed to the commandline by passing `--help` as parameter.\x0aSee the `Options` section for further details on how options are mapped to instance methods.\x0a\x0aAfter startup FileServer checks if the directory layout required by Amber is present and logs a warning on absence.\x0a\x0a\x0a## Options\x0a\x0aEach option is of the form `--some-option-string` which is transformed into a selector of the format `someOptionString:`.\x0aThe trailing `--` gets removed, each `-[a-z]` gets transformed into the according uppercase letter, and a `:` is appended to create a selector which takes a single argument.\x0aAfterwards, the selector gets executed on the `FileServer` instance with the value following in the options array as parameter.\x0a\x0a## Adding new commandline parameters\x0a\x0aAdding new commandline parameters to `FileServer` is as easy as adding a new single parameter method to the `accessing` protocol.";
$core.addMethod(
$core.method({
selector: "base64Decode:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return (new Buffer(aString, 'base64').toString());
return self;
}, function($ctx1) {$ctx1.fill(self,"base64Decode:",{aString:aString},$globals.FileServer)});
},
args: ["aString"],
source: "base64Decode: aString\x0a\x09<return (new Buffer(aString, 'base64').toString())>",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "basePath",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@basePath"];
if(($receiver = $1) == null || $receiver.isNil){
return $recv(self._class())._defaultBasePath();
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"basePath",{},$globals.FileServer)});
},
args: [],
source: "basePath\x0a\x09^ basePath ifNil: [self class defaultBasePath]",
referencedClasses: [],
messageSends: ["ifNil:", "defaultBasePath", "class"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "basePath:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
self["@basePath"]=aString;
self._validateBasePath();
return self;
}, function($ctx1) {$ctx1.fill(self,"basePath:",{aString:aString},$globals.FileServer)});
},
args: ["aString"],
source: "basePath: aString\x0a\x09basePath := aString.\x0a\x09self validateBasePath.",
referencedClasses: [],
messageSends: ["validateBasePath"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "checkDirectoryLayout",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(self["@fs"])._existsSync_(self._withBasePath_("index.html"));
if(!$core.assert($1)){
$recv(console)._warn_("Warning: project directory does not contain index.html.");
$ctx1.sendIdx["warn:"]=1;
$recv(console)._warn_("    You can specify the directory containing index.html with --base-path.");
$ctx1.sendIdx["warn:"]=2;
$recv(console)._warn_("    You can also specify a page to be served by default,");
$ctx1.sendIdx["warn:"]=3;
$recv(console)._warn_("    for all paths that do not map to a file, with --fallback-page.");
};
return self;
}, function($ctx1) {$ctx1.fill(self,"checkDirectoryLayout",{},$globals.FileServer)});
},
args: [],
source: "checkDirectoryLayout\x0a\x09(fs existsSync:\x09(self withBasePath: 'index.html')) ifFalse: [\x0a\x09\x09console warn: 'Warning: project directory does not contain index.html.'.\x0a\x09\x09console warn: '    You can specify the directory containing index.html with --base-path.'.\x0a\x09\x09console warn: '    You can also specify a page to be served by default,'.\x0a\x09\x09console warn: '    for all paths that do not map to a file, with --fallback-page.'].",
referencedClasses: [],
messageSends: ["ifFalse:", "existsSync:", "withBasePath:", "warn:"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "fallbackPage",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@fallbackPage"];

},
args: [],
source: "fallbackPage\x0a\x09^ fallbackPage",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "fallbackPage:",
protocol: 'accessing',
fn: function (aString){
var self=this;
self["@fallbackPage"]=aString;
return self;

},
args: ["aString"],
source: "fallbackPage: aString\x0a\x09fallbackPage := aString",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "handleGETRequest:respondTo:",
protocol: 'request handling',
fn: function (aRequest,aResponse){
var self=this;
var uri,filename;
return $core.withContext(function($ctx1) {
var $1;
uri=$recv(self["@url"])._parse_($recv(aRequest)._url());
filename=$recv(self["@path"])._join_with_(self._basePath(),$recv(uri)._pathname());
$recv(self["@fs"])._exists_do_(filename,(function(aBoolean){
return $core.withContext(function($ctx2) {
if($core.assert(aBoolean)){
$1=$recv($recv(self["@fs"])._statSync_(filename))._isDirectory();
if($core.assert($1)){
return self._respondDirectoryNamed_from_to_(filename,uri,aResponse);
} else {
return self._respondFileNamed_to_(filename,aResponse);
};
} else {
return self._respondNotFoundTo_(aResponse);
};
}, function($ctx2) {$ctx2.fillBlock({aBoolean:aBoolean},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"handleGETRequest:respondTo:",{aRequest:aRequest,aResponse:aResponse,uri:uri,filename:filename},$globals.FileServer)});
},
args: ["aRequest", "aResponse"],
source: "handleGETRequest: aRequest respondTo: aResponse\x0a\x09| uri filename |\x0a\x09uri := url parse: aRequest url.\x0a\x09filename := path join: self basePath with: uri pathname.\x0a\x09fs exists: filename do: [:aBoolean |\x0a\x09\x09aBoolean\x0a\x09\x09\x09ifFalse: [self respondNotFoundTo: aResponse]\x0a\x09\x09\x09ifTrue: [(fs statSync: filename) isDirectory\x0a\x09\x09\x09\x09ifTrue: [self respondDirectoryNamed: filename from: uri to: aResponse]\x0a\x09\x09\x09\x09ifFalse: [self respondFileNamed: filename to: aResponse]]]",
referencedClasses: [],
messageSends: ["parse:", "url", "join:with:", "basePath", "pathname", "exists:do:", "ifFalse:ifTrue:", "respondNotFoundTo:", "ifTrue:ifFalse:", "isDirectory", "statSync:", "respondDirectoryNamed:from:to:", "respondFileNamed:to:"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "handleOPTIONSRequest:respondTo:",
protocol: 'request handling',
fn: function (aRequest,aResponse){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((200),$globals.HashedCollection._newFromPairs_(["Access-Control-Allow-Origin","*","Access-Control-Allow-Methods","GET, PUT, POST, DELETE, OPTIONS","Access-Control-Allow-Headers","Content-Type, Accept","Content-Length",(0),"Access-Control-Max-Age",(10)]));
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"handleOPTIONSRequest:respondTo:",{aRequest:aRequest,aResponse:aResponse},$globals.FileServer)});
},
args: ["aRequest", "aResponse"],
source: "handleOPTIONSRequest: aRequest respondTo: aResponse\x0a\x09aResponse writeHead: 200 options: #{'Access-Control-Allow-Origin' -> '*'.\x0a\x09\x09\x09\x09\x09'Access-Control-Allow-Methods' -> 'GET, PUT, POST, DELETE, OPTIONS'.\x0a\x09\x09\x09\x09\x09'Access-Control-Allow-Headers' -> 'Content-Type, Accept'.\x0a\x09\x09\x09\x09\x09'Content-Length' -> 0.\x0a\x09\x09\x09\x09\x09'Access-Control-Max-Age' -> 10}.\x0a\x09aResponse end",
referencedClasses: [],
messageSends: ["writeHead:options:", "end"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "handlePUTRequest:respondTo:",
protocol: 'request handling',
fn: function (aRequest,aResponse){
var self=this;
var file,stream;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
$1=self._isAuthenticated_(aRequest);
if(!$core.assert($1)){
self._respondAuthenticationRequiredTo_(aResponse);
return nil;
};
file=".".__comma($recv(aRequest)._url());
$ctx1.sendIdx[","]=1;
stream=$recv(self["@fs"])._createWriteStream_(file);
$recv(stream)._on_do_("error",(function(error){
return $core.withContext(function($ctx2) {
$2=console;
$3="Error creating WriteStream for file ".__comma(file);
$ctx2.sendIdx[","]=2;
$recv($2)._warn_($3);
$ctx2.sendIdx["warn:"]=1;
$recv(console)._warn_("    Did you forget to create the necessary directory in your project (often /src)?");
$ctx2.sendIdx["warn:"]=2;
$recv(console)._warn_("    The exact error is: ".__comma(error));
return self._respondNotCreatedTo_(aResponse);
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,2)});
}));
$ctx1.sendIdx["on:do:"]=1;
$recv(stream)._on_do_("close",(function(){
return $core.withContext(function($ctx2) {
return self._respondCreatedTo_(aResponse);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
$ctx1.sendIdx["on:do:"]=2;
$recv(aRequest)._setEncoding_("utf8");
$recv(aRequest)._on_do_("data",(function(data){
return $core.withContext(function($ctx2) {
return $recv(stream)._write_(data);
}, function($ctx2) {$ctx2.fillBlock({data:data},$ctx1,4)});
}));
$ctx1.sendIdx["on:do:"]=3;
$recv(aRequest)._on_do_("end",(function(){
return $core.withContext(function($ctx2) {
$4=$recv(stream)._writable();
if($core.assert($4)){
return $recv(stream)._end();
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"handlePUTRequest:respondTo:",{aRequest:aRequest,aResponse:aResponse,file:file,stream:stream},$globals.FileServer)});
},
args: ["aRequest", "aResponse"],
source: "handlePUTRequest: aRequest respondTo: aResponse\x0a\x09| file stream |\x0a\x09(self isAuthenticated: aRequest)\x0a\x09\x09ifFalse: [self respondAuthenticationRequiredTo: aResponse. ^ nil].\x0a\x0a\x09file := '.', aRequest url.\x0a\x09stream := fs createWriteStream: file.\x0a\x0a\x09stream on: 'error' do: [:error |\x0a\x09\x09console warn: 'Error creating WriteStream for file ', file.\x0a\x09\x09console warn: '    Did you forget to create the necessary directory in your project (often /src)?'.\x0a\x09\x09console warn: '    The exact error is: ', error.\x0a\x09\x09self respondNotCreatedTo: aResponse].\x0a\x0a\x09stream on: 'close' do: [\x0a\x09\x09self respondCreatedTo: aResponse].\x0a\x0a\x09aRequest setEncoding: 'utf8'.\x0a\x09aRequest on: 'data' do: [:data |\x0a\x09\x09stream write: data].\x0a\x0a\x09aRequest on: 'end' do: [\x0a\x09\x09stream writable ifTrue: [stream end]]",
referencedClasses: [],
messageSends: ["ifFalse:", "isAuthenticated:", "respondAuthenticationRequiredTo:", ",", "url", "createWriteStream:", "on:do:", "warn:", "respondNotCreatedTo:", "respondCreatedTo:", "setEncoding:", "write:", "ifTrue:", "writable", "end"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "handleRequest:respondTo:",
protocol: 'request handling',
fn: function (aRequest,aResponse){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$4,$3,$5;
$2=$recv(aRequest)._method();
$ctx1.sendIdx["method"]=1;
$1=$recv($2).__eq("PUT");
$ctx1.sendIdx["="]=1;
if($core.assert($1)){
self._handlePUTRequest_respondTo_(aRequest,aResponse);
};
$4=$recv(aRequest)._method();
$ctx1.sendIdx["method"]=2;
$3=$recv($4).__eq("GET");
$ctx1.sendIdx["="]=2;
if($core.assert($3)){
self._handleGETRequest_respondTo_(aRequest,aResponse);
};
$5=$recv($recv(aRequest)._method()).__eq("OPTIONS");
if($core.assert($5)){
self._handleOPTIONSRequest_respondTo_(aRequest,aResponse);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"handleRequest:respondTo:",{aRequest:aRequest,aResponse:aResponse},$globals.FileServer)});
},
args: ["aRequest", "aResponse"],
source: "handleRequest: aRequest respondTo: aResponse\x0a\x09aRequest method = 'PUT'\x0a\x09\x09ifTrue: [self handlePUTRequest: aRequest respondTo: aResponse].\x0a\x09aRequest method = 'GET'\x0a\x09\x09ifTrue:[self handleGETRequest: aRequest respondTo: aResponse].\x0a\x09aRequest method = 'OPTIONS'\x0a\x09\x09ifTrue:[self handleOPTIONSRequest: aRequest respondTo: aResponse]",
referencedClasses: [],
messageSends: ["ifTrue:", "=", "method", "handlePUTRequest:respondTo:", "handleGETRequest:respondTo:", "handleOPTIONSRequest:respondTo:"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "host",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@host"];

},
args: [],
source: "host\x0a\x09^ host",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "host:",
protocol: 'accessing',
fn: function (hostname){
var self=this;
self["@host"]=hostname;
return self;

},
args: ["hostname"],
source: "host: hostname\x0a\x09host := hostname",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
(
$ctx1.supercall = true,
($globals.FileServer.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@http"]=self._require_("http");
$ctx1.sendIdx["require:"]=1;
self["@util"]=self._require_("util");
$ctx1.sendIdx["require:"]=2;
self["@url"]=self._require_("url");
$1=self._class();
$ctx1.sendIdx["class"]=1;
self["@host"]=$recv($1)._defaultHost();
self["@port"]=$recv(self._class())._defaultPort();
self["@username"]=nil;
self["@password"]=nil;
self["@fallbackPage"]=nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.FileServer)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09http := self require: 'http'.\x0a\x09util := self require: 'util'.\x0a\x09url := self require: 'url'.\x0a\x09host := self class defaultHost.\x0a\x09port := self class defaultPort.\x0a\x09username := nil.\x0a\x09password := nil.\x0a\x09fallbackPage := nil.",
referencedClasses: [],
messageSends: ["initialize", "require:", "defaultHost", "class", "defaultPort"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "isAuthenticated:",
protocol: 'private',
fn: function (aRequest){
var self=this;
var header,token,auth,parts;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$4,$5,$6,$9,$10,$8,$7,$receiver;
$2=$recv(self["@username"])._isNil();
$ctx1.sendIdx["isNil"]=1;
$1=$recv($2)._and_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@password"])._isNil();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["and:"]=1;
if($core.assert($1)){
return true;
};
$3=$recv($recv(aRequest)._headers())._at_("authorization");
$ctx1.sendIdx["at:"]=1;
if(($receiver = $3) == null || $receiver.isNil){
header="";
} else {
header=$3;
};
$4=$recv(header)._isEmpty();
if($core.assert($4)){
return false;
} else {
$5=$recv(header)._tokenize_(" ");
$ctx1.sendIdx["tokenize:"]=1;
if(($receiver = $5) == null || $receiver.isNil){
token="";
} else {
token=$5;
};
token;
$6=$recv(token)._at_((2));
$ctx1.sendIdx["at:"]=2;
auth=self._base64Decode_($6);
auth;
parts=$recv(auth)._tokenize_(":");
parts;
$9=self["@username"];
$10=$recv(parts)._at_((1));
$ctx1.sendIdx["at:"]=3;
$8=$recv($9).__eq($10);
$ctx1.sendIdx["="]=1;
$7=$recv($8)._and_((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@password"]).__eq($recv(parts)._at_((2)));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,7)});
}));
if($core.assert($7)){
return true;
} else {
return false;
};
};
return self;
}, function($ctx1) {$ctx1.fill(self,"isAuthenticated:",{aRequest:aRequest,header:header,token:token,auth:auth,parts:parts},$globals.FileServer)});
},
args: ["aRequest"],
source: "isAuthenticated: aRequest\x0a\x09\x22Basic HTTP Auth: http://stackoverflow.com/a/5957629/293175\x0a\x09 and https://gist.github.com/1686663\x22\x0a\x09| header token auth parts|\x0a\x0a\x09(username isNil and: [password isNil]) ifTrue: [^ true].\x0a\x0a\x09\x22get authentication header\x22\x0a\x09header := (aRequest headers at: 'authorization') ifNil:[''].\x0a\x09(header isEmpty)\x0a\x09ifTrue: [^ false]\x0a\x09ifFalse: [\x0a\x09\x09\x22get authentication token\x22\x0a\x09\x09token := (header tokenize: ' ') ifNil:[''].\x0a\x09\x09\x22convert back from base64\x22\x0a\x09\x09auth := self base64Decode: (token at: 2).\x0a\x09\x09\x22split token at colon\x22\x0a\x09\x09parts := auth tokenize: ':'.\x0a\x0a\x09\x09((username = (parts at: 1)) and: [password = (parts at: 2)])\x0a\x09\x09\x09ifTrue: [^ true]\x0a\x09\x09\x09ifFalse: [^ false]\x0a\x09].",
referencedClasses: [],
messageSends: ["ifTrue:", "and:", "isNil", "ifNil:", "at:", "headers", "ifTrue:ifFalse:", "isEmpty", "tokenize:", "base64Decode:", "="]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "password:",
protocol: 'accessing',
fn: function (aPassword){
var self=this;
self["@password"]=aPassword;
return self;

},
args: ["aPassword"],
source: "password: aPassword\x0a\x09password := aPassword.",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "port",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@port"];

},
args: [],
source: "port\x0a\x09^ port",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "port:",
protocol: 'accessing',
fn: function (aNumber){
var self=this;
self["@port"]=aNumber;
return self;

},
args: ["aNumber"],
source: "port: aNumber\x0a\x09port := aNumber",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "require:",
protocol: 'private',
fn: function (aModuleString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(require)._value_(aModuleString);
}, function($ctx1) {$ctx1.fill(self,"require:",{aModuleString:aModuleString},$globals.FileServer)});
},
args: ["aModuleString"],
source: "require: aModuleString\x0a\x09\x22call to the require function\x22\x0a\x09^require value: aModuleString",
referencedClasses: [],
messageSends: ["value:"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondAuthenticationRequiredTo:",
protocol: 'request handling',
fn: function (aResponse){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((401),$globals.HashedCollection._newFromPairs_(["WWW-Authenticate","Basic realm=\x22Secured Developer Area\x22"]));
$recv(aResponse)._write_("<html><body>Authentication needed</body></html>");
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondAuthenticationRequiredTo:",{aResponse:aResponse},$globals.FileServer)});
},
args: ["aResponse"],
source: "respondAuthenticationRequiredTo: aResponse\x0a\x09aResponse\x0a\x09\x09writeHead: 401 options: #{'WWW-Authenticate' -> 'Basic realm=\x22Secured Developer Area\x22'};\x0a\x09\x09write: '<html><body>Authentication needed</body></html>';\x0a\x09\x09end.",
referencedClasses: [],
messageSends: ["writeHead:options:", "write:", "end"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondCreatedTo:",
protocol: 'request handling',
fn: function (aResponse){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((201),$globals.HashedCollection._newFromPairs_(["Content-Type","text/plain","Access-Control-Allow-Origin","*"]));
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondCreatedTo:",{aResponse:aResponse},$globals.FileServer)});
},
args: ["aResponse"],
source: "respondCreatedTo: aResponse\x0a\x09aResponse\x0a\x09\x09writeHead: 201 options: #{'Content-Type' -> 'text/plain'. 'Access-Control-Allow-Origin' -> '*'};\x0a\x09\x09end.",
referencedClasses: [],
messageSends: ["writeHead:options:", "end"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondDirectoryNamed:from:to:",
protocol: 'request handling',
fn: function (aDirname,aUrl,aResponse){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$3,$5,$7,$6,$4,$receiver;
$2=$recv(aUrl)._pathname();
$ctx1.sendIdx["pathname"]=1;
$1=$recv($2)._endsWith_("/");
if($core.assert($1)){
$3=$recv(aDirname).__comma("index.html");
$ctx1.sendIdx[","]=1;
self._respondFileNamed_to_($3,aResponse);
} else {
$5=$recv($recv(aUrl)._pathname()).__comma("/");
$7=$recv(aUrl)._search();
if(($receiver = $7) == null || $receiver.isNil){
$6="";
} else {
$6=$7;
};
$4=$recv($5).__comma($6);
$ctx1.sendIdx[","]=2;
self._respondRedirect_to_($4,aResponse);
};
return self;
}, function($ctx1) {$ctx1.fill(self,"respondDirectoryNamed:from:to:",{aDirname:aDirname,aUrl:aUrl,aResponse:aResponse},$globals.FileServer)});
},
args: ["aDirname", "aUrl", "aResponse"],
source: "respondDirectoryNamed: aDirname from: aUrl to: aResponse\x0a\x09(aUrl pathname endsWith: '/')\x0a\x09\x09ifTrue: [self respondFileNamed: aDirname, 'index.html' to: aResponse]\x0a\x09\x09ifFalse: [self respondRedirect: aUrl pathname, '/', (aUrl search ifNil: ['']) to: aResponse]",
referencedClasses: [],
messageSends: ["ifTrue:ifFalse:", "endsWith:", "pathname", "respondFileNamed:to:", ",", "respondRedirect:to:", "ifNil:", "search"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondFileNamed:to:",
protocol: 'request handling',
fn: function (aFilename,aResponse){
var self=this;
var type,filename;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
filename=aFilename;
$recv(self["@fs"])._readFile_do_(filename,(function(ex,file){
return $core.withContext(function($ctx2) {
$1=$recv(ex)._notNil();
if($core.assert($1)){
$2=console;
$3=$recv(filename).__comma(" does not exist");
$ctx2.sendIdx[","]=1;
$recv($2)._log_($3);
return self._respondNotFoundTo_(aResponse);
} else {
type=$recv(self._class())._mimeTypeFor_(filename);
type;
$4=$recv(type).__eq("application/javascript");
if($core.assert($4)){
type=$recv(type).__comma(";charset=utf-8");
type;
};
$recv(aResponse)._writeHead_options_((200),$globals.HashedCollection._newFromPairs_(["Content-Type",type]));
$recv(aResponse)._write_encoding_(file,"binary");
return $recv(aResponse)._end();
};
}, function($ctx2) {$ctx2.fillBlock({ex:ex,file:file},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"respondFileNamed:to:",{aFilename:aFilename,aResponse:aResponse,type:type,filename:filename},$globals.FileServer)});
},
args: ["aFilename", "aResponse"],
source: "respondFileNamed: aFilename to: aResponse\x0a\x09| type filename |\x0a\x0a\x09filename := aFilename.\x0a\x0a\x09fs readFile: filename do: [:ex :file |\x0a\x09\x09ex notNil \x0a\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09console log: filename, ' does not exist'.\x0a\x09\x09\x09\x09self respondNotFoundTo: aResponse]\x0a\x09\x09\x09ifFalse: [\x0a\x09\x09\x09\x09type := self class mimeTypeFor: filename.\x0a\x09\x09\x09\x09type = 'application/javascript'\x0a\x09\x09\x09\x09\x09ifTrue: [ type:=type,';charset=utf-8' ].\x0a\x09\x09\x09\x09aResponse \x0a\x09\x09\x09\x09\x09writeHead: 200 options:  #{'Content-Type' -> type};\x0a\x09\x09\x09\x09\x09write: file encoding: 'binary';\x0a\x09\x09\x09\x09\x09end]]",
referencedClasses: [],
messageSends: ["readFile:do:", "ifTrue:ifFalse:", "notNil", "log:", ",", "respondNotFoundTo:", "mimeTypeFor:", "class", "ifTrue:", "=", "writeHead:options:", "write:encoding:", "end"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondInternalErrorTo:",
protocol: 'request handling',
fn: function (aResponse){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((500),$globals.HashedCollection._newFromPairs_(["Content-Type","text/plain"]));
$recv(aResponse)._write_("500 Internal server error");
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondInternalErrorTo:",{aResponse:aResponse},$globals.FileServer)});
},
args: ["aResponse"],
source: "respondInternalErrorTo: aResponse\x0a\x09aResponse \x0a\x09\x09writeHead: 500 options: #{'Content-Type' -> 'text/plain'};\x0a\x09\x09write: '500 Internal server error';\x0a\x09\x09end",
referencedClasses: [],
messageSends: ["writeHead:options:", "write:", "end"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondNotCreatedTo:",
protocol: 'request handling',
fn: function (aResponse){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((400),$globals.HashedCollection._newFromPairs_(["Content-Type","text/plain"]));
$recv(aResponse)._write_("File could not be created. Did you forget to create the src directory on the server?");
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondNotCreatedTo:",{aResponse:aResponse},$globals.FileServer)});
},
args: ["aResponse"],
source: "respondNotCreatedTo: aResponse\x0a\x09aResponse\x0a\x09\x09writeHead: 400 options: #{'Content-Type' -> 'text/plain'};\x0a\x09\x09write: 'File could not be created. Did you forget to create the src directory on the server?';\x0a\x09\x09end.",
referencedClasses: [],
messageSends: ["writeHead:options:", "write:", "end"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondNotFoundTo:",
protocol: 'request handling',
fn: function (aResponse){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=self._fallbackPage();
$ctx1.sendIdx["fallbackPage"]=1;
$1=$recv($2)._isNil();
if(!$core.assert($1)){
return self._respondFileNamed_to_(self._fallbackPage(),aResponse);
};
$recv(aResponse)._writeHead_options_((404),$globals.HashedCollection._newFromPairs_(["Content-Type","text/html"]));
$recv(aResponse)._write_("<html><body><p>404 Not found</p>");
$ctx1.sendIdx["write:"]=1;
$recv(aResponse)._write_("<p>Did you forget to put an index.html file into the directory which is served by \x22bin/amber serve\x22? To solve this you can:<ul>");
$ctx1.sendIdx["write:"]=2;
$recv(aResponse)._write_("<li>create an index.html in the served directory.</li>");
$ctx1.sendIdx["write:"]=3;
$recv(aResponse)._write_("<li>can also specify the location of a page to be served whenever path does not resolve to a file with the \x22--fallback-page\x22 option.</li>");
$ctx1.sendIdx["write:"]=4;
$recv(aResponse)._write_("<li>change the directory to be served with the \x22--base-path\x22 option.</li>");
$ctx1.sendIdx["write:"]=5;
$recv(aResponse)._write_("</ul></p></body></html>");
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondNotFoundTo:",{aResponse:aResponse},$globals.FileServer)});
},
args: ["aResponse"],
source: "respondNotFoundTo: aResponse\x0a\x09self fallbackPage isNil ifFalse: [^self respondFileNamed: self fallbackPage to: aResponse].\x0a\x09aResponse \x0a\x09\x09writeHead: 404 options: #{'Content-Type' -> 'text/html'};\x0a\x09\x09write: '<html><body><p>404 Not found</p>';\x0a\x09\x09write: '<p>Did you forget to put an index.html file into the directory which is served by \x22bin/amber serve\x22? To solve this you can:<ul>';\x0a\x09\x09write: '<li>create an index.html in the served directory.</li>';\x0a\x09\x09write: '<li>can also specify the location of a page to be served whenever path does not resolve to a file with the \x22--fallback-page\x22 option.</li>';\x0a\x09\x09write: '<li>change the directory to be served with the \x22--base-path\x22 option.</li>';\x0a\x09\x09write: '</ul></p></body></html>';\x0a\x09\x09end",
referencedClasses: [],
messageSends: ["ifFalse:", "isNil", "fallbackPage", "respondFileNamed:to:", "writeHead:options:", "write:", "end"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondOKTo:",
protocol: 'request handling',
fn: function (aResponse){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((200),$globals.HashedCollection._newFromPairs_(["Content-Type","text/plain","Access-Control-Allow-Origin","*"]));
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondOKTo:",{aResponse:aResponse},$globals.FileServer)});
},
args: ["aResponse"],
source: "respondOKTo: aResponse\x0a\x09aResponse\x0a\x09\x09writeHead: 200 options: #{'Content-Type' -> 'text/plain'. 'Access-Control-Allow-Origin' -> '*'};\x0a\x09\x09end.",
referencedClasses: [],
messageSends: ["writeHead:options:", "end"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondRedirect:to:",
protocol: 'request handling',
fn: function (aString,aResponse){
var self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((303),$globals.HashedCollection._newFromPairs_(["Location",aString]));
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondRedirect:to:",{aString:aString,aResponse:aResponse},$globals.FileServer)});
},
args: ["aString", "aResponse"],
source: "respondRedirect: aString to: aResponse\x0a\x09aResponse\x0a\x09\x09writeHead: 303 options: #{'Location' -> aString};\x0a\x09\x09end.",
referencedClasses: [],
messageSends: ["writeHead:options:", "end"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "start",
protocol: 'starting',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$8,$7,$6,$10,$9,$5;
self._checkDirectoryLayout();
$1=$recv(self["@http"])._createServer_((function(request,response){
return $core.withContext(function($ctx2) {
return self._handleRequest_respondTo_(request,response);
}, function($ctx2) {$ctx2.fillBlock({request:request,response:response},$ctx1,1)});
}));
$recv($1)._on_do_("error",(function(error){
return $core.withContext(function($ctx2) {
$2=console;
$3="Error starting server: ".__comma(error);
$ctx2.sendIdx[","]=1;
return $recv($2)._log_($3);
$ctx2.sendIdx["log:"]=1;
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,2)});
}));
$ctx1.sendIdx["on:do:"]=1;
$recv($1)._on_do_("listening",(function(){
return $core.withContext(function($ctx2) {
$4=console;
$8=self._host();
$ctx2.sendIdx["host"]=1;
$7="Starting file server on http://".__comma($8);
$6=$recv($7).__comma(":");
$ctx2.sendIdx[","]=3;
$10=self._port();
$ctx2.sendIdx["port"]=1;
$9=$recv($10)._asString();
$5=$recv($6).__comma($9);
$ctx2.sendIdx[","]=2;
return $recv($4)._log_($5);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
$recv($1)._listen_host_(self._port(),self._host());
return self;
}, function($ctx1) {$ctx1.fill(self,"start",{},$globals.FileServer)});
},
args: [],
source: "start\x0a\x09\x22Checks if required directory layout is present (issue warning if not).\x0a\x09 Afterwards start the server.\x22\x0a\x09self checkDirectoryLayout.\x0a\x09(http createServer: [:request :response |\x0a\x09      self handleRequest: request respondTo: response])\x0a\x09      on: 'error' do: [:error | console log: 'Error starting server: ', error];\x0a\x09      on: 'listening' do: [console log: 'Starting file server on http://', self host, ':', self port asString];\x0a\x09      listen: self port host: self host.",
referencedClasses: [],
messageSends: ["checkDirectoryLayout", "on:do:", "createServer:", "handleRequest:respondTo:", "log:", ",", "host", "asString", "port", "listen:host:"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "startOn:",
protocol: 'starting',
fn: function (aPort){
var self=this;
return $core.withContext(function($ctx1) {
self._port_(aPort);
self._start();
return self;
}, function($ctx1) {$ctx1.fill(self,"startOn:",{aPort:aPort},$globals.FileServer)});
},
args: ["aPort"],
source: "startOn: aPort\x0a\x09self port: aPort.\x0a\x09self start",
referencedClasses: [],
messageSends: ["port:", "start"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "username:",
protocol: 'accessing',
fn: function (aUsername){
var self=this;
self["@username"]=aUsername;
return self;

},
args: ["aUsername"],
source: "username: aUsername\x0a\x09username := aUsername.",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "validateBasePath",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$7,$6,$5,$8,$9,$receiver;
$1=self["@fs"];
$2=self._basePath();
$ctx1.sendIdx["basePath"]=1;
$recv($1)._stat_then_($2,(function(err,stat){
return $core.withContext(function($ctx2) {
if(($receiver = err) == null || $receiver.isNil){
$3=$recv(stat)._isDirectory();
if(!$core.assert($3)){
$4=console;
$7=self._basePath();
$ctx2.sendIdx["basePath"]=2;
$6="Warning: --base-path parameter ".__comma($7);
$ctx2.sendIdx[","]=2;
$5=$recv($6).__comma(" is not a directory.");
$ctx2.sendIdx[","]=1;
return $recv($4)._warn_($5);
$ctx2.sendIdx["warn:"]=1;
};
} else {
$8=console;
$9=$recv("Warning: path at --base-path parameter ".__comma(self._basePath())).__comma(" does not exist.");
$ctx2.sendIdx[","]=3;
return $recv($8)._warn_($9);
};
}, function($ctx2) {$ctx2.fillBlock({err:err,stat:stat},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"validateBasePath",{},$globals.FileServer)});
},
args: [],
source: "validateBasePath\x0a\x09\x22The basePath must be an existing directory. \x22\x0a\x09fs stat: self basePath then: [ :err :stat | err\x0a\x09\x09ifNil: [ stat isDirectory ifFalse: [ console warn: 'Warning: --base-path parameter ' , self basePath , ' is not a directory.' ]]\x0a\x09\x09ifNotNil: [ console warn: 'Warning: path at --base-path parameter ' , self basePath , ' does not exist.'  ]].",
referencedClasses: [],
messageSends: ["stat:then:", "basePath", "ifNil:ifNotNil:", "ifFalse:", "isDirectory", "warn:", ","]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "withBasePath:",
protocol: 'private',
fn: function (aBaseRelativePath){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self["@path"])._join_with_(self._basePath(),aBaseRelativePath);
}, function($ctx1) {$ctx1.fill(self,"withBasePath:",{aBaseRelativePath:aBaseRelativePath},$globals.FileServer)});
},
args: ["aBaseRelativePath"],
source: "withBasePath: aBaseRelativePath\x0a\x09\x22return a file path which is relative to the basePath.\x22\x0a\x09^ path join: self basePath with: aBaseRelativePath",
referencedClasses: [],
messageSends: ["join:with:", "basePath"]
}),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "writeData:toFileNamed:",
protocol: 'private',
fn: function (data,aFilename){
var self=this;
return $core.withContext(function($ctx1) {
$recv(console)._log_(aFilename);
return self;
}, function($ctx1) {$ctx1.fill(self,"writeData:toFileNamed:",{data:data,aFilename:aFilename},$globals.FileServer)});
},
args: ["data", "aFilename"],
source: "writeData: data toFileNamed: aFilename\x0a\x09console log: aFilename",
referencedClasses: [],
messageSends: ["log:"]
}),
$globals.FileServer);


$globals.FileServer.klass.iVarNames = ['mimeTypes'];
$core.addMethod(
$core.method({
selector: "commandLineSwitches",
protocol: 'accessing',
fn: function (){
var self=this;
var switches;
return $core.withContext(function($ctx1) {
switches=$recv(self._methodsInProtocol_("accessing"))._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._selector();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["collect:"]=1;
switches=$recv(switches)._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._match_("^[^:]*:$");
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
switches=$recv(switches)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv($recv($recv(each)._allButLast())._replace_with_("([A-Z])","-$1"))._asLowercase())._replace_with_("^([a-z])","--$1");
$ctx2.sendIdx["replace:with:"]=1;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
return switches;
}, function($ctx1) {$ctx1.fill(self,"commandLineSwitches",{switches:switches},$globals.FileServer.klass)});
},
args: [],
source: "commandLineSwitches\x0a\x09\x22Collect all methodnames from the 'accessing' protocol\x0a\x09 and select the ones with only one parameter.\x0a\x09 Then remove the ':' at the end of the name\x0a\x09 and add a '--' at the beginning.\x0a\x09 Additionally all uppercase letters are made lowercase and preceded by a '-'.\x0a\x09 Example: fallbackPage: becomes --fallback-page.\x0a\x09 Return the Array containing the commandline switches.\x22\x0a\x09| switches |\x0a\x09switches := ((self methodsInProtocol: 'accessing') collect: [ :each | each selector]).\x0a\x09switches := switches select: [ :each | each match: '^[^:]*:$'].\x0a\x09switches :=switches collect: [ :each |\x0a\x09\x09(each allButLast replace: '([A-Z])' with: '-$1') asLowercase replace: '^([a-z])' with: '--$1' ].\x0a\x09^ switches",
referencedClasses: [],
messageSends: ["collect:", "methodsInProtocol:", "selector", "select:", "match:", "replace:with:", "asLowercase", "allButLast"]
}),
$globals.FileServer.klass);

$core.addMethod(
$core.method({
selector: "createServerWithArguments:",
protocol: 'initialization',
fn: function (options){
var self=this;
var server,popFront,front,optionName,optionValue,switches;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$8;
var $early={};
try {
switches=self._commandLineSwitches();
server=self._new();
$recv(options)._ifEmpty_((function(){
throw $early=[server];

}));
$1=$recv($recv(options)._size())._even();
if(!$core.assert($1)){
$recv(console)._log_("Using default parameters.");
$ctx1.sendIdx["log:"]=1;
$2=console;
$3="Wrong commandline options or not enough arguments for: ".__comma(options);
$ctx1.sendIdx[","]=1;
$recv($2)._log_($3);
$ctx1.sendIdx["log:"]=2;
$4=console;
$5="Use any of the following ones: ".__comma(switches);
$ctx1.sendIdx[","]=2;
$recv($4)._log_($5);
$ctx1.sendIdx["log:"]=3;
return server;
};
popFront=(function(args){
return $core.withContext(function($ctx2) {
front=$recv(args)._first();
front;
$recv(args)._remove_(front);
return front;
}, function($ctx2) {$ctx2.fillBlock({args:args},$ctx1,3)});
});
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(options)._notEmpty();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
optionName=$recv(popFront)._value_(options);
$ctx2.sendIdx["value:"]=1;
optionName;
optionValue=$recv(popFront)._value_(options);
optionValue;
$6=$recv(switches)._includes_(optionName);
if($core.assert($6)){
optionName=self._selectorForCommandLineSwitch_(optionName);
optionName;
return $recv(server)._perform_withArguments_(optionName,$recv($globals.Array)._with_(optionValue));
} else {
$7=console;
$8=$recv(optionName).__comma(" is not a valid commandline option");
$ctx2.sendIdx[","]=3;
$recv($7)._log_($8);
$ctx2.sendIdx["log:"]=4;
return $recv(console)._log_("Use any of the following ones: ".__comma(switches));
};
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}));
return server;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"createServerWithArguments:",{options:options,server:server,popFront:popFront,front:front,optionName:optionName,optionValue:optionValue,switches:switches},$globals.FileServer.klass)});
},
args: ["options"],
source: "createServerWithArguments: options\x0a\x09\x22If options are empty return a default FileServer instance.\x0a\x09 If options are given loop through them and set the passed in values\x0a\x09 on the FileServer instance.\x0a\x09 \x0a\x09 Commanline options map directly to methods in the 'accessing' protocol\x0a\x09 taking one parameter.\x0a\x09 Adding a method to this protocol makes it directly settable through\x0a\x09 command line options.\x0a\x09 \x22\x0a\x09| server popFront front optionName optionValue switches |\x0a\x0a\x09switches := self commandLineSwitches.\x0a\x0a\x09server := self new.\x0a\x0a\x09options ifEmpty: [^server].\x0a\x0a\x09(options size even) ifFalse: [\x0a\x09\x09console log: 'Using default parameters.'.\x0a\x09\x09console log: 'Wrong commandline options or not enough arguments for: ' , options.\x0a\x09\x09console log: 'Use any of the following ones: ', switches.\x0a\x09\x09^server].\x0a\x0a\x09popFront := [:args |\x0a\x09\x09front := args first.\x0a\x09\x09args remove: front.\x0a\x09\x09front].\x0a\x0a\x09[options notEmpty] whileTrue: [\x0a\x09\x09optionName  := popFront value: options.\x0a\x09\x09optionValue := popFront value: options.\x0a\x0a\x09\x09(switches includes: optionName) ifTrue: [\x0a\x09\x09\x09optionName := self selectorForCommandLineSwitch: optionName.\x0a\x09\x09\x09server perform: optionName withArguments: (Array with: optionValue)]\x0a\x09\x09\x09ifFalse: [\x0a\x09\x09\x09\x09console log: optionName, ' is not a valid commandline option'.\x0a\x09\x09\x09\x09console log: 'Use any of the following ones: ', switches ]].\x0a\x09^ server.",
referencedClasses: ["Array"],
messageSends: ["commandLineSwitches", "new", "ifEmpty:", "ifFalse:", "even", "size", "log:", ",", "first", "remove:", "whileTrue:", "notEmpty", "value:", "ifTrue:ifFalse:", "includes:", "selectorForCommandLineSwitch:", "perform:withArguments:", "with:"]
}),
$globals.FileServer.klass);

$core.addMethod(
$core.method({
selector: "defaultBasePath",
protocol: 'accessing',
fn: function (){
var self=this;
return "./";

},
args: [],
source: "defaultBasePath\x0a\x09^ './'",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer.klass);

$core.addMethod(
$core.method({
selector: "defaultHost",
protocol: 'accessing',
fn: function (){
var self=this;
return "127.0.0.1";

},
args: [],
source: "defaultHost\x0a\x09^ '127.0.0.1'",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer.klass);

$core.addMethod(
$core.method({
selector: "defaultMimeTypes",
protocol: 'accessing',
fn: function (){
var self=this;
return $globals.HashedCollection._newFromPairs_(["%","application/x-trash","323","text/h323","abw","application/x-abiword","ai","application/postscript","aif","audio/x-aiff","aifc","audio/x-aiff","aiff","audio/x-aiff","alc","chemical/x-alchemy","art","image/x-jg","asc","text/plain","asf","video/x-ms-asf","asn","chemical/x-ncbi-asn1-spec","aso","chemical/x-ncbi-asn1-binary","asx","video/x-ms-asf","au","audio/basic","avi","video/x-msvideo","b","chemical/x-molconn-Z","bak","application/x-trash","bat","application/x-msdos-program","bcpio","application/x-bcpio","bib","text/x-bibtex","bin","application/octet-stream","bmp","image/x-ms-bmp","book","application/x-maker","bsd","chemical/x-crossfire","c","text/x-csrc","c++","text/x-c++src","c3d","chemical/x-chem3d","cac","chemical/x-cache","cache","chemical/x-cache","cascii","chemical/x-cactvs-binary","cat","application/vnd.ms-pki.seccat","cbin","chemical/x-cactvs-binary","cc","text/x-c++src","cdf","application/x-cdf","cdr","image/x-coreldraw","cdt","image/x-coreldrawtemplate","cdx","chemical/x-cdx","cdy","application/vnd.cinderella","cef","chemical/x-cxf","cer","chemical/x-cerius","chm","chemical/x-chemdraw","chrt","application/x-kchart","cif","chemical/x-cif","class","application/java-vm","cls","text/x-tex","cmdf","chemical/x-cmdf","cml","chemical/x-cml","cod","application/vnd.rim.cod","com","application/x-msdos-program","cpa","chemical/x-compass","cpio","application/x-cpio","cpp","text/x-c++src","cpt","image/x-corelphotopaint","crl","application/x-pkcs7-crl","crt","application/x-x509-ca-cert","csf","chemical/x-cache-csf","csh","text/x-csh","csm","chemical/x-csml","csml","chemical/x-csml","css","text/css","csv","text/comma-separated-values","ctab","chemical/x-cactvs-binary","ctx","chemical/x-ctx","cu","application/cu-seeme","cub","chemical/x-gaussian-cube","cxf","chemical/x-cxf","cxx","text/x-c++src","dat","chemical/x-mopac-input","dcr","application/x-director","deb","application/x-debian-package","dif","video/dv","diff","text/plain","dir","application/x-director","djv","image/vnd.djvu","djvu","image/vnd.djvu","dl","video/dl","dll","application/x-msdos-program","dmg","application/x-apple-diskimage","dms","application/x-dms","doc","application/msword","dot","application/msword","dv","video/dv","dvi","application/x-dvi","dx","chemical/x-jcamp-dx","dxr","application/x-director","emb","chemical/x-embl-dl-nucleotide","embl","chemical/x-embl-dl-nucleotide","ent","chemical/x-pdb","eps","application/postscript","etx","text/x-setext","exe","application/x-msdos-program","ez","application/andrew-inset","fb","application/x-maker","fbdoc","application/x-maker","fch","chemical/x-gaussian-checkpoint","fchk","chemical/x-gaussian-checkpoint","fig","application/x-xfig","flac","application/x-flac","fli","video/fli","fm","application/x-maker","frame","application/x-maker","frm","application/x-maker","gal","chemical/x-gaussian-log","gam","chemical/x-gamess-input","gamin","chemical/x-gamess-input","gau","chemical/x-gaussian-input","gcd","text/x-pcs-gcd","gcf","application/x-graphing-calculator","gcg","chemical/x-gcg8-sequence","gen","chemical/x-genbank","gf","application/x-tex-gf","gif","image/gif","gjc","chemical/x-gaussian-input","gjf","chemical/x-gaussian-input","gl","video/gl","gnumeric","application/x-gnumeric","gpt","chemical/x-mopac-graph","gsf","application/x-font","gsm","audio/x-gsm","gtar","application/x-gtar","h","text/x-chdr","h++","text/x-c++hdr","hdf","application/x-hdf","hh","text/x-c++hdr","hin","chemical/x-hin","hpp","text/x-c++hdr","hqx","application/mac-binhex40","hs","text/x-haskell","hta","application/hta","htc","text/x-component","htm","text/html","html","text/html","hxx","text/x-c++hdr","ica","application/x-ica","ice","x-conference/x-cooltalk","ico","image/x-icon","ics","text/calendar","icz","text/calendar","ief","image/ief","iges","model/iges","igs","model/iges","iii","application/x-iphone","inp","chemical/x-gamess-input","ins","application/x-internet-signup","iso","application/x-iso9660-image","isp","application/x-internet-signup","ist","chemical/x-isostar","istr","chemical/x-isostar","jad","text/vnd.sun.j2me.app-descriptor","jar","application/java-archive","java","text/x-java","jdx","chemical/x-jcamp-dx","jmz","application/x-jmol","jng","image/x-jng","jnlp","application/x-java-jnlp-file","jpe","image/jpeg","jpeg","image/jpeg","jpg","image/jpeg","js","application/javascript","kar","audio/midi","key","application/pgp-keys","kil","application/x-killustrator","kin","chemical/x-kinemage","kpr","application/x-kpresenter","kpt","application/x-kpresenter","ksp","application/x-kspread","kwd","application/x-kword","kwt","application/x-kword","latex","application/x-latex","lha","application/x-lha","lhs","text/x-literate-haskell","lsf","video/x-la-asf","lsx","video/x-la-asf","ltx","text/x-tex","lzh","application/x-lzh","lzx","application/x-lzx","m3u","audio/x-mpegurl","m4a","audio/mpeg","maker","application/x-maker","man","application/x-troff-man","mcif","chemical/x-mmcif","mcm","chemical/x-macmolecule","mdb","application/msaccess","me","application/x-troff-me","mesh","model/mesh","mid","audio/midi","midi","audio/midi","mif","application/x-mif","mm","application/x-freemind","mmd","chemical/x-macromodel-input","mmf","application/vnd.smaf","mml","text/mathml","mmod","chemical/x-macromodel-input","mng","video/x-mng","moc","text/x-moc","mol","chemical/x-mdl-molfile","mol2","chemical/x-mol2","moo","chemical/x-mopac-out","mop","chemical/x-mopac-input","mopcrt","chemical/x-mopac-input","mov","video/quicktime","movie","video/x-sgi-movie","mp2","audio/mpeg","mp3","audio/mpeg","mp4","video/mp4","mpc","chemical/x-mopac-input","mpe","video/mpeg","mpeg","video/mpeg","mpega","audio/mpeg","mpg","video/mpeg","mpga","audio/mpeg","ms","application/x-troff-ms","msh","model/mesh","msi","application/x-msi","mvb","chemical/x-mopac-vib","mxu","video/vnd.mpegurl","nb","application/mathematica","nc","application/x-netcdf","nwc","application/x-nwc","o","application/x-object","oda","application/oda","odb","application/vnd.oasis.opendocument.database","odc","application/vnd.oasis.opendocument.chart","odf","application/vnd.oasis.opendocument.formula","odg","application/vnd.oasis.opendocument.graphics","odi","application/vnd.oasis.opendocument.image","odm","application/vnd.oasis.opendocument.text-master","odp","application/vnd.oasis.opendocument.presentation","ods","application/vnd.oasis.opendocument.spreadsheet","odt","application/vnd.oasis.opendocument.text","ogg","application/ogg","old","application/x-trash","oth","application/vnd.oasis.opendocument.text-web","oza","application/x-oz-application","p","text/x-pascal","p7r","application/x-pkcs7-certreqresp","pac","application/x-ns-proxy-autoconfig","pas","text/x-pascal","pat","image/x-coreldrawpattern","pbm","image/x-portable-bitmap","pcf","application/x-font","pcf.Z","application/x-font","pcx","image/pcx","pdb","chemical/x-pdb","pdf","application/pdf","pfa","application/x-font","pfb","application/x-font","pgm","image/x-portable-graymap","pgn","application/x-chess-pgn","pgp","application/pgp-signature","pk","application/x-tex-pk","pl","text/x-perl","pls","audio/x-scpls","pm","text/x-perl","png","image/png","pnm","image/x-portable-anymap","pot","text/plain","ppm","image/x-portable-pixmap","pps","application/vnd.ms-powerpoint","ppt","application/vnd.ms-powerpoint","prf","application/pics-rules","prt","chemical/x-ncbi-asn1-ascii","ps","application/postscript","psd","image/x-photoshop","psp","text/x-psp","py","text/x-python","pyc","application/x-python-code","pyo","application/x-python-code","qt","video/quicktime","qtl","application/x-quicktimeplayer","ra","audio/x-realaudio","ram","audio/x-pn-realaudio","rar","application/rar","ras","image/x-cmu-raster","rd","chemical/x-mdl-rdfile","rdf","application/rdf+xml","rgb","image/x-rgb","rm","audio/x-pn-realaudio","roff","application/x-troff","ros","chemical/x-rosdal","rpm","application/x-redhat-package-manager","rss","application/rss+xml","rtf","text/rtf","rtx","text/richtext","rxn","chemical/x-mdl-rxnfile","sct","text/scriptlet","sd","chemical/x-mdl-sdfile","sd2","audio/x-sd2","sda","application/vnd.stardivision.draw","sdc","application/vnd.stardivision.calc","sdd","application/vnd.stardivision.impress","sdf","chemical/x-mdl-sdfile","sdp","application/vnd.stardivision.impress","sdw","application/vnd.stardivision.writer","ser","application/java-serialized-object","sgf","application/x-go-sgf","sgl","application/vnd.stardivision.writer-global","sh","text/x-sh","shar","application/x-shar","shtml","text/html","sid","audio/prs.sid","sik","application/x-trash","silo","model/mesh","sis","application/vnd.symbian.install","sit","application/x-stuffit","skd","application/x-koan","skm","application/x-koan","skp","application/x-koan","skt","application/x-koan","smf","application/vnd.stardivision.math","smi","application/smil","smil","application/smil","snd","audio/basic","spc","chemical/x-galactic-spc","spl","application/x-futuresplash","src","application/x-wais-source","stc","application/vnd.sun.xml.calc.template","std","application/vnd.sun.xml.draw.template","sti","application/vnd.sun.xml.impress.template","stl","application/vnd.ms-pki.stl","stw","application/vnd.sun.xml.writer.template","sty","text/x-tex","sv4cpio","application/x-sv4cpio","sv4crc","application/x-sv4crc","svg","image/svg+xml","svgz","image/svg+xml","sw","chemical/x-swissprot","swf","application/x-shockwave-flash","swfl","application/x-shockwave-flash","sxc","application/vnd.sun.xml.calc","sxd","application/vnd.sun.xml.draw","sxg","application/vnd.sun.xml.writer.global","sxi","application/vnd.sun.xml.impress","sxm","application/vnd.sun.xml.math","sxw","application/vnd.sun.xml.writer","t","application/x-troff","tar","application/x-tar","taz","application/x-gtar","tcl","text/x-tcl","tex","text/x-tex","texi","application/x-texinfo","texinfo","application/x-texinfo","text","text/plain","tgf","chemical/x-mdl-tgf","tgz","application/x-gtar","tif","image/tiff","tiff","image/tiff","tk","text/x-tcl","tm","text/texmacs","torrent","application/x-bittorrent","tr","application/x-troff","ts","text/texmacs","tsp","application/dsptype","tsv","text/tab-separated-values","txt","text/plain","udeb","application/x-debian-package","uls","text/iuls","ustar","application/x-ustar","val","chemical/x-ncbi-asn1-binary","vcd","application/x-cdlink","vcf","text/x-vcard","vcs","text/x-vcalendar","vmd","chemical/x-vmd","vms","chemical/x-vamas-iso14976","vor","application/vnd.stardivision.writer","vrm","x-world/x-vrml","vrml","x-world/x-vrml","vsd","application/vnd.visio","wad","application/x-doom","wav","audio/x-wav","wax","audio/x-ms-wax","wbmp","image/vnd.wap.wbmp","wbxml","application/vnd.wap.wbxml","wk","application/x-123","wm","video/x-ms-wm","wma","audio/x-ms-wma","wmd","application/x-ms-wmd","wml","text/vnd.wap.wml","wmlc","application/vnd.wap.wmlc","wmls","text/vnd.wap.wmlscript","wmlsc","application/vnd.wap.wmlscriptc","wmv","video/x-ms-wmv","wmx","video/x-ms-wmx","wmz","application/x-ms-wmz","wp5","application/wordperfect5.1","wpd","application/wordperfect","wrl","x-world/x-vrml","wsc","text/scriptlet","wvx","video/x-ms-wvx","wz","application/x-wingz","xbm","image/x-xbitmap","xcf","application/x-xcf","xht","application/xhtml+xml","xhtml","application/xhtml+xml","xlb","application/vnd.ms-excel","xls","application/vnd.ms-excel","xlt","application/vnd.ms-excel","xml","application/xml","xpi","application/x-xpinstall","xpm","image/x-xpixmap","xsl","application/xml","xtel","chemical/x-xtel","xul","application/vnd.mozilla.xul+xml","xwd","image/x-xwindowdump","xyz","chemical/x-xyz","zip","application/zip","zmt","chemical/x-mopac-input","~","application/x-trash"]);

},
args: [],
source: "defaultMimeTypes\x0a\x09^ #{\x0a\x09\x09'%' -> 'application/x-trash'.\x0a\x09\x09'323' -> 'text/h323'.\x0a\x09\x09'abw' -> 'application/x-abiword'.\x0a\x09\x09'ai' -> 'application/postscript'.\x0a\x09\x09'aif' -> 'audio/x-aiff'.\x0a\x09\x09'aifc' -> 'audio/x-aiff'.\x0a\x09\x09'aiff' -> 'audio/x-aiff'.\x0a\x09\x09'alc' -> 'chemical/x-alchemy'.\x0a\x09\x09'art' -> 'image/x-jg'.\x0a\x09\x09'asc' -> 'text/plain'.\x0a\x09\x09'asf' -> 'video/x-ms-asf'.\x0a\x09\x09'asn' -> 'chemical/x-ncbi-asn1-spec'.\x0a\x09\x09'aso' -> 'chemical/x-ncbi-asn1-binary'.\x0a\x09\x09'asx' -> 'video/x-ms-asf'.\x0a\x09\x09'au' -> 'audio/basic'.\x0a\x09\x09'avi' -> 'video/x-msvideo'.\x0a\x09\x09'b' -> 'chemical/x-molconn-Z'.\x0a\x09\x09'bak' -> 'application/x-trash'.\x0a\x09\x09'bat' -> 'application/x-msdos-program'.\x0a\x09\x09'bcpio' -> 'application/x-bcpio'.\x0a\x09\x09'bib' -> 'text/x-bibtex'.\x0a\x09\x09'bin' -> 'application/octet-stream'.\x0a\x09\x09'bmp' -> 'image/x-ms-bmp'.\x0a\x09\x09'book' -> 'application/x-maker'.\x0a\x09\x09'bsd' -> 'chemical/x-crossfire'.\x0a\x09\x09'c' -> 'text/x-csrc'.\x0a\x09\x09'c++' -> 'text/x-c++src'.\x0a\x09\x09'c3d' -> 'chemical/x-chem3d'.\x0a\x09\x09'cac' -> 'chemical/x-cache'.\x0a\x09\x09'cache' -> 'chemical/x-cache'.\x0a\x09\x09'cascii' -> 'chemical/x-cactvs-binary'.\x0a\x09\x09'cat' -> 'application/vnd.ms-pki.seccat'.\x0a\x09\x09'cbin' -> 'chemical/x-cactvs-binary'.\x0a\x09\x09'cc' -> 'text/x-c++src'.\x0a\x09\x09'cdf' -> 'application/x-cdf'.\x0a\x09\x09'cdr' -> 'image/x-coreldraw'.\x0a\x09\x09'cdt' -> 'image/x-coreldrawtemplate'.\x0a\x09\x09'cdx' -> 'chemical/x-cdx'.\x0a\x09\x09'cdy' -> 'application/vnd.cinderella'.\x0a\x09\x09'cef' -> 'chemical/x-cxf'.\x0a\x09\x09'cer' -> 'chemical/x-cerius'.\x0a\x09\x09'chm' -> 'chemical/x-chemdraw'.\x0a\x09\x09'chrt' -> 'application/x-kchart'.\x0a\x09\x09'cif' -> 'chemical/x-cif'.\x0a\x09\x09'class' -> 'application/java-vm'.\x0a\x09\x09'cls' -> 'text/x-tex'.\x0a\x09\x09'cmdf' -> 'chemical/x-cmdf'.\x0a\x09\x09'cml' -> 'chemical/x-cml'.\x0a\x09\x09'cod' -> 'application/vnd.rim.cod'.\x0a\x09\x09'com' -> 'application/x-msdos-program'.\x0a\x09\x09'cpa' -> 'chemical/x-compass'.\x0a\x09\x09'cpio' -> 'application/x-cpio'.\x0a\x09\x09'cpp' -> 'text/x-c++src'.\x0a\x09\x09'cpt' -> 'image/x-corelphotopaint'.\x0a\x09\x09'crl' -> 'application/x-pkcs7-crl'.\x0a\x09\x09'crt' -> 'application/x-x509-ca-cert'.\x0a\x09\x09'csf' -> 'chemical/x-cache-csf'.\x0a\x09\x09'csh' -> 'text/x-csh'.\x0a\x09\x09'csm' -> 'chemical/x-csml'.\x0a\x09\x09'csml' -> 'chemical/x-csml'.\x0a\x09\x09'css' -> 'text/css'.\x0a\x09\x09'csv' -> 'text/comma-separated-values'.\x0a\x09\x09'ctab' -> 'chemical/x-cactvs-binary'.\x0a\x09\x09'ctx' -> 'chemical/x-ctx'.\x0a\x09\x09'cu' -> 'application/cu-seeme'.\x0a\x09\x09'cub' -> 'chemical/x-gaussian-cube'.\x0a\x09\x09'cxf' -> 'chemical/x-cxf'.\x0a\x09\x09'cxx' -> 'text/x-c++src'.\x0a\x09\x09'dat' -> 'chemical/x-mopac-input'.\x0a\x09\x09'dcr' -> 'application/x-director'.\x0a\x09\x09'deb' -> 'application/x-debian-package'.\x0a\x09\x09'dif' -> 'video/dv'.\x0a\x09\x09'diff' -> 'text/plain'.\x0a\x09\x09'dir' -> 'application/x-director'.\x0a\x09\x09'djv' -> 'image/vnd.djvu'.\x0a\x09\x09'djvu' -> 'image/vnd.djvu'.\x0a\x09\x09'dl' -> 'video/dl'.\x0a\x09\x09'dll' -> 'application/x-msdos-program'.\x0a\x09\x09'dmg' -> 'application/x-apple-diskimage'.\x0a\x09\x09'dms' -> 'application/x-dms'.\x0a\x09\x09'doc' -> 'application/msword'.\x0a\x09\x09'dot' -> 'application/msword'.\x0a\x09\x09'dv' -> 'video/dv'.\x0a\x09\x09'dvi' -> 'application/x-dvi'.\x0a\x09\x09'dx' -> 'chemical/x-jcamp-dx'.\x0a\x09\x09'dxr' -> 'application/x-director'.\x0a\x09\x09'emb' -> 'chemical/x-embl-dl-nucleotide'.\x0a\x09\x09'embl' -> 'chemical/x-embl-dl-nucleotide'.\x0a\x09\x09'ent' -> 'chemical/x-pdb'.\x0a\x09\x09'eps' -> 'application/postscript'.\x0a\x09\x09'etx' -> 'text/x-setext'.\x0a\x09\x09'exe' -> 'application/x-msdos-program'.\x0a\x09\x09'ez' -> 'application/andrew-inset'.\x0a\x09\x09'fb' -> 'application/x-maker'.\x0a\x09\x09'fbdoc' -> 'application/x-maker'.\x0a\x09\x09'fch' -> 'chemical/x-gaussian-checkpoint'.\x0a\x09\x09'fchk' -> 'chemical/x-gaussian-checkpoint'.\x0a\x09\x09'fig' -> 'application/x-xfig'.\x0a\x09\x09'flac' -> 'application/x-flac'.\x0a\x09\x09'fli' -> 'video/fli'.\x0a\x09\x09'fm' -> 'application/x-maker'.\x0a\x09\x09'frame' -> 'application/x-maker'.\x0a\x09\x09'frm' -> 'application/x-maker'.\x0a\x09\x09'gal' -> 'chemical/x-gaussian-log'.\x0a\x09\x09'gam' -> 'chemical/x-gamess-input'.\x0a\x09\x09'gamin' -> 'chemical/x-gamess-input'.\x0a\x09\x09'gau' -> 'chemical/x-gaussian-input'.\x0a\x09\x09'gcd' -> 'text/x-pcs-gcd'.\x0a\x09\x09'gcf' -> 'application/x-graphing-calculator'.\x0a\x09\x09'gcg' -> 'chemical/x-gcg8-sequence'.\x0a\x09\x09'gen' -> 'chemical/x-genbank'.\x0a\x09\x09'gf' -> 'application/x-tex-gf'.\x0a\x09\x09'gif' -> 'image/gif'.\x0a\x09\x09'gjc' -> 'chemical/x-gaussian-input'.\x0a\x09\x09'gjf' -> 'chemical/x-gaussian-input'.\x0a\x09\x09'gl' -> 'video/gl'.\x0a\x09\x09'gnumeric' -> 'application/x-gnumeric'.\x0a\x09\x09'gpt' -> 'chemical/x-mopac-graph'.\x0a\x09\x09'gsf' -> 'application/x-font'.\x0a\x09\x09'gsm' -> 'audio/x-gsm'.\x0a\x09\x09'gtar' -> 'application/x-gtar'.\x0a\x09\x09'h' -> 'text/x-chdr'.\x0a\x09\x09'h++' -> 'text/x-c++hdr'.\x0a\x09\x09'hdf' -> 'application/x-hdf'.\x0a\x09\x09'hh' -> 'text/x-c++hdr'.\x0a\x09\x09'hin' -> 'chemical/x-hin'.\x0a\x09\x09'hpp' -> 'text/x-c++hdr'.\x0a\x09\x09'hqx' -> 'application/mac-binhex40'.\x0a\x09\x09'hs' -> 'text/x-haskell'.\x0a\x09\x09'hta' -> 'application/hta'.\x0a\x09\x09'htc' -> 'text/x-component'.\x0a\x09\x09'htm' -> 'text/html'.\x0a\x09\x09'html' -> 'text/html'.\x0a\x09\x09'hxx' -> 'text/x-c++hdr'.\x0a\x09\x09'ica' -> 'application/x-ica'.\x0a\x09\x09'ice' -> 'x-conference/x-cooltalk'.\x0a\x09\x09'ico' -> 'image/x-icon'.\x0a\x09\x09'ics' -> 'text/calendar'.\x0a\x09\x09'icz' -> 'text/calendar'.\x0a\x09\x09'ief' -> 'image/ief'.\x0a\x09\x09'iges' -> 'model/iges'.\x0a\x09\x09'igs' -> 'model/iges'.\x0a\x09\x09'iii' -> 'application/x-iphone'.\x0a\x09\x09'inp' -> 'chemical/x-gamess-input'.\x0a\x09\x09'ins' -> 'application/x-internet-signup'.\x0a\x09\x09'iso' -> 'application/x-iso9660-image'.\x0a\x09\x09'isp' -> 'application/x-internet-signup'.\x0a\x09\x09'ist' -> 'chemical/x-isostar'.\x0a\x09\x09'istr' -> 'chemical/x-isostar'.\x0a\x09\x09'jad' -> 'text/vnd.sun.j2me.app-descriptor'.\x0a\x09\x09'jar' -> 'application/java-archive'.\x0a\x09\x09'java' -> 'text/x-java'.\x0a\x09\x09'jdx' -> 'chemical/x-jcamp-dx'.\x0a\x09\x09'jmz' -> 'application/x-jmol'.\x0a\x09\x09'jng' -> 'image/x-jng'.\x0a\x09\x09'jnlp' -> 'application/x-java-jnlp-file'.\x0a\x09\x09'jpe' -> 'image/jpeg'.\x0a\x09\x09'jpeg' -> 'image/jpeg'.\x0a\x09\x09'jpg' -> 'image/jpeg'.\x0a\x09\x09'js' -> 'application/javascript'.\x0a\x09\x09'kar' -> 'audio/midi'.\x0a\x09\x09'key' -> 'application/pgp-keys'.\x0a\x09\x09'kil' -> 'application/x-killustrator'.\x0a\x09\x09'kin' -> 'chemical/x-kinemage'.\x0a\x09\x09'kpr' -> 'application/x-kpresenter'.\x0a\x09\x09'kpt' -> 'application/x-kpresenter'.\x0a\x09\x09'ksp' -> 'application/x-kspread'.\x0a\x09\x09'kwd' -> 'application/x-kword'.\x0a\x09\x09'kwt' -> 'application/x-kword'.\x0a\x09\x09'latex' -> 'application/x-latex'.\x0a\x09\x09'lha' -> 'application/x-lha'.\x0a\x09\x09'lhs' -> 'text/x-literate-haskell'.\x0a\x09\x09'lsf' -> 'video/x-la-asf'.\x0a\x09\x09'lsx' -> 'video/x-la-asf'.\x0a\x09\x09'ltx' -> 'text/x-tex'.\x0a\x09\x09'lzh' -> 'application/x-lzh'.\x0a\x09\x09'lzx' -> 'application/x-lzx'.\x0a\x09\x09'm3u' -> 'audio/x-mpegurl'.\x0a\x09\x09'm4a' -> 'audio/mpeg'.\x0a\x09\x09'maker' -> 'application/x-maker'.\x0a\x09\x09'man' -> 'application/x-troff-man'.\x0a\x09\x09'mcif' -> 'chemical/x-mmcif'.\x0a\x09\x09'mcm' -> 'chemical/x-macmolecule'.\x0a\x09\x09'mdb' -> 'application/msaccess'.\x0a\x09\x09'me' -> 'application/x-troff-me'.\x0a\x09\x09'mesh' -> 'model/mesh'.\x0a\x09\x09'mid' -> 'audio/midi'.\x0a\x09\x09'midi' -> 'audio/midi'.\x0a\x09\x09'mif' -> 'application/x-mif'.\x0a\x09\x09'mm' -> 'application/x-freemind'.\x0a\x09\x09'mmd' -> 'chemical/x-macromodel-input'.\x0a\x09\x09'mmf' -> 'application/vnd.smaf'.\x0a\x09\x09'mml' -> 'text/mathml'.\x0a\x09\x09'mmod' -> 'chemical/x-macromodel-input'.\x0a\x09\x09'mng' -> 'video/x-mng'.\x0a\x09\x09'moc' -> 'text/x-moc'.\x0a\x09\x09'mol' -> 'chemical/x-mdl-molfile'.\x0a\x09\x09'mol2' -> 'chemical/x-mol2'.\x0a\x09\x09'moo' -> 'chemical/x-mopac-out'.\x0a\x09\x09'mop' -> 'chemical/x-mopac-input'.\x0a\x09\x09'mopcrt' -> 'chemical/x-mopac-input'.\x0a\x09\x09'mov' -> 'video/quicktime'.\x0a\x09\x09'movie' -> 'video/x-sgi-movie'.\x0a\x09\x09'mp2' -> 'audio/mpeg'.\x0a\x09\x09'mp3' -> 'audio/mpeg'.\x0a\x09\x09'mp4' -> 'video/mp4'.\x0a\x09\x09'mpc' -> 'chemical/x-mopac-input'.\x0a\x09\x09'mpe' -> 'video/mpeg'.\x0a\x09\x09'mpeg' -> 'video/mpeg'.\x0a\x09\x09'mpega' -> 'audio/mpeg'.\x0a\x09\x09'mpg' -> 'video/mpeg'.\x0a\x09\x09'mpga' -> 'audio/mpeg'.\x0a\x09\x09'ms' -> 'application/x-troff-ms'.\x0a\x09\x09'msh' -> 'model/mesh'.\x0a\x09\x09'msi' -> 'application/x-msi'.\x0a\x09\x09'mvb' -> 'chemical/x-mopac-vib'.\x0a\x09\x09'mxu' -> 'video/vnd.mpegurl'.\x0a\x09\x09'nb' -> 'application/mathematica'.\x0a\x09\x09'nc' -> 'application/x-netcdf'.\x0a\x09\x09'nwc' -> 'application/x-nwc'.\x0a\x09\x09'o' -> 'application/x-object'.\x0a\x09\x09'oda' -> 'application/oda'.\x0a\x09\x09'odb' -> 'application/vnd.oasis.opendocument.database'.\x0a\x09\x09'odc' -> 'application/vnd.oasis.opendocument.chart'.\x0a\x09\x09'odf' -> 'application/vnd.oasis.opendocument.formula'.\x0a\x09\x09'odg' -> 'application/vnd.oasis.opendocument.graphics'.\x0a\x09\x09'odi' -> 'application/vnd.oasis.opendocument.image'.\x0a\x09\x09'odm' -> 'application/vnd.oasis.opendocument.text-master'.\x0a\x09\x09'odp' -> 'application/vnd.oasis.opendocument.presentation'.\x0a\x09\x09'ods' -> 'application/vnd.oasis.opendocument.spreadsheet'.\x0a\x09\x09'odt' -> 'application/vnd.oasis.opendocument.text'.\x0a\x09\x09'ogg' -> 'application/ogg'.\x0a\x09\x09'old' -> 'application/x-trash'.\x0a\x09\x09'oth' -> 'application/vnd.oasis.opendocument.text-web'.\x0a\x09\x09'oza' -> 'application/x-oz-application'.\x0a\x09\x09'p' -> 'text/x-pascal'.\x0a\x09\x09'p7r' -> 'application/x-pkcs7-certreqresp'.\x0a\x09\x09'pac' -> 'application/x-ns-proxy-autoconfig'.\x0a\x09\x09'pas' -> 'text/x-pascal'.\x0a\x09\x09'pat' -> 'image/x-coreldrawpattern'.\x0a\x09\x09'pbm' -> 'image/x-portable-bitmap'.\x0a\x09\x09'pcf' -> 'application/x-font'.\x0a\x09\x09'pcf.Z' -> 'application/x-font'.\x0a\x09\x09'pcx' -> 'image/pcx'.\x0a\x09\x09'pdb' -> 'chemical/x-pdb'.\x0a\x09\x09'pdf' -> 'application/pdf'.\x0a\x09\x09'pfa' -> 'application/x-font'.\x0a\x09\x09'pfb' -> 'application/x-font'.\x0a\x09\x09'pgm' -> 'image/x-portable-graymap'.\x0a\x09\x09'pgn' -> 'application/x-chess-pgn'.\x0a\x09\x09'pgp' -> 'application/pgp-signature'.\x0a\x09\x09'pk' -> 'application/x-tex-pk'.\x0a\x09\x09'pl' -> 'text/x-perl'.\x0a\x09\x09'pls' -> 'audio/x-scpls'.\x0a\x09\x09'pm' -> 'text/x-perl'.\x0a\x09\x09'png' -> 'image/png'.\x0a\x09\x09'pnm' -> 'image/x-portable-anymap'.\x0a\x09\x09'pot' -> 'text/plain'.\x0a\x09\x09'ppm' -> 'image/x-portable-pixmap'.\x0a\x09\x09'pps' -> 'application/vnd.ms-powerpoint'.\x0a\x09\x09'ppt' -> 'application/vnd.ms-powerpoint'.\x0a\x09\x09'prf' -> 'application/pics-rules'.\x0a\x09\x09'prt' -> 'chemical/x-ncbi-asn1-ascii'.\x0a\x09\x09'ps' -> 'application/postscript'.\x0a\x09\x09'psd' -> 'image/x-photoshop'.\x0a\x09\x09'psp' -> 'text/x-psp'.\x0a\x09\x09'py' -> 'text/x-python'.\x0a\x09\x09'pyc' -> 'application/x-python-code'.\x0a\x09\x09'pyo' -> 'application/x-python-code'.\x0a\x09\x09'qt' -> 'video/quicktime'.\x0a\x09\x09'qtl' -> 'application/x-quicktimeplayer'.\x0a\x09\x09'ra' -> 'audio/x-realaudio'.\x0a\x09\x09'ram' -> 'audio/x-pn-realaudio'.\x0a\x09\x09'rar' -> 'application/rar'.\x0a\x09\x09'ras' -> 'image/x-cmu-raster'.\x0a\x09\x09'rd' -> 'chemical/x-mdl-rdfile'.\x0a\x09\x09'rdf' -> 'application/rdf+xml'.\x0a\x09\x09'rgb' -> 'image/x-rgb'.\x0a\x09\x09'rm' -> 'audio/x-pn-realaudio'.\x0a\x09\x09'roff' -> 'application/x-troff'.\x0a\x09\x09'ros' -> 'chemical/x-rosdal'.\x0a\x09\x09'rpm' -> 'application/x-redhat-package-manager'.\x0a\x09\x09'rss' -> 'application/rss+xml'.\x0a\x09\x09'rtf' -> 'text/rtf'.\x0a\x09\x09'rtx' -> 'text/richtext'.\x0a\x09\x09'rxn' -> 'chemical/x-mdl-rxnfile'.\x0a\x09\x09'sct' -> 'text/scriptlet'.\x0a\x09\x09'sd' -> 'chemical/x-mdl-sdfile'.\x0a\x09\x09'sd2' -> 'audio/x-sd2'.\x0a\x09\x09'sda' -> 'application/vnd.stardivision.draw'.\x0a\x09\x09'sdc' -> 'application/vnd.stardivision.calc'.\x0a\x09\x09'sdd' -> 'application/vnd.stardivision.impress'.\x0a\x09\x09'sdf' -> 'chemical/x-mdl-sdfile'.\x0a\x09\x09'sdp' -> 'application/vnd.stardivision.impress'.\x0a\x09\x09'sdw' -> 'application/vnd.stardivision.writer'.\x0a\x09\x09'ser' -> 'application/java-serialized-object'.\x0a\x09\x09'sgf' -> 'application/x-go-sgf'.\x0a\x09\x09'sgl' -> 'application/vnd.stardivision.writer-global'.\x0a\x09\x09'sh' -> 'text/x-sh'.\x0a\x09\x09'shar' -> 'application/x-shar'.\x0a\x09\x09'shtml' -> 'text/html'.\x0a\x09\x09'sid' -> 'audio/prs.sid'.\x0a\x09\x09'sik' -> 'application/x-trash'.\x0a\x09\x09'silo' -> 'model/mesh'.\x0a\x09\x09'sis' -> 'application/vnd.symbian.install'.\x0a\x09\x09'sit' -> 'application/x-stuffit'.\x0a\x09\x09'skd' -> 'application/x-koan'.\x0a\x09\x09'skm' -> 'application/x-koan'.\x0a\x09\x09'skp' -> 'application/x-koan'.\x0a\x09\x09'skt' -> 'application/x-koan'.\x0a\x09\x09'smf' -> 'application/vnd.stardivision.math'.\x0a\x09\x09'smi' -> 'application/smil'.\x0a\x09\x09'smil' -> 'application/smil'.\x0a\x09\x09'snd' -> 'audio/basic'.\x0a\x09\x09'spc' -> 'chemical/x-galactic-spc'.\x0a\x09\x09'spl' -> 'application/x-futuresplash'.\x0a\x09\x09'src' -> 'application/x-wais-source'.\x0a\x09\x09'stc' -> 'application/vnd.sun.xml.calc.template'.\x0a\x09\x09'std' -> 'application/vnd.sun.xml.draw.template'.\x0a\x09\x09'sti' -> 'application/vnd.sun.xml.impress.template'.\x0a\x09\x09'stl' -> 'application/vnd.ms-pki.stl'.\x0a\x09\x09'stw' -> 'application/vnd.sun.xml.writer.template'.\x0a\x09\x09'sty' -> 'text/x-tex'.\x0a\x09\x09'sv4cpio' -> 'application/x-sv4cpio'.\x0a\x09\x09'sv4crc' -> 'application/x-sv4crc'.\x0a\x09\x09'svg' -> 'image/svg+xml'.\x0a\x09\x09'svgz' -> 'image/svg+xml'.\x0a\x09\x09'sw' -> 'chemical/x-swissprot'.\x0a\x09\x09'swf' -> 'application/x-shockwave-flash'.\x0a\x09\x09'swfl' -> 'application/x-shockwave-flash'.\x0a\x09\x09'sxc' -> 'application/vnd.sun.xml.calc'.\x0a\x09\x09'sxd' -> 'application/vnd.sun.xml.draw'.\x0a\x09\x09'sxg' -> 'application/vnd.sun.xml.writer.global'.\x0a\x09\x09'sxi' -> 'application/vnd.sun.xml.impress'.\x0a\x09\x09'sxm' -> 'application/vnd.sun.xml.math'.\x0a\x09\x09'sxw' -> 'application/vnd.sun.xml.writer'.\x0a\x09\x09't' -> 'application/x-troff'.\x0a\x09\x09'tar' -> 'application/x-tar'.\x0a\x09\x09'taz' -> 'application/x-gtar'.\x0a\x09\x09'tcl' -> 'text/x-tcl'.\x0a\x09\x09'tex' -> 'text/x-tex'.\x0a\x09\x09'texi' -> 'application/x-texinfo'.\x0a\x09\x09'texinfo' -> 'application/x-texinfo'.\x0a\x09\x09'text' -> 'text/plain'.\x0a\x09\x09'tgf' -> 'chemical/x-mdl-tgf'.\x0a\x09\x09'tgz' -> 'application/x-gtar'.\x0a\x09\x09'tif' -> 'image/tiff'.\x0a\x09\x09'tiff' -> 'image/tiff'.\x0a\x09\x09'tk' -> 'text/x-tcl'.\x0a\x09\x09'tm' -> 'text/texmacs'.\x0a\x09\x09'torrent' -> 'application/x-bittorrent'.\x0a\x09\x09'tr' -> 'application/x-troff'.\x0a\x09\x09'ts' -> 'text/texmacs'.\x0a\x09\x09'tsp' -> 'application/dsptype'.\x0a\x09\x09'tsv' -> 'text/tab-separated-values'.\x0a\x09\x09'txt' -> 'text/plain'.\x0a\x09\x09'udeb' -> 'application/x-debian-package'.\x0a\x09\x09'uls' -> 'text/iuls'.\x0a\x09\x09'ustar' -> 'application/x-ustar'.\x0a\x09\x09'val' -> 'chemical/x-ncbi-asn1-binary'.\x0a\x09\x09'vcd' -> 'application/x-cdlink'.\x0a\x09\x09'vcf' -> 'text/x-vcard'.\x0a\x09\x09'vcs' -> 'text/x-vcalendar'.\x0a\x09\x09'vmd' -> 'chemical/x-vmd'.\x0a\x09\x09'vms' -> 'chemical/x-vamas-iso14976'.\x0a\x09\x09'vor' -> 'application/vnd.stardivision.writer'.\x0a\x09\x09'vrm' -> 'x-world/x-vrml'.\x0a\x09\x09'vrml' -> 'x-world/x-vrml'.\x0a\x09\x09'vsd' -> 'application/vnd.visio'.\x0a\x09\x09'wad' -> 'application/x-doom'.\x0a\x09\x09'wav' -> 'audio/x-wav'.\x0a\x09\x09'wax' -> 'audio/x-ms-wax'.\x0a\x09\x09'wbmp' -> 'image/vnd.wap.wbmp'.\x0a\x09\x09'wbxml' -> 'application/vnd.wap.wbxml'.\x0a\x09\x09'wk' -> 'application/x-123'.\x0a\x09\x09'wm' -> 'video/x-ms-wm'.\x0a\x09\x09'wma' -> 'audio/x-ms-wma'.\x0a\x09\x09'wmd' -> 'application/x-ms-wmd'.\x0a\x09\x09'wml' -> 'text/vnd.wap.wml'.\x0a\x09\x09'wmlc' -> 'application/vnd.wap.wmlc'.\x0a\x09\x09'wmls' -> 'text/vnd.wap.wmlscript'.\x0a\x09\x09'wmlsc' -> 'application/vnd.wap.wmlscriptc'.\x0a\x09\x09'wmv' -> 'video/x-ms-wmv'.\x0a\x09\x09'wmx' -> 'video/x-ms-wmx'.\x0a\x09\x09'wmz' -> 'application/x-ms-wmz'.\x0a\x09\x09'wp5' -> 'application/wordperfect5.1'.\x0a\x09\x09'wpd' -> 'application/wordperfect'.\x0a\x09\x09'wrl' -> 'x-world/x-vrml'.\x0a\x09\x09'wsc' -> 'text/scriptlet'.\x0a\x09\x09'wvx' -> 'video/x-ms-wvx'.\x0a\x09\x09'wz' -> 'application/x-wingz'.\x0a\x09\x09'xbm' -> 'image/x-xbitmap'.\x0a\x09\x09'xcf' -> 'application/x-xcf'.\x0a\x09\x09'xht' -> 'application/xhtml+xml'.\x0a\x09\x09'xhtml' -> 'application/xhtml+xml'.\x0a\x09\x09'xlb' -> 'application/vnd.ms-excel'.\x0a\x09\x09'xls' -> 'application/vnd.ms-excel'.\x0a\x09\x09'xlt' -> 'application/vnd.ms-excel'.\x0a\x09\x09'xml' -> 'application/xml'.\x0a\x09\x09'xpi' -> 'application/x-xpinstall'.\x0a\x09\x09'xpm' -> 'image/x-xpixmap'.\x0a\x09\x09'xsl' -> 'application/xml'.\x0a\x09\x09'xtel' -> 'chemical/x-xtel'.\x0a\x09\x09'xul' -> 'application/vnd.mozilla.xul+xml'.\x0a\x09\x09'xwd' -> 'image/x-xwindowdump'.\x0a\x09\x09'xyz' -> 'chemical/x-xyz'.\x0a\x09\x09'zip' -> 'application/zip'.\x0a\x09\x09'zmt' -> 'chemical/x-mopac-input'.\x0a\x09\x09'~' -> 'application/x-trash'\x0a\x09}",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer.klass);

$core.addMethod(
$core.method({
selector: "defaultPort",
protocol: 'accessing',
fn: function (){
var self=this;
return (4000);

},
args: [],
source: "defaultPort\x0a\x09^ 4000",
referencedClasses: [],
messageSends: []
}),
$globals.FileServer.klass);

$core.addMethod(
$core.method({
selector: "main",
protocol: 'initialization',
fn: function (){
var self=this;
var fileServer,args;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
args=$recv(process)._argv();
$recv(args)._removeFrom_to_((1),(3));
$recv(args)._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
$1=$recv(each).__eq("--help");
if($core.assert($1)){
return $recv($globals.FileServer)._printHelp();
};
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
fileServer=$recv($globals.FileServer)._createServerWithArguments_(args);
fileServer;
throw $early=[$recv(fileServer)._start()];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"main",{fileServer:fileServer,args:args},$globals.FileServer.klass)});
},
args: [],
source: "main\x0a\x09\x22Main entry point for Amber applications.\x0a\x09 Creates and starts a FileServer instance.\x22\x0a\x09| fileServer args |\x0a\x09args := process argv.\x0a\x09\x22Remove the first args which contain the path to the node executable and the script file.\x22\x0a\x09args removeFrom: 1 to: 3.\x0a\x0a\x09args detect: [ :each |\x0a\x09\x09(each = '--help') ifTrue: [FileServer printHelp]]\x0a\x09ifNone: [\x0a\x09\x09fileServer := FileServer createServerWithArguments: args.\x0a\x09\x09^ fileServer start]",
referencedClasses: ["FileServer"],
messageSends: ["argv", "removeFrom:to:", "detect:ifNone:", "ifTrue:", "=", "printHelp", "createServerWithArguments:", "start"]
}),
$globals.FileServer.klass);

$core.addMethod(
$core.method({
selector: "mimeTypeFor:",
protocol: 'accessing',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._mimeTypes())._at_ifAbsent_($recv(aString)._replace_with_(".*[\x5c.]",""),(function(){
return "text/plain";

}));
}, function($ctx1) {$ctx1.fill(self,"mimeTypeFor:",{aString:aString},$globals.FileServer.klass)});
},
args: ["aString"],
source: "mimeTypeFor: aString\x0a\x09^ self mimeTypes at: (aString replace: '.*[\x5c.]' with: '') ifAbsent: ['text/plain']",
referencedClasses: [],
messageSends: ["at:ifAbsent:", "mimeTypes", "replace:with:"]
}),
$globals.FileServer.klass);

$core.addMethod(
$core.method({
selector: "mimeTypes",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@mimeTypes"];
if(($receiver = $1) == null || $receiver.isNil){
self["@mimeTypes"]=self._defaultMimeTypes();
return self["@mimeTypes"];
} else {
return $1;
};
}, function($ctx1) {$ctx1.fill(self,"mimeTypes",{},$globals.FileServer.klass)});
},
args: [],
source: "mimeTypes\x0a\x09^ mimeTypes ifNil: [mimeTypes := self defaultMimeTypes]",
referencedClasses: [],
messageSends: ["ifNil:", "defaultMimeTypes"]
}),
$globals.FileServer.klass);

$core.addMethod(
$core.method({
selector: "printHelp",
protocol: 'accessing',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(console)._log_("Available commandline options are:");
$ctx1.sendIdx["log:"]=1;
$recv(console)._log_("--help");
$ctx1.sendIdx["log:"]=2;
$recv(self._commandLineSwitches())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(console)._log_($recv(each).__comma(" <parameter>"));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"printHelp",{},$globals.FileServer.klass)});
},
args: [],
source: "printHelp\x0a\x09console log: 'Available commandline options are:'.\x0a\x09console log: '--help'.\x0a\x09self commandLineSwitches do: [ :each |\x0a\x09\x09console log: each, ' <parameter>']",
referencedClasses: [],
messageSends: ["log:", "do:", "commandLineSwitches", ","]
}),
$globals.FileServer.klass);

$core.addMethod(
$core.method({
selector: "selectorForCommandLineSwitch:",
protocol: 'accessing',
fn: function (aSwitch){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv(aSwitch)._replace_with_("^--",""))._replace_with_("-[a-z]",(function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._second())._asUppercase();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$ctx1.sendIdx["replace:with:"]=1;
return $recv($1).__comma(":");
}, function($ctx1) {$ctx1.fill(self,"selectorForCommandLineSwitch:",{aSwitch:aSwitch},$globals.FileServer.klass)});
},
args: ["aSwitch"],
source: "selectorForCommandLineSwitch: aSwitch\x0a\x09\x22Remove the trailing '--', add ':' at the end\x0a\x09 and replace all occurences of a lowercase letter preceded by a '-' with\x0a\x09 the Uppercase letter.\x0a\x09 Example: --fallback-page becomes fallbackPage:\x22\x0a\x09^ ((aSwitch replace: '^--' with: '')\x0a\x09\x09replace: '-[a-z]' with: [ :each | each second asUppercase ]), ':'",
referencedClasses: [],
messageSends: [",", "replace:with:", "asUppercase", "second"]
}),
$globals.FileServer.klass);


$core.addClass('Initer', $globals.BaseFileManipulator, ['childProcess', 'nmPath'], 'AmberCli');
$core.addMethod(
$core.method({
selector: "bowerInstallThenDo:",
protocol: 'action',
fn: function (aBlock){
var self=this;
var child;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
child=$recv(self["@childProcess"])._fork_args_(self._npmScriptForModule_named_("bower","bower"),["install"]);
$1=child;
$recv($1)._on_do_("error",aBlock);
$ctx1.sendIdx["on:do:"]=1;
$recv($1)._on_do_("close",(function(code){
return $core.withContext(function($ctx2) {
$3=$recv(code).__eq((0));
if($core.assert($3)){
$2=nil;
} else {
$2=code;
};
return $recv(aBlock)._value_($2);
}, function($ctx2) {$ctx2.fillBlock({code:code},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"bowerInstallThenDo:",{aBlock:aBlock,child:child},$globals.Initer)});
},
args: ["aBlock"],
source: "bowerInstallThenDo: aBlock\x0a\x09| child |\x0a\x09child := childProcess\x0a\x09\x09fork: (self npmScriptForModule: 'bower' named: 'bower')\x0a\x09\x09args: #('install').\x0a\x09child\x0a\x09\x09on: 'error' do: aBlock;\x0a\x09\x09on: 'close' do: [ :code |\x0a\x09\x09\x09aBlock value: (code = 0 ifTrue: [ nil ] ifFalse: [ code ]) ]",
referencedClasses: [],
messageSends: ["fork:args:", "npmScriptForModule:named:", "on:do:", "value:", "ifTrue:ifFalse:", "="]
}),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "finishMessage",
protocol: 'action',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(console)._log_([" ", "The project should now be set up.", " ", " "]._join_($recv($globals.String)._lf()));
$recv((function(){

}))._valueWithTimeout_((600));
return self;
}, function($ctx1) {$ctx1.fill(self,"finishMessage",{},$globals.Initer)});
},
args: [],
source: "finishMessage\x0a\x09console log: (#(\x0a\x09\x09' '\x0a\x09\x09'The project should now be set up.'\x0a\x09\x09' '\x0a\x09\x09' '\x0a\x09) join: String lf).\x0a\x09[] valueWithTimeout: 600",
referencedClasses: ["String"],
messageSends: ["log:", "join:", "lf", "valueWithTimeout:"]
}),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "gruntInitThenDo:",
protocol: 'action',
fn: function (aBlock){
var self=this;
var child,sanitizedTemplatePath;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
sanitizedTemplatePath=$recv($recv($recv(self["@path"])._join_with_(self["@nmPath"],"grunt-init-amber"))._replace_with_("\x5c\x5c","\x5c\x5c"))._replace_with_(":","\x5c:");
$ctx1.sendIdx["replace:with:"]=1;
child=$recv(self["@childProcess"])._fork_args_(self._npmScriptForModule_named_("grunt-init","grunt-init"),[sanitizedTemplatePath]);
$1=child;
$recv($1)._on_do_("error",aBlock);
$ctx1.sendIdx["on:do:"]=1;
$recv($1)._on_do_("close",(function(code){
return $core.withContext(function($ctx2) {
$3=$recv(code).__eq((0));
if($core.assert($3)){
$2=nil;
} else {
$2=code;
};
return $recv(aBlock)._value_($2);
}, function($ctx2) {$ctx2.fillBlock({code:code},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"gruntInitThenDo:",{aBlock:aBlock,child:child,sanitizedTemplatePath:sanitizedTemplatePath},$globals.Initer)});
},
args: ["aBlock"],
source: "gruntInitThenDo: aBlock\x0a\x09| child sanitizedTemplatePath |\x0a\x09sanitizedTemplatePath := ((path join: nmPath with: 'grunt-init-amber')\x0a\x09\x09replace: '\x5c\x5c' with: '\x5c\x5c') replace: ':' with: '\x5c:'.\x0a\x09child := childProcess\x0a\x09\x09fork: (self npmScriptForModule: 'grunt-init' named: 'grunt-init')\x0a\x09\x09args: {sanitizedTemplatePath}.\x0a\x09child\x0a\x09\x09on: 'error' do: aBlock;\x0a\x09\x09on: 'close' do: [ :code |\x0a\x09\x09\x09aBlock value: (code = 0 ifTrue: [ nil ] ifFalse: [ code ]) ]",
referencedClasses: [],
messageSends: ["replace:with:", "join:with:", "fork:args:", "npmScriptForModule:named:", "on:do:", "value:", "ifTrue:ifFalse:", "="]
}),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "gruntThenDo:",
protocol: 'action',
fn: function (aBlock){
var self=this;
var child;
return $core.withContext(function($ctx1) {
var $1,$3,$2;
child=$recv(self["@childProcess"])._fork_args_(self._npmScriptForModule_named_("grunt-cli","grunt"),["default", "devel"]);
$1=child;
$recv($1)._on_do_("error",aBlock);
$ctx1.sendIdx["on:do:"]=1;
$recv($1)._on_do_("close",(function(code){
return $core.withContext(function($ctx2) {
$3=$recv(code).__eq((0));
if($core.assert($3)){
$2=nil;
} else {
$2=code;
};
return $recv(aBlock)._value_($2);
}, function($ctx2) {$ctx2.fillBlock({code:code},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"gruntThenDo:",{aBlock:aBlock,child:child},$globals.Initer)});
},
args: ["aBlock"],
source: "gruntThenDo: aBlock\x0a\x09| child |\x0a\x09child := childProcess\x0a\x09\x09fork: (self npmScriptForModule: 'grunt-cli' named: 'grunt')\x0a\x09\x09args: #('default' 'devel').\x0a\x09child\x0a\x09\x09on: 'error' do: aBlock;\x0a\x09\x09on: 'close' do: [ :code |\x0a\x09\x09\x09aBlock value: (code = 0 ifTrue: [ nil ] ifFalse: [ code ]) ]",
referencedClasses: [],
messageSends: ["fork:args:", "npmScriptForModule:named:", "on:do:", "value:", "ifTrue:ifFalse:", "="]
}),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Initer.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@childProcess"]=$recv(require)._value_("child_process");
self["@nmPath"]=$recv(self["@path"])._join_with_(self._rootDirname(),"node_modules");
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.Initer)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09childProcess := require value: 'child_process'.\x0a\x09nmPath := path join: self rootDirname with: 'node_modules'",
referencedClasses: [],
messageSends: ["initialize", "value:", "join:with:", "rootDirname"]
}),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "npmInstallThenDo:",
protocol: 'action',
fn: function (aBlock){
var self=this;
var child;
return $core.withContext(function($ctx1) {
var $1;
child=$recv(self["@childProcess"])._exec_thenDo_("npm install",aBlock);
$1=$recv(child)._stdout();
$ctx1.sendIdx["stdout"]=1;
$recv($1)._pipe_options_($recv(process)._stdout(),$globals.HashedCollection._newFromPairs_(["end",false]));
return self;
}, function($ctx1) {$ctx1.fill(self,"npmInstallThenDo:",{aBlock:aBlock,child:child},$globals.Initer)});
},
args: ["aBlock"],
source: "npmInstallThenDo: aBlock\x0a\x09| child |\x0a\x09child := childProcess\x0a\x09\x09exec: 'npm install'\x0a\x09\x09thenDo: aBlock.\x0a\x09child stdout pipe: process stdout options: #{ 'end' -> false }",
referencedClasses: [],
messageSends: ["exec:thenDo:", "pipe:options:", "stdout"]
}),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "npmScriptForModule:named:",
protocol: 'npm',
fn: function (aString,anotherString){
var self=this;
var modulePath,packageJson,binSection,scriptPath;
return $core.withContext(function($ctx1) {
var $1,$3,$4,$2,$5;
$1=self["@path"];
$3=$recv($globals.JSObjectProxy)._on_(require);
$4=$recv(aString).__comma("/package.json");
$ctx1.sendIdx[","]=1;
$2=$recv($3)._resolve_($4);
modulePath=$recv($1)._dirname_($2);
packageJson=$recv($globals.Smalltalk)._readJSObject_($recv(require)._value_($recv(aString).__comma("/package.json")));
binSection=$recv(packageJson)._at_("bin");
$ctx1.sendIdx["at:"]=1;
$5=$recv(binSection)._isString();
if($core.assert($5)){
scriptPath=binSection;
} else {
scriptPath=$recv(binSection)._at_(anotherString);
};
return $recv(self["@path"])._join_with_(modulePath,scriptPath);
}, function($ctx1) {$ctx1.fill(self,"npmScriptForModule:named:",{aString:aString,anotherString:anotherString,modulePath:modulePath,packageJson:packageJson,binSection:binSection,scriptPath:scriptPath},$globals.Initer)});
},
args: ["aString", "anotherString"],
source: "npmScriptForModule: aString named: anotherString\x0a\x09| modulePath packageJson binSection scriptPath |\x0a\x09modulePath := path dirname: (\x0a\x09\x09(JSObjectProxy on: require)\x0a\x09\x09\x09resolve: aString, '/package.json').\x0a\x09packageJson := Smalltalk readJSObject: (\x0a\x09\x09require value: aString, '/package.json').\x0a\x09binSection := packageJson at: 'bin'.\x0a\x09scriptPath := binSection isString\x0a\x09\x09ifTrue: [ binSection ]\x0a\x09\x09ifFalse: [ binSection at: anotherString ].\x0a\x09^ path join: modulePath with: scriptPath",
referencedClasses: ["JSObjectProxy", "Smalltalk"],
messageSends: ["dirname:", "resolve:", "on:", ",", "readJSObject:", "value:", "at:", "ifTrue:ifFalse:", "isString", "join:with:"]
}),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "start",
protocol: 'action',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$receiver;
self._gruntInitThenDo_((function(error){
return $core.withContext(function($ctx2) {
if(($receiver = error) == null || $receiver.isNil){
return self._bowerInstallThenDo_((function(error2){
return $core.withContext(function($ctx3) {
if(($receiver = error2) == null || $receiver.isNil){
return self._npmInstallThenDo_((function(error3){
return $core.withContext(function($ctx4) {
if(($receiver = error3) == null || $receiver.isNil){
return self._gruntThenDo_((function(error4){
return $core.withContext(function($ctx5) {
if(($receiver = error4) == null || $receiver.isNil){
self._finishMessage();
return $recv(process)._exit();
} else {
$7=console;
$recv($7)._log_("grunt exec error:");
$ctx5.sendIdx["log:"]=7;
$recv($7)._log_(error4);
return $recv(process)._exit_((104));
};
}, function($ctx5) {$ctx5.fillBlock({error4:error4},$ctx4,10)});
}));
} else {
$5=console;
$recv($5)._log_("npm install exec error:");
$ctx4.sendIdx["log:"]=5;
$6=$recv($5)._log_(error3);
$ctx4.sendIdx["log:"]=6;
$6;
return $recv(process)._exit_((103));
$ctx4.sendIdx["exit:"]=3;
};
}, function($ctx4) {$ctx4.fillBlock({error3:error3},$ctx3,7)});
}));
} else {
$3=console;
$recv($3)._log_("bower install exec error:");
$ctx3.sendIdx["log:"]=3;
$4=$recv($3)._log_(error2);
$ctx3.sendIdx["log:"]=4;
$4;
return $recv(process)._exit_((102));
$ctx3.sendIdx["exit:"]=2;
};
}, function($ctx3) {$ctx3.fillBlock({error2:error2},$ctx2,4)});
}));
} else {
$1=console;
$recv($1)._log_("grunt-init exec error:");
$ctx2.sendIdx["log:"]=1;
$2=$recv($1)._log_(error);
$ctx2.sendIdx["log:"]=2;
$2;
return $recv(process)._exit_((101));
$ctx2.sendIdx["exit:"]=1;
};
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"start",{},$globals.Initer)});
},
args: [],
source: "start\x0a\x09self gruntInitThenDo: [ :error | error\x0a\x09ifNotNil: [\x0a\x09\x09console log: 'grunt-init exec error:'; log: error.\x0a\x09\x09process exit: 101 ]\x0a\x09ifNil: [\x0a\x0a\x09self bowerInstallThenDo: [ :error2 | error2\x0a\x09ifNotNil: [\x0a\x09\x09console log: 'bower install exec error:'; log: error2.\x0a\x09\x09process exit: 102 ]\x0a\x09ifNil: [\x0a\x0a\x09self npmInstallThenDo: [ :error3 | error3\x0a\x09ifNotNil: [\x0a\x09\x09console log: 'npm install exec error:'; log: error3.\x0a\x09\x09process exit: 103 ]\x0a\x09ifNil: [\x0a\x0a\x09self gruntThenDo: [ :error4 | error4\x0a\x09ifNotNil: [\x0a\x09\x09console log: 'grunt exec error:'; log: error4.\x0a\x09\x09process exit: 104 ]\x0a\x09ifNil: [\x0a\x0a\x09self finishMessage.\x0a\x09process exit ]]]]]]]]",
referencedClasses: [],
messageSends: ["gruntInitThenDo:", "ifNotNil:ifNil:", "log:", "exit:", "bowerInstallThenDo:", "npmInstallThenDo:", "gruntThenDo:", "finishMessage", "exit"]
}),
$globals.Initer);



$core.addClass('Repl', $globals.Object, ['readline', 'interface', 'util', 'session', 'resultCount', 'commands'], 'AmberCli');
$globals.Repl.comment="I am a class representing a REPL (Read Evaluate Print Loop) and provide a command line interface to Amber Smalltalk.\x0aOn the prompt you can type Amber statements which will be evaluated after pressing <Enter>.\x0aThe evaluation is comparable with executing a 'DoIt' in a workspace.\x0a\x0aMy runtime requirement is a functional Node.js executable with working Readline support.";
$core.addMethod(
$core.method({
selector: "addVariableNamed:to:",
protocol: 'private',
fn: function (aString,anObject){
var self=this;
var newClass,newObject;
return $core.withContext(function($ctx1) {
newClass=self._subclass_withVariable_($recv(anObject)._class(),aString);
self._encapsulateVariable_withValue_in_(aString,anObject,newClass);
newObject=$recv(newClass)._new();
self._setPreviousVariablesFor_from_(newObject,anObject);
return newObject;
}, function($ctx1) {$ctx1.fill(self,"addVariableNamed:to:",{aString:aString,anObject:anObject,newClass:newClass,newObject:newObject},$globals.Repl)});
},
args: ["aString", "anObject"],
source: "addVariableNamed: aString to: anObject\x0a\x09| newClass newObject |\x0a\x09newClass := self subclass: anObject class withVariable: aString.\x0a\x09self encapsulateVariable: aString withValue: anObject in: newClass.\x0a\x09newObject := newClass new.\x0a\x09self setPreviousVariablesFor: newObject from: anObject.\x0a\x09^ newObject",
referencedClasses: [],
messageSends: ["subclass:withVariable:", "class", "encapsulateVariable:withValue:in:", "new", "setPreviousVariablesFor:from:"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "assignNewVariable:do:",
protocol: 'private',
fn: function (buffer,aBlock){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$3,$1,$receiver;
return self._parseAssignment_do_(buffer,(function(name,expr){
var varName,value;
return $core.withContext(function($ctx2) {
if(($receiver = name) == null || $receiver.isNil){
varName=self._nextResultName();
} else {
varName=name;
};
varName;
self["@session"]=self._addVariableNamed_to_(varName,self["@session"]);
self["@session"];
$recv((function(){
return $core.withContext(function($ctx3) {
$2=$recv(varName).__comma(" := ");
if(($receiver = expr) == null || $receiver.isNil){
$3=buffer;
} else {
$3=expr;
};
$1=$recv($2).__comma($3);
$ctx3.sendIdx[","]=1;
value=self._eval_on_($1,self["@session"]);
return value;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}))._on_do_($globals.Error,(function(e){
return $core.withContext(function($ctx3) {
$recv($recv($globals.ConsoleErrorHandler)._new())._logError_(e);
value=nil;
return value;
}, function($ctx3) {$ctx3.fillBlock({e:e},$ctx2,5)});
}));
return $recv(aBlock)._value_value_(varName,value);
}, function($ctx2) {$ctx2.fillBlock({name:name,expr:expr,varName:varName,value:value},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"assignNewVariable:do:",{buffer:buffer,aBlock:aBlock},$globals.Repl)});
},
args: ["buffer", "aBlock"],
source: "assignNewVariable: buffer do: aBlock\x0a\x09\x22Assigns a new variable and calls the given block with the variable's name and value\x0a\x09 if buffer contains an assignment expression. If it doesn't the block is called with nil for\x0a\x09 both arguments.\x22\x0a\x09^ self parseAssignment: buffer do: [ :name :expr || varName value |\x0a\x09\x09varName := name ifNil: [self nextResultName].\x0a\x09\x09session := self addVariableNamed: varName to: session.\x0a\x09\x09[ value := self eval: varName, ' := ', (expr ifNil: [buffer]) on: session ]\x0a\x09\x09\x09on: Error\x0a\x09\x09\x09do: [ :e | ConsoleErrorHandler new logError: e. value := nil].\x0a\x09\x09aBlock value: varName value: value]",
referencedClasses: ["Error", "ConsoleErrorHandler"],
messageSends: ["parseAssignment:do:", "ifNil:", "nextResultName", "addVariableNamed:to:", "on:do:", "eval:on:", ",", "logError:", "new", "value:value:"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "clearScreen",
protocol: 'actions',
fn: function (){
var self=this;
var esc,cls;
return $core.withContext(function($ctx1) {
var $1;
esc=$recv($globals.String)._fromCharCode_((27));
$1=$recv($recv(esc).__comma("[2J")).__comma(esc);
$ctx1.sendIdx[","]=2;
cls=$recv($1).__comma("[0;0f");
$ctx1.sendIdx[","]=1;
$recv($recv(process)._stdout())._write_(cls);
$recv(self["@interface"])._prompt();
return self;
}, function($ctx1) {$ctx1.fill(self,"clearScreen",{esc:esc,cls:cls},$globals.Repl)});
},
args: [],
source: "clearScreen\x0a\x09| esc cls |\x0a\x09esc := String fromCharCode: 27.\x0a\x09cls := esc, '[2J', esc, '[0;0f'.\x0a\x09process stdout write: cls.\x0a\x09interface prompt",
referencedClasses: ["String"],
messageSends: ["fromCharCode:", ",", "write:", "stdout", "prompt"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "close",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($recv(process)._stdin())._destroy();
return self;
}, function($ctx1) {$ctx1.fill(self,"close",{},$globals.Repl)});
},
args: [],
source: "close\x0a\x09process stdin destroy",
referencedClasses: [],
messageSends: ["destroy", "stdin"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "commands",
protocol: 'accessing',
fn: function (){
var self=this;
return self["@commands"];

},
args: [],
source: "commands\x0a\x09^ commands",
referencedClasses: [],
messageSends: []
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "createInterface",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
self["@interface"]=$recv(self["@readline"])._createInterface_stdout_($recv(process)._stdin(),$recv(process)._stdout());
$recv(self["@interface"])._on_do_("line",(function(buffer){
return $core.withContext(function($ctx2) {
return self._processLine_(buffer);
}, function($ctx2) {$ctx2.fillBlock({buffer:buffer},$ctx1,1)});
}));
$ctx1.sendIdx["on:do:"]=1;
$recv(self["@interface"])._on_do_("close",(function(){
return $core.withContext(function($ctx2) {
return self._close();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
self._printWelcome();
self._setupHotkeys();
self._setPrompt();
$recv(self["@interface"])._prompt();
return self;
}, function($ctx1) {$ctx1.fill(self,"createInterface",{},$globals.Repl)});
},
args: [],
source: "createInterface\x0a\x09interface := readline createInterface: process stdin stdout: process stdout.\x0a\x09interface on: 'line' do: [:buffer | self processLine: buffer].\x0a\x09interface on: 'close' do: [self close].\x0a\x09self printWelcome; setupHotkeys; setPrompt.\x0a\x09interface prompt",
referencedClasses: [],
messageSends: ["createInterface:stdout:", "stdin", "stdout", "on:do:", "processLine:", "close", "printWelcome", "setupHotkeys", "setPrompt", "prompt"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "encapsulateVariable:withValue:in:",
protocol: 'private',
fn: function (aString,anObject,aClass){
var self=this;
var compiler;
return $core.withContext(function($ctx1) {
var $1,$4,$3,$2,$5,$6;
compiler=$recv($globals.Compiler)._new();
$1=compiler;
$4=$recv(aString).__comma(": anObject ^ ");
$ctx1.sendIdx[","]=3;
$3=$recv($4).__comma(aString);
$ctx1.sendIdx[","]=2;
$2=$recv($3).__comma(" := anObject");
$ctx1.sendIdx[","]=1;
$recv($1)._install_forClass_protocol_($2,aClass,"session");
$ctx1.sendIdx["install:forClass:protocol:"]=1;
$5=compiler;
$6=$recv($recv(aString).__comma(" ^ ")).__comma(aString);
$ctx1.sendIdx[","]=4;
$recv($5)._install_forClass_protocol_($6,aClass,"session");
return self;
}, function($ctx1) {$ctx1.fill(self,"encapsulateVariable:withValue:in:",{aString:aString,anObject:anObject,aClass:aClass,compiler:compiler},$globals.Repl)});
},
args: ["aString", "anObject", "aClass"],
source: "encapsulateVariable: aString withValue: anObject in: aClass\x0a\x09\x22Add getter and setter for given variable to session.\x22\x0a\x09| compiler |\x0a\x09compiler := Compiler new.\x0a\x09compiler install: aString, ': anObject ^ ', aString, ' := anObject' forClass: aClass protocol: 'session'.\x0a\x09compiler install: aString, ' ^ ', aString forClass: aClass protocol: 'session'.",
referencedClasses: ["Compiler"],
messageSends: ["new", "install:forClass:protocol:", ","]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "eval:",
protocol: 'actions',
fn: function (buffer){
var self=this;
return $core.withContext(function($ctx1) {
return self._eval_on_(buffer,$recv($globals.DoIt)._new());
}, function($ctx1) {$ctx1.fill(self,"eval:",{buffer:buffer},$globals.Repl)});
},
args: ["buffer"],
source: "eval: buffer\x0a\x09^ self eval: buffer on: DoIt new.",
referencedClasses: ["DoIt"],
messageSends: ["eval:on:", "new"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "eval:on:",
protocol: 'actions',
fn: function (buffer,anObject){
var self=this;
var result;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv(buffer)._isEmpty();
if(!$core.assert($1)){
$recv((function(){
return $core.withContext(function($ctx2) {
result=$recv($recv($globals.Compiler)._new())._evaluateExpression_on_(buffer,anObject);
return result;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}))._tryCatch_((function(e){
return $core.withContext(function($ctx2) {
$2=$recv(e)._isSmalltalkError();
if($core.assert($2)){
return $recv(e)._resignal();
} else {
return $recv($recv(process)._stdout())._write_($recv(e)._jsStack());
};
}, function($ctx2) {$ctx2.fillBlock({e:e},$ctx1,3)});
}));
};
return result;
}, function($ctx1) {$ctx1.fill(self,"eval:on:",{buffer:buffer,anObject:anObject,result:result},$globals.Repl)});
},
args: ["buffer", "anObject"],
source: "eval: buffer on: anObject\x0a\x09| result |\x0a\x09buffer isEmpty ifFalse: [\x0a\x09\x09[result := Compiler new evaluateExpression: buffer on: anObject]\x0a\x09\x09\x09tryCatch: [:e |\x0a\x09\x09\x09\x09e isSmalltalkError\x0a\x09\x09\x09\x09    ifTrue: [ e resignal ]\x0a\x09\x09\x09 \x09   ifFalse: [ process stdout write: e jsStack ]]].\x0a\x09^ result",
referencedClasses: ["Compiler"],
messageSends: ["ifFalse:", "isEmpty", "tryCatch:", "evaluateExpression:on:", "new", "ifTrue:ifFalse:", "isSmalltalkError", "resignal", "write:", "stdout", "jsStack"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "executeCommand:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
$recv(self._commands())._keysAndValuesDo_((function(names,cmd){
return $core.withContext(function($ctx2) {
$1=$recv(names)._includes_(aString);
if($core.assert($1)){
$recv(cmd)._value();
throw $early=[true];
};
}, function($ctx2) {$ctx2.fillBlock({names:names,cmd:cmd},$ctx1,1)});
}));
return false;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"executeCommand:",{aString:aString},$globals.Repl)});
},
args: ["aString"],
source: "executeCommand: aString\x0a\x09\x22Tries to process the given string as a command. Returns true if it was a command, false if not.\x22\x0a\x09self commands keysAndValuesDo: [:names :cmd |\x0a\x09\x09(names includes: aString) ifTrue: [\x0a\x09\x09\x09cmd value.\x0a\x09\x09\x09^ true]].\x0a\x09^ false",
referencedClasses: [],
messageSends: ["keysAndValuesDo:", "commands", "ifTrue:", "includes:", "value"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
(
$ctx1.supercall = true,
($globals.Repl.superclass||$boot.dnu).fn.prototype._initialize.apply($recv(self), []));
$ctx1.supercall = false;
self["@session"]=$recv($globals.DoIt)._new();
self["@readline"]=$recv(require)._value_("readline");
$ctx1.sendIdx["value:"]=1;
self["@util"]=$recv(require)._value_("util");
self._setupCommands();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{},$globals.Repl)});
},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09session := DoIt new.\x0a\x09readline := require value: 'readline'.\x0a\x09util := require value: 'util'.\x0a\x09self setupCommands",
referencedClasses: ["DoIt"],
messageSends: ["initialize", "new", "value:", "setupCommands"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "instanceVariableNamesFor:",
protocol: 'private',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$receiver;
$1=$recv(aClass)._superclass();
$ctx1.sendIdx["superclass"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return $recv(aClass)._instanceVariableNames();
} else {
$2=$recv(aClass)._instanceVariableNames();
$ctx1.sendIdx["instanceVariableNames"]=1;
return $recv($2)._copyWithAll_(self._instanceVariableNamesFor_($recv(aClass)._superclass()));
};
}, function($ctx1) {$ctx1.fill(self,"instanceVariableNamesFor:",{aClass:aClass},$globals.Repl)});
},
args: ["aClass"],
source: "instanceVariableNamesFor: aClass\x0a\x09\x22Yields all instance variable names for the given class, including inherited ones.\x22\x0a\x09^ aClass superclass\x0a\x09\x09ifNotNil: [\x0a\x09\x09\x09aClass instanceVariableNames copyWithAll: (self instanceVariableNamesFor: aClass superclass)]\x0a\x09\x09ifNil: [\x0a\x09\x09\x09aClass instanceVariableNames]",
referencedClasses: [],
messageSends: ["ifNotNil:ifNil:", "superclass", "copyWithAll:", "instanceVariableNames", "instanceVariableNamesFor:"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "isIdentifier:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(aString)._match_("^[a-z_]\x5cw*$"._asRegexp());
}, function($ctx1) {$ctx1.fill(self,"isIdentifier:",{aString:aString},$globals.Repl)});
},
args: ["aString"],
source: "isIdentifier: aString\x0a\x09^ aString match: '^[a-z_]\x5cw*$' asRegexp",
referencedClasses: [],
messageSends: ["match:", "asRegexp"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "isVariableDefined:",
protocol: 'private',
fn: function (aString){
var self=this;
return $core.withContext(function($ctx1) {
return $recv(self._instanceVariableNamesFor_($recv(self["@session"])._class()))._includes_(aString);
}, function($ctx1) {$ctx1.fill(self,"isVariableDefined:",{aString:aString},$globals.Repl)});
},
args: ["aString"],
source: "isVariableDefined: aString\x0a\x09^ (self instanceVariableNamesFor: session class) includes: aString",
referencedClasses: [],
messageSends: ["includes:", "instanceVariableNamesFor:", "class"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "nextResultName",
protocol: 'private',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $1,$receiver;
$1=self["@resultCount"];
if(($receiver = $1) == null || $receiver.isNil){
self["@resultCount"]=(1);
} else {
self["@resultCount"]=$recv(self["@resultCount"]).__plus((1));
};
return "res".__comma($recv(self["@resultCount"])._asString());
}, function($ctx1) {$ctx1.fill(self,"nextResultName",{},$globals.Repl)});
},
args: [],
source: "nextResultName\x0a\x09resultCount := resultCount\x0a    \x09ifNotNil: [resultCount + 1]\x0a    \x09ifNil: [1].\x0a    ^ 'res', resultCount asString",
referencedClasses: [],
messageSends: ["ifNotNil:ifNil:", "+", ",", "asString"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "onKeyPress:",
protocol: 'private',
fn: function (key){
var self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv(key)._ctrl())._and_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv(key)._name()).__eq("l");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
if($core.assert($1)){
self._clearScreen();
};
return self;
}, function($ctx1) {$ctx1.fill(self,"onKeyPress:",{key:key},$globals.Repl)});
},
args: ["key"],
source: "onKeyPress: key\x0a\x09(key ctrl and: [key name = 'l'])\x0a\x09\x09ifTrue: [self clearScreen]",
referencedClasses: [],
messageSends: ["ifTrue:", "and:", "ctrl", "=", "name", "clearScreen"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "parseAssignment:do:",
protocol: 'private',
fn: function (aString,aBlock){
var self=this;
var assignment;
return $core.withContext(function($ctx1) {
var $2,$1;
assignment=$recv($recv(aString)._tokenize_(":="))._collect_((function(s){
return $core.withContext(function($ctx2) {
return $recv(s)._trimBoth();
}, function($ctx2) {$ctx2.fillBlock({s:s},$ctx1,1)});
}));
$1=$recv($recv($recv(assignment)._size()).__eq((2)))._and_((function(){
return $core.withContext(function($ctx2) {
$2=$recv(assignment)._first();
$ctx2.sendIdx["first"]=1;
return self._isIdentifier_($2);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
if($core.assert($1)){
return $recv(aBlock)._value_value_($recv(assignment)._first(),$recv(assignment)._last());
$ctx1.sendIdx["value:value:"]=1;
} else {
return $recv(aBlock)._value_value_(nil,nil);
};
}, function($ctx1) {$ctx1.fill(self,"parseAssignment:do:",{aString:aString,aBlock:aBlock,assignment:assignment},$globals.Repl)});
},
args: ["aString", "aBlock"],
source: "parseAssignment: aString do: aBlock\x0a\x09\x22Assigns a new variable if the given string is an assignment expression. Calls the given block with name and value.\x0a\x09 If the string is not one no variable will be assigned and the block will be called with nil for both arguments.\x22\x0a\x09| assignment |\x0a\x09assignment := (aString tokenize: ':=') collect: [:s | s trimBoth].\x0a\x09^ (assignment size = 2 and: [self isIdentifier: assignment first])\x0a\x09\x09ifTrue: [ aBlock value: assignment first value: assignment last ]\x0a\x09\x09ifFalse: [ aBlock value: nil value: nil ]",
referencedClasses: [],
messageSends: ["collect:", "tokenize:", "trimBoth", "ifTrue:ifFalse:", "and:", "=", "size", "isIdentifier:", "first", "value:value:", "last"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "presentResultNamed:withValue:",
protocol: 'private',
fn: function (varName,value){
var self=this;
return $core.withContext(function($ctx1) {
var $3,$2,$1;
$3=$recv($recv(varName).__comma(": ")).__comma($recv($recv(value)._class())._name());
$ctx1.sendIdx[","]=3;
$2=$recv($3).__comma(" = ");
$ctx1.sendIdx[","]=2;
$1=$recv($2).__comma($recv(value)._asString());
$ctx1.sendIdx[","]=1;
$recv($globals.Transcript)._show_($1);
$recv($globals.Transcript)._cr();
$recv(self["@interface"])._prompt();
return self;
}, function($ctx1) {$ctx1.fill(self,"presentResultNamed:withValue:",{varName:varName,value:value},$globals.Repl)});
},
args: ["varName", "value"],
source: "presentResultNamed: varName withValue: value\x0a\x09Transcript show: varName, ': ', value class name, ' = ', value asString; cr.\x0a\x09interface prompt",
referencedClasses: ["Transcript"],
messageSends: ["show:", ",", "name", "class", "asString", "cr", "prompt"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "printWelcome",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Transcript)._show_("Type :q to exit.");
$recv($globals.Transcript)._cr();
return self;
}, function($ctx1) {$ctx1.fill(self,"printWelcome",{},$globals.Repl)});
},
args: [],
source: "printWelcome\x0a\x09Transcript show: 'Type :q to exit.'; cr.",
referencedClasses: ["Transcript"],
messageSends: ["show:", "cr"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "processLine:",
protocol: 'private',
fn: function (buffer){
var self=this;
var show;
return $core.withContext(function($ctx1) {
var $1,$2;
show=(function(varName,value){
return $core.withContext(function($ctx2) {
return self._presentResultNamed_withValue_(varName,value);
}, function($ctx2) {$ctx2.fillBlock({varName:varName,value:value},$ctx1,1)});
});
$1=self._executeCommand_(buffer);
if(!$core.assert($1)){
$2=self._isVariableDefined_(buffer);
if($core.assert($2)){
$recv(show)._value_value_(buffer,$recv(self["@session"])._perform_(buffer));
} else {
self._assignNewVariable_do_(buffer,show);
};
};
return self;
}, function($ctx1) {$ctx1.fill(self,"processLine:",{buffer:buffer,show:show},$globals.Repl)});
},
args: ["buffer"],
source: "processLine: buffer\x0a\x09\x22Processes lines entered through the readline interface.\x22\x0a\x09| show |\x0a\x09show := [:varName :value | self presentResultNamed: varName withValue: value].\x0a\x09(self executeCommand: buffer) ifFalse: [\x0a\x09\x09(self isVariableDefined: buffer)\x0a\x09\x09\x09ifTrue: [show value: buffer value: (session perform: buffer)]\x0a\x09\x09\x09ifFalse: [self assignNewVariable: buffer do: show]]",
referencedClasses: [],
messageSends: ["presentResultNamed:withValue:", "ifFalse:", "executeCommand:", "ifTrue:ifFalse:", "isVariableDefined:", "value:value:", "perform:", "assignNewVariable:do:"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "prompt",
protocol: 'accessing',
fn: function (){
var self=this;
return "amber >> ";

},
args: [],
source: "prompt\x0a\x09^ 'amber >> '",
referencedClasses: [],
messageSends: []
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "setPreviousVariablesFor:from:",
protocol: 'private',
fn: function (newObject,oldObject){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._instanceVariableNamesFor_($recv(oldObject)._class()))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(newObject)._perform_withArguments_($recv(each).__comma(":"),[$recv(oldObject)._perform_(each)]);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"setPreviousVariablesFor:from:",{newObject:newObject,oldObject:oldObject},$globals.Repl)});
},
args: ["newObject", "oldObject"],
source: "setPreviousVariablesFor: newObject from: oldObject\x0a\x09(self instanceVariableNamesFor: oldObject class) do: [:each |\x0a\x09\x09newObject perform: each, ':' withArguments: {oldObject perform: each}].",
referencedClasses: [],
messageSends: ["do:", "instanceVariableNamesFor:", "class", "perform:withArguments:", ",", "perform:"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "setPrompt",
protocol: 'actions',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self["@interface"])._setPrompt_(self._prompt());
return self;
}, function($ctx1) {$ctx1.fill(self,"setPrompt",{},$globals.Repl)});
},
args: [],
source: "setPrompt\x0a\x09interface setPrompt: self prompt",
referencedClasses: [],
messageSends: ["setPrompt:", "prompt"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "setupCommands",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1;
$2=$recv([":q"]).__minus_gt((function(){
return $core.withContext(function($ctx2) {
return $recv(process)._exit();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$ctx1.sendIdx["->"]=1;
$1=[$2,$recv([""]).__minus_gt((function(){
return $core.withContext(function($ctx2) {
return $recv(self["@interface"])._prompt();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}))];
self["@commands"]=$recv($globals.Dictionary)._from_($1);
return self;
}, function($ctx1) {$ctx1.fill(self,"setupCommands",{},$globals.Repl)});
},
args: [],
source: "setupCommands\x0a\x09commands := Dictionary from: {\x0a\x09\x09{':q'} -> [process exit].\x0a\x09\x09{''} -> [interface prompt]}",
referencedClasses: ["Dictionary"],
messageSends: ["from:", "->", "exit", "prompt"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "setupHotkeys",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
var $receiver;
$recv($recv(process)._stdin())._on_do_("keypress",(function(s,key){
return $core.withContext(function($ctx2) {
if(($receiver = key) == null || $receiver.isNil){
return key;
} else {
return self._onKeyPress_(key);
};
}, function($ctx2) {$ctx2.fillBlock({s:s,key:key},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"setupHotkeys",{},$globals.Repl)});
},
args: [],
source: "setupHotkeys\x0a\x09process stdin on: 'keypress' do: [:s :key | key ifNotNil: [self onKeyPress: key]].",
referencedClasses: [],
messageSends: ["on:do:", "stdin", "ifNotNil:", "onKeyPress:"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "subclass:withVariable:",
protocol: 'private',
fn: function (aClass,varName){
var self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.ClassBuilder)._new())._addSubclassOf_named_instanceVariableNames_package_(aClass,$recv(self._subclassNameFor_(aClass))._asSymbol(),[varName],"Compiler-Core");
}, function($ctx1) {$ctx1.fill(self,"subclass:withVariable:",{aClass:aClass,varName:varName},$globals.Repl)});
},
args: ["aClass", "varName"],
source: "subclass: aClass withVariable: varName\x0a\x09\x22Create subclass with new variable.\x22\x0a\x09^ ClassBuilder new\x0a\x09\x09addSubclassOf: aClass\x0a\x09\x09named: (self subclassNameFor: aClass) asSymbol\x0a\x09\x09instanceVariableNames: {varName}\x0a\x09\x09package: 'Compiler-Core'",
referencedClasses: ["ClassBuilder"],
messageSends: ["addSubclassOf:named:instanceVariableNames:package:", "new", "asSymbol", "subclassNameFor:"]
}),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "subclassNameFor:",
protocol: 'private',
fn: function (aClass){
var self=this;
return $core.withContext(function($ctx1) {
var $2,$1,$6,$5,$4,$3,$7,$receiver;
$2=$recv(aClass)._name();
$ctx1.sendIdx["name"]=1;
$1=$recv($2)._matchesOf_("\x5cd+$");
$ctx1.sendIdx["matchesOf:"]=1;
if(($receiver = $1) == null || $receiver.isNil){
return $recv($recv(aClass)._name()).__comma("2");
} else {
var counter;
$6=$recv(aClass)._name();
$ctx1.sendIdx["name"]=2;
$5=$recv($6)._matchesOf_("\x5cd+$");
$4=$recv($5)._first();
$3=$recv($4)._asNumber();
counter=$recv($3).__plus((1));
counter;
$7=$recv(aClass)._name();
$ctx1.sendIdx["name"]=3;
return $recv($7)._replaceRegexp_with_("\x5cd+$"._asRegexp(),$recv(counter)._asString());
};
}, function($ctx1) {$ctx1.fill(self,"subclassNameFor:",{aClass:aClass},$globals.Repl)});
},
args: ["aClass"],
source: "subclassNameFor: aClass\x0a\x09^ (aClass name matchesOf: '\x5cd+$')\x0a\x09\x09ifNotNil: [ | counter |\x0a\x09\x09\x09counter := (aClass name matchesOf: '\x5cd+$') first asNumber + 1.\x0a\x09\x09\x09aClass name replaceRegexp: '\x5cd+$' asRegexp with: counter asString]\x0a\x09\x09ifNil: [\x0a\x09\x09\x09aClass name, '2'].",
referencedClasses: [],
messageSends: ["ifNotNil:ifNil:", "matchesOf:", "name", "+", "asNumber", "first", "replaceRegexp:with:", "asRegexp", "asString", ","]
}),
$globals.Repl);


$core.addMethod(
$core.method({
selector: "main",
protocol: 'initialization',
fn: function (){
var self=this;
return $core.withContext(function($ctx1) {
$recv(self._new())._createInterface();
return self;
}, function($ctx1) {$ctx1.fill(self,"main",{},$globals.Repl.klass)});
},
args: [],
source: "main\x0a\x09self new createInterface",
referencedClasses: [],
messageSends: ["createInterface", "new"]
}),
$globals.Repl.klass);

});

(function () {
                            define('app',["amber/devel", "amber_cli/AmberCli"], function (amber) {
                                amber.initialize().then(function () {
                                    amber.globals.AmberCli._main();
                                });
                            });
                        }());

require(["app"]);
});
define.require('__wrap__');
}((function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                if (callback) {
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}(module)), require));